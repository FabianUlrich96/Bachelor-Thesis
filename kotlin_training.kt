this.setState({
  counter: this.state.counter + this.props.increment,
});

this.setState(function(prevState, props) {
  return {
    counter: prevState.counter + props.increment
  };
});

//Located in the ReactComponent class in ReactComponent.kt
fun setState(builder: S.() -&gt; Unit) {
    ...
}

setState
setState {
    counter: state.counter + props.increment
}

fun setState(builder: S.(prevState: S, props: P) -&gt; Unit) {
    ...
}

setState { prevState, props -&gt;
    counter: prevState.counter + props.increment
}

// Loads all the settings changed in the theme
    override fun onCreate() {
        super.onCreate()

        var sharedPreferences = getSharedPreferences(
            CatalystConstants.keyThemeObject,
            AppCompatActivity.MODE_PRIVATE
        )

        when (sharedPreferences.getInt(CatalystConstants.prefName, CatalystConstants.themeLight)) {
            CatalystConstants.themeLight -&gt; {
                AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO)
            }
            CatalystConstants.themeDark -&gt; {
                AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES)
            }
        }
    }
}```


myList.setOnItemClickListener{ view  -&gt;
    val intent = Intent(this, DetailedActivity::class.java) 
    startActivity(intent)
}

myList.setOnItemClickListener{ parent, view, position, id -&gt;
                val intent = Intent(this, DetailedActivity::class.java)
                intent.putExtra("thePosition (text)", position)
                startActivity(intent)
}

val lambda: () -&gt; Unit = null

lambda?.let { it() }

lambda?.invoke()

class ColorsArray(context: Context) {}

class ColorsArray(var context: Context){}

fun main(args: Array&lt;String&gt;) {
    val myList = List(3) {it + 1}

    println(myList)
}

@Throw
@Throws(NotFoundException::class)

@Throws
NotFoundException
NullPointerException
for (int i = startingIndex; i &lt; items.size(); i++) 

Range
BaseResponse&lt;Iterable&lt;User&gt;&gt;::class

receiver
Int.
Int.(Int, Float) -&gt; Int

if (elements != null) {
    for (element in elements) {
        // ...
    }
}

kotlin.Char
public class Char private constructor() : Comparable&lt;Char&gt; {
...
}

Comparable&lt;T&gt;
public interface Comparable&lt;in T&gt; {
    public operator fun compareTo(other: T): Int
}

Serializable
fun main(args: Array&lt;String&gt;) {
  println('A'::class) // class kotlin.Char
  println('A'::class.java) // char
  println('A' is java.io.Serializable) // true
}

val value: String = "Adrian"


"Cannot find value: Adrian"

let value: String = "Adrian"
print("Cannot find \(string.description): \(value)")

let a: String = "b"
print("\(a.description) = \(a)"
///prints "a = b"

val lambdas  = mutableListOf&lt;()-&gt;Unit&gt;()
lambdas.add{println("a")} // this compiles fine
lambdas.add{()-&gt;println("b")} //why can't I do this?


error: expecting a name
lambdas.add{{()-&gt;println("b")}}

class Food
class Grass extends Food
class Cookies extends Food
class Fish extends Food

abstract class Animal {
  type SuitableFood &lt;: Food
  def eat(food: SuitableFood)
}

class Cow extends Animal {
  type SuitableFood = Grass
  override def eat(food: SuitableFood) = {}
}

val bessy: Animal = new Cow
bessy eat new Fish
bessy eat new Cookies

fun main(args:Array&lt;String&gt;){

    fun multiplyAndDivide(number: Int, factor: Int): Pair&lt;Int, Int&gt; {
        return Pair(number * factor, number / factor)
    }
    val (product, quotient) = multiplyAndDivide(4, 2)

    fun multiplyInferred(number: Int, multiplier: Int) = number * multiplier
}

User
inner data class
UserProperty
User
inner
data
UserProperty
val url = URL("https://google.ca")
val conn = url.openConnection() as HttpURLConnection

with(conn) {
    //doStuff
}
conn.disconnect()

E/AndroidRuntime: FATAL EXCEPTION: main
Process: com.hdmc.smartristraveller, PID: 4788
java.lang.IllegalArgumentException: Parameter specified as non-null is null: method kotlin.jvm.internal.Intrinsics.checkParameterIsNotNull, parameter location
    at com.hdmc.smartristraveller.fahrplanmap$onCreate$1.onSuccess(Unknown Source:2)
    at com.hdmc.smartristraveller.fahrplanmap$onCreate$1.onSuccess(fahrplanmap.kt:22)
    at com.google.android.gms.tasks.zzn.run(Unknown Source:27)
    at android.os.Handler.handleCallback(Handler.java:873)
    at android.os.Handler.dispatchMessage(Handler.java:99)
    at android.os.Looper.loop(Looper.java:193)
    at android.app.ActivityThread.main(ActivityThread.java:6669)
    at java.lang.reflect.Method.invoke(Native Method)
    at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493)
    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858)

class fahrplanmap : AppCompatActivity() {
var webservices = webservices()
var StationID = IntArray(300)
var haltestellen_name : ArrayList&lt;String&gt; = ArrayList()
var haltestellen_lat: DoubleArray = DoubleArray(300)                        //all busstops
var haltestellen_lon: DoubleArray = DoubleArray(300)                        //all busstops
var StopDistances = DoubleArray(300)
var Haltestellen : ArrayList&lt;String&gt; = ArrayList()
var time = Handler()
var latitude = 0.0
var longitude = 0.0
companion object {
    private const val LOCATION_PERMISSION_REQUEST_CODE = 1
}

private lateinit var fusedLocationClient: FusedLocationProviderClient
private val mOnNavigationItemSelectedListener = BottomNavigationView.OnNavigationItemSelectedListener { item -&gt;
    when (item.itemId) {                //wenn Bottom Navigationbar berührt wird
        R.id.navigation_Auskunft -&gt; {
            //               message.setText(R.string.title_Auskunft)
            return@OnNavigationItemSelectedListener true
        }
        R.id.navigation_Abfahrtsmonitor -&gt; {
            //               message.setText(R.string.title_Abfahrtsmonitor)
            val intent = Intent(this, Abfahrtsmonitor::class.java)        //Opens fahrplanmap Class
            startActivity(intent)
            return@OnNavigationItemSelectedListener true
        }
        R.id.navigation_Karte -&gt; {
            //            message.setText(R.string.title_Karte)
            val intent = Intent(this, MapsAnzeigeActivity::class.java)  
            startActivity(intent)
            return@OnNavigationItemSelectedListener true
        }
        R.id.navigation_Meldungen -&gt; {
           message.setText(R.string.title_meldungen)
            return@OnNavigationItemSelectedListener true
        }
        R.id.navigation_weiteres -&gt; {
            message.setText(R.string.title_weiteres)
            return@OnNavigationItemSelectedListener true
        }
    }
    false
}

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_fahrplanmap)
    val navigation = findViewById&lt;BottomNavigationView&gt;(R.id.navigation)       // findViewById&lt;BottomNavigationView&gt;(R.id.navigation)

    navigation.setOnNavigationItemSelectedListener(mOnNavigationItemSelectedListener)
    Haltestellen.clear()
    Recycleview2.layoutManager = LinearLayoutManager(this)
    Recycleview2.adapter = listadapter(haltestellen_name, this)
    fusedLocationClient = LocationServices.getFusedLocationProviderClient(this)
    if (ActivityCompat.checkSelfPermission(this,
                    android.Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
        ActivityCompat.requestPermissions(this,
                arrayOf(android.Manifest.permission.ACCESS_FINE_LOCATION), fahrplanmap.LOCATION_PERMISSION_REQUEST_CODE)
        return
    }

    val locationManager = getSystemService(Context.LOCATION_SERVICE) as 
LocationManager

// Define a listener that responds to location updates

    val locationListener = object : LocationListener {

        override fun onLocationChanged(location: Location) {
            // Called when a new location is found by the network location provider.
            println("GPS WOrks yeahhhh")
        }

        override fun onStatusChanged(provider: String, status: Int, extras: Bundle) {
        }

        override fun onProviderEnabled(provider: String) {
        }

        override fun onProviderDisabled(provider: String) {
        }
    }

    // Register the listener with the Location Manager to receive location updates
    locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 0, 0f,locationListener)
    fusedLocationClient.lastLocation
            .addOnSuccessListener { location: Location -&gt;
                if( location != null) {
                    latitude = location?.latitude
                    longitude = location?.longitude
                    println(latitude)
                    println(longitude)
                    println("gps?")

                    StopsFromWebservice().execute()
                }
            }
    println(fusedLocationClient.lastLocation)
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
}

fun FindClosestStops(){
    for (i in 0..haltestellen_lat.size-1){
        var x=0.0
        var y=0.0
        var distance = 0.0
        x= (haltestellen_lat[i]-latitude)*(haltestellen_lat[i]-latitude)
        y= (haltestellen_lon[i]-longitude)*(haltestellen_lon[i]-longitude)
        distance = sqrt(x+y)
        StopDistances[i]= distance

        Haltestellen.add(distance.toString())
    }
    SortDistance()
    time.post(UpdateView);
}

inner class StopsFromWebservice : AsyncTask&lt;String, String, String&gt;() {                      //Todo buslinien noch richtig stellen, von busroute zu lineid!!
    override fun doInBackground(vararg p0: String?): String {
        webservices.get_Haltestellen()
        StationID = webservices.StationID
        haltestellen_name = webservices.Haltestellen
        haltestellen_lat = webservices.haltestellen_lat
        haltestellen_lon = webservices.haltestellen_lon     //todo schauen ob hintergrundprozess nötig
        FindClosestStops()

        return ""
    }

}
private val UpdateView = object : Runnable {
    override fun run() {
        Recycleview2.adapter.notifyDataSetChanged()                                                            //draws the route on maps
        time.postDelayed(this, 1000)

    }

}
fun deleteTimer(){
    time.removeCallbacks(UpdateView);
}
fun SortDistance(){
    var sorted = false
    var i = 0
    var k = 0
    while(k&lt;haltestellen_name.size) {
        while (i &lt; haltestellen_name.size - 1) {
            if (Haltestellen[i] &gt; Haltestellen[i + 1]) {
                var dummy1 = Haltestellen[i]
                var dummy2 = haltestellen_name[i]

                Haltestellen[i] = Haltestellen[i + 1]
                haltestellen_name[i] = haltestellen_name[i + 1]

                Haltestellen[i + 1] = dummy1
                haltestellen_name[i + 1] = dummy2

            }
            i++
        }
        k++
        i=0
        println(k)
    }
    deleteTimer()
}
}

buildChain
IChain&lt;T&gt;
next
interface Chain&lt;T&gt; {
    var next: T?

    operator fun plus(next: T): T?
}

fun &lt;T : Chain&lt;T&gt;&gt; buildChain(first: T, vararg members: T): T {
    var next: T? = null
    members.forEachIndexed { i, t -&gt;
        if (i == 0) {
            next = first + t
        } else {
            next = next?.run { this + t }
        }
    }
    return first
}

data class Person(val name: String) : Chain&lt;Person&gt; {
    override var next: Person? = null

    override fun plus(next: Person): Person? {
        this.next = next
        return next
    }
}

fun createPersonChain()
        = buildChain(Person("Bob"), Person("Bitzy"), Person("Blitzy"))

@JvmStatic fun main(args: Array&lt;String&gt;) {
    var first = createPersonChain()
    // first.name = "Bob"
    // first.next.name = "Bitzy"
    // first.next.next.name = "Blitzy"
 }

functional
simpler
code
String
Int
T
override onSomeListenerEvent(index: Int): Unit = myArrayList.remove(index)

class Processor{
  Long getLatestOffset(){
    return null
  }
}

@Test
fun testNull() {
  assertThat(processor.latestOffset).isNull() ---&gt; Fails
  assertThat(processor.latestOffset as Long?).isNull() ---&gt;Passes
}

arrivals
{
  "arrivals": [
    {
      "airline": "Iraqi Airways",
      "alia": "Iraqi Airways IAW",
      "flight": "IA136"
    }
  ]
}

private fun handleJson (jsonString: String?){

        val jsonObj = JSONArray("arrivals")
        val list =  ArrayList&lt;FlightShdu&gt;()
        var x = 0
        while (x &lt; jsonObj.length()){

            val jsonObject = jsonObj.getJSONObject(x)

            list.add(FlightShdu(

                jsonObject.getInt("airline"),
                jsonObject.getString("fn")

            ))


            x++
        }
        val adapter = ListAdapte(this@MainActivity,list)
        flightShdu_list.adapter = adapter

    }

abstract class BaseClass {

}

class ConcretClasOne : BaseCalculator {


}

class ConcretClasTwo : BaseCalculator {


}

abstract class BaseRun {

    abstract fun run(param: BaseClass): Int
}

class ConcretRun : BaseRun {

    override fun run(param: ConcretClasOne): Int {

        return 0
    }
}

run overrides nothing
ConcretRun
ConcretClasOne
fun findStringsThatEndWith(sentences: List&lt;String&gt;, value: String) = sentences
    .filter { it.endsWith(value) }

fun findStringsThatEndWith(sentences: List&lt;String&gt;, vararg value: String) = sentences
    .filter { it.endsWith(value // This won't work //) }

fun findStringsThatEndWith(sentences: List&lt;String&gt;, vararg value: String) = sentences
    .filter { it.endsWith(value[0]) || it.endsWith(value[1]) }

email.addSubject(if (creator != null)  String.format( inviteDescription, creator) else String.format(inviteDescriptionNoCreator, group))

ArrivedResult
{
  "ArrivedResult": {
    "arrivals": [
      {
        "ident": "MSR637",
        "aircrafttype": "A321",
        "actualdeparturetime": 1541399820,
        "actualarrivaltime": 1541406652,
        "origin": "HECA"
      }
    ]
  }
}

private fun handleJson(jsonString: String?) {
    val jsonObj = JSONObject(jsonString)
    val ArrivedResult = jsonObj.getJSONObject("ArrivedResult")
    val jsonArray = JSONArray(ArrivedResult.get("arrivals").toString())

    val list =  ArrayList&lt;FlightShdu&gt;()
    var x = 0
    while (x &lt; jsonArray.length()) {
        val jsonObject = jsonArray.getJSONObject(x)
        list.add(FlightShdu(
            jsonObject.getString("aircrafttype"),
            jsonObject.getString("destination")
        ))
        x++
    }
}

Caused by: org.json.JSONException: No value for ArrivedResult
val parts = it.split("\\s".toRegex())
 val part1 = parts[0]
 val part2 = parts[1]
 val part3 = parts[2]
 val part4 = parts[3]

class MyActivity: AppCompatActivity() {

    companion object {
        fun updateDisplay(message: String) {
            mTextView.text = message // Unresolved reference: mTextView
        }
    }

    @BindView(R.id.my_text_view) lateinit var mTextView: TextView

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.my_activity)
        ButterKnife.bind(this)
    }

    // ...

}

data class Rectangle(val width: Int, val height: Int)
data class Circle(val radius: Int)

fun main(args: Array&lt;String&gt;) {
    val listOfRects: List&lt;Rectangle&gt; = listOf(Rectangle(5,5))

    val listOfUnkown: List&lt;Any?&gt; = listOfRects

    val listOfWrongType: List&lt;Circle&gt; = listOfUnkown as List&lt;Circle&gt;
    // also works, thought should throw null
    // val listOfWrongType: List&lt;Circle&gt;? = listOfUnkown as? List&lt;Circle&gt;

    print(listOfWrongType)
}

Test.kt:9:44: warning: unchecked cast: List&lt;Any?&gt; to List&lt;Circle&gt;
    val listA: List&lt;Circle&gt; = listOfUnkown as List&lt;Circle&gt;
                                           ^
[Rectangle(width=5, height=5)]

fun Int.toUpperCase() = ""

fun main(args: Array&lt;String&gt;){
    var ab: String? = "hello"
    ab = null
    println(ab?.toUpperCase())
}

class IdableK&lt;T : IdableK&lt;T&gt;&gt; : Comparable&lt;T&gt; {    
    private var id : Long? = null
}

compareTo
    override fun compareTo(other: T): Int {
        if (id == null) {
            return -1;
        }

        if (other.id == null) {
            return 1;
        }

        return id!!.compareTo(other.id!!)
    }

list
    .zip(list.reverse)
    .foreach{case (x, y) =&gt; println(s"$x $y")}

class PopUpClass : DialogFragment() {



    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
        var v = inflater.inflate(R.layout.poplayout,container,false 

        return v
    }
//tried to pass the data in the constructor and then handle it but did not work


interface Identifiable {
    var id: String`
}

class ArticleShrinked(val category: ArticleCategory,
                      override var id: String,
                      val timestamp: Date) : Shrinkable, Identifiable, Indexable {

    override val order: String
        get() = &quot;id&quot;
}

// There has to be a bettwe way to deal with this
fun setItem(item: Identifiable?) {
        val article: Article? = item as? Article
        if (article != null) {
            // do something with article
        }

        val shrinked: ArticleShrinked? = item as? ArticleShrinked
        if (shrinked != null) {
            // do something with shrinked
        }

        val bloated: ArticleBloated? = item as? ArticleBloated
        if (bloated != null) {
            // do something with bloated
        }

        val annotation: ArticleAnnotation? = item as? ArticleAnnotation
        if (annotation != null) {
            // do something with bloated
        }
}

if (item is Article)

when (item) {

   is Article -&gt; // do something

}

item as Any? as Article
applyif
builder.applyif(&lt;condition expression&gt;) {
    builder.set...
}

builder.apply {
    if (&lt;condition expression&gt;) {
        builder.set...
    }
}

copy
val newInst = someMap.map { it.toPair() }.toMap()

val
class MyClass {
    companion object {
        private val TAG = MyClass::class.java.simpleName
    }
}

const val
class MyClass {
    companion object {
        private const val TAG = MyClass::class.java.simpleName
    }
}

MyClass.kt:27:33: error: const 'val' initializer should be a constant value
        private const val TAG = MyClass::class.java.simpleName

simpleName
const val
Unit
a: Int -&gt; Unit
a: String, b: Int -&gt; Unit
() -&gt; Unit

Unit
var test: KCallable&lt;Unit&gt; = { var a = 1 } // COMPILE ERROR

() -&gt; Unit
KCallable&lt;Unit&gt;
Any
// actual method
fun foo(a : String, b : String) {
    // do something
}

// syntax error here
val callback : (String, String) -&gt; Unit = foo(a, b)

// invoke method
callback.invoke("a", "b")

Guid.Empty
var offset=0 //Global offset
fun foo(){
    bar(offset)
}

fun bar(offset:Int){//Function argument offset
    .......
    .......
    .......
    if(baz()){
        .......
        .......
        offset+=10 // I want to update the global offset, but function argument offset is reffered here
        bar(offset)
    }
}

fun baz():Boolean{
    .......
    .......
}

val textView = findViewById&lt;TextView&gt;(R.id.textView)

textView.text = 'hello'

package com.example.appzilla

import androidx.appcompat.app.AppCompatActivity

import android.os.Bundle
import android.view.View
import android.widget.AdapterView
import android.widget.TextView
import androidx.cardview.widget.CardView

class Place_Page : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.place_page)
    }
    val textView = findViewById&lt;TextView&gt;(R.id.textView)
    textView.text = 'hello'

    val place : Place = intent.getParcelableExtra("Extra_Place")


}

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".Place_Page"&gt;

    &lt;TextView
        android:id="@+id/textView"
        android:layout_width="300dp"
        android:layout_height="150dp"
        android:layout_marginStart="8dp"
        android:layout_marginTop="268dp"
        android:layout_marginEnd="8dp"
        android:text="TextView"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintHorizontal_bias="0.494"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" /&gt;

&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;

package search
import java.util.*
import kotlin.system.exitProcess

fun main() {
    val scanner = Scanner(System.`in`)

    println(&quot;Enter the number of people: &quot;)
    val datasetSize = scanner.nextInt()

    println(&quot;Enter all people: &quot;)
    val dataset = Array&lt;String&gt;(datasetSize){readLine()!!}
    println(&quot;===Menu===&quot;)
    println(&quot;1. Find a person&quot;)
    println(&quot;2. Print all people&quot;)
    println(&quot;0. Exit&quot;)
    var choice = scanner.nextInt()
    while(true){
        when(choice) {
            1 -&gt; find(datasetSize,dataset)
            2 -&gt; listp(datasetSize,dataset)
            0 -&gt; exitProcess(-1)
            else -&gt; println(&quot;Incorrect option! Try again.&quot;)
        }
    }
}

tailrec
fun swap(a :Int, b:Int) {

}

  var a = 10
    var b = 5

    swap(a,b)

    // a should be 5
    // b should be 10

Warning:the '-d' option with a directory destination is ignored because '-module' is specified
(s: String) -&gt; writer.println(s)
val writeStuff: (PrintWriter) -&gt; (String) -&gt; Unit = {
    val writer = it
    val f: (String) -&gt; Unit = {
        writer.println(it)
    }
    f
}
PrintWriter("test").use { writeStuff(it)("TEST") }

val writeStuff: (PrintWriter) -&gt; (String) -&gt; Unit = { writer -&gt;
    { writer.println(it) }
}

val sendStuff: (Any) -&gt; (String) -&gt; Unit = { sender -&gt;
    { sender.equals(it) }
}

@Test fun test1() {
    val li = listOf("a", "b", "c")

    val process: List&lt;(String) -&gt; Unit&gt; = 
        listOf(writeStuff(PrintWriter("a")), sendStuff(Object()))

    process.map { li.map(it) }
}

roundToInt()
Unresolved Reference
fun solve(meal_cost: Double, tip_percent: Int, tax_percent: Int): Unit {
    var tip = (meal_cost *tip_percent)/100
    var tax = (meal_cost *tax_percent)/100
    var totalCost = (tip+tax+meal_cost).roundToInt()

    System.out.println("The total cost is "+totalCost+".")
}

Solution.kt:25:41: error: unresolved reference: roundToInt
var totalCost = (tip+tax+meal_cost).roundToInt()
                                    ^   

open class A (val i: Int)
class B (val j: Int) : A(j)

fun f(x: A){
    print(x)
}

fun test_f(){
    f(A(1))
    f(B(1)) //no problem
}

fun g(x: (A)-&gt;Int){
    print(x)
}

fun test_g(){
    val l1 = { a: A -&gt; a.hashCode()}
    g(l1)

    val l2 = { b: B -&gt; b.hashCode()}
    g(l2) //Error: Type mismatch. Required: (A)-&gt;Int, Found: (B)-&gt;Int
}

(B) -&gt; Int
(A) -&gt; Int
A.h
z: (A) -&gt; X
h
B
z: (B) -&gt; X
// Using generics doesn't allow me to pass A.
open class A (val i: Int) {
    fun &lt;M: A&gt; g(x: (M)-&gt;Int){
        print(x(this)) // Error: Type mismatch. Expected: M, Found: A 
    }
}

fun main() {
    var arrTwoD : Array&lt;IntArray&gt; = arrayOf(
            intArrayOf(1,1,1,0,0,0),
            intArrayOf(0,1,0,0,0,0),
            intArrayOf(1,1,1,0,0,0),
            intArrayOf(0,0,2,4,4,0),
            intArrayOf(0,0,0,2,0,0),
            intArrayOf(0,0,1,2,4,0)
    )

    var max = Int.MIN_VALUE
    for (x in 1..4){
        for(y in 1..4){
          var currentSum = arrTwoD[x][y] + arrTwoD[x][y+1] + arrTwoD[x][y+2] + arrTwoD[x+1][y+1] + arrTwoD[x+2][y] + arrTwoD[x+2][y+1] + arrTwoD[x+2][y+2]
            max = kotlin.math.max(max, currentSum)
        }
    }
    println(max)
}

Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 6
var a = [1, 2, 3]
return a..push(4) // returned data: array of [1, 2, 3, 4]

var a = mutableListOf(1, 2, 3)
a.add(4)
return a

var a = mutableListOf(1, 2, 3)
return (a..add(4))

data class Item(val name: String)
data class Order(val id: Int, val items: List&lt;Item&gt;)

listOf('a', 'b', 'o'), &quot;baobab&quot;) -&gt; true
listOf('a, 'a', &quot;aa&quot;)
fun canBuildFrom(chars: List&lt;Char&gt;, word: String): Boolean {
    var i = 0
    for (item in chars) {
        for (char in word) {
            if (char.toLowerCase() == item.toLowerCase()) {
                i++
            }
        }
    }
    return (i == word.length)
}

____ ___  ____ ___  ____ ____ ____ _  _ _  _ _  _ _    _  _
|__| |__] |    |  \ |___ |___ | __ |__| |  | |_/  |    |\/|
|  | |__] |___ |__/ |___ |    |__] |  | | _| | \_ |___ |  |
_  _ ____ ___  ____ ____ ____ ___ _  _ _  _ _ _ _ _  _ _   _ ___ 
|\ | |  | |__] |  | |__/ [__   |  |  | |  | | | |  \/   \_/    / 
| \| |__| |    |_\| |  \ ___]  |  |__|  \/  |_|_| _/\_   |    /__

Enter name and surname: Bill Gates
Enter person's status: VIP
***************************************************
*  ___  _ _    _         ____ ____ ___ ____ ____  *
*  |__] | |    |         | __ |__|  |  |___ [__   *
*  |__] | |___ |___      |__] |  |  |  |___ ___]  *
*                       VIP                       *
***************************************************

Enter name and surname: Tom Smith
Enter person's status: Worker
*********************************************
*  ___ ____ _  _      ____ _  _ _ ___ _  _  *
*   |  |  | |\/|      [__  |\/| |  |  |__|  *
*   |  |__| |  |      ___] |  | |  |  |  |  *
*                  Worker                   *
*********************************************

Enter name and surname: Mr Anonimous
Enter person's status: Participant
**************************************************************
*  _  _ ____      ____ _  _ ____ _  _ _ _  _ ____ _  _ ____  *
*  |\/| |__/      |__| |\ | |  | |\ | | |\/| |  | |  | [__   *
*  |  | |  \      |  | | \| |__| | \| | |  | |__| |__| ___]  *
*                        Participant                         *
**************************************************************

Enter name and surname: John S
Enter person's status: Worker-coworker-superdupercoworker
****************************************
*      _ ____ _  _ _  _      ____      *
*      | |  | |__| |\ |      [__       *
*     _| |__| |  | | \|      ___]      *
*  Worker-coworker-superdupercoworker  *
****************************************

package signature

import java.util.*

fun main() {
    val scanner = Scanner(System.`in`)
    print(&quot;Enter name and surname: &quot;)
    val name = scanner.nextLine().toLowerCase()
    val nameArr = name.toCharArray()
    print(&quot;Enter person's status: &quot;)
    val stat = scanner.nextLine()
    var newName: Array&lt;String&gt; = arrayOf(&quot;&quot;, &quot;&quot;, &quot;&quot;)

    val letters = mapOf(
            (&quot;a&quot; to listOf(&quot;____&quot;, &quot;|__|&quot;, &quot;|  |&quot;)),
            (&quot;b&quot; to listOf(&quot;___ &quot;, &quot;|__]&quot;, &quot;|__]&quot;)),
            (&quot;c&quot; to listOf(&quot;____&quot;, &quot;|   &quot;, &quot;|___&quot;)),
            (&quot;d&quot; to listOf(&quot;___ &quot;, &quot;|  \\&quot;, &quot;|__/&quot;)),
            (&quot;e&quot; to listOf(&quot;____&quot;, &quot;|___&quot;, &quot;|___&quot;)),
            (&quot;f&quot; to listOf(&quot;____&quot;, &quot;|___&quot;, &quot;|   &quot;)),
            (&quot;g&quot; to listOf(&quot;____&quot;, &quot;| __&quot;, &quot;|__]&quot;)),
            (&quot;h&quot; to listOf(&quot;_  _&quot;, &quot;|__|&quot;, &quot;|  |&quot;)),
            (&quot;i&quot; to listOf(&quot;_&quot;, &quot;|&quot;, &quot;|&quot;)),
            (&quot;j&quot; to listOf(&quot; _&quot;, &quot; |&quot;, &quot;_|&quot;)),
            (&quot;k&quot; to listOf(&quot;_  _&quot;, &quot;|_/ &quot;, &quot;| \\_&quot;)),
            (&quot;l&quot; to listOf(&quot;_   &quot;, &quot;|   &quot;, &quot;|___&quot;)),
            (&quot;m&quot; to listOf(&quot;_  _&quot;, &quot;|\\/|&quot;, &quot;|  |&quot;)),
            (&quot;n&quot; to listOf(&quot;_  _&quot;, &quot;|\\ |&quot;, &quot;| \\|&quot;)),
            (&quot;o&quot; to listOf(&quot;____&quot;, &quot;|  |&quot;, &quot;|__|&quot;)),
            (&quot;p&quot; to listOf(&quot;___ &quot;, &quot;|__]&quot;, &quot;|   &quot;)),
            (&quot;q&quot; to listOf(&quot;____&quot;, &quot;|  |&quot;, &quot;|_\\|&quot;)),
            (&quot;r&quot; to listOf(&quot;____&quot;, &quot;|__/&quot;, &quot;|  \\&quot;)),
            (&quot;s&quot; to listOf(&quot;____&quot;, &quot;[__ &quot;, &quot;___]&quot;)),
            (&quot;t&quot; to listOf(&quot;___&quot;, &quot; | &quot;, &quot; | &quot;)),
            (&quot;u&quot; to listOf(&quot;_  _&quot;, &quot;|  |&quot;, &quot;|__|&quot;)),
            (&quot;v&quot; to listOf(&quot;_  _&quot;, &quot;|  |&quot;, &quot; \\/ &quot;)),
            (&quot;w&quot; to listOf(&quot;_ _ _&quot;, &quot;| | |&quot;, &quot;|_|_|&quot;)),
            (&quot;x&quot; to listOf(&quot;_  _&quot;, &quot; \\/ &quot;, &quot;_/\\_&quot;)),
            (&quot;y&quot; to listOf(&quot;_   _&quot;, &quot; \\_/ &quot;, &quot;  |  &quot;)),
            (&quot;z&quot; to listOf(&quot;___ &quot;, &quot;  / &quot;, &quot; /__&quot;)),
            (&quot; &quot; to listOf(&quot;    &quot;, &quot;    &quot;, &quot;    &quot;))
    )
    for (i in 0..2) {
        for (j in nameArr) {
            newName[i] += &quot;${letters[&quot;$j&quot;]?.get(i)} &quot;
        }
    }
    var size = 0
    if (newName[0].length &gt; stat.length) {
        size = newName[0].length
        star(size)
        println()
        println(&quot;*  ${newName[0]} *&quot;)
        println(&quot;*  ${newName[1]} *&quot;)
        println(&quot;*  ${newName[2]} *&quot;)
        print(&quot;*  &quot;)
        Status(stat, size)
        println(&quot; *&quot;)
        star(size)
    } else {
        size = stat.length
        var space = (size / 2) - (newName[0].length / 2)
        star(size)
        println()
        shortName(newName[0], space, size)
        shortName(newName[1], space, size)
        shortName(newName[2], space, size)
        print(&quot;* &quot;)
        Status(stat, size)
        println(&quot; *&quot;)
        star(size)
    }
}

fun star(nameSize: Int) {
    repeat(nameSize + 5) {
        print(&quot;*&quot;)
    }
}

fun Status( status: String, nameSize: Int){
    val statSize = status.length
    var space = (nameSize / 2) - (statSize / 2)
    Space(space - 1)
    print(status)
    if (statSize % 2 == 0 || nameSize % 2 != 0) {
        Space(space + 1)
    } else Space(space)
}

fun Space(space: Int) {
    repeat(space){
        print(&quot; &quot;)
    }
}
fun shortName(name: String, space: Int, size: Int) {

    if (size - name.length &lt;= 1 ) {
        print(&quot;* &quot;)
    } else print(&quot;*  &quot;)
    Space(space)
    print(name)
    Space(space)
    println(&quot; *&quot;)
}

Wrong output for input lines &quot;X Y&quot; and &quot;VeryVeryLoooooooooongSatus&quot;. Some indentation in your signature is incorrect. This test checks a long status with even length.

Please find below the output of your program during this failed test.
Note that the '&gt;' character indicates the beginning of the input line.

---

Enter name and surname: &gt; X Y
Enter person's status: &gt; VeryVeryLoooooooooongSatus
*******************************
*       _  _      _   _       *
*        \/        \_/        *
*       _/\_        |         *
* VeryVeryLoooooooooongSatus  *
*******************************

interface Point {
    val name: String
    val position: Position
    fun move(newPosition: Position): Point
}

Point
Foo
Bar
move
Point
move
class A : Point {
  override fun move(newPosition: Position): Point {
     return A(name, newPosition);
  }
  ...
}
class B : Point {
  override fun move(newPosition: Position): Point {
     return B(name, newPosition);
  }
}

var a: Point = A()
...
a = a.move(newPos)

val x = 2 + 3 //x = 5 CORRECT

val x = 2 +
    3 //x = 5 CORRECT

val x = 2
    + 3 //x = 2 WRONG

if (currentPlayer == 1) {
   currentPlayer = 0
} else {
   currentPlayer = 1
}

fun main(args: Array&lt;String&gt;) {
    val thing = Stuff(1, "Hi", true)
    val(thing1, thing2, thing3) = thing

    println(thing1)
}

data class Stuff(val thing1: Int, val thing2: String, val thing3: Boolean)

for (i in 0..10)
for (byte i = 1 &lt;&lt; 7; i != 0; i &gt;&gt;= 1)

for (byte i = 0x01; i != 0; i &lt;&lt;= 1)

Thing
!!
?:
class Thing {
}

private var myThing: Thing? = null

fun getThing(): Thing {
    // if null create, otherwise return exiting
    val tempThing = myThing ?: Thing()
    myThing = tempThing
    return tempThing
}

fun getAdminUser(): User {
    return getAllUsers().first { it.userType == ADMIN } as User
}

getAllUsers()
NoSuchElementException
try-catch
if (x in myList)

if (myList.contains(x))

if (x not in mylist)

if !(x in mylist)

if !(mylist.contains(x)))
&quot;abcde&quot;.splitAt(2) == listOf(&quot;ab&quot;, &quot;cd&quot;, &quot;e&quot;)

const val EMAIL_REGEX = &quot;^[A-Za-z](.*)([@])(.+)(\\.)(.{1,})&quot;

const val EMAIL_REGEX = &quot;^[A-Za-z](.*)([@])(.+)(\\.)(.{1,})&quot;
val emailMatcher = EMAIL_REGEX.toRegex()
val tmpList = emailMatcher.findAll(html).map { it.value }.toList()

re.findall(r&quot;[a-z0-9.\-+_]+@[a-z0-9.\-+_]+\.[a-z]+&quot;, response.text, re.I)

0
n
m
// represents number of mutable lists in the array
val n = 2
// represents number of Ints inside each mutable list
val m = 3

val arr = Array&lt;MutableList&lt;Int&gt;&gt;(n) { ??? }

arr
MutableList
n
Int
m
0
annotation class Base{}

@Base
class MyClass{}

fun &lt;T&gt; myFunc(myClass: T) where T: (&quot;Base&quot; is annotated){
  //-----
}

(&quot;Base&quot; is annotated)
class City(val country: String, val name: String, val population: Int)

fun main(args: Array&lt;String&gt;) {
  val cities = arrayOf&lt;City&gt;(
    City(country = &quot;USA&quot;, name = &quot;Boston&quot;, population = 2500000000),
    City(country = &quot;China&quot;, name = &quot;Beijing&quot;, population = 100000000),
    City(country = &quot;USA&quot;, name = &quot;Atlanta&quot;, population = 6000300)
  )

  printCitiesByCountry(cities);

listo
fun main(args: Array&lt;String&gt;) {
    class product(var product: String, var productName: String)
    val listo = arrayListOf(
            product(&quot;shirt&quot;, &quot;yoyo&quot;)
    )
    val testing = product(&quot;shirt&quot;, &quot;yoyo&quot;)
    if (testing in listo) {
        println(&quot;True&quot;)
    } else {
        println(&quot;False&quot;)
    }
}

class State(private val startStatus: Status, private val expectedStatus: Status) {
  
  companion object StatusList {
    val listStatuses = listOf(
      State(Status.A, Status.B),
      State(Status.B, Status.A),
      State(Status.B, Status.C),
      State(Status.C, Status.B),
      State(Status.C, Status.E),
      State(Status.C, Status.D),
      State(Status.D, Status.B),
      State(Status.E, Status.C),
      State(Status.E, Status.B)
    )
  
    open fun mapStatuses(): Map&lt;Status, Collection&lt;Status&gt;&gt; {
      return listStatuses.associateBy(
        keySelector = { key -&gt; key.expectedStatus },
        valueTransform = State::startStatus)
    }
  }
}

println(path.toString())
var i=0
for(i in 0 until path.size)
println(path[i].toString())

fun main() {
    println(&quot;Warming up&quot;)
    val input1 = Runningpath(&quot;in Forest&quot;, 2000, &quot;some houses&quot;)
    val input2 = Runningpath(&quot;at lake&quot;, 1500, &quot;a school&quot;)
    val path = arrayOf(input1, input2 )
    println(path.toString())
/*    var i=0
    for(i in 0 until path.size)
    println(path[i].toString())
   */
}
class  Runningpath(val name: String, val length: Int, val spot: String){
    override fun toString(): String= &quot;The Path $name ($length m) is near $spot&quot;
}

private var dates: Map&lt;String, Long?&gt; = mapOf(
    &quot;creation&quot; to System.currentTimeMillis(),
    &quot;lastUpdate&quot; to System.currentTimeMillis()
)

fun start(): Boolean {
    this.dates[&quot;lastUpdate&quot;] = System.currentTimeMillis()
    return true
}

printMaxMinPath()
printMaxMinPath()
 class  Runningpath(val name: String, val length: Int, val spot: String){                              
            override fun toString(): String= &quot;The path $name ($length m) is near $spot&quot;                       
                                                                                                                                                                                                       
            fun printMaxMinPath (p: Array&lt;Runningpath&gt; , min:Int, max:Int) {                                  
                println(&quot;The shortest path is with $min m. It is the path $name near $spot&quot;)                  
                println(&quot;The longest path is with $max m. It is the path $name near $spot&quot;)                   
                                                                                                              
            }                                                                                                 
        }                 
        
        fun main() {                                                                                          
            println(&quot;Warming up&quot;)                                                                             
            val input1 = Runningpath(&quot;in Forest&quot;, 2000, &quot;some houses&quot;)                                        
            val input2 = Runningpath(&quot;at lake&quot;, 1500, &quot;a school&quot;)                                             
            val input3 = Runningpath(&quot;in mountain&quot;, 2800, &quot;under sky&quot;)                                        
            val path = arrayOf(input1, input2, input3)                                                        
                                                                                
    line19   val max = path.length.max()                                                                       
        20   val min = path.length.min()                                                                       
            input1.printMaxMinPath(path, min, max)                                                            
        }                                                                                                     
                                             

                                                             
                                      

                     

                         

class Site(val address: String, val foundationYear: Int)
makeReddit()
Site
reddit.com
2005
class Site(val address: String, val foundationYear: Int) {
    fun makeReddit(address: String, foundationYear: Int): Site {
        return reddit
    }
    private val reddit = makeReddit(&quot;reddit.com&quot;, 2005)
}

var array=Array(5){it+1}

class State(private val startStatus: Status, private val expectedStatus: Status) {
   
  companion object StatusList {
    val listStatuses = listOf(
      State(Status.A, Status.B),
      State(Status.B, Status.A),
      State(Status.B, Status.C),
      State(Status.C, Status.B),
      State(Status.C, Status.E),
      State(Status.C, Status.D),
      State(Status.D, Status.B),
      State(Status.E, Status.C),
      State(Status.E, Status.B)
    )
   
    open fun mapStatuses(): Map&lt;Status, List&lt;Status&gt;&gt; {
      return listStatuses.groupBy({ it.startStatus }, { it.expectedStatus })
     // this returns {A=[B], B=[A, C], C=[B, E, D], D=[E], E=[C, B]}
    }
  }
}

fun isStateChangeValid(
    startStatus: Status,
    matchingStatus: List&lt;Status&gt;
  ): Boolean {
 
    val statusMap = mapStatuses()
 
    return statusChangeMap.containsKey(startStatus) &amp;&amp; statusChangeMap.containsValue(matchingStatus) ?: false 
}

{A=[B], B=[A, C], C=[B, E, D], D=[E], E=[C, B]}

isStateChangeValid(B,A) -&gt; true
isStateChangeValid(B,C) -&gt; true

isStateChangeValid(A,B) -&gt; true

fun isStateChangeValid(
    startStatus: Status,
    matchingStatus: List&lt;Status&gt;
  ): Boolean {

for ((k, v) in statusChangeMap) {
      return if (k == startStatus &amp;&amp; v[0] == matchingStatus[0]) {
        println(&quot;Find value by key  : $k = ${v[0]}&quot;)
        true
      } else {
        false
      }
    }
    return true ?: false
}

val x =
    if (true) {
        for (i in 1..5)
            if (i == 4)
                return@whats_there 0
        1
    }
    else 2

open class EchoWebSocketListener(instance: MainActivity?) : WebSocketListener() {
        open fun ReceiveString(message: String?) {
            println(&quot;foo&quot;)
        }
        override fun onMessage(webSocket: WebSocket?, text: String?) {
            output(&quot;Receiving : &quot; + text!!)
            ReceiveString(text)
        }
}

class NewMessage(instance: MainActivity?) : WebSocket.EchoWebSocketListener(instance) {
    override fun ReceiveString(message: String?) {
        println(message)
    }
}

class foo() {
  fun a() {
    println(&quot;foo&quot;)
  }

  //Assume this function is unchangeable and is running in a loop
  fun b() {
    fun a()
  }
}

+ - % /
var Num = 200_200
private val scoreModel = ScoreModel()

private lateinit var textEditMdl: EditText
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    setContentView(R.layout.activity_new_acft)

    textEditMdl = findViewById(R.id.newAcft_textEdit_mdl)

    newAcft_btn_save.setOnClickListener {
        calculateMdl(textEditMdl)
    }
}
private fun calculateMdl(rawScore: EditText): Double? {
    val rawScore = rawScore.text.toString()
    val key: Double? = rawScore.toDoubleOrNull()
    val value = scoreModel.eventMDL.values
    val valueMdl = value.toDoubleArray()

    if (value.contains(key)) {
            return valueMdl[0]
        }else {
        return 0.0
    }
}

open class Charator(var hp: Int, val power: Int) {

    fun attack(charator: Charator, power: Int = this.power) {
        charator.defense(power)
    }

    open fun defense(damage: Int) {
        hp -= damage
        if (hp &gt; 0) println(&quot;${javaClass.simpleName}'s hp is $hp &quot;)
        else println(&quot;die&quot;)
    }
}


class SuperMonster(hp: Int, power: Int) : Charator(hp, power) {
    fun bite(charator: Charator) {   **------&gt; Q. HOW CAN USE super EVEN DO NOT HAVE override ?**
                                                
        super.attack(charator, power + 2)
    }
}

JSONObject jsonObject = new JSONObject(response);
JSONArray jsonArray = jsonObject.getJSONArray(&quot;searches&quot;);
for (int i = 0; i &lt; jsonArray.length(); i++) {
     JSONObject jsonObject1 = jsonArray.getJSONObject(i);
     SearchHomeModel searchHomeModel = new SearchHomeModel();
     searchHomeModel.setWord(jsonObject1.getString(&quot;word&quot;));
     searchHomeModel.setUrl(jsonObject1.getString(&quot;url&quot;));
     JSONArray jsonArray1 = new JSONArray(jsonObject1.getString(&quot;user&quot;));
     for (int j = 0; j &lt; jsonArray1.length(); j++) {
          JSONObject jsonObject2 = jsonArray1.getJSONObject(j);
          searchHomeModel.setUsername(jsonObject2.getString(&quot;username&quot;));
          searchHomeModel.setId(jsonObject2.getString(&quot;id&quot;));
          searchHomeModel.setImage(jsonObject2.getString(&quot;image&quot;));
          }
     arrayList.add(searchHomeModel);
}

public class SearchHomeModel {

private String word, url, username, id, image, country, city, gender, job, age;
public String getWord() {
    return word;
}
public void setWord(String word) {
    this.word = word;
}
public String getUrl() {
    return url;
}
public void setUrl(String url) {
    this.url = url;
}
public String getUsername() {
    return username;
}
public void setUsername(String username) {
    this.username = username;
}
public String getId() {
    return id;
}
public void setId(String id) {
    this.id = id;
}
public String getImage() {
    return image;
}
public void setImage(String image) {
    this.image = image;
}
public String getCountry() {
    return country;
}
public void setCountry(String country) {
    this.country = country;
}
public String getCity() {
    return city;
}
public void setCity(String city) {
    this.city = city;
}
public String getGender() {
    return gender;
}
public void setGender(String gender) {
    this.gender = gender;
}
public String getJob() {
    return job;
}
public void setJob(String job) {
    this.job = job;
}
public String getAge() {
    return age;
}
public void setAge(String age) {
    this.age = age;
}

}

data class SearchHomeModel(
    val word: String,
    val url: String,
    val username: String,
    val id: String,
    val image: String,
    val country: String,
    val city: String,
    val gender: String,
    val job: String,
    val age: String
)

    private fun takePhoto() {
        // Get a stable reference of the modifiable image capture use case
        val imageCapture = imageCapture ?: return

        // Create timestamped output file to hold the image
//        val photoFile = File(
//                outputDirectory, SimpleDateFormat(FILENAME_FORMAT, Locale.ENGLISH
//        ).format(System.currentTimeMillis()) + &quot;.jpg&quot;)

        var photoFile = File(
                outputDirectory, &quot;image.jpg&quot;)

        // Create output options object which contains file + metadata
        val outputOptions = ImageCapture.OutputFileOptions.Builder(photoFile).build()

        // Setup image capture listener which is triggered after photo has been taken
        imageCapture.takePicture(
                outputOptions, cameraExecutor, object : ImageCapture.OnImageSavedCallback {
            override fun onError(exc: ImageCaptureException) {
                Log.e(TAG, &quot;Photo capture failed: ${exc.message}&quot;, exc)
            }

            override fun onImageSaved(output: ImageCapture.OutputFileResults) {

                //Creates intent and send our unique key and image name with activity, such that we can find our image.
                val intent = Intent(activity, ImagePreview::class.java)
                val extras = Bundle()
                extras.putString(&quot;EXTRA_URI&quot;, Uri.fromFile(photoFile).toString())
                intent.putExtras(extras)
                startActivity(intent)
            }
        })
    }

onResume
extras.putString(&quot;EXTRA_URI&quot;, Uri.fromFile(photoFile).toString())
photoFile.absoluteFile
val cannot be reassigned
line
fun modifyArray() {

    val lines = Array(5){&quot;&quot;}

    //why I can do this?
    for (i in 0..lines.lastIndex) {
        lines[i] = &quot;something&quot;
    }

    //but I can't do this?
    for (line in lines) {
        line = &quot;something else&quot;
    }
}

interface IConnectionManager {
    fun connect(connection: Int)
    fun disconnect(connection: Int)
    fun disconnectAll()
}

class ConnectionManager: IConnectionManager {
    private val connections = mutableMapOf&lt;Int, String&gt;()
    
    override fun connect(connection: Int) {
        connections[connection] = &quot;Connection $connection&quot;
    }
    
    override fun disconnect(connection: Int) {
        connections.remove(connection)?.let {
            println(&quot;Closing connection $it&quot;)
        }
    }

    override fun disconnectAll() {
        connections.forEach {
            disconnect(it.key)
        }
    }
}

disconnectAll()
ConcurrentModificationException
disconnect()
disconnectAll()
disconnectAll()
connections.keys
disconnectAll()
disconnect(iterator)
private closeConnection(connection: Int)
disconnect()
disconnectAll()
Syncable
SyncableWrapper
Syncable
getSelectorsToCompareValuesBy
==
.equals()
data class
getSelectorsToCompareValuesBy()
interface Syncable {
    fun &lt;T&gt; getSelectorsToCompareValuesBy(): (T) -&gt; Comparable&lt;T&gt;
}

class SyncableWrapper&lt;T: Syncable&gt;(
        val previous: T,
        val changed: T
) {
    fun comparePrevToChanged(): Int = compareValuesBy(previous, changed,
                previous.getSelectorsToCompareValuesBy()
        )
}

SyncableWrapper
comparePrevToChanged()
data class Something (
        val fieldToCompareWith1: String,
        val fieldToCompareWith2: String,
        val fieldToCompareWith3: String,
        val fieldToIgnore: String,
): Syncable {
        override fun &lt;Something&gt; getSelectorsToCompareValuesBy(): (Something) -&gt; Comparator&lt;Something&gt; {
                return {
                {it.fieldToCompareWith1}, {it.fieldToCompareWith2}, {it.fieldToCompareWith3}
                }
        }
}

comparePrevToChanged()
getSelectorsToCompareValuesBy
Comparable.compareTo
fun main(args : Array&lt;String&gt;){

    val rand = Random()
    var a:Int = rand.nextInt(10)
    var b:Int = rand.nextInt(10)
    
    while (a&lt;5 &amp;&amp; b&lt;5){
        a = rand.nextInt(10)
        b = rand.nextInt(10)
    }
    
    println(&quot;a is &quot;+a)
    println(&quot;b is &quot;+b)
}

a is 1
b is 6

fun plusMinus(expression: String): Int {
    try {
        val numbers = expression.split(&quot; &quot;)
    } catch (e: Exception) {
        throw e
    }
    var sum = 0
    val numbers = expression.split(&quot; &quot;)
    if (expression[0].isDigit()) {
        sum = numbers[0].toInt()
        for (i in 1 until numbers.size) {
            if (numbers[i] != &quot;+&quot; &amp;&amp; numbers[i] != &quot;-&quot;) {
                when (numbers[i - 1]) {
                    &quot;+&quot; -&gt; sum += numbers[i].toInt()
                    &quot;-&quot; -&gt; sum -= numbers[i].toInt()
                }
            }
        }
    }
    return sum
}

assertEquals(4, plusMinus(&quot;2 + 2&quot;))
assertEquals(6, plusMinus(&quot;2 + 31 - 40 + 13&quot;))
assertThrows(IllegalArgumentException::class.java) { plusMinus(&quot;+2&quot;) }
assertThrows(IllegalArgumentException::class.java) { plusMinus(&quot;2+2&quot;) }
assertThrows(IllegalArgumentException::class.java) { plusMinus(&quot;44 - - 12&quot;) }

fun next(prev: Int): Int
fun Int.nextValue(): Int
fun main() {
    val str1="Three "
    val str2="concantenated "
    var str3="strings."
    str3 = str3.tripcon(str1,str2)
    println(str3)
}

fun String.tripcon(s1: String,  s2: String) : String{
    return s1 + s2 + this
}

Three concatenated strings.

fun String.tripcon(s1: String,  s2: String){
    this= s1+s2+this
}

str3.tripcon(str1,str2)

this= s1+s2+this

false
object Keyboard{
    val keys = Key.values().associate { it to false }.toMutableMap()
    fun pressButtonForEvent(event : KeyEvent){
        keys[event.key] = true
    }

    fun isPressed(key : Key) : Boolean {
        return keys[key]
    }

}

fun isPressed(key : Key) : Boolean {
    return if (keys.containsKey(key)){
        keys[key]!!
    } else false
}

List&lt;Integer&gt; a = new ArrayList&lt;&gt;();
List&lt;? extends Number&gt; b = a;

Array&lt;String?&gt;
package com.blueslimee.kirani.listeners

import net.dv8tion.jda.core.entities.*
import net.dv8tion.jda.core.hooks.*
import net.dv8tion.jda.core.JDA
import net.dv8tion.jda.core.events.message.MessageReceivedEvent
import com.blueslimee.kirani.utils.KiraniLogging
import com.blueslimee.kirani.KiraniCommand
import com.blueslimee.kirani.utils.Registry

class MessageListener() : ListenerAdapter() {
  override fun onMessageReceived (event: MessageReceivedEvent) {
    val jda: JDA = event.getJDA()
    // todo: cmds guild-only  event.isFromType(ChannelType.TEXT)
    if (!event.getAuthor().isBot()) {
        var msgContent: String? = event.getMessage()
        if (msgContent === null) {
          return 
        }
        var args: Array&lt;String?&gt; = msgContent!!.split(" ")
        var firstArg: String? = args[0]
        if (!firstArg!!.startsWith("k-", true)) {
          return 
        }
        firstArg = firstArg!!.replace("k-", "", true)
        var cmde: KiraniCommand? = Registry.getCommand(firstArg)
        if (cmde  != null) {
          try {
            cmde!!.run(jda, event, args)
          } catch (e: Exception) {
            event.getChannel().sendMessage("Oopsie Woopsie, um erro ocorreu! Meu dono já foi reportado sobre, peço que aguarde.").queue()
            e.printStackTrace()
          }
       }
    }
  }
}

myInt = dat.getOrElse(0, 0).toInt()

The integer literal does not conform to the expected type (Int) -&gt; Byte

fun main (args: Array&lt;String&gt;) {
    val Myself = "Programmer"
    var Alphi = Myself[5]
    println(Alphi)
}

val src = (0 until 1000000).toList()
val dest = ArrayList&lt;Double&gt;(src.size / 2 + 1)    

for (i in src)
{
    if (i % 2 == 0) dest.add(Math.sqrt(i.toDouble()))
}

val src = (0 until 1000000).toList()
val dest = ArrayList&lt;Double&gt;(src.size / 2 + 1)
src.filter { it % 2 == 0 }
   .mapTo(dest) { Math.sqrt(it.toDouble()) }

filter
filter
interface Foo {
    fun bar(): String {
        return "baz"
    }
}

bar()
super.bar()
class A(val id: String) {

    inner class B {}
}

fun test() {
    val a = A("test")
    val b = a.B()
    aid(a)
    bid(b)
}

fun aid(a:A): String = a.id
fun bid(b:A.B): String = b.id //Unresolved reference: id

this@A.id
class Person {
   var name:String? = null
   var age:Int? = null

   fun setter(propName:String, value:Any): Person{
      return this.apply {
          try {
              // the line below caused error
              this[propName] = value
          } catch(e:Exception){
              println(e.printStackTrace()) 
          }
      }
   }
}


//usage
var person = Person(null,null)
person
   .setter(name, "Baby")
   .setter(age, 20)

private var mMediaController by Delegates.notNull&lt;MediaControllerCompat&gt;()

lateinit private var mMediaController: MediaControllerCompat

    @Subscribe
    fun connectToSession(token: MediaSessionCompat.Token) {
         mMediaController = MediaControllerCompat(activity, token)
         mMediaController.registerCallback(mMediaControllerCallback)
    }

fun test() {
    class Test(val foo: ((Double, Double) -&gt; Double)?)
    val test = Test(null)

    if(test.foo != null) test.foo(1.0, 2.0)
}

test.foo?.invoke(1.0, 2.0)
test.foo.invoke(1.0, 2.0)
test.foo(1.0, 2.0)
fun test2() {
    val foo: ((Double, Double) -&gt; Double)? = null

    if(foo != null) foo(1.0, 2.0)
}

fun foo(){} //global foo
fun bar(){} //global bar

class FooBar {

   fun foo(){
       foo() //this makes me a recurrence but I want to call global foo here
   }

   fun bar(){
       bar() //this makes me a recurrence but I want to call global bar here
   }

    companion object {
       fun foo() {
           bar()// how to call global bar here?
       }
    }
}

val list: List&lt;Animal&gt; = listOf(Animal(1), Animal(2), Animal(7))

val storage = object : Storage  {
    override fun &lt;T&gt; fetch(clazz: Class&lt;T&gt;): List&lt;T&gt; {
       if(clazz is Animal::class.java){
           return list
       }
        throw RuntimeException()
    }

} 

Error:(14, 20) Kotlin: Type mismatch: inferred type is kotlin.collections.List&lt;polar.QueryTest.Animal&gt; but kotlin.collections.List&lt;T&gt; was expected

     bitmap1 = Bitmap.createScaledBitmap(

        bitmap1, // &lt;---- error is  here 

        (width.toInt()),

        (height.toInt()),

        false)

    numberOfInvaders ++

                 if (uhOrOh) {
                    canvas.drawBitmap(Invader.bitmap1, // &lt;--- error is here 
                        invader.position.left,
                        invader.position.top,
                        paint)
                } else {
                    canvas.drawBitmap(Invader.bitmap2, // &lt;---- and here
                        invader.position.left,
                        invader.position.top,
                        paint)
                }

init
object
fun main(args: Array&lt;String&gt;) {
    TestObj
    TestObj
}

object TestObj {
    var count = 0

    init {
        fun howManyTimes() {
            println(++count)
        }
    }
}

data class Column&lt;T&gt;(val name: String, val value: T)
data class Row(val data: List&lt;Column&lt;*&gt;&gt;)
data class Grid(val rows: List&lt;Row&gt;)

i
*Context
// Demo data:
open class Super
class Sub0: Super
class Sub1: Super
// Mappers:
fun map(a: Super) = println("Super")
fun map(a: Sub0) = println("Sub0")
fun map(a: Sub1) = println("Sub1")

listOf(Super(), Sub0(), Sub1()).forEach {
    when (it) {
        is B, is C -&gt; { print('*'); map(it) }
        else -&gt; map(it)
    }
}

it
map
Super
*Super
*Super

SubX
when (it) {
    is Sub0 -&gt; {
        print("*");
        map(it)
    }
    is Sub1 -&gt; {
         print("*");
         map(it)
    }
    else -&gt; map(it)
}

map(X)
fun waitUntilConditionIsMatched() {
    val maximumWaitTime = Duration.ofSeconds(10L)
    val maximum = currentTimeMillis() + maximumWaitTime.toMillis()

    println("Waiting for maximum of $maximumWaitTime for a condition to be matched...")

    while (currentTimeMillis() &lt;= maximum) {
        if (conditionIsMatched) {
            println("...condition matched")
            break
        } else {
            doWait(Duration.ofMillis(500))
        }
    }

    println("...timeout exceeded. Condition was not matched.")
}

@var ||= 'value' 

@var
'value'
@var
@var
nil
testVariableArguments
testFunctionWithReceiver
fun main(args: Array&lt;String&gt;) {
    testVariableArguments { a: Int -&gt; println(a) }
    testVariableArguments { a: Int, b: Int -&gt; println("$a, $b") }
    testVariableArguments { a: Int, b: Int, c: Int -&gt; println("$a, $b, $c") }
    testVariableArguments { a: Int, b: Int, c: Int, d: Int -&gt; println("$a, $b, $c, $d") }

    testFunctionWithReceiver {
        doSomething()
        doAnotherThing()
    }
}

fun &lt;R, T : Function&lt;R&gt;&gt; testVariableArguments(function: T) {
    val method = function::class
            .java
            .declaredMethods
            // May need to do something else here to get the
            // correct method in case the return type is 
            // expected to be Object, but for my case it 
            // would never be Object
            .first { m -&gt; m.name == "invoke" &amp;&amp; m.returnType != Object::class.java }


    val args = method
            .parameterTypes
            // Mapping to Int here for demonstration, in real
            // situations would use the parameter types to
            // create the correct value
            .withIndex()
            .map { i -&gt; i.index }
            // Not really needed, but would be if I were 
            // using multiple types and not just Int
            .map { i -&gt; i as Any }
            .toTypedArray()

    method.invoke(function, *args)
}

fun &lt;R&gt; testFunctionWithReceiver(function: MyInterface.() -&gt; R) {
    val myObject = object : MyInterface {
        override fun doSomething() {
            println("doing something")
        }

        override fun doAnotherThing() {
            println("doing another thing")
        }
    }
    function(myObject)
}

interface MyInterface {
    fun doSomething()
    fun doAnotherThing()
}

MyInterface
operator fun &lt;R, T : Function&lt;R&gt;&gt; T.unaryPlus() {
    testVariableArgumentDefinition(this)
}

testFunctionWithReceiver
testFunctionWithReceiver {
    +{ a: Int, b: Int -&gt;
        println("$a, $b")
        doSomething()
        doAnotherThing()
    }
}

data class Something(val mendatory: String = "default value")

val userInput: String? by SomeTypeOfInputFieldThatReturnsNullable

//val something = Something(userInput)    //not valid because userInput is String?

val something = if (userInput == null) 
                    Something() 
                else 
                    Something(userInput)

val map = Map(1 to 111, 2 to 222, 3 to 111)

Map(111 to List(1,3), 222 to 2)

private var myObject : Any

fun dataClassTypeCheck(): Boolean {
      if (myObject is KClass&lt;*&gt;) {return true}
      return false
    }

val result = MutableList(N) { 0 }

result
for (item in result.withIndex()) {
                result[item.index] = result[item.index] + 1
}

it-&gt; it+=1
::test
{ test }
::test
{ test }
::test
KProperty
() -&gt; String
class Test(val test : String) {
  fun testFun(func: ()-&gt;String) : String = func()
  fun callTest() {
    testFun { test } // or (::test) // is it using reflection? are these real references?
  }
}

List&lt;T?&gt;
sequence
fun &lt;T&gt; sequence(a : List&lt;T?&gt;) : List&lt;T&gt;? {
    return 
        a.fold(
            listOf(),
            { 
                prevArray, element -&gt; 
                    if(element == null) null else prevArray + element 
            })
}

Null can not be a value of a non-null type kotlin.collections.List&lt;T&gt;
Optional
fun &lt;T&gt; sequence(a : List&lt;T?&gt;) : Optional&lt;List&lt;T&gt;&gt; {
    return 
        a.fold(
            Optional.of(listOf()),
            { 
                prevArray, element -&gt; 
                    if(element == null) Optional.empty&lt;List&lt;T&gt;&gt;() else Optional.of(prevArray + element) 
            })
}

Kotlin
main()
fun main() {
    dayOfWeek()
}

Kotlin
Java
 ArrayList&lt;String&gt; staticlist = new ArrayList&lt;String&gt;()
        staticlist.add("Dairy")
        staticlist.add("Food")
        staticlist.add("Juice")
        staticlist.add("Bakery")
        staticlist.add("Poultry")

ArrayList&lt;String&gt; mySortedItems= new ArrayList&lt;String&gt;()
       staticlist.add("Food")
        staticlist.add("Poultry")
        staticlist.add("Juice")
        staticlist.add("Bakery")

mySortedItems.sort((s1,s2)-&gt; Integer.compare(mySortedItems.indexOf(s1),mySortedItems.indexOf(s1)))

val originalImage = imagesArray.find {it.position == 2}

data class Image (
    val position: Int? = 0,
    val coor: IntArray = intArrayOf(0, 0)
) {
    override fun equals(other: Any?): Boolean {
        return super.equals(other)
    }

    override fun hashCode(): Int {
        return super.hashCode()
    }
}

fun Route.customerUploadImage() {
logger.info { "Receiveing Image request" };
post("/me/image") {
    logger.info { "Receiveing Image POST request" };
    call.customerService.saveProfileImage(call.receiveMultipart(), loggedUser().userId!!)
    call.respondStatus(HttpStatusCode.Accepted)
}

suspend fun saveProfileImage(multipart: MultiPartData, userId: Long) {
    logger.info { "Receving Image Request!!!!" }
    multipart.forEachPart { part -&gt;
        (part as? PartData.FileItem)?.run {
            logger.info { this.headers.get("Content-Type") }
            logger.info { "save image, name: $name, file name: $originalFileName" }
            val imageName = allowedProfileImages.firstOrNull { it == name } ?: throw AppException(ErrorCode.INVALID_IMAGE_NAME)
            bao.put(streamProvider(), "profile/$userId-${imageName.toLowerCase()}", blobContentType).also { resourceUrl -&gt;
                logger.info { "resourceUrl - $resourceUrl" }
                dao.get(Customer::class, userId)?.also { customer -&gt;
                    logger.info { "customer - $customer" }
                    dao.put(customer.copy(images = setOf(resourceUrl, *customer.images.toTypedArray())))
                }
            }
        }
        part.dispose()
    }
}

public class VehicleSpec()
{
var OEM: String? = null
var ModelName: String? = null
var EngineSize: String? = null
}

var VehicleSpec = arrayOf(20,20)
VehicleSpec[0][0] = Null //OEM
VehicleSpec[0][1] = Null //ModelName
VehicleSpec[0][2] = Null //EngineSize

import java.text.DecimalFormat

fun main(args: Array&lt;String&gt;) {
    val l = 1513741500
    val f:Float = l.toFloat()
    val df = DecimalFormat("0")
    println(df.format(f))
}

Output:
1513741440

Piece
fun choose(): KClass&lt;Piece&gt;

return Queen::class
KClass&lt;*&gt;
MutableList.remove
fun &lt;T&gt; MutableCollection&lt;out T&gt;.remove(element: T): Boolean

myBook
Stuff?
null
data class Stuff(val name: String)

fun main(args: Array&lt;String&gt;) {
    val myListOfStuff: ArrayList&lt;Stuff&gt; = arrayListOf(
            Stuff("bed"),
            Stuff("backpack"),
            Stuff("lunch")
    )
    val myBook = myListOfStuff.find { it.name == "book" }
    val found = myListOfStuff.remove(myBook)
    println(myListOfStuff)
}

remove
T?
fun &lt;T&gt; MutableCollection&lt;out T&gt;.remove(element: T?): Boolean

out
T
var poses = arrayOf&lt;Array&lt;Double&gt;&gt;()

poses.forEach {
        println(Arrays.toString(it))
    }

[-71.42510166478651, 106.43593221597114]
[104.46430594348055, 78.62761919208839]
[100.27031925094859, 79.65568893000942]
[311.2433803626159, 233.67219485640456]
[330.3015877764689, -114.9000129699181]
[34.76986782382592, -383.71914014833436]
[355.477931403836, -173.29388985868835]
[322.72821807215564, -45.99138725647516]
...

let
run
apply
foo.bar?.let(return true)?:return false

return foo.getbar() != null

Point
(0,0)
x,y
interface Generic {
    val t: T //I need this type only once, thats why I dont wanna pass in the class level

    fun &lt;E&gt; gMethod(e: E) { //This works, so I'm wondering if there's something similiar to properties

    }
}

val criteriaList = aList.stream().map { dateRange -&gt; {
            Criteria.where("KEY").`is`(dateRange) } }.toList().toTypedArray()

Criteria().orOperator(*criteriaList)

Criteria().orOperator(*criteriaList)

Type mismatch.
Required:
Array&lt;(out) Criteria!&gt;!
Found:
Array&lt;(() → Criteria!)!&gt;

items.forEach { item -&gt;
            request += getDetails(item.propertyId, item.destinationIds)
            count++
            if( count == bulkSize) {
                save(request)
                request = ""
                count = 0
            }
        }

        if(!request.isEmpty()) {
            save(request)
        }

    private fun updateJar(frame: LaunchFrame, project: Project) {
    val sourcePath = project.jarSourcePath
    val jarPath = project.jarPath
    val repoName = project.repoName

    frame.log("Reading source URL from '$sourcePath'")
    val sourceUrl = readTextFile(sourcePath)?.let { URI(it) }
    frame.log("Source URL: $sourceUrl")

    frame.log("Connecting to GitHub")
    val github = GitHub.connectAnonymously()

    frame.log("Using repository '$repoName'")
    val repo = github.getRepository(repoName)

    frame.log("Finding latest release")
    val latestRelease = repo.listReleases().first()
    val assets = latestRelease.assets
    check(assets.size == 1) { "Release must only have one asset" }
    val asset = assets.first()
    val downloadUrl = URI(asset.browserDownloadUrl)
    frame.log("Latest URL: $downloadUrl")

    if (sourceUrl == null || sourceUrl != downloadUrl || !verifyJar(jarPath)) {
        frame.log("Downloading '$downloadUrl' to '$jarPath'")
        downloadFile(downloadUrl, jarPath)

        frame.log("Writing '$downloadUrl' to '$sourcePath'")
        writeTextFile(sourcePath, downloadUrl.toString())
    } else {
        frame.log("'$jarPath' is up to date")
    }
}

val (minValue, minInt) = Values.zip(Ints).minBy { (_ /* Value not needed */, rating) -&gt;
        rating } ?: throw IllegalArgumentException("Cannot find the minimum of an empty list.")

val text = """
        a
        10 rows; 120 columns
        b
        """

val columns = "(\\d+) rows; (\\d+) columns".toRegex(RegexOption.MULTILINE).find(text)?.destructured?.let { (height, width) -&gt;
  width.toIntOrNull()
} ?: 90

    var num:Int? = null
    var vice:Float = 20.0f
    if (num?.toFloat()?:0.0f- vice &lt; 0.0f)

val realNumFloat = num?.toFloat()?:0.0f
    if(realNumFloat - vice &lt; 0.0f)
var String.setString
    get() = "ignorethis"
    set(value) = this = value

Variable expected.
this
class abc {
    constructor(a: Int)
    constructor(a: Int, e: Int)
}

class def(a: Int) {
    constructor(a: Int, e: Int) : this(a)
}

[A, B, C]
[[A, B], [A, C], [B, C]]
for(i in 0 until arr.size-1)
    for(j in i+1 until arr.size)
        //do stuff with arr[i], arr[j]

val ipColumn = headerRow.cellIterator().let {
    it.forEach { cell -&gt;  
        if ("IP" == formater.formatCellValue(cell))
            return@let cell.columnIndex 
    }
}

switch
when
when
override fun getItemViewType(position: Int): Int {
    when (position) {
        0 -&gt; return ItemViewType.TITLE.type
        1 -&gt; return ItemViewType.SUBTITLE.type
        2 -&gt; return ItemViewType.ITEM.type
        else -&gt; return -1
    }
}

Return can be lifted out of 'when'
when
        fun getUpdatedStr(): DoubleArray {
            var Strings : DoubleArray = doubleArrayOf()
            for (i in 0..9) {
                val page = Jsoup.connect("somesite.com").get()
                val table = page.select("table").first().select("td").first()
                Strings += table.text()
                }
            return Strings
        }

val ints = listOf(0, 1, 2)
val strings = listOf("a", "b", "c")

0a, 1a, 2a, 0b
ints.forEach { int -&gt; 

    strings.forEach { string -&gt;  


        println("$int $string")

    }

}

     // REST web service call to get data from coinmarketcap API
inner class RetrieveFeedTask : AsyncTask&lt;Void, Void, String&gt;() {
    override fun doInBackground(vararg p0: Void?): String? {
 //            TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
        try {
            // create a connection
            val siteURL  = URL("https://api.coinmarketcap.com/v1/ticker/?limit=200")
            val urlConn = siteURL.openConnection() as HttpURLConnection
            urlConn.connect()
            // if there the connection is successful
            try {
                // reads the urlConn as a string
                val bufferedReader = urlConn.inputStream.bufferedReader()
                val stringBuilder = StringBuilder("")
                // each line from the json object
                var line : String?
                do {
                    line = bufferedReader.readLine()
                    stringBuilder.append(line).append("\n")
                    if (line === null)
                        break
                } while (true)
                bufferedReader.close()
                return stringBuilder.toString()
            } catch (e : Exception) {
                throw e
            } finally {
                urlConn.disconnect()
            }
        } catch (e : Exception) {
            Log.e("NETWORK","Couldn't connect to the website: " + e)
            return null
        }
    }

    override fun onPostExecute(result: String?) {
        if (result == null) {
            // should return an error message
            testTextView!!.text = "Error with website"
        } else {
            testTextView!!.text = result
        }
    }

}

if (bar == null) {
    // do something
}

bar ?: run {
    // do something. 
}

public abstract class Element&lt;S extends Snapshot&gt; { ... }
public abstract class Snapshot&lt;E extends Element&gt; { ... }

public class SnapshotImpl extends Snapshot&lt;ElementImpl&gt; { ... }
public class ElementImpl extends Element&lt;SnapshotImpl&gt; { ... }

abstract class Element&lt;S : Snapshot&gt; 
abstract class Snapshot&lt;E : Element&gt;

Error:(6, 28) Kotlin: One type argument expected for class Snapshot&lt;E&gt; defined in model
 Error:(6, 25) Kotlin: One type argument expected for class Element&lt;S&gt; defined in model
open class Foo {
    fun start() {
        bar()
        //...
    }
    fun bar() {
        TODO("implement me in deriving class")
    }
}

interface Base {
    fun print()
}
class BaseImpl(val x: Int) : Base {
    override fun print() { print(x) }
}
fun main(args: Array&lt;String&gt;) {
    val b : Base = BaseImpl(10)
    b.print() // prints 10
}

Base
b
kotlin
interface Base {
    fun print()
}
class BaseImpl(val x: Int) : Base {
    override fun print() { print(x) }
}
class Derived(b: Base) : Base by b // why extra line of code? 
                                   // if the above example works fine without it.
fun main(args: Array&lt;String&gt;) {
    val b = BaseImpl(10)
    Derived(b).print() // prints 10
}

null
item.parent
interface Item {
    val parent: Directory
}

interface ItemWithChildren{
    val children: MutableList&lt;Item&gt;
}

class Directory() : Item, ItemWithChildren {
    override val children: MutableList&lt;Item&gt; = mutableListOf()
    override val parent: Directory by lazy { this }

    constructor(par: Directory) : this() {
        parent = par //Error: val cannot be reassigned 
    }
}

class File(override val parent: Directory) : Item

val parent
this
null
item.parent
List
Array
val names1 = listOf("Joe","Ben","Thomas")
val names2 = arrayOf("Joe","Ben","Thomas")

for (name in names1)
    println(name)
for (name in names2)
    println(name)

// compiles just fine
fun &lt;A, B&gt; CompletableFuture&lt;A&gt;.map(fn: (A) -&gt; B): CompletableFuture&lt;B&gt; = 
    this.thenApplyAsync(fn)

// Compile error:
// Type inference failed: fun &lt;U : Any!&gt; thenApplyAsync(p0: Function&lt;in A!, out U!&gt;!, p1: Executor!): CompletableFuture&lt;U!&gt;!
// cannot be applied to
// ((A) -&gt; B,ExecutorService)
// 
// Type mismatch: inferred type is (A) -&gt; B but Function&lt;in A!, out B!&gt;! was expected
fun &lt;A, B&gt; CompletableFuture&lt;A&gt;.map(fn: (A) -&gt; B): CompletableFuture&lt;B&gt; =
    this.thenApplyAsync(fn, BackgroundPool)

(Context!, String!, SQLiteDatabase.CursorFactory!, Int)
class TodoListDBHandler(context: Context, databaseName: String, factory: SQLiteDatabase.CursorFactory, databaseVersion: Int): 
    SQLiteOpenHelper(context, databaseName, factory, databaseVersion)

class TodoListDBHandler(context: Context, databaseName: String, factory: SQLiteDatabase.CursorFactory, databaseVersion: Int): 
    SQLiteOpenHelper(context, databaseName, factory, databaseVersion) {

    val databaseFileName = "todoList.db"
    val databaseVersion = 1

    override fun onCreate(db: SQLiteDatabase?) {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }

    override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
}

public TodoListDBHandler(Context context, SQLiteDatabase.CursorFactory factory) {
    // databaseFileName and databaseVersion are already specified inside the class
    super(context, databaseFileName, factory, databaseVersion)
}

class FullWallModeActivity : AppCompatActivity() {

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_full_wall_mode)

}

private var trackConstantTime: Long? = null
this.trackConstantTime = measureTimeMillis {
 /* determine if a given number is even or odd */
 var n = (0..(Int.MAX_VALUE)).random()
 if(n % 2 == 0) "Even" else "Odd"
}
println("O(1), Constant Time for fxConstantTime(...):${TimeUnit.MILLISECONDS.toSeconds(trackConstantTime!!)}")

private var trackLinearTime: Long? = null
private var uL: MutableList&lt;Int&gt; = mutableListOf()
for(i in 0..100){
 this.uL.add( ((0)..(100)).random() )
}
this.trackLinearTime = measureTimeMillis { 
 /* determine the maximum value in an unsorted array */
 var max: Int = 0
 for(i in 0 until uL.size) {
  if (uL[i] &gt; max) max = uL[i]
  println(max)
 }
}
println("O(n), Linear Time for fxLinearTime(...):${TimeUnit.MILLISECONDS.toSeconds(trackLinearTime!!)}")

val data = mutableMapOf&lt;String,String&gt;()
data.put("some_string_1","data_1")
.
.
.
data.put("some_string_n","data_n")

Iterator whatever = entrySet.iterator()
while (whatever.hasNext()) {
    for (int i = 0; i &lt; 4; i++) {
        if (i == 3) {
            whatever.remove(whatever.next().key)
        }
    }
}

fun describe(obj?: Any): String =
    when(obj?) {
        1           -&gt; "one"
        "hello"     -&gt; "greeting"
        is Long     -&gt; "long"
        !is String  -&gt; "not String"
        is null     -&gt; "null"
        else        -&gt; "unknown"
    }


fun main() {
    println(describe(1))
    println(describe("Hello"))
    println(describe(1000L))
    println(describe(2))
    println(describe(null))
    println(describe("other"))
}

fun main(args: Array&lt;String&gt;) {
    val bis = File(args[0]).inputStream().buffered()
    val buf = ArrayList&lt;Int&gt;()
    while(true) {
        val i = bis.read()
        if (i &lt; 0) break
        buf.add(i)
        if (i == 0x0d) {
            process(buf)
            buf.clear() 
        }
    }
    bis.close()
}

class MyTest {

    var test: String = "string"
        get() {
            logIt("Property accessed")
            return it
        }

}

it
val wxPayOrderObj = WxPayOrder(appid = "wx0b6dcsad20b379f1", mch_id = 
            "1508334851", nonce_str = UUID.randomUUID().toString(),sign = null,
            body = "QQTopUp", out_trade_no = "20150806125346", total_fee = req.total_fee,
            spbill_create_ip = "123.12.12.123",
            trade_type = "JSAPI", openid = "oUpF8uMuAJO_M2pxb1Q9zNjWeS6o")

    appid=wx0b6dc78d20b379f1&amp;mch_id=150788851&amp;nonce_str=UUID.randomUUID().toString()&amp;
body=QQTopUp&amp;out_trade_no=20150806125346&amp;total_fee=req.total_fee&amp;
spbill_create_ip=123.12.12.123&amp;trade_type=JSAPI&amp;openid=oUpF8uMuAJO_M2pxb1Q9zNjWeS6o

class PostWithComments (
@Embedded val post: Post,
@Relation(
    parentColumn = "id",
    entityColumn = "commentId"
)
val comments : List&lt;Comment&gt;
)

@Transaction
@Query("SELECT * FROM post")
fun getPostsandComments(): LiveData&lt;List&lt;PostWithComments&gt;&gt;

@ColumnInfo(name = "postId")
val postId:Int = 0,

@ColumnInfo(name = "comment")
val comment: String
): Parcelable {
@PrimaryKey(autoGenerate = true)
@ColumnInfo(name = "commentId")
val id :Int = 0
 }

Collections.isEmpty
Collections.size
isEmpty
size === 0
isEmpty
data class Cats(var data: Data? = null)
Cats
data
data: Data? = null
data class Cats(var data: Data? = null)

data class Data(var images: ArrayList&lt;Image&gt;? = null)

data class Image(var url: String? = "", var id: String? = "", var source_url: String? = "")

fun invoke(callback: Callback): Unit

void
Unit
void
(Result) -&gt; Unit
// inside a java method (currently)
abstractClass.invoke(callback)
return Unit.INSTANCE

// what I'd prefer instead
return abstractClass.invoke(callback) // invoke returns Unit, but it's in Kotlin, so it maps to void in Java. So this doesn't work

fun FlowOrPhrasingOrMetaDataContent.script(type : String? = null, src : String? = null, block : SCRIPT.() -&gt; Unit = {}) : Unit = SCRIPT(attributesMapOf("type", type,"src", src), consumer).visit(block)

&lt;ClassName&gt;.()
fun main(args: Array&lt;String&gt;) {
    println("sddfsdf".isNice())
}

fun String.isNice(): Boolean {
    val hasRepeat = {
        for (i in 0 .. (length - 2)) {
            if (subSequence(i, i + 2).toSet().size == 1) {
                true
                println(subSequence(i, i + 2))
            }
        }
        false
    }

    return hasRepeat()
}

dd
false

abstract class AbsSuperClass {
    abstract fun someFun()
}

class Subclass : AbsSuperClass {
    override fun someFun()
}

class NeverNullMap&lt;K, V&gt;(private val backing: MutableMap&lt;K, V&gt; = mutableMapOf(), val default: () -&gt; V): MutableMap&lt;K, V&gt; by backing {
    override operator fun get(key: K): V = backing.getOrPut(key, default)
}

fun main(args: Array&lt;String&gt;) {
    val myMap = NeverNullMap&lt;String, Int&gt; {0}
    println(myMap["test"])
    myMap["test"] = myMap["test"] + 10
    println(myMap["test"])
}

0
10

fun main(args: Array&lt;String&gt;) {
    val myMap = NeverNullMap&lt;String, Int&gt; {0}
    println(myMap["test"])
    myMap["test"] += 10
    println(myMap["test"])
}

Exception in thread "main" java.lang.IllegalAccessError: tried to access method kotlin.collections.MapsKt__MapsKt.set(Ljava/util/Map;Ljava/lang/Object;Ljava/lang/Object;)V from class Day08Kt
    at Day08Kt.main(Day08.kt:10)

+=
  Map var2 = (Map)myMap;
  String var3 = "test";
  Integer var4 = ((Number)myMap.get("test")).intValue() + 10;
  var2.put(var3, var4);

MapsKt.set(myMap, "test", ((Number)myMap.get("test")).intValue() + 10);

trait HasAge {
    val dateOfBirth: LocalDate
    val age: Int
        get() = ...
}

class Person : HasAge {
    ...
    public override var dateOfBirth: LocalDate? = null
}

trait HasAge {
    val dateOfBirth: LocalDate
    val age: Int
        get() = ...
}

trait HasAgeN {
    val dateOfBirth: LocalDate?
    val age: Int?
        get() = ...
}

 /first/
 /first/second
 /first/third
 /first/third/forth
 /first/third/fifth
 /first/sixth
 /first/sixth/seventh
 /first/eighth
 /first/ninth

first
  second
  third
    forth
    fifth
sixth
  seventh
eighth
ninth

fun getDirs(directoryName: String): MutableList&lt;String&gt; {
    val ret = mutableListOf&lt;String&gt;()

    File(directoryName).walk().forEach {
        if (it.isDirectory) { ret.add(it.toString()) }
    }    

    return ret
}

private fun nodesFromPathList(dirPaths: MutableList&lt;String&gt;) : Tree.Node {
    val ret = Tree.Node("root")

    for (dir in dirPaths) {
        ret.add(Tree.Node(dir))
    }

    return ret
}

class A {} // This is Java class

A.foo() // This is call of extension function `foo` from Kotlin code

class TestSub(val sub: Sub) {

    fun create() = template()

    fun template() = Files.newBufferedReader(ClassPathResource(templateId.location).file.toPath()).readText()
}

data class Sub(val name: String, val age: Int)

fun main(args: Array&lt;String&gt;) {
    val sub = Sub("Prashant", 32)

    println(TestSub(sub).create())
}

fun template()
fun template() = "&lt;h1&gt;Hello ${sub.name}. Your age is ${sub.age}&lt;/h1&gt;"

val foo: Int = 1
foo.toDouble() // ok

val bar = 2.toUInt()
bar.toDouble() // error!

toDouble
.toFloat
Error:(11, 4) Unresolved reference. None of the following candidates is applicable because of receiver type mismatch:
@InlineOnly public inline fun String.toDouble(): Double defined in kotlin.text

//judging employee's salary level,  and set a default implemention of the function:whether it &gt; amount
fun paidMore(amount: Int, employee: Employee,
     predicate: (Int, Employee) -&gt; Boolean = { amount, employee -&gt; employee.salary &gt; amount }
): Boolean = predicate(amount, employee)

fun paidMore(amount: Int, employee: Employee, 
      predicate: (Int, Employee) -&gt; Boolean = employee.salary &gt; amount
): Boolean = predicate(amount, employee)

//This code is treated as a Boolean expression, not a function.
employee.salary &gt; amount

fun main(args: Array&lt;String&gt;){
    var person = Person("Jimmy")
    println(person)
}


class Person(val name: String){
    var age = 10
}

package start

fun main(args: Array&lt;String&gt;) {
}

fun myfun(args: Array&lt;String&gt;) {
}

package start
// OK!
fun main(args: Array&lt;String&gt;) {
}
// Error! Conflicting overloads
fun myfun(args: Array&lt;String&gt;) {
}

import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__

import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.*

package blah

class `__` {

}

fun parse(type: Any) : MyObject {
    return handleParse(type)
}

fun parse(type: Any?) : MyObject? {
    if (type == null)
        return null

    return handleParse(type)
}

Platform declaration clash: The following declarations have the same JVM signature

!!
@JvmName("-name")
fun getMnemonic(color: Color) = when (color) {   

    color.RED -&gt; "Richard"   
    color.ORANGE -&gt; "Of" 
    color.YELLOW -&gt; "York" 
    color.GREEN -&gt; "Gave" 
    color.BLUE -&gt; "Battle" 
    color.INDIGO -&gt; "In" 
    color.VIOLET -&gt; "Vain" 
    else -&gt; println("ok retry") 
}    

fun main() {
    println(getMnemonic(color.BLUE))
}      

==
// PersonImpl0 has the name variable in the primary constructor
data class PersonImpl0(val id: Long, var name: String="") {
}

// PersonImpl1 has the name variable in the body
data class PersonImpl1(val id: Long) {
     var name: String=""
}

fun main(args: Array&lt;String&gt;) {
    val person0 = PersonImpl0(0)
    person0.name = "Charles"

    val person1 = PersonImpl0(0)
    person1.name = "Eugene"

     val person2 = PersonImpl1(0)
    person0.name = "Charles"

    val person3 = PersonImpl1(0)
    person1.name = "Eugene"

    println(person0 == person1) // Are not equal ??
    println(person2 == person3) // Are equal ??

 }

false
true

private void example() {
  Optional&lt;String&gt; foo = ...
  Optional&lt;String&gt; bar = 
      foo.map(this::transform1)
          .map(this::transform2)
}

private String transform1(String s) {
  return s + "!";
}

private String transform2(String s) {
  return "@" + s;
}

transform
fun &lt;A, B&gt; nullMap(a: A?, mapper: (a: A) -&gt; B?): B? =
  if (a != null) mapper.invoke(a) else null

fun example() {
  val foo: String? = "Space cookies"
  val bar1: String? = nullMap(foo, Example::transform1)
  val bar2: String? = nullMap(bar1, Example::transform2)
}

fun transform(s: String) = s + "!"
fun transform2(s: String) = "@" + s

transform
s
nullMap
nullMap
Any
null
TIME_INTERVAL
MyEvent
MyEvent
private val stopWatch = object : () -&gt; Unit {
  var timer = System.currentTimeMillis()
  var isRunning = false

  override fun invoke() {
    timer = System.currentTimeMillis()
    if (isRunning) return
    synchronized(this) {
      isRunning = true

      while (System.currentTimeMillis() - timer &lt;= TIME_INTERVAL) {}

      fireNotification()
      isRunning = false
    }
  }
}

override fun onSomeEvent(e: MyEvent?) {
  runAsync(stopWatch)
}

kotlin.concurrent
val
()
{}
val Customer.orderedProducts: Set&lt;Product&gt; get() {
    // Return all products this customer has ordered
    todoCollectionTask()
}

//  val (a, b, c, d, e) = listOf(1, 2, 3, 4, 5)
val (a, b, c, d, e, f, g) = listOf(1, 2, 3, 4, 5, 6, 7)

&gt; Error:(70, 41) Kotlin: Destructuring declaration initializer of type
&gt; List&lt;Int&gt; must have a 'component6()' function 
&gt; Error:(70, 41) Kotlin: Destructuring declaration initializer of type 
&gt; List&lt;Int&gt; must have a 'component7()' function

    constructor(vararg items: Item){
    val itemMap = items.fold(mutableMapOf&lt;Int, MutableList&lt;Item&gt;&gt;(), { acc, item -&gt;
        if (acc.containsKey(item.state)) {
            acc[item.state]?.add(item)
        } else {
            acc.put(item.state, mutableListOf(item))
        }
        return acc
    })

}

varargs
val optionStrArr = arrayOfNulls&lt;String&gt;(options.size)
for (i in options.indices) {
    optionStrArr[i] = options[i].value
}
App.instance?.analyticPollReceive(pollID!!, title!!, question!!, *optionStrArr)

...

fun analyticPollReceive(id: String, title: String, question: String, vararg options: String) {
    // function body
}

Type mismatch. Required: String; Found: Array&lt;String?&gt;
Type mismatch. Required: Array&lt;out String&gt;; Found: Array&lt;String?&gt;
vararg options: String?
data class Resultado (val resultado: Int, val tesoro: Boolean)

fun main() {
        val busca =  fun(intento: Int): Resultado
        {
                val cosas = listOf( 3, 33, 333, 42, 1, 1, 111 )
                if ( intento == 4  ) {
                        return Resultado( 42, true )
                } else {
                        return Resultado( cosas[intento], false )
                }
        }

        val (valor1, premio1) = busca( 2 )
        println( "2 devuelve " + valor1 + " y tiene premio " + premio1  )
        val (valor2, premio2) = busca( 4 )
        println( "4 devuelve " + valor2 + " y tiene premio " + premio2  )

}

kotlinc code/tesoro.kt -include-runtime -d tesoro.jar

ls *.class *.jar
Resultado.class  tesoro.jar  TesoroKt.class  TesoroKt$main$busca$1.class

java -jar tesoro.jar 
no hay ningún atributo de manifiesto principal en tesoro.jar

java -version
java version "1.8.0_201"
Java(TM) SE Runtime Environment (build 1.8.0_201-b09)
Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)

    var testVar: String? = null;

    // if (testVar != null )
    {
        // Doing some work....
        println(testVar.length)
    }

if
// Doing some work....
testVar
null
// Doing some work
 @GetMapping(value = "/pagina")
    public ResponseEntity&lt;Page&lt;PersonFindDTO&gt;&gt; findAll(
            @RequestParam(value = "page", defaultValue = "0") Integer page,
            @RequestParam(value = "linesPerPage", defaultValue = "24") Integer linesPerPage,
            @RequestParam(value = "order", defaultValue = "ASC") String order,
            @RequestParam(value = "orderBy", defaultValue = "name") String orderBy) {


        var person = personService.findAll(page, linesPerPage, order, orderBy);

        var personFindDto = person.map(PersonFindDTO::new);

        return ResponseEntity.ok().body(personFindDTO);
    }

   @GetMapping(value = ["/{companyId}/{active}"])
    override fun findAll(
            @RequestParam(value = "page", defaultValue = "0") page: Int,
            @RequestParam(value = "linesPerPage", defaultValue = "24") linesPerPage: Int,
            @RequestParam(value = "order", defaultValue = "ASC") order: String,
            @RequestParam(value = "orderBy", defaultValue = "tradeName") orderBy: String,
            @PathVariable companyId: Long, @PathVariable active: Boolean): ResponseEntity&lt;Page&lt;Any&gt;&gt; {

        val lp = service.findAll(page, linesPerPage, order, orderBy, companyId, active)?.let {
            it.map {
                fun LegalPerson.toLegalPersonMPage() = LegalPersonMPage(id = it.id,
                        tradeName = it.tradeName, companyName = it.companyName, cnpj = it.cnpj)
            }
        }
        return ResponseEntity.ok().body(lp)
    }

data class LegalPerson(
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  override var id: Long,
  @Column(nullable = false)
  val companyId: Long,
  @Column(nullable = false)
  var active: Boolean,
  @Column(nullable = false, length = 100)
  val tradeName: String,
  @Column(nullable = false, length = 100)
  val companyName: String,
  @Column(nullable = false, length = 100)
  val email: String,
  @Column(nullable = false, length = 18)
  val cnpj: String,
  @Column(length = 15)
  val stateRegistration: String,
  @Column(length = 15)
  val municipalRegistration: String,
  @Column(nullable = false)
  val openingDate: LocalDate,
  @Column(nullable = false)
  val address: Long,
  @ElementCollection(fetch = FetchType.EAGER)
  @CollectionTable(name = "phone", schema = "legal_person")
  val phones: List&lt;Long&gt;
) 

data class LegalPersonMPage(

        val id: Long,
        val tradeName: String,
        val companyName: String,
        val cnpj: String
)  {
}

object OldTownRoad {
  const val COWBOY_HATS = "from Gucci"
  const val WRANGLER = "on my booty"
}

public class Scrap {
  @Named(OldTownRoad.COWBOY_HATS)
  public void lilNasXrefs() {
    System.out.println(OldTownRoad.COWBOY_HATS);
    System.out.println(OldTownRoad.WRANGLER);
  }
}

println()
COWBOY_HATS
@Named
@JvmStatic
@JvmField
const val
const
companion object
class OldTownRoad {
  companion object {
    const val COWBOY_HATS = "from Gucci"
    const val WRANGLER = "on my booty"
  }
}

test 'test_01' {
  description " test that a user by name tom is present
  author : xyz
  GET /userstore/users/user(name=tom) {
     verify(/first-name == 'Tom')
  }
}

$ kotlinc hello.kt -include-runtime -d hello.jar

""Java"" is not recognized as an internal or external command, program or batch file

val a =  "1"
val b = a[0]
val c = b.toInt()
println(c)

listOf(HashSet&lt;String&gt;()).flatMapTo(HashSet&lt;String&gt;()) { it.iterator() as Iterator&lt;String&gt; }

flatMapTo
[1,2,4,6,7,8,12,13,14,15,20]

[12,13,14,15]

Sequence
groupBy
println
class InitOrderDemo(name: String) {
   val firstProperty = "First property: $name".also(::println)
}

To use a property, we simply refer to it by name, as if it were a field in Java:

fun copyAddress(address: Address): Address {
    val result = Address() // there's no 'new' keyword in Kotlin
    result.name = address.name // accessors are called
    result.street = address.street
    // ...
    return result
}

package app.foo
open class FooClass {
    var fooProp = "test";

    fun doSomething() {
        // Just to show what's going on
        val tmpFoo = FooClass()
        tmpFoo.fooProp // No error here
        tmpFoo.fooProp = "New Value" // No error here
    }
}

// Different Class, same package
package app.foo
import app.foo.FooClass
class Foo2Class {
    fun doSomething() {
        // Just to show what's going on
        val tmpFoo = FooClass()
        tmpFoo.fooProp // No error here
        tmpFoo.fooProp = "New Value" // No error here
    }
}


// Different Class, different package
package app.bar
import app.foo.FooClass
class BarClass {
    fun doSomething() {
        // Just to show what's going on
        val tmpFoo = FooClass()
        tmpFoo.fooProp // Error here
        tmpFoo.fooProp = "New Value" // Error here
        tmpFoo.getFooProp() // No error here
        tmpFoo.setFooProp("New Value") // No error here
    }
}

@Dao
 interface UserDAO {

    @Override
    @Query("SELECT * FROM User WHERE IC LIKE :UIC AND " +"Password LIKE :UPSW LIMIT 1")
    public fun findByIC(UIC: String, UPSW: String): UserModel
    {
        var getted = findByIC(UIC, UPSW)
        //var user:UserModel = UserModel(getted.getName(),getted.getPsw(),getted.getEmail(),getted.getIC(),getted.getContactNo())
       // user.setID(getted.getID())
        return getted
    }
    @Insert//(onConflict = OnConflictStrategy.IGNORE)
    fun insertAll(vararg users:userEntity)
    //@Delete
    //fun delete(user: UserModel)
}

@Database(entities = arrayOf(userEntity::class), version = 1)
abstract class AppDatabase : RoomDatabase() {

     abstract fun UserDAO(): UserDAO

}

public final class UsersDAO_Impl implements UserDAO //Problem's here
{
  private final RoomDatabase __db;

  private final EntityInsertionAdapter __insertionAdapterOfuserEntity;

  public UsersDAO_Impl(RoomDatabase __db) {
    this.__db = __db;
    this.__insertionAdapterOfuserEntity = new EntityInsertionAdapter&lt;userEntity&gt;(__db) {
      @Override
      public String createQuery() {
        return "INSERT OR ABORT INTO `User`(`uid`,`Name`,`Password`,`Email`,`IC`,`Contact_No`) VALUES (nullif(?, 0),?,?,?,?,?)";
      }

      @Override
      public void bind(SupportSQLiteStatement stmt, userEntity value) {
        stmt.bindLong(1, value.getUid());
        if (value.getUname() == null) {
          stmt.bindNull(2);
        } else {
          stmt.bindString(2, value.getUname());
        }
        if (value.getUpassword() == null) {
          stmt.bindNull(3);
        } else {
          stmt.bindString(3, value.getUpassword());
        }
        if (value.getUemail() == null) {
          stmt.bindNull(4);
        } else {
          stmt.bindString(4, value.getUemail());
        }
        if (value.getUic() == null) {
          stmt.bindNull(5);
        } else {
          stmt.bindString(5, value.getUic());
        }
        if (value.getUcontact_no() == null) {
          stmt.bindNull(6);
        } else {
          stmt.bindString(6, value.getUcontact_no());
        }
      }
    };
  }

  @Override
  public void insertAll(userEntity... users) {
    __db.beginTransaction();
    try {
      __insertionAdapterOfuserEntity.insert(users);
      __db.setTransactionSuccessful();
    } finally {
      __db.endTransaction();
    }
  }
}

abstract class Fun() {
    /** 
     * i = 0 -- the function itself, 
     * i = 1, 2, 3, ... -- its successive derivatives
     */
    abstract fun d(i: Int, x: Float): Float
}

class Lin(val k: Float) : Fun() { 
    // y = k*x
    override fun d(i: Int, x: Float, p: Float) = when (i) {
        0 -&gt; k * x
        1 -&gt; k
        else -&gt; 0.0f
    }
}

class Sum(val fun0: Fun, val fun1: Fun) : Fun() {
    // y = fun0(x) + fun1(x)
    override fun d(i: Int, x: Float, p: Float) = fun0.d(i, x) + fun1.d(i, x)
}

class Example(val fun1: Fun, val fun2: Fun){
    var res = fun1.d(0, 5.25f) // fun1 value at 5.25f
    res = fun1.d(1, 3.29f) // fun1 first derivative at  3.29f
    val sum = Sum(fun1, fun2) // sum of f1 and f2
    res = sum(0, 3.78f) // sum value at 3.78f
    res = sum(1, 5.69f) // sum first derivative at 5.69f
}

class ParametricCurveXYZ(val fun_x: Fun, val fun_y: Fun, val fun_z: Fun) {

    fun pointToXYZ(s: Float) = VectorXYZ(fun_x.d(0, s), fun_y.d(0, s),    fun_z.d(0, s))

    fun tangent(s: Float) = VectorXYZ(fun_x.d(1, s), fun_y.d(1, s), fun_z.d(1, s)).normalized()

}

data class ObjA(val key: String, val value: String)

fun test() {
    val listOfA = mutableListOf(
            ObjA("one", ""), //This will be taken in distinctBy.
            ObjA("one", "o"),
            ObjA("one", "on"),
            ObjA("one", "one"), //This will be ignored in distinctBy. I WANT THIS ONE.

            ObjA("two", ""), //This will be returned in distinctBy
            ObjA("two", "2"),
            ObjA("two", "two"), //But I want this.

            ObjA("three", "3"),
            ObjA("four", "4"),
            ObjA("five", "five")
    )

    val listOfAWithNoDuplicates = listOfA.distinctBy { it.key }

    for (o in listOfAWithNoDuplicates) {
        println("key: ${o.key}, value: ${o.value}")
    }
}

key: one, value: 
key: two, value: 
key: three, value: 3
key: four, value: 4
key: five, value: five

class Person() {
    var age: Pair&lt;String, Int&gt; = Pair("person_age", 23)
    // override getValue and setValue here
}

Pair
getValue
setValue
val p = Person()
p.age = 25

if(p.age &lt;= 30)

getter
setter
override fun onOptionsItemSelected(item: MenuItem): Boolean {

    when (item.itemId) {
        R.id.nav_home -&gt;
 // I want to display the home screen here
        else -&gt;
            return super.onOptionsItemSelected(item)
    }
}

media
descriptions
descriptions
if (media.descriptions == null) { media.descriptions = listOf("myValue")}
else { media.descriptions.add("myValue") }

fun main(args: Array&lt;String&gt;) {
    val StringCharacter = "A"
    val CharCharacter = StringCharacter.toChar()
    println(CharCharacter)
}

args: Array&lt;String&gt;
java.lang
println
Array
Int
fun arrayOfMinusOnes(size: Int): IntArray {
    return IntArray(size).apply { fill(-1) }
}

class Wrapped&lt;out T&gt;(val value: T)

open class Wrapper&lt;T&gt; {
    fun wrap(map: T): Wrapped&lt;T&gt; = Wrapped(map)
}

class Wrapper2 : Wrapper&lt;Map&lt;String, String&gt;&gt;()

val wrapped: Wrapped&lt;Map&lt;String, String&gt;&gt; = Wrapper2().wrap(mapOf())

Wrapper2.wrap
    Map&lt;String, String&gt; toWrap = new HashMap&lt;&gt;();
    Wrapped&lt;Map&lt;String, String&gt;&gt; result;
    result = new Wrapper&lt;Map&lt;String, String&gt;&gt;().wrap(toWrap); // ok
    result = new Wrapper2().wrap(toWrap); // NOT ok, returns Wrapped&lt;Map&lt;String, ? extends String&gt;&gt;

wrap
Wrapper2
Wrapper2.wrap
Wrapper.wrap
open class TestRunner {

    init {
        instance = this
    }

    companion object {
        private lateinit var instance: TestRunner

        fun addTestSetups(vararg testSetups: () -&gt; TestSetup): TestRunner {
           for (setup in testSetups) {
              testsSetups.add(setup)
           }

           return instance
        }
    }
}

instance = this
// 1. doesn't work.
fun main(vararg args: String){
    println("this is a test.")
}

// 2. doesn't work
fun main(args: Array&lt;String&gt;){
    println("this is a test.")
}

// 3. this works. but where can I get the command line parameters?
fun main(){
    println("this is a test.")
}

λ java -jar test-1.0-SNAPSHOT.jar
Exception in thread "main" java.lang.NoClassDefFoundError: kotlin/jvm/internal/Intrinsics
        at com.yxy.ProgramFileKt.main(ProgramFile.kt)
Caused by: java.lang.ClassNotFoundException: kotlin.jvm.internal.Intrinsics
        at java.net.URLClassLoader.findClass(Unknown Source)
        at java.lang.ClassLoader.loadClass(Unknown Source)
        at sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source)
        at java.lang.ClassLoader.loadClass(Unknown Source)
        ... 1 more

var barCode: BarCode? = null

var barCode: BarCode? = null
override get

private var barCode: BarCode? = null

override fun getBarCode(): BarCode? = barCode
fun setBarCode(barCode: BarCode) {
    this.barCode = barCode
}

linkedSet
LinkedHashSet&lt;Serializable&gt;
val linkedSet = linkedSetOf(linkedSetOf(1, 2, 3), 2)

LinkedHashSet&lt;Int&gt;
LinkedHashSet
Serializable
Int
Serializable
Serializable
val printMessage = { message: String -&gt; println(message) }
printMessage("hello")
printMessage("world")

{ message -&gt; println(message) }

{println(it)}

val printMessage = {println(it)}
printMessage("print something")

fun &lt;T&gt; MutableList&lt;T&gt;.insertOrUpdate(items: List&lt;T&gt;, comparator: Comparator&lt;T&gt;): List&lt;T&gt; {
    val out = mutableListOf&lt;T&gt;()
    val toInsert = items.toMutableList()
    forEach { oldItem -&gt;
        var wasUpdated = false
        items.forEach { newItem -&gt;
            if (comparator.compare(oldItem, newItem) == 0) {
                out.add(newItem)
                toInsert.remove(newItem)
                wasUpdated = true
            }
        }
        if(!wasUpdated){
            out.add(oldItem)
        }
    }

    out.addAll(toInsert)

    return out
}


fun square( arg : Int ) : Int{
   return (arg * arg)
}

var arr : Array&lt;Int&gt; = Array(5, square)

val c = Manager.customers.entries.stream()
                        .filter { x -&gt; x.value.name == "Jaime Garcia" }

val id = (c as Customer)?.id
.collect(Collectors.toMap(a -&gt; a.getValue()))
object Model {
    data class Result(val query: Query)
    data class Query(val searchinfo: SearchInfo)
    data class SearchInfo(val totalhits: Int)
}

class Model {
    data class Result(val query: Query)
    data class Query(val searchinfo: SearchInfo)
    data class SearchInfo(val totalhits: Int)
}

::class.java
lateinit
abstract class MVIFragment&lt;
        out INTERACTOR : MVIInteractor&lt;UINTERFACE&gt;,
        UINTERFACE : MVIUIInterface,
        MODEL : MVIViewModel
        &gt;
    : Fragment(), MVIUIInterface, KodeinAware {


lateinit var viewModel: MODEL

ViewModel
        viewModel = ViewModelProviders.of(this).get(viewModel::class.java)

        viewModel = ViewModelProviders.of(this).get(MODEL::class.java)

PropertyMetaData
class Obj(var name : String = "")

class Bar {
 val prop1 : Obj by Inject.inject() // &lt;- can inject() access prop1 without passing it explicitly?
 val prop2 : Obj by Inject.inject()
}

object Inject {

 val injected = arrayListOf&lt;ReadOnlyProperty&lt;Any, Obj&gt;&gt;()

 fun inject() : ReadOnlyProperty&lt;Any, Obj&gt; {

    val delegate = Delegates.lazy {
        Obj("NEED THE DELEGATED PROPERTY'S NAME HERE") // &lt;- like "prop1" "prop2" ...
    }
    injected.add(delegate)
    return delegate
 }
}

val scrollPlace by injectBy&lt;Image&gt;("scrollPlace").replaceBy {

    val scrollPane = ScrollPane(VerticalGroup().space(12f).center())
    scrollPane.setPosition(it.x, it.y)
    scrollPane.setSize(it.width, it.height)
    scrollPane
}

 public final fun &lt;T : Actor, R : Actor&gt; O2dInjectionClosure&lt;T&gt;.replaceBy(replacer : (replaced : T) -&gt; R) : O2dInjectionClosure&lt;R&gt; {
    val originalInitializer = this.initializer
    return O2dInjectionClosure { propName -&gt;

        ... some transferring of the previous O2dInjectionClosure to this one
        new
    }
}

fun interval(reserves: ArrayList&lt;Reserves&gt;, dayInferior: Int, daySuperior: Int) {
    var count = dayInferior
    var person: Int
    for (reserve in reserves) {
        person = 0
        for (reserve in reserves) {
            if (reserve.day == count &amp;&amp; reserve.day &lt;= daySuperior) {
                person++
            }
        }
        if (count &lt;= daySuperior) {
            println("${reserve.numFlight} Day $count has $person")
        }
        count++
    }

}

class Reserves {
    var numCc: Int?
    var name: String
    var numFlight: String
    var day: Int

    constructor(numCc: Int?, name: String, numFlight: String, day: Int) {
        this.numCc = numCc
        this.name = name
        this.numFlight = numFlight
        this.day = day
    }
}


fun readFileReserves(fileNameInput: String): ArrayList&lt;Reserves&gt; {
    val reserves: ArrayList&lt;Reserves&gt; = ArrayList()
    val lines = File(fileNameInput).readLines()

    for (line in lines) {
        val parts = line.split(':')
        val numCc = parts[0].toIntOrNull()
        val name = parts[1]
        val numFlight = parts[2]
        val day = parts[3].toIntOrNull()

        if (day == null || numCc == null) {
            println("Invalid day")
        } else {
            val r = Reserves(numCc, name, numFlight, day)
            reserves.add(r)
        }

    }
    return reserves
}

var UserSettings: UserSettings?
    get() = getUserSettings() // Replace this with an anonymous function?
    set(value) {
        putPref(USER_SETTINGS, Json.stringify(UserSettings.serializer(), value!!))
    }

private fun getUserSettings(): UserSettings? {
    val info = getPref(KEY_USER_SETTINGS)
    return Json.parse(UserSettings.serializer(), info!!)
}

guard let e = email.text , !e.isEmpty else { return }

class Foo&lt;out T&gt; {
  fun or&lt;U of T or greater&gt;(other: U): &lt;U&gt; = ...
}

class Foo[+T] {
  def or[U &gt;: T](other: U): U = ...
}

"a" to {"b" to "c"}
"teachers" to {"a" to "c"; "c" to "d"}

 (teachers, () -&gt; kotlin.Pair&lt;kotlin.String, kotlin.String&gt;)

"a" to mapOf("a" to "b"...)

List&lt;Int?&gt;
List&lt;Int&gt;
mapNotNull
    @Test
    fun main() {
        val testData = listOf(1, null, 3, null)
        val noNull = processAwayNull(testData)
    }

    private fun processAwayNull(testData: List&lt;Int?&gt;): List&lt;Int&gt; {
        return testData.mapNotNull{ it }
    }

Map&lt;String, Int?&gt;
Map&lt;String, Int&gt;
testData.filter { it.value != null }
Map&lt;String, Int?&gt;
    @Test
    fun main() {
        val testData = mapOf("One" to 1, "Two" to null, "Three" to 3, "Four" to null)
        val noNull = processAwayNull(testData)
    }

    private fun processAwayNull(testData: Map&lt;String, Int?&gt;): Map&lt;String, Int&gt; {
        return testData.filter { it.value != null }
    }

fun buildMyObject(stringParam: String?, intParam: Int?): MyClass {
    return MyClass(stringParam, intParam)
}

class MyClass(val stringParam: String = "Hello world!", val intParam: Int = 42)

import kotlinx.android.synthetic.main.myActivity.*

with
apply
also
run
runCatching
takeIf
takeUnless
with
ints2.forEach
level 1 xx ====
let@
ints2.forEach
fun foo() {
    val ints = Array(5, {i-&gt;i})
    ints.forEach let@ {
        println("level 1 $it ====")
        val ints2 = Array(3, {i-&gt;i})
        ints2.forEach {
            if (it == 2) return@let
            println("level 2 $it")
        }
    }
}

fun main(args: Array&lt;String&gt;) {
    foo()
}

class A {
    fun myFunA() {
        val b = B()

        b.myFunB() {

        }
    }
}

class B {
    fun myFunB() {
       // Is it possible to obtain a reference to the instance of class A that is calling
       // this function?
    }
}

open class A {
    fun doStuff() {

    }
}

class B: A() {
   companion object {
        doStuff() //compile error
   }
}

a.x()
a.y()
a.z()

a.run { x(); y(); z() }

a.x()
b.x()
c.x()

applyTo(a, b, c) { it.x() }

fun &lt;P&gt; applyTo(vararg ps: P, fx: (P) -&gt; Unit) = ps.forEach { fx(it) }

::x.eachOf(a, b, c)

fun &lt;P, R&gt; ((P) -&gt; R).eachOf(vararg p: P) = p.forEach { this(it) }

data class FoodParceable(val idCover: Int, val name: String, val 
price: Double):Parcelable {
constructor(parcel: Parcel) : this(
    parcel.readInt(),
    parcel.readString(),
    parcel.readDouble()
)

override fun writeToParcel(parcel: Parcel, flags: Int) {
    parcel.writeInt(idCover)
    parcel.writeString(name)
    parcel.writeDouble(price)
}

override fun describeContents(): Int {
    return 0
}

companion object CREATOR : Parcelable.Creator&lt;FoodParceable&gt; {
    override fun createFromParcel(parcel: Parcel): FoodParceable {
        return FoodParceable(parcel)
    }

    override fun newArray(size: Int): Array&lt;FoodParceable?&gt; {
        return arrayOfNulls(size)
    }
}

    val arrayListParceable = ArrayList&lt;FoodParceable&gt;()
    for (Food in listFood) {

        arrayListParceable.add(FoodParceable(R.mipmap.ic_food_meat, "Carne", 9.99))
        arrayListParceable.add(FoodParceable(R.mipmap.ic_food_meat, "Vegetales", 29.99))
        arrayListParceable.add(FoodParceable(R.mipmap.ic_food_meat, "Frutas", 39.99))
    }
    val intent = Intent()
    intent.putParcelableArrayListExtra(LIST_PRODUCT,arrayListParceable)
    activity?.setResult(Activity.RESULT_OK, intent)

if(resultCode == Activity.RESULT_OK){
                if(data != null){
                    val listItems = data.getParcelableArrayListExtra&lt;Parcelable&gt;(LIST_PRODUCT)
                    listItems[0]. //ERROR

                }
            }

class TestsAdapter(
    private val clickListener: ClickListener
) : PagedListAdapter&lt;RecyclerViewTestInfo, TestsViewHolder&gt;(diffCallback) {

    override fun getItemCount(): Int {
        return super.getItemCount()
    }

    override fun onBindViewHolder(holder: TestsViewHolder, position: Int) {
        val testInfo = getItem(position) as RecyclerViewTestInfo

        with(holder) {
            bindTo(testInfo)
            testInfo.let {
                itemView.setOnClickListener {
                    clickListener(testInfo)
                }
            }
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): TestsViewHolder =
        TestsViewHolder(parent)
}

data class Item(val month: Int, val year: Int, val value: Int)
val items = listOf(
    Item(month = 1, year = 2019, value = 5000),
    Item(month = 1, year = 2019, value = 200),
    Item(month = 1, year = 2019, value = 300),
    Item(month = 1, year = 2019, value = 1000),
    Item(month = 2, year = 2019, value = 5000),
    Item(month = 2, year = 2019, value = 6000),
    Item(month = 3, year = 2019, value = 500),
    Item(month = 3, year = 2019, value = 1500),
    Item(month = 5, year = 2019, value = 900),
    Item(month = 1, year = 2020, value = 700)
)

val result = listOf(
    Item(month = 1, year = 2019, value = 6500),
    Item(month = 2, year = 2019, value = 11000),
    Item(month = 3, year = 2019, value = 2000),
    Item(month = 5, year = 2019, value = 900),
    Item(month = 1, year = 2020, value = 700)
)

readlint()!!
.split(' ')
prints
fun getTheData() {
       try{
           val(a,b,c) = readLine()!!.split(' ')
           println("$a , $b, $c")

       }catch (ex: IndexOutOfBoundsException){
            println("invalid")
       }
    }

val isFinished: Boolean
        get() = actor.actions.size == 0

fun isFinished() = actor.actions.size == 0

var foo: String = null
var foo: String? = null
var foo = null
when
private fun bindValue(target: Activity) {
    val declaredFields = target::class.java.declaredFields

    for (field in declaredFields) {
        for (annotation in field.annotations) {

            when(annotation) {
                is ReflectSource -&gt; {
                    field.isAccessible = true
                    field.set(target, annotation.value)
                }
                is ReflectBinary -&gt; {
                    field.isAccessible = true
                    field.set(target, annotation.value)
                }
                is ReflectRuntime -&gt; {
                    field.isAccessible = true
                    field.set(target, annotation.value)
                }
            }
        }
    }
}

private fun bindValue(target: Activity) {
    val declaredFields = target::class.java.declaredFields

    for (field in declaredFields) {
        for (annotation in field.annotations) {

            when(annotation) {
                is ReflectSource, is ReflectBinary, is ReflectRuntime -&gt; {
                    field.isAccessible = true
                    field.set(target, annotation.value)
                }
            }
        }
    }
}

value
annotation
@Retention(AnnotationRetention.SOURCE)
@Target(AnnotationTarget.FIELD)
annotation class ReflectSource(val value: Int)

@Retention(AnnotationRetention.BINARY)
@Target(AnnotationTarget.FIELD)
annotation class ReflectBinary(val value: Int)

@Retention(AnnotationRetention.RUNTIME)
@Target(AnnotationTarget.FIELD)
annotation class ReflectRuntime(val value: Int)

val seq1 = sequenceOf(1, 2, 3)
val seq2 = sequenceOf(5, 6, 7)
sequenceOf(seq1, seq2).flatten().forEach { ... }

class GenericClass&lt;T&gt;() {
    private var arr : Array&lt;T&gt;? = null

    {
        arr = Array&lt;T&gt;(10, { null })
    }
}

class A {

  fun f(x: Int) = 42

  val g = fun(x: Int) = 42

}

val
f
g
val z = g andThen A::f // f is a member function

f
val
::f
g
val fref: KFunction1&lt;Int, Int&gt; = ::f

val gref: (Int) -&gt; Int = g

KFunction1&lt;Int, Int&gt;
(Int) -&gt; Int
Int -&gt; Int
val z = g andThen A::f.partially1(this)

this
val
fun
val list = listOf(Pair("A", 1), Pair("A", 2), Pair("A", 1), Pair("B", 5))
val map = list.groupBy ({ it.first }, {it.second})

map = {A = [1, 2, 1], B = [5]}

map = {A = [1, 2], B = [5]}

val books: MutableList&lt;Book&gt; = deserializer.getBookList()
val persons: MutableList&lt;Person&gt; = deserializer.getPersonList()

getBookList
getPersonList
fun DataInput.getBookList(): MutableList&lt;Book&gt; {
    val list = mutableListOf&lt;Book&gt;()
    val size = this.readInt()

    for(i in 0 .. size) {
        val item = Book()
        item.readExternal(this)
        list.add(item)
    }

    return list
}

List
val item = T()
myObj.myVar = 99
myVar
myObj
class CharRange : CharProgression, ClosedRange&lt;Char&gt;

CharProgression
open class CharProgression : Iterable&lt;Char&gt;

Progression
Iterable
Progression
ClosedRange
fun isOdd(x: Int) = x % 2 != 0

val numbers = listOf(1, 2, 3)
println(numbers.filter(::isOdd))

&lt;no path&gt;:1:org.jetbrains.jet.codegen.CompilationException: Back-end (JVM) Internal error: Cannot resolve: callableReferenceFakeCall
File being compiled and position: (1,9) in dummy.kt
PsiElement: callableReferenceFakeCall(p0)

    at org.jetbrains.jet.codegen.ExpressionCodegen.visitCallExpression(ExpressionCodegen.java:1893)
    at org.jetbrains.jet.codegen.ExpressionCodegen.visitCallExpression(ExpressionCodegen.java:80)
    at org.jetbrains.jet.lang.psi.JetCallExpression.accept(JetCallExpression.java:42)
    at org.jetbrains.jet.codegen.ExpressionCodegen.genQualified(ExpressionCodegen.java:257)
    at org.jetbrains.jet.codegen.ExpressionCodegen.genQualified(ExpressionCodegen.java:234)
    at org.jetbrains.jet.codegen.ExpressionCodegen.gen(ExpressionCodegen.java:273)
    at org.jetbrains.jet.codegen.ExpressionCodegen.gen(ExpressionCodegen.java:277)
    at org.jetbrains.jet.codegen.ExpressionCodegen.invokeMethodWithArguments(ExpressionCodegen.java:2122)
    at org.jetbrains.jet.codegen.ExpressionCodegen.invokeFunction(ExpressionCodegen.java:2014)
    at org.jetbrains.jet.codegen.ExpressionCodegen$4.doGenerateBody(ExpressionCodegen.java:2531)
    at org.jetbrains.jet.codegen.FunctionGenerationStrategy$CodegenBased.generateBody(FunctionGenerationStrategy.java:106)
    at org.jetbrains.jet.codegen.FunctionCodegen.generateMethodBody(FunctionCodegen.java:290)
    at org.jetbrains.jet.codegen.FunctionCodegen.generateMethod(FunctionCodegen.java:143)
    at org.jetbrains.jet.codegen.FunctionCodegen.generateMethod(FunctionCodegen.java:94)
    at org.jetbrains.jet.codegen.ClosureCodegen.gen(ClosureCodegen.java:122)
    at org.jetbrains.jet.codegen.ExpressionCodegen.visitCallableReferenceExpression(ExpressionCodegen.java:2597)
    at org.jetbrains.jet.codegen.ExpressionCodegen.visitCallableReferenceExpression(ExpressionCodegen.java:80)
    at org.jetbrains.jet.lang.psi.JetCallableReferenceExpression.accept(JetCallableReferenceExpression.java:57)
    at org.jetbrains.jet.codegen.ExpressionCodegen.genQualified(ExpressionCodegen.java:257)
    at org.jetbrains.jet.codegen.ExpressionCodegen.genQualified(ExpressionCodegen.java:234)
    at org.jetbrains.jet.codegen.ExpressionCodegen.gen(ExpressionCodegen.java:273)
    at org.jetbrains.jet.codegen.ExpressionCodegen.gen(ExpressionCodegen.java:277)
    at org.jetbrains.jet.codegen.ExpressionCodegen.pushMethodArguments(ExpressionCodegen.java:2336)
    at org.jetbrains.jet.codegen.ExpressionCodegen.pushArgumentsAndInvoke(ExpressionCodegen.java:2138)
    at org.jetbrains.jet.codegen.ExpressionCodegen.invokeMethodWithArguments(ExpressionCodegen.java:2134)
    at org.jetbrains.jet.codegen.ExpressionCodegen.invokeFunction(ExpressionCodegen.java:2014)
    at org.jetbrains.jet.codegen.ExpressionCodegen.visitCallExpression(ExpressionCodegen.java:1922)
    at org.jetbrains.jet.codegen.ExpressionCodegen.visitCallExpression(ExpressionCodegen.java:80)
    at org.jetbrains.jet.lang.psi.JetCallExpression.accept(JetCallExpression.java:42)
    at org.jetbrains.jet.codegen.ExpressionCodegen.genQualified(ExpressionCodegen.java:257)
    at org.jetbrains.jet.codegen.ExpressionCodegen.genQualified(ExpressionCodegen.java:234)
    at org.jetbrains.jet.codegen.ExpressionCodegen.visitDotQualifiedExpression(ExpressionCodegen.java:2605)
    at org.jetbrains.jet.codegen.ExpressionCodegen.visitDotQualifiedExpression(ExpressionCodegen.java:80)
    at org.jetbrains.jet.lang.psi.JetDotQualifiedExpression.accept(JetDotQualifiedExpression.java:34)
    at org.jetbrains.jet.codegen.ExpressionCodegen.genQualified(ExpressionCodegen.java:257)
    at org.jetbrains.jet.codegen.ExpressionCodegen.genQualified(ExpressionCodegen.java:234)
    at org.jetbrains.jet.codegen.ExpressionCodegen.gen(ExpressionCodegen.java:273)
    at org.jetbrains.jet.codegen.ExpressionCodegen.gen(ExpressionCodegen.java:277)
    at org.jetbrains.jet.codegen.ExpressionCodegen.pushMethodArguments(ExpressionCodegen.java:2336)
    at org.jetbrains.jet.codegen.ExpressionCodegen.pushArgumentsAndInvoke(ExpressionCodegen.java:2138)
    at org.jetbrains.jet.codegen.ExpressionCodegen.invokeMethodWithArguments(ExpressionCodegen.java:2134)
    at org.jetbrains.jet.codegen.ExpressionCodegen.invokeFunction(ExpressionCodegen.java:2014)
    at org.jetbrains.jet.codegen.ExpressionCodegen.visitCallExpression(ExpressionCodegen.java:1922)
    at org.jetbrains.jet.codegen.ExpressionCodegen.visitCallExpression(ExpressionCodegen.java:80)
    at org.jetbrains.jet.lang.psi.JetCallExpression.accept(JetCallExpression.java:42)
    at org.jetbrains.jet.codegen.CodegenStatementVisitor.visitJetElement(CodegenStatementVisitor.java:31)
    at org.jetbrains.jet.codegen.CodegenStatementVisitor.visitJetElement(CodegenStatementVisitor.java:22)
    at org.jetbrains.jet.lang.psi.JetVisitor.visitExpression(JetVisitor.java:154)
    at org.jetbrains.jet.lang.psi.JetVisitor.visitCallExpression(JetVisitor.java:246)
    at org.jetbrains.jet.lang.psi.JetCallExpression.accept(JetCallExpression.java:42)
    at org.jetbrains.jet.codegen.ExpressionCodegen.genQualified(ExpressionCodegen.java:257)
    at org.jetbrains.jet.codegen.ExpressionCodegen.genStatement(ExpressionCodegen.java:286)
    at org.jetbrains.jet.codegen.ExpressionCodegen.generateBlock(ExpressionCodegen.java:1429)
    at org.jetbrains.jet.codegen.ExpressionCodegen.visitBlockExpression(ExpressionCodegen.java:1288)
    at org.jetbrains.jet.codegen.ExpressionCodegen.visitBlockExpression(ExpressionCodegen.java:80)
    at org.jetbrains.jet.lang.psi.JetBlockExpression.accept(JetBlockExpression.java:47)
    at org.jetbrains.jet.codegen.ExpressionCodegen.genQualified(ExpressionCodegen.java:257)
    at org.jetbrains.jet.codegen.ExpressionCodegen.genQualified(ExpressionCodegen.java:234)
    at org.jetbrains.jet.codegen.ExpressionCodegen.gen(ExpressionCodegen.java:273)
    at org.jetbrains.jet.codegen.ExpressionCodegen.returnExpression(ExpressionCodegen.java:1590)
    at org.jetbrains.jet.codegen.FunctionGenerationStrategy$FunctionDefault.doGenerateBody(FunctionGenerationStrategy.java:83)
    at org.jetbrains.jet.codegen.FunctionGenerationStrategy$CodegenBased.generateBody(FunctionGenerationStrategy.java:106)
    at org.jetbrains.jet.codegen.FunctionCodegen.generateMethodBody(FunctionCodegen.java:290)
    at org.jetbrains.jet.codegen.FunctionCodegen.generateMethod(FunctionCodegen.java:143)
    at org.jetbrains.jet.codegen.FunctionCodegen.generateMethod(FunctionCodegen.java:94)
    at org.jetbrains.jet.codegen.FunctionCodegen.gen(FunctionCodegen.java:80)
    at org.jetbrains.jet.codegen.MemberCodegen.genFunctionOrProperty(MemberCodegen.java:47)
    at org.jetbrains.jet.codegen.ClassBodyCodegen.generateDeclaration(ClassBodyCodegen.java:116)
    at org.jetbrains.jet.codegen.ImplementationBodyCodegen.generateDeclaration(ImplementationBodyCodegen.java:1594)
    at org.jetbrains.jet.codegen.ClassBodyCodegen.generateClassBody(ClassBodyCodegen.java:102)
    at org.jetbrains.jet.codegen.ClassBodyCodegen.generate(ClassBodyCodegen.java:69)
    at org.jetbrains.jet.codegen.MemberCodegen.genClassOrObject(MemberCodegen.java:91)
    at org.jetbrains.jet.codegen.NamespaceCodegen.generateClassOrObject(NamespaceCodegen.java:206)
    at org.jetbrains.jet.codegen.NamespaceCodegen.generate(NamespaceCodegen.java:178)
    at org.jetbrains.jet.codegen.NamespaceCodegen.generate(NamespaceCodegen.java:113)
    at org.jetbrains.jet.codegen.KotlinCodegenFacade.generateNamespace(KotlinCodegenFacade.java:71)
    at org.jetbrains.jet.codegen.KotlinCodegenFacade.compileCorrectFiles(KotlinCodegenFacade.java:60)
    at org.jetbrains.jet.cli.jvm.compiler.KotlinToJVMBytecodeCompiler.generate(KotlinToJVMBytecodeCompiler.java:298)
    at org.jetbrains.jet.cli.jvm.compiler.KotlinToJVMBytecodeCompiler.analyzeAndGenerate(KotlinToJVMBytecodeCompiler.java:260)
    at org.jetbrains.jet.cli.jvm.compiler.KotlinToJVMBytecodeCompiler.compileBunchOfSources(KotlinToJVMBytecodeCompiler.java:187)
    at org.jetbrains.jet.cli.jvm.K2JVMCompiler.doExecute(K2JVMCompiler.java:142)
    at org.jetbrains.jet.cli.jvm.K2JVMCompiler.doExecute(K2JVMCompiler.java:48)
    at org.jetbrains.jet.cli.common.CLICompiler.exec(CLICompiler.java:147)
    at org.jetbrains.kotlin.gradle.tasks.KotlinCompile.compile(Tasks.kt:116)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.gradle.util.JavaMethod.invoke(JavaMethod.java:62)
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.doExecute(AnnotationProcessingTaskFactory.java:219)
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:212)
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:201)
    at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:527)
    at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:510)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:80)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:61)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:46)
    at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute(PostExecutionAnalysisTaskExecuter.java:35)
    at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:64)
    at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:58)
    at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:42)
    at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:52)
    at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:53)
    at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)
    at org.gradle.api.internal.AbstractTask.executeWithoutThrowingTaskFailure(AbstractTask.java:283)
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.executeTask(AbstractTaskPlanExecutor.java:79)
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.processTask(AbstractTaskPlanExecutor.java:63)
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.run(AbstractTaskPlanExecutor.java:51)
    at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$1.run(DefaultTaskPlanExecutor.java:33)
    at org.gradle.internal.Factories$1.create(Factories.java:22)
    at org.gradle.cache.internal.DefaultCacheAccess.longRunningOperation(DefaultCacheAccess.java:214)
    at org.gradle.cache.internal.DefaultCacheAccess.longRunningOperation(DefaultCacheAccess.java:276)
    at org.gradle.cache.internal.DefaultPersistentDirectoryStore.longRunningOperation(DefaultPersistentDirectoryStore.java:142)
    at org.gradle.api.internal.changedetection.state.DefaultTaskArtifactStateCacheAccess.longRunningOperation(DefaultTaskArtifactStateCacheAccess.java:78)
    at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor.process(DefaultTaskPlanExecutor.java:31)
    at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter.execute(DefaultTaskGraphExecuter.java:86)
    at org.gradle.execution.SelectedTaskExecutionAction.execute(SelectedTaskExecutionAction.java:29)
    at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:61)
    at org.gradle.execution.DefaultBuildExecuter.access$200(DefaultBuildExecuter.java:23)
    at org.gradle.execution.DefaultBuildExecuter$2.proceed(DefaultBuildExecuter.java:67)
    at org.gradle.execution.DryRunBuildExecutionAction.execute(DryRunBuildExecutionAction.java:32)
    at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:61)
    at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:54)
    at org.gradle.initialization.DefaultGradleLauncher.doBuildStages(DefaultGradleLauncher.java:166)
    at org.gradle.initialization.DefaultGradleLauncher.doBuild(DefaultGradleLauncher.java:113)
    at org.gradle.initialization.DefaultGradleLauncher.run(DefaultGradleLauncher.java:81)
    at org.gradle.launcher.exec.InProcessBuildActionExecuter$DefaultBuildController.run(InProcessBuildActionExecuter.java:64)
    at org.gradle.tooling.internal.provider.BuildModelAction.run(BuildModelAction.java:70)
    at org.gradle.tooling.internal.provider.BuildModelAction.run(BuildModelAction.java:30)
    at org.gradle.tooling.internal.provider.ConfiguringBuildAction.run(ConfiguringBuildAction.java:108)
    at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:35)
    at org.gradle.launcher.daemon.server.exec.ExecuteBuild.doBuild(ExecuteBuild.java:45)
    at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:34)
    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
    at org.gradle.launcher.daemon.server.exec.WatchForDisconnection.execute(WatchForDisconnection.java:42)
    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
    at org.gradle.launcher.daemon.server.exec.ResetDeprecationLogger.execute(ResetDeprecationLogger.java:24)
    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
    at org.gradle.launcher.daemon.server.exec.StartStopIfBuildAndStop.execute(StartStopIfBuildAndStop.java:33)
    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
    at org.gradle.launcher.daemon.server.exec.ReturnResult.execute(ReturnResult.java:34)
    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
    at org.gradle.launcher.daemon.server.exec.ForwardClientInput$2.call(ForwardClientInput.java:71)
    at org.gradle.launcher.daemon.server.exec.ForwardClientInput$2.call(ForwardClientInput.java:69)
    at org.gradle.util.Swapper.swap(Swapper.java:38)
    at org.gradle.launcher.daemon.server.exec.ForwardClientInput.execute(ForwardClientInput.java:69)
    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
    at org.gradle.launcher.daemon.server.exec.LogToClient.doBuild(LogToClient.java:60)
    at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:34)
    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
    at org.gradle.launcher.daemon.server.exec.EstablishBuildEnvironment.doBuild(EstablishBuildEnvironment.java:59)
    at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:34)
    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
    at org.gradle.launcher.daemon.server.exec.StartBuildOrRespondWithBusy$1.run(StartBuildOrRespondWithBusy.java:45)
    at org.gradle.launcher.daemon.server.DaemonStateCoordinator.runCommand(DaemonStateCoordinator.java:186)
    at org.gradle.launcher.daemon.server.exec.StartBuildOrRespondWithBusy.doBuild(StartBuildOrRespondWithBusy.java:49)
    at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:34)
    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
    at org.gradle.launcher.daemon.server.exec.HandleStop.execute(HandleStop.java:36)
    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
    at org.gradle.launcher.daemon.server.exec.CatchAndForwardDaemonFailure.execute(CatchAndForwardDaemonFailure.java:32)
    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
    at org.gradle.launcher.daemon.server.exec.DefaultDaemonCommandExecuter.executeCommand(DefaultDaemonCommandExecuter.java:48)
    at org.gradle.launcher.daemon.server.DefaultIncomingConnectionHandler$ConnectionWorker.handleCommand(DefaultIncomingConnectionHandler.java:155)
    at org.gradle.launcher.daemon.server.DefaultIncomingConnectionHandler$ConnectionWorker.receiveAndHandleCommand(DefaultIncomingConnectionHandler.java:128)
    at org.gradle.launcher.daemon.server.DefaultIncomingConnectionHandler$ConnectionWorker.run(DefaultIncomingConnectionHandler.java:116)
    at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:66)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
    at java.lang.Thread.run(Thread.java:724)

        ^
:gf_publisher:compileDebugKotlin FAILED

&lt;T&gt;
&lt;T : Any&gt;
public static final Creator&lt;Save&gt; CREATOR = new Creator&lt;Save&gt;() {

    @Override
    public Save[] newArray(int size) {
        return new Save[size];
    }

    @Override
    public Save createFromParcel(Parcel incoming) {
        return new Save(incoming);
    }
};

val CREATOR: Parcelable.Creator&lt;Save&gt; = object : Parcelable.Creator&lt;Save&gt; {

    override fun newArray(size: Int): Array&lt;Save&gt; {
        return arrayOfNulls(size)
    }

    override fun createFromParcel(incoming: Parcel): Save {
        return Save(incoming)
    }
}

class Dog() {
  var id: UUID?
}

class Cat() {
  var id: UUID?
}

class Animal() {
  var id: UUID?
}
class Dog: Animal()
class Cat: Animal()

fun main(args: Array&lt;String&gt;) {
  val char = 'H'
  val string = "ello World"
  val appendingWorks = string + char //but not what I want...
  //val prependingFails = char + string //no .plus(str:String) version
  val prependingWorkaround1 = char.toString() + string
  val prependingWorkaround2 = "" + char + string
  val prependingWorkaround3 = String(charArray(char)) + string

}

+
plus
'H' + "ello World"
String test = 'H' + "ello World";
java.lang.String
java.lang.Character.toString(char c)
plus(str:String)
Set&lt;E&gt;
MutableSet&lt;E&gt;
setOf()
mutableSetOf()
MutableSet
A generic unordered collection of elements
Comparable
HashSet
is
payload is MyModel
is
MyModel
is
dynamic
by Delegates.mapVal(...)
Map&lt;String, Any?&gt;
dynamic
Any?
Map&lt;String, Any?&gt;
class SelectionRAdapter(var list: ArrayList&lt;Image&gt;) :
    RecyclerView.Adapter&lt;SelectionRAdapter.FolderRViewHolder&gt;() {

    inner class FolderRViewHolder(var view: View) : 
        RecyclerView.ViewHolder(view), View.OnClickListener {
        init {
            view.setOnClickListener(this)
        }

        override fun onClick(v: View?) {
            view.checkbox_container.setBackgroundColor(Color.parseColor("59FFFFFF"))
        }

        interface OnItemSelectListener {

        }
    }

}

 companion object {
        var strarray: Array&lt;String&gt; = arrayOf()
        var objectarray: LinkedHashMap&lt;Int, List&lt;Any&gt;&gt; = LinkedHashMap&lt;Int, List&lt;Any&gt;&gt;()
    }

 fun csvFileToString():String {

    val inputStream = File(Paths.get("").toAbsolutePath().toString()
            .plus("/src/main/SampleCSVFile_2kb.csv")).inputStream()
    val reader = inputStream.bufferedReader()
    var iterator = reader.lineSequence().iterator()
    var index:Int = 1;

    while (iterator.hasNext()){
        var lineText:String = iterator.next()
       strarray.set(index, lineText)
       index++
    }

    return ""
}

a.csvFileToString()
println(CsvParser.strarray)

Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 1 
strarray.set(index, lineText) &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; because of this line

fun whichColumnIsChip(chip : Chip) : Int{
        val x = chip.x/2
        val columnWidth = Chip.radius*2 + distanceBetweenColumns
        val rightColumnBorder = IntArray(gamefield.columns.size){ i -&gt; marginLeft+(i+1) * (Chip.radius*2 + distanceBetweenColumns) }
        when {
            x.betweenInclusive(0.0, rightColumnBorder[0].toDouble()) -&gt; return 0
            x.betweenInclusive(rightColumnBorder[0].toDouble(), rightColumnBorder[1].toDouble()) -&gt; return 1
            x.betweenInclusive(rightColumnBorder[1].toDouble(), rightColumnBorder[2].toDouble()) -&gt; return 2
            x.betweenInclusive(rightColumnBorder[2].toDouble(), rightColumnBorder[3].toDouble()) -&gt; return 3
            x.betweenInclusive(rightColumnBorder[3].toDouble(), rightColumnBorder[4].toDouble()) -&gt; return 4
            x.betweenInclusive(rightColumnBorder[4].toDouble(), rightColumnBorder[5].toDouble()) -&gt; return 5
            x.betweenInclusive(rightColumnBorder[5].toDouble(), rightColumnBorder[6].toDouble()) -&gt; return 6
            else -&gt; return -10
        }
    }

fun main(args: Array&lt;String&gt;)
{
   try
   {
      println("args size: ${args.size}");
   }
   catch (e: Exception)
   {
      println(e.getMessage())
      System.exit(1)
   }
}

test_exception.kt:12:17: error: unresolved reference: getMessage
      println(e.getMessage())
                ^

fun main(args: Array&lt;String&gt;)
{
   try
   {
      println("args size: ${args.size}");
      throw Exception("something went wrong")
   }
   catch (e: Exception)
   {
      println(e.toString())
      System.exit(1)
   }
}

java.lang.Exception: something went wrong

if (windows != null || doors != null || pipes...)
{"id":111,
 "date":"02/12/2017"
 }

{"id":111,
 "date":"02/8/2018"}

@ExperimentalContracts
fun &lt;T&gt; List&lt;T&gt;.isListOfInt(): Boolean {
    contract {
        returns(true) implies (this@isListOfInt is List&lt;Int&gt;)
    }
    return TODO("some way that I know")
}

this@isListOfInt is List&lt;Int&gt;
Cannot check for instance of erased type: List&lt;Int&gt;
fun main() {
    test()
}

data class ObjA(val key: String, val value: String)
data class ObjB(val key: String, val value: String, val ref: Int)

fun test() {
    val listOfA = mutableListOf(
            ObjA("one", ""),
            ObjA("one", "o"),
            ObjA("one", "on"),
            ObjA("one", "one"),

            ObjA("two", ""),
            ObjA("two", "2"),
            ObjA("two", "two"),

            ObjA("three", "3"),
            ObjA("four", "4"),
            ObjA("five", "five")
    )

    //Use this list's object keys to get object with similar keys in above array.
    val listOfB = mutableListOf(
            ObjB("one", "i", 2),
            ObjB("two", "ii", 5)
    )

    val distinctListOfA = listOfA.distinctBy { it.key } //Remove duplicates in listOfA

    /*    
    val desiredList = doSomething to compare keys in distinctListOfA and listOfB
    for (o in desiredList) {
        println("key: ${o.key}, value: ${o.value}")
    }
    */

    /* I was hoping to get this kind of output with duplicates removed and comparison made.
      key: one, value: one
      key: two, value: two
     */
}

fun mapReservas(reservas: List&lt;Reservas&gt;): Map&lt;Pair&lt;String, Int&gt;, List&lt;Reservas&gt;&gt; {
    val map = mutableMapOf&lt;Pair&lt;String, Int&gt;, MutableList&lt;Reservas&gt;&gt;()
    for (reserva in reservas) {
        val key = reserva.numVoo to reserva.day
        val list = map[key] ?: mutableListOf()
        list.add(reserva)
        map[key] = list
    }
    return map
}


fun analiseEconomica(reserves: List&lt;Reserves&gt;) {
    val map = mapReserves(reserves)
    for (reserve in reserves) {
        map.forEach {
            val reservesNum = it.key.first
            val reservesDay = it.key.second
            val reservesCount = it.value.count()
            if (reservesNum == reserva.numFLight) {
                val conversion : Double = reservasCount * 1.5
                conversion!!.toInt()
                var count = 0
                val space = 10 - reservesNum.length
                print("$reservesNum")
                for (i in 0..space) {
                    print(" ")
                }
                while (count &lt; conversion) {
                    print("#")
                    count++
                }
                println()
            }
        }
    }
}

    for (var i in 0...data.size - 1) {
        for (j in 0..bytes.size - 1) {
            bytes[j] = data[i++]//cant do i++ in current kotlin because "i" is val
        }
        //do stuff
    }

    var i = 0
    while (i &lt; data.size) {
        for (j in 0..bytes.size - 1) {
            bytes[j] = data[i++]
        }
        //do stuff
    }

fun main(args : Array&lt;String&gt;) {
  println("Hello, world!")
}

$ kotlinc -out dist -src hello.kt
$ ls dist
namespace.class
$ java dist/namespace
Exception in thread "main" java.lang.NoClassDefFoundError: dist/namespace (wrong name: namespace)
$ java -jar /usr/local/kotlin/lib/kotlin-runtime.jar
Failed to load Main-Class manifest attribute from
/usr/local/kotlin/lib/kotlin-runtime.jar 

abstract class Element&lt;E : Element&lt;E, S&gt;, S : Snapshot&lt;S, E&gt;&gt; {

    var snapshot: S

    init {
        snapshot = ((this.javaClass.getGenericSuperclass() as 
            ParameterizedType).actualTypeArguments[0] as Class&lt;S&gt;).newInstance()
        snapshot.element = this
// This is solution        snapshot.element = this as E
    }
}


abstract class Snapshot&lt;S : Snapshot&lt;S, E&gt;, E : Element&lt;E, S&gt;&gt;{
    lateinit var element: E
}

Element
snapshot.element = this
Type mismatch.
Required: E
Found: Element&lt;E, S&gt;

fun Router.handleJsonGet(path: String, method: () -&gt; Any) {
    this.get(path).handler {
        it.response().putHeader("Content-Type", "application/json").end((gson.toJson(method())))
    }
}

router.handleJsonGet("/business/list", { BusinessService.listBusinesses() })

GET
fun Router.handleJsonGet(path: String, method: (any:Any) -&gt; Any) {
    this.get(path).handler {
        val map: MultiMap = it.request().params() ?: MultiMap.caseInsensitiveMultiMap()
        it.response().putHeader("Content-Type", "application/json").end((gson.toJson(method(map))))
    }
}

router.handleJsonGet("/business/list", BusinessService::listBusinesses)

object BusinessService {
    fun listBusinesses(any: Any) : List&lt;Business&gt; {
        // do something with any as MultiMap
        return Business.findAllBusinesss();
    } 
}

val payloadClass =  try {
    Class.forName("com.something.SomeClass")
} catch (e: ClassNotFoundException) {
   null
}

false
is
payloadClass is AGreatInterface
is
Class.forName
payloadClass.interfaces.contains(AGreatInterface::class.java)
is
parent
this
parent
this
parent
@ManyToOne(fetch = FetchType.EAGER)

@JoinColumn(name = "parent_id")
var _parent: T? = null
var parent: T
    get() = if (isParent) this as T else _parent!!
    set(value) {
        _parent = if (value == null) null else value.parent
    }

_parent
parent: T
fun main(args: Array&lt;String&gt;) {
println("HelloWorld!")
}

kotlinc HelloWorld.kt -include-runtime -d HelloWorld.jar

Exception in thread "main" java.lang.UnsupportedClassVersionError: org/jetbrains/kotlin/preloading/Preloader : Unsupported major.minor version 52.0
at java.lang.ClassLoader.defineClass1(Native Method)
at java.lang.ClassLoader.defineClass(ClassLoader.java:803)
at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
at java.net.URLClassLoader.defineClass(URLClassLoader.java:449)
at java.net.URLClassLoader.access$100(URLClassLoader.java:71)
at java.net.URLClassLoader$1.run(URLClassLoader.java:361)
at java.net.URLClassLoader$1.run(URLClassLoader.java:355)
at java.security.AccessController.doPrivileged(Native Method)
at java.net.URLClassLoader.findClass(URLClassLoader.java:354)
at java.lang.ClassLoader.loadClass(ClassLoader.java:425)
at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
at java.lang.ClassLoader.loadClass(ClassLoader.java:358)
at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:482)

interface base {
  abstract static fun foo()
}

class impl : base { 
  override static fun foo()
}

fun &lt;T : base&gt; bar() {
  T.foo()
}

T
import kotlin.reflect.full.*

interface DynamicBuilder {
    fun build(sides: Int): Shape?
}

interface Shape {
    companion object : DynamicBuilder {
        override fun build(sides: Int) = null
    }
}

abstract class Shape2D : Shape {
    companion object : DynamicBuilder {
        override fun build(sides: Int) = if(sides &gt; 0) Square() else Circle()
    }
}

abstract class Shape3D : Shape {
    companion object : DynamicBuilder {
        override fun build(sides: Int) = if(sides &gt; 0) Cube() else Sphere()
    }
}

class Square : Shape2D()
class Circle : Shape2D()
class Sphere : Shape3D()
class Cube : Shape3D()

fun Build(sides: Int, builder: DynamicBuilder): Shape? {
    return builder.build(sides)
}

inline fun &lt;reified T : Shape&gt; Build(sides: Int): Shape? {
    return Build(sides, T::class.companionObjectInstance as DynamicBuilder)
}

fun main() {
    println(Build(0, Shape2D))
    println(Build(4, Shape2D))

    println(Build&lt;Shape3D&gt;(0))
    println(Build&lt;Shape3D&gt;(6))
}

Shape
package com.beaudoin

import java.io.BufferedWriter
import java.io.FileInputStream
import java.io.FileWriter
import java.nio.channels.FileChannel

fun main(args: Array&lt;String&gt;) {
    val s = System.currentTimeMillis()

    val channel = FileInputStream("client.dll").channel
    val buffer = channel.map(FileChannel.MapMode.READ_ONLY, 0, channel.size())
    val data = ByteArray(buffer.capacity())
    buffer.get(data)

    val writer = BufferedWriter(FileWriter("dump.txt", false))
    val bytes = ByteArray(16)

    var offset = 0
    var i = 0
    while (i &lt; data.size) {
        for (j in bytes.indices) {
            bytes[j] = data[i++]
        }
        writer.write(HexRow(offset, bytes).toString())
        writer.newLine()
        offset += 16
    }

    writer.close()

    println(System.currentTimeMillis() - s)
}

private val HEX_ARRAY = "0123456789ABCDEF".toCharArray()
private val bytes = ByteArray(4);

class HexRow(val offset: Int, val values: ByteArray) {

    fun bytesToChar(bytes: ByteArray, width: Int): CharArray {
        val hexChars = CharArray((bytes.size * 2) + (bytes.size / width))

        for (i in bytes.indices) {
            val v = bytes[i].toInt() and 0xFF
            val idx = (i * 2) + i / width

            hexChars[idx] = HEX_ARRAY[v.ushr(4)]
            hexChars[idx + 1] = HEX_ARRAY[v and 0x0F]
            if (idx + 2 &lt; hexChars.size) {
                hexChars[idx + 2] = ' '
            }
        }
        return hexChars;
    }

    fun bytesToHex(value: Int) = String(bytesToChar(toByteArray(value), 6))

    fun bytesToHex(bytes: ByteArray) = String(bytesToChar(bytes, 1))

    fun toByteArray(value: Int): ByteArray {
        bytes[0] = value.ushr(24).toByte()
        bytes[1] = value.ushr(16).toByte()
        bytes[2] = value.ushr(8).toByte()
        bytes[3] = value.toByte()
        return bytes
    }

    override fun toString() = bytesToHex(offset) + " " + bytesToHex(values)

}

package com.beaudoin

import java.io.BufferedWriter
import java.io.FileInputStream
import java.io.FileWriter
import java.nio.channels.FileChannel

fun main(args: Array&lt;String&gt;) {
    val s = System.currentTimeMillis()

    val channel = FileInputStream("client.dll").channel
    val buffer = channel.map(FileChannel.MapMode.READ_ONLY, 0, channel.size())
    val data = ByteArray(buffer.capacity())
    buffer.get(data)

    val writer = BufferedWriter(FileWriter("dump.txt", false))
    val bytes = ByteArray(16)

    var offset = 0
/*  var i = 0
    while (i &lt; data.size) {
        for (j in bytes.indices) {
            bytes[j] = data[i++]
        }
        writer.write(HexRow(offset, bytes).toString())
        writer.newLine()
        offset += 16
    }*/

    for (i in data.indices) {
        for (j in bytes.indices) {
            bytes[j] = data[i]
            i.inc()
        }
        writer.write(HexRow(offset, bytes).toString())
        writer.newLine()
        offset += 16
    }

    writer.close()

    println(System.currentTimeMillis() - s)
}

private val HEX_ARRAY = "0123456789ABCDEF".toCharArray()
private val bytes = ByteArray(4);

class HexRow(val offset: Int, val values: ByteArray) {

    fun bytesToChar(bytes: ByteArray, width: Int): CharArray {
        val hexChars = CharArray((bytes.size * 2) + (bytes.size / width))

        for (i in bytes.indices) {
            val v = bytes[i].toInt() and 0xFF
            val idx = (i * 2) + i / width

            hexChars[idx] = HEX_ARRAY[v.ushr(4)]
            hexChars[idx + 1] = HEX_ARRAY[v and 0x0F]
            if (idx + 2 &lt; hexChars.size) {
                hexChars[idx + 2] = ' '
            }
        }
        return hexChars;
    }

    fun bytesToHex(value: Int) = String(bytesToChar(toByteArray(value), 6))

    fun bytesToHex(bytes: ByteArray) = String(bytesToChar(bytes, 1))

    fun toByteArray(value: Int): ByteArray {
        bytes[0] = value.ushr(24).toByte()
        bytes[1] = value.ushr(16).toByte()
        bytes[2] = value.ushr(8).toByte()
        bytes[3] = value.toByte()
        return bytes
    }

    override fun toString() = bytesToHex(offset) + " " + bytesToHex(values)

}

public &lt;T&gt; T readJson(Class&lt;T&gt; c) throws IOException {

Map&lt;String, String&gt; map = foo.readJson(Map.class);

foo.readJson(Map::class.java)

Map&lt;String, String&gt;
Type inference failed. Expected type mismatch.
required Map&lt;String, String&gt;
found Map&lt;*, *&gt;!

interface StringMap : Map&lt;String, String&gt;

Cannot cast ...LinkedTreeMap to ...StringMap

Kotlin 1.2.50

@Nullable
public static final Drawable getDrawable(@NonNull Context context, @DrawableRes int id)

MovieItemDecorator()
@MovieListScope
    @Provides
    fun provideMovieItemDecorator(context: Context): MovieItemDecorator {
        var drawable: Drawable by Delegates.notNull()

        ContextCompat.getDrawable(context, R.drawable.blue_border)?.let {
            drawable = it
        }

        return MovieItemDecorator(drawable)
    }

 @MovieListScope
    @Provides
    fun provideMovieItemDecorator(context: Context): MovieItemDecorator {
        ContextCompat.getDrawable(context, R.drawable.blue_border)?.let {
           return MovieItemDecorator(it)
        } ?: {
            return MovieItemDecorator(....) /* what to return here */
        }
    }

fun operate(m: Message) {
  use(m.messageId)
}

sealed class Message(val messageId: String)

class Track(val event: String, messageId: String): Message(messageId)

sealed class Message(val messageId: String)

data class Track(val event: String, messageId: String): Message(messageId)

sealed class Message(val messageId: String)

data class Track(val event: String, val messageId: String): Message(messageId)

sealed class Message(open val messageId: String)

data class Track(val event: String, override val messageId: String): Message(messageId)

kotlin
handler.postDelayed(object : Runnable {
            override fun run() {
                Timber.i("run post msg")
                handler.postDelayed(this, AppPrefs.SEARCH_DELAY)
            }
        },AppPrefs.SOCKET_INTERVAL)

Runnable
class
this
Runnable
handler.postDelayed({
            Timber.i("run post msg")
            handler.postDelayed(this, AppPrefs.SOCKET_INTERVAL)
        },AppPrefs.SOCKET_INTERVAL)

this
protected fun getBestMethodFor(o: Any): Method? {
    val nodeClass = o.javaClass
    val objectClass = Any::class.java
    ...

    // Go through superclasses.
    var c = nodeClass
    while (c != objectClass &amp;&amp; ans == null) {
        debugMsg("Looking for class match for " + c.name)
        ...
        c = c.superclass
    }
    ...
}

Error:(57, 17) Kotlin: Type mismatch: inferred type is Class&lt;in Any!&gt;! but Class&lt;Any&gt; was expected
Error:(57, 19) Kotlin: Type inference failed. Expected type mismatch: inferred type is Class&lt;in Any!&gt;! but Class&lt;Any&gt; was expected

val mPagerAdapter: PagerAdapter by lazy {
    PagerAdapter(supportFragmentManager, fragments, mTabsName)
}

val fragments = Vector&lt;Fragment&gt;() by lazy {
    Vector&lt;Fragment&gt;()
}

Unresolve Reference: by
val (x, y) = getSomeXYPair()

lateinit
class Foo {

    private lateinit var x: Int
    private lateinit var y: Int

    init {
        (x, y) = getSomeXYPair()
    }
}

// I know activity is not ideal here due to lack of equality guaranty; please ignore this part
private val mActivities: WeakHashMap&lt;Activity, Int&gt; = WeakHashMap()
....
mActivities.put(null, null)
mActivities.filter { (backStackEntry: Activity?) -&gt;
    // Issue: this does not show any errors but fails at runtime
    Logger.warn("$TAG - Activity ${backStackEntry.localClassName}")
    val entry: Activity? = backStackEntry
    // Works as expected: this does show the error as expected
    Logger.warn("$TAG - Activity ${entry.localClassName}")
}

${backStackEntry?.localClassName}
${backStackEntry.localClassName}
${entry.localClassName}
if ((oldTest != null) &amp;&amp; (oldTest.snapshotUrl != null)) {
    val startPos = oldTest.snapshotUrl!!.lastIndexOf("_") + 1
}

if (oldTest != null) {
    val startPos = oldTest.snapshotUrl?.lastIndexOf("_") + 1
}

fun bindService() {
        val intent = Intent(this, BluetoothService::class.java)
        bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE)
    }

 bindService()
        launch {
            delay(500L)
            service = serviceConnection.serviceBinder?.getService() as BluetoothService
        }

delay()
var firstArray = arrayListOf(1,2,3,4)

var secondArray = firstArray.copyOfRange(0,1)

inp
InputStream
import java.io.*
import org.apache.poi.util.*

class MyDataInputStream(val inp: InputStream) : DataInputStream(inp) {

    fun readShortLittle(): Short {
        val r: Short
        try {
            r = LittleEndian.readShort(inp)
        } catch (e: LittleEndian.BufferUnderrunException) {
            throw EOFException()
        }
        return r
    }

    fun readIntLittle(): Int {
        val r: Int
        try {
            r = LittleEndian.readInt(inp)
        } catch (e: LittleEndian.BufferUnderrunException) {
            throw EOFException()
        }
        return r
    }

    fun readLongLittle(): Long {
        val r: Long
        try {
            r = LittleEndian.readLong(inp)
        } catch (e: LittleEndian.BufferUnderrunException) {
            throw EOFException()
        }
        return r
    }
}

fun main(args: Array&lt;String&gt;) {
    var i: Int
    val inp = MyDataInputStream(System.`in`)
    while (true) {
        // llegir int en binari si EOF break
        try {
            i = inp.readIntLittle()
        } catch (e: EOFException) {
            break
        }
        println(i);
    }
}

fun DataInputStream.readShortLittle(): Short {
    ...
}

fun DataInputStream.readIntLittle(): Int {
    ....
}

fun DataInputStream.readLongLittle(): Long {
    ....
}

inp
4011=Error thrown expected: {0} found: {1}.

loggingService.logTheMsg("4011", arrayOf("${expectedVal}", "${actualVal}"))

var errorMessage = props.getProperty(errorCode)
errorMessage = MessageFormat.format(errorMessage as String, args)
println("${errorMessage}.")

Error thrown expected:[Ljava.lang.String;@38f3b4ba found: {1}.

parse(value, new String[]{"firstName","lastName"});

parse(String value, String[]args) {         
    value = MessageFormat.format((String) value, args);         
    System.out.println(value); 
}

compareTo
equals
class MyClass {
    companion object {
        private val NUMBER: Int = 5

        operator fun compareTo(value: Int) = NUMBER - value

        override operator fun equals(other: Any?) =
                when (other) {
                    is Int -&gt; NUMBER == other
                    else -&gt; throw Exception("")
                }
    }
}

fun test() {
    if (MyClass &lt; 10) {
        //ok
    }

    //Operator '==' cannot be applied to 'MyClass.companion' and kotlin.Int
    if (MyClass == 5) {
    }
}

open class Test(){
    override fun toString(): String {
        return "This is test!"
    }
}


fun createTestX(): Test {
    return object : Test() {
        override fun toString(): String {
            return super.toString() + "XXX"
        }
    }

}

fun main(args: Array&lt;String&gt;) {
    val x = createTestX()
    println(x)
}

val x = Test()
x.toString = () -&gt; x.toString() + "XXX"

data class User (
    val profilePics = arrayOf("a", "b", "c")
)

data class User (
    val profilePics: Array&lt;String&gt;(3)
)

data class User (
    val profilePics = arrayOfNulls&lt;String&gt;(3)
)

data class User (
    val profilePics: Array&lt;String&gt;
)

class AnyUsernamePersistentNodePath(override val value: String) : AnyPersistenceNodePath {
    override val key = "username"    
}

interface AnyPersistenceNodePath {
    val key: String
    val value: String
}

value
username
value
value
class AnyUsernamePersistentNodePath(val username: String) : AnyPersistenceNodePath {
    override val key = "username"
    override val value = username
}

Void
Unit
Nothing
null
undefined
void(0)
5721/25818 KB   19242/25818 KB   25693/25818 KB   Downloaded: http://maven.aliyun.com/nexus/content/groups/public/org/jetbrains/kotlin/kotlin-compiler/1.1.2-2/kotlin-compiler-1.1.2-2.jar (25818 KB at 113.2 KB/sec)
[WARNING] Error injecting: org.jetbrains.kotlin.maven.K2JVMCompileMojo
java.lang.TypeNotPresentException: Type org.jetbrains.kotlin.maven.K2JVMCompileMojo not present
    at org.eclipse.sisu.space.URLClassSpace.loadClass(URLClassSpace.java:115)
    at org.eclipse.sisu.space.NamedClass.load(NamedClass.java:46)
    at org.eclipse.sisu.space.AbstractDeferredClass.get(AbstractDeferredClass.java:48)
    at com.google.inject.internal.ProviderInternalFactory.provision(ProviderInternalFactory.java:86)
    at com.google.inject.internal.InternalFactoryToInitializableAdapter.provision(InternalFactoryToInitializableAdapter.java:54)
    at com.google.inject.internal.ProviderInternalFactory$1.call(ProviderInternalFactory.java:70)
    at com.google.inject.internal.ProvisionListenerStackCallback$Provision.provision(ProvisionListenerStackCallback.java:113)
    at org.eclipse.sisu.bean.BeanScheduler$Activator.onProvision(BeanScheduler.java:176)
    at com.google.inject.internal.ProvisionListenerStackCallback$Provision.provision(ProvisionListenerStackCallback.java:122)
    at com.google.inject.internal.ProvisionListenerStackCallback.provision(ProvisionListenerStackCallback.java:68)
    at com.google.inject.internal.ProviderInternalFactory.circularGet(ProviderInternalFactory.java:68)
    at com.google.inject.internal.InternalFactoryToInitializableAdapter.get(InternalFactoryToInitializableAdapter.java:46)
    at com.google.inject.internal.InjectorImpl$2$1.call(InjectorImpl.java:1009)
    at com.google.inject.internal.InjectorImpl.callInContext(InjectorImpl.java:1059)
    at com.google.inject.internal.InjectorImpl$2.get(InjectorImpl.java:1005)
    at com.google.inject.Scopes$1$1.get(Scopes.java:59)
    at org.eclipse.sisu.inject.LazyBeanEntry.getValue(LazyBeanEntry.java:82)
    at org.eclipse.sisu.plexus.LazyPlexusBean.getValue(LazyPlexusBean.java:51)
    at org.codehaus.plexus.DefaultPlexusContainer.lookup(DefaultPlexusContainer.java:263)
    at org.codehaus.plexus.DefaultPlexusContainer.lookup(DefaultPlexusContainer.java:255)
    at org.apache.maven.plugin.internal.DefaultMavenPluginManager.getConfiguredMojo(DefaultMavenPluginManager.java:464)
    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:119)
    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:208)
    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)
    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)
    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:116)
    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:80)
    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)
    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:120)
    at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:355)
    at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:155)
    at org.apache.maven.cli.MavenCli.execute(MavenCli.java:584)
    at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:216)
    at org.apache.maven.cli.MavenCli.main(MavenCli.java:160)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)
    at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)
    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)
    at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)
    at org.codehaus.classworlds.Launcher.main(Launcher.java:47)
Caused by: java.lang.UnsupportedClassVersionError: org/jetbrains/kotlin/maven/K2JVMCompileMojo : Unsupported major.minor version 52.0
    at java.lang.ClassLoader.defineClass1(Native Method)
    at java.lang.ClassLoader.defineClass(ClassLoader.java:800)
    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
    at java.net.URLClassLoader.defineClass(URLClassLoader.java:449)
    at java.net.URLClassLoader.access$100(URLClassLoader.java:71)
    at java.net.URLClassLoader$1.run(URLClassLoader.java:361)
    at java.net.URLClassLoader$1.run(URLClassLoader.java:355)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.net.URLClassLoader.findClass(URLClassLoader.java:354)
    at org.codehaus.plexus.classworlds.realm.ClassRealm.loadClassFromSelf(ClassRealm.java:401)
    at org.codehaus.plexus.classworlds.strategy.SelfFirstStrategy.loadClass(SelfFirstStrategy.java:42)
    at org.codehaus.plexus.classworlds.realm.ClassRealm.unsynchronizedLoadClass(ClassRealm.java:271)
    at org.codehaus.plexus.classworlds.realm.ClassRealm.loadClass(ClassRealm.java:247)
    at org.codehaus.plexus.classworlds.realm.ClassRealm.loadClass(ClassRealm.java:239)
    at org.eclipse.sisu.space.URLClassSpace.loadClass(URLClassSpace.java:107)
    ... 42 more

    &lt;plugin&gt;
        &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
        &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;${kotlin.version}&lt;/version&gt;
        &lt;executions&gt;
            &lt;execution&gt;
                &lt;id&gt;compile&lt;/id&gt;
                &lt;phase&gt;compile&lt;/phase&gt;
                &lt;goals&gt;
                    &lt;goal&gt;compile&lt;/goal&gt;
                &lt;/goals&gt;
            &lt;/execution&gt;
            &lt;execution&gt;
                &lt;id&gt;test-compile&lt;/id&gt;
                &lt;phase&gt;test-compile&lt;/phase&gt;
                &lt;goals&gt;
                    &lt;goal&gt;test-compile&lt;/goal&gt;
                &lt;/goals&gt;
            &lt;/execution&gt;
        &lt;/executions&gt;
    &lt;/plugin&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
    &lt;artifactId&gt;kotlin-stdlib-jre7&lt;/artifactId&gt;
    &lt;version&gt;${kotlin.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
    &lt;artifactId&gt;kotlin-test&lt;/artifactId&gt;
    &lt;version&gt;${kotlin.version}&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

java.lang.Thread
MyThread
interface MyRunnable{
    fun run()
}

class MyThread(runnable : MyRunnable){    
}

fun test(){
    Thread({})     // All Alright

    MyThread({})   //Exception. Type mismatch &lt;&lt;-- Why ?
}

String [] errorSoon = {"Hello", "World"};
Kotlin
class CameraBrandDto(override val id: Long = 0, override var dateCreated: Date = Date(), override var dateUpdated: Date = Date()) : DataTransportObject {
    override var clazz = this.javaClass.simpleName.replace("Dto", "")

    @NotBlank
    @Size(max = 13)
    var name: String = ""

    var models: MutableSet&lt;DtoMin&gt; = mutableSetOf(DtoMin(0, "UNDEFINED", "UNDEFINED", Date(), Date()))

}

val axisDto  = CameraBrandDto()
axisDto.name = "AXIS"

&gt;&gt;&gt; import java.io.StringReader
&gt;&gt;&gt; val json = p.parse(StringReader("""{"abc":"123"}""")) as JsonObject
&gt;&gt;&gt; json.string("abc")
error: unresolved reference: string
json.string("abc")
     ^

&gt;&gt;&gt; json
JsonObject(map={abc=123})

interface AuthServiceResponse {
    val statusCode: Int
    val data: AuthServiceResponseData
    val errors: List&lt;AuthServiceResponseError&gt;?
}

data class AuthServiceBasicResponse(override var statusCode: Int,
                                    override var data: AuthServiceResponseData,
                                    override var errors: List&lt;AuthServiceResponseError&gt;) : AuthServiceResponse

    @PostMapping
    fun loginUser(@RequestParam username: String,
                  @RequestParam password: String): Mono&lt;AuthServiceResponse&gt; {
        return authenticationService.loginUser(username, password)
    }

fun loginUser(username: String,
              password: String): Mono&lt;AuthServiceBasicResponse&gt; {
...
}

main
2
1
fun main(args: Array&lt;String&gt;) {
    println("1")
}

var print_me = println("2")

Entity
Account
abstract class Entity(
    var id: String? = null,
    var created: Date? = Date()) {

    constructor(entity: Entity?) : this() {
        fromEntity(entity)
    }

    fun fromEntity(entity: Entity?): Entity {
        id = entity?.id
        created = entity?.created
        return this;
    }
}

data class Account( 
    var name: String? = null,
    var accountFlags: Int? = null
) : Entity() {

    constructor(entity: Entity) : this() {
        super(entity)
    }
}

 constructor(entity: Entity) : this() {
    super.fromEntity(entity)
}

Function&lt;Unit&gt;
Function1&lt;Unit, Unit&gt;
fun fact(x:Int):Int{

    tailrec fun factTail(y:Int, z:Int=1) : Int{

        if (x == 0) {return z}
        else if (x == 1) {return z}
        else {
            return factTail(y-1, y*z)
        }

    }

return factTail(x,1)

fun main(args: Array&lt;String&gt;) {

println("5! is ${fact(5)}")

}

public abstract class A {
   abstract int getA()
}

class B : A() {
    val a = 0
}

class B : A() {
    override val a = 0
}

class B : A() {
    override val a: Int get () = 1
}

class B : A() {
    override val a: Int override get () = 1
}

class B : A() {
    val a: Int override get () = 1
}

class B : A() {
    override fun getA() = 1
}

var
fun printExecutionTime(block: () -&gt; Any) {
    run {
        val currentTimeMillis = System.currentTimeMillis()
        block()
        Logr.d("Execution time of " + block.javaClass.name + " -&gt; " + System.currentTimeMillis().minus(currentTimeMillis))
    }
}

PerformanceKt.printExecutionTime(this::voidFunc);

interface Action {
    fun call()
}


class CreateWorkflowActivity: AppCompatActivity(), View.OnClickListener {

    var touchHelper:ItemTouchHelper?= null
    private lateinit var callback:ItemMoveCallback
    private lateinit var rec_view: RecyclerView
    companion object {
        private lateinit var viewModel : WorkflowViewModel
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_create_workflow)
        val factory= InjectorUtils.provideWorkflowViewModelFactory("")
        viewModel = ViewModelProviders.of(this,factory).get(WorkflowViewModel::class.java)
        rec_view= findViewById(R.id.recyclerView_addedBlocksOnCreation)
        rec_view.layoutManager= LinearLayoutManager(this)
        val observer = Observer&lt;ArrayList&lt;String&gt;&gt;{
            val adapter = BlockViewAdapter(it!!, this@CreateWorkflowActivity)
            callback= ItemMoveCallback(adapter,this@CreateWorkflowActivity,ItemTouchHelper.UP.or(ItemTouchHelper.DOWN),0)
            touchHelper= ItemTouchHelper(callback)
            touchHelper?.attachToRecyclerView(rec_view)
            runOnUiThread{
                rec_view.adapter= adapter
            }
        }
        viewModel.getLiveBlockNames().observe(this,observer)


    }

//this gets called when the user has decided the parameters for the block
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)

        if(requestCode == 1) {
            if(resultCode==Activity.RESULT_OK) {

               //all block additions

                }

            }

        }

    }

}




class ItemMoveCallback(adapter: BlockViewAdapter, context: Context, dragDirs: Int, swipeDirs: Int) : ItemTouchHelper.SimpleCallback(dragDirs, swipeDirs)
{
    var mAdapter = adapter


    override fun onSwiped(p0: RecyclerView.ViewHolder, p1: Int) {
        return
    }

    override fun onMove(p0: RecyclerView, viewHolder: RecyclerView.ViewHolder, target: RecyclerView.ViewHolder): Boolean {
        mAdapter.swapItems(viewHolder.adapterPosition, target.adapterPosition)
        return true
    }
    fun setAdapter(adapter: BlockViewAdapter){
        mAdapter=adapter
    }

}


class BlockViewAdapter(val dataset: ArrayList&lt;String&gt;,val context: Context): RecyclerView.Adapter&lt;BlockViewHolder&gt;(){

    @SuppressLint("ClickableViewAccessibility")
    override fun onBindViewHolder(holder: BlockViewHolder, position: Int) {
        holder.tView?.text = dataset[position]

        }


    override fun getItemCount(): Int {
        return dataset.size
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): BlockViewHolder {

        return BlockViewHolder(
            LayoutInflater.from(context).inflate(
                R.layout.block_item,
                parent,
                false
            )
        )

    }

    fun swapItems(fromPosition: Int, toPosition: Int) {

        if (fromPosition &lt; toPosition) {
            for (i in fromPosition..toPosition - 1) {
                dataset.set(i, dataset.set(i+1, dataset.get(i)))
            }
        } else {
            for (i in fromPosition..toPosition + 1) {
                dataset.set(i, dataset.set(i-1, dataset.get(i)))
            }
        }

        notifyItemMoved(fromPosition, toPosition)
    }


}


fun f(i:Int, list:MutableList&lt;Int&gt;) : Boolean {
    for (number in list) {
        if (i % number == 0) {
            return false
        }
    }
    return true
}

fun main(args:Array&lt;String&gt;) {
    val result = mutableListOf&lt;Int&gt;()
    for (number in 2..100) {
        if (f(number, result)) {
            result.append(number)
        }   

       print(result.joinToString())
}

open class Time {

    var hh: Int = 0
    var mm: Int = 0
    var ss: Int = 0

    constructor(hh: Int, mm: Int, ss: Int) {
        this.hh = hh
        this.mm = mm
        this.ss = ss
    }

    constructor(seconds: Int) {
        this.hh = seconds / 3600
        this.mm = (seconds % 3600) / 60
        this.ss = (seconds % 3600) % 60
    }

    val isValid = mm in 0..59 &amp;&amp; ss in 0..59

    val toSeconds = hh * 3600 + mm * 60 + ss

    val toString = "$hh:$mm:$ss"

}

assertFalse(Time(0, 59, 60).isValid)

open class Time(val hh: Int, val mm: Int, val ss: Int) {

    constructor(seconds: Int) : this(seconds / 3600, (seconds % 3600) / 60, (seconds % 3600) % 60)

    val isValid = mm in 0..59 &amp;&amp; ss in 0..59

    val toSeconds = hh * 3600 + mm * 60 + ss

    val toString = "$hh:$mm:$ss"
} 

abstract class Shader(/*Input arguments omitted for the sake of an MCVE*/){

    init{
        //Shader loading and attaching, not relevant
        bindAttribs()//One of the abstract methods. In my actual program, this uses OpenGL to bind attributes
        //GLSL program validation
        getUniforms()//Same as the previous one: abstract method using GL calls to get uniforms. This gets locations so an integer is set (the problem)

    }
    abstract fun getUniforms();//This is the one causing problems
    abstract fun bindAttribs();//This would to if primitives or non-lateinit vars are set
}

abstract class BoilerplateShader() : Shader(){
    var loc_projectionMatrix: Int = 404//404 is an initial value. This can be anything though
    var loc_transformationMatrix: Int = 404
    var loc_viewMatrix: Int = 404

    override fun getUniforms(){
        //These would be grabbed by using glGetUniformLocations, but it's reproducable with static values as well
        loc_projectionMatrix = 0
        loc_transformationMatrix = 1
        loc_viewMatrix = 2
        println(loc_projectionMatrix.toString() + ", " + loc_transformationMatrix + ", " + loc_viewMatrix)
    }

    //debug method, only used to show the values
    fun dump(){
        println(loc_projectionMatrix.toString() + ", " + loc_transformationMatrix + ", " + loc_viewMatrix)
    }

}

class TextureShader() : BoilerplateShader(){

    override fun bindAttribs() {
        //This doesn't cause a problem even though it's called from the init block, as nothing is assigned
        //bindAttrib(0, "a_position");
        //bindAttrib(1, "a_texCoord0");
    }
}

//Other repetitive shaders, omitted for brevity

val tx = TextureShader()
tx.dump()

0, 1, 2
404, 404, 404

getUniforms
getUniforms
BoilerplateShader
TextureShader
getUniforms
fun init(){
    bindAttribs();
    getUniforms();
}

val ts = TexturedShader();
ts.init();
ts.dump()

abstract class Shader{
    public Shader(){
        getUniforms();
    }

     public abstract void getUniforms();
}

abstract class BoilerplateShader extends Shader{
    int loc_projectionMatrix;//When this is initialized, it produces the same issue as Kotlin. But Java doesn't require the vars to be initialized when they're declared globally, so it doesn't cause a problem
    public void getUniforms(){
        loc_projectionMatrix = 1;
        System.out.println(loc_projectionMatrix);
    }
    //and a dump method or any kind of basic print statement to print it after object creation
}

class TextureShader extends BoilerplateShader {
    public TextureShader(){
        super();
    }
}

var test: String = ""

0, 1, 2, test
404, 404, 404, 

test
lateinit var
lateinit var test: String

0, 1, 2, test
404, 404, 404, test

lateinit
Shader
&lt;init&gt; is private in Shader
init()
Expression&lt;Func&lt;int, int, int&gt;&gt; add = (a, b) =&gt; a + b;

val add = { a: Int, b: Int -&gt; a + b }

word
 fun main(args: Array&lt;String&gt;) {

        val sentence = "this is a nice sentence"

        val wordLengths: List&lt;Any&gt; = sentence.split(' ').map {
            object {
                val length = it.length
                val word = it
            }
        }

        wordLengths.forEach { it:Any -&gt; println(it) }
    }

const val
const val bitmask = (5 shl 3) + 2
const val aComputedString = "Hello ${0x57.toChar()}orld${((1 shl 5) or 1).toChar()}"
const val comparedInt = 5.compareTo(6)
const val comparedString = "Hello".compareTo("World!")
const val toStringedInt = 5.compareTo(6).toString()
const val charFromString = "Hello World!".get(3)

// An extension function on Int.
const val coercedInt = 3.coerceIn(1..5)

// Using operator syntax to call the get-function.
const val charFromString = "Hello World!"[3]

// An immediate type is not a primitive.
const val stringFromImmediateList = "Hello World!".toList().toString()

// Using a function defined by yourself.
fun foo() = "Hello world!"
const val stringFromFunction = foo()

let
public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R

var a: String? = "maybe null" 
val x: Boolean = a?.let { 
    a.contains("maybe") // note that contains returns Boolean, not Boolean?
}

Boolean
Boolean?
Boolean
contains
Boolean
val b:Byte = 0xFF
kotlin.Byte
0x00
0xFF
Byte b = 0xFF
@ExperimentalMultiplatform
@Repository
class ClientUserGatewayImpl(private val repo: ClientUserRepo) : 
ClientUserGateway {
   override fun save(model: DetailClientUser): ServiceResult&lt;DetailClientUser&gt; {
    return try {
        ServiceResult.Success(repo.save(model))
    } catch (e: Exception) {
        ServiceResult.Failure(errMsg = e.message ?: "exception had no message, check logs")
    }
}
}

b
a
fun run() {
    fun makePair() = Pair("Apple", "Orange")

    val (a, b) = makePair()

    println("b = $b")
}

class SwipePagerFragment : Fragment() {

    private lateinit var parent: MainActivity
    private lateinit var state: State
    private lateinit var ctx: Context
    private lateinit var swipeList: MutableList&lt;Int&gt;
    private lateinit var pager: ViewPager

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {

        val view = inflater.inflate(R.layout.fragment_swipe_pager, container, false)

        parent = activity as MainActivity
        state = parent.state
        ctx = state.ctx
        swipeList = state.swipeList

        pager = view.findViewById(R.id.fragmentSwipePager_pager)
        val pagerAdapter = ScreenSlidePagerAdapter(childFragmentManager)
        pager.adapter = pagerAdapter

        return view
    }

    private inner class ScreenSlidePagerAdapter(fm: FragmentManager) : FragmentStatePagerAdapter(fm) {
        override fun getCount(): Int = swipeList.size

        override fun getItem(position: Int): Fragment = when (state.swipeEntityType) {
            0 -&gt; {
                makeUserFragment(swipeList[position])
            }
            else -&gt; {
                makeEventFragment(swipeList[position])
            }
        }
    }

    private fun makeUserFragment(uid: Int): UserFragment {
        val bundle = Bundle()
        bundle.putInt("uid", uid)
        val frag = UserFragment()
        frag.arguments = bundle
        return frag
    }

    private fun makeEventFragment(eid: Int): EventFragment {
        val bundle = Bundle()
        bundle.putInt("eid", eid)
        val frag = EventFragment()
        frag.arguments = bundle
        return frag
    }

}

klass = Class.forName({MyClassName}).kotlin as KClass&lt;{MySuperClassName}&gt;
int startFrom = arr.length / 2;
for (int i = startFrom; i &lt; arr.length; i++)
{
    String.format("Index %d value %s", i, arr[i]);
}

val startFrom = inputData.size / 2
for ((i, item) in inputData.drop(startFrom).withIndex()){
    val fixedIndex = i + startFrom
    println("Index $i, fixed index $fixedIndex value $item")
}

A
B
val fpath: Path = Paths.get("")

fpath
if (a) b else c

when
val someString: String = try {

    String.format("Okay %s", "there") // or any function that returns String

} catch(exception: Exception) {

    try {
        // fun incrementErrorCount() { ... }
        incrementErrorCount() // [1] Error: Type mismatch: Inferred type is Unit but String was expected
    } finally {
        throw exception
    }

    // throw exception // [2] Fixes the type mismatch when uncommented, but raises Warning: Unreachable code
}

1
incrementErrorCount()
exception
2
throw
finally
string
*
n
val s = ""
val n = 100
for (j in 0 until n) {
    s += "*"
}

ByteArray, ShortArray, IntArray, CharArray, DoubleArray, FloatArray
byte[], short[], int[],char[], double[], float[]
StringArray
String[]
    private fun getUserFromSharePreferences() {

    Timber.d("getSP() = ${getSP()}")  // sharedPreferences
    Timber.d("sp = ${sp}")  // null
    }


    private fun getSP() = CoreApplication.context.getSharedPreferences(FLAG_SP_USER, Context.MODE_PRIVATE)

    private val sp = CoreApplication.context!!.getSharedPreferences(FLAG_SP_USER, Context.MODE_PRIVATE)!!

public final class UserKt {
   private static User currentUser = getUserFromSharePreferences();
   private static final SharedPreferences sp;




   private static final void getUserFromSharePreferences() {
      Timber.d("getSP() = " + getSP(), new Object[0]);
      Timber.d("sp = " + sp, new Object[0]);
   }

   private static final SharedPreferences getSP() {
      return CoreApplication.context.getSharedPreferences("FLAG_SP_USER", 0);
   }

   static {
      Context var10000 = CoreApplication.context;
      if(CoreApplication.context == null) {
         Intrinsics.throwNpe();
      }

      SharedPreferences var0 = var10000.getSharedPreferences("FLAG_SP_USER", 0);
      if(var0 == null) {
         Intrinsics.throwNpe();
      }

      sp = var0;
   }
}

Type mismatch: inferred type is Any but Nothing was expected
interface ConverterInterface&lt;T&gt;{
    fun sender(value: T): ByteArray
    fun receiver(bytes: ByteArray): T
}

class TestClass {
    val objA = object: ConverterInterface&lt;String&gt;{
        override fun sender(value: String): ByteArray {
            //...
        }

        override fun receiver(bytes: ByteArray): String {
            //...
        }
    }
}

fun test(){
    val testList: List&lt;ConverterInterface&lt;*&gt;&gt; = listOf(objA)

    // This works
    testList[0].receiver(byteArrayOf())

    // This does not
    testList[0].sender("")
    /* Out-projected type 'ConverterInterface&lt;*&gt;' prohibits the use of
    'public abstract fun sender(value: T): ByteArray defined in ConverterInterface */
}

*
Any
out Any
receiver
@Test
fun `ApiBuilder prefixes paths with slash`() = TestUtil.test { app, http -&gt;
    app.routes {
        //code
    }
    assertThat(http.getBody("/level-1/hello"), `is`("Hello from level 1"))
}

public static void test(ThrowingBiConsumer&lt;Javalin, HttpUtil&gt; test) {
    test(Javalin.create(), test);
}

var parent: T? = null
    get() = if (isParent) this as T else field
    set(value) { field = if (value == null) null else value.parent }

val isParent: Boolean
    get() = parent == null

var description = ""
    get() = if (isParent) field else parent!!.description
    set(value) { if (isParent) field = value else parent!!.description = value }

isParent
true
parent
getParent()
String getDescription() { return getParent().description; }
void setDescription(String value) { getParent().description = value; }

var description = ""
    get() = parent.field
    set(value) { parent.field = value }

parent
private var View.v: Boolean
    get() = this.visibility == View.VISIBLE
    set(visible) {
        if (visible) {
            this.visibility = View.VISIBLE
        } else {
            this.visibility = View.GONE
        }
    }

private var Int.v: Boolean
    get() = find&lt;View&gt;(this).v
    set(visible) = find&lt;View&gt;(this).v(visible)

Error:(40, 35) Expression 'v' of type 'Boolean' cannot be invoked as a function. The function 'invoke()' is not found

buildscript {
    ext.kotlin_version = '1.3.30'
    ext.kotlin_gradle_plugin_version = '1.3.0'
    ext.kotlinx_coroutines = '1.0.0'

    repositories {
        maven { url "https://kotlin.bintray.com/kotlin-eap" }
        mavenCentral()
        jcenter()
        google()
    }
    dependencies {
        implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.2.1")
    }
    }
plugins {
    id 'java'
    kotlin("jvm") version "1.3.30"
}

group 'Test2.project'
version '1.0-SNAPSHOT'

sourceCompatibility = 1.8

import kotlinx.coroutines.*

fun main(args: Array&lt;String&gt;) 
{
    println("hello")
}

import android.annotation.TargetApi
import android.content.Intent
import android.os.Build
import android.os.Bundle
import android.support.design.widget.FloatingActionButton
import android.support.v4.app.ActivityOptionsCompat
import android.support.v4.app.Fragment
import android.support.v4.util.Pair
import android.support.v4.view.ViewCompat
import android.support.v4.view.animation.FastOutSlowInInterpolator
import android.text.Editable
import android.text.TextWatcher
import android.transition.Transition
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.*
import android.widget.Toast.LENGTH_LONG
import com.google.samples.apps.topeka.adapter.AvatarAdapter
import com.google.samples.apps.topeka.base.R
import com.google.samples.apps.topeka.helper.ActivityLaunchHelper
import com.google.samples.apps.topeka.helper.ApiLevelHelper
import com.google.samples.apps.topeka.helper.DefaultLogin
import com.google.samples.apps.topeka.helper.TAG
import com.google.samples.apps.topeka.helper.TransitionHelper
import com.google.samples.apps.topeka.helper.isLoggedIn
import com.google.samples.apps.topeka.helper.login
import com.google.samples.apps.topeka.helper.onLayoutChange
import com.google.samples.apps.topeka.helper.onSmartLockResult
import com.google.samples.apps.topeka.model.Avatar
import com.google.samples.apps.topeka.model.Player
import com.google.samples.apps.topeka.persistence.TopekaDatabaseHelper
import com.google.samples.apps.topeka.widget.TextWatcherAdapter
import com.google.samples.apps.topeka.widget.TransitionListenerAdapter

/**
 * Enable selection of an [Avatar] and user name.
 */
class SignInFragment : Fragment() {

    private var firstNameView: EditText? = null
    private var lastInitialView: EditText? = null
    private var doneFab: FloatingActionButton? = null
    private var avatarGrid: GridView? = null

    private val edit by lazy { arguments?.getBoolean(ARG_EDIT, false) ?: false }


    private var selectedAvatarView: View? = null
    private var player: Player? = null
    private var selectedAvatar: Avatar? = null

    var a = TopekaDatabaseHelper.getInstance(this.requireContext())

    override fun onCreate(savedInstanceState: Bundle?) {


        if (savedInstanceState != null) {
            val avatarIndex = savedInstanceState.getInt(KEY_SELECTED_AVATAR_INDEX)
            if (avatarIndex != GridView.INVALID_POSITION) {
                selectedAvatar = Avatar.values()[avatarIndex]
            }
        }



        activity?.run {
            if (isLoggedIn()) {
                navigateToCategoryActivity()
            } else {
                login.loginPlayer(this, ::onSuccessfulLogin)
            }
        }
        super.onCreate(savedInstanceState)
    }

    /**
     * Called when logged in successfully.
     */
    private fun onSuccessfulLogin(player: Player) {
        if (login != DefaultLogin) return
        this.player = player
        if (edit) {
            with(player) {
                firstNameView?.setText(player.firstName)
                lastInitialView?.run {
                    setText(player.lastInitial)
                    requestFocus()
                    setSelection(length())
                }
                this@SignInFragment.player = player.also {
                    if (activity != null)
                        login.savePlayer(activity!!, this, { selectAvatar(it.avatar!!) })
                }
            }
        } else {
            navigateToCategoryActivity()
        }
    }



    private fun navigateToCategoryActivity() {
        activity?.run {
            ActivityLaunchHelper.launchCategorySelection(this)
            supportFinishAfterTransition()
        }
    }

    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        activity?.onSmartLockResult(
                requestCode,
                resultCode,
                data,
                success = {
                    player = it
                    initContents()
                    navigateToCategoryActivity()
                },
                failure = {
                    activity?.run {
                        login.loginPlayer(this, ::onSuccessfulLogin)
                    }
                }
        )
        super.onActivityResult(requestCode, resultCode, data)
    }

    override fun onCreateView(inflater: LayoutInflater,
                              container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {
        val contentView = inflater.inflate(R.layout.fragment_sign_in, container, false)


        val Button =
        contentView.onLayoutChange {
            avatarGrid?.apply {
                adapter = AvatarAdapter(activity!!)
                onItemClickListener = AdapterView.OnItemClickListener { _, view, position, _ -&gt;
                    selectedAvatarView = view
                    selectedAvatar = Avatar.values()[position]
                    // showing the floating action button if input data is valid
                    showFab()
                }
                numColumns = calculateSpanCount()
                selectedAvatar?.run { selectAvatar(this) }



            }
        }
        return contentView
    }

    /**
     * Calculates spans for avatars dynamically.

     * @return The recommended amount of columns.
     */
    private fun calculateSpanCount(): Int {
        val avatarSize = resources.getDimensionPixelSize(R.dimen.size_fab)
        val avatarPadding = resources.getDimensionPixelSize(R.dimen.spacing_double)
        return (avatarGrid?.width ?: 0) / (avatarSize + avatarPadding)
    }

    override fun onSaveInstanceState(outState: Bundle) {
        outState.putInt(KEY_SELECTED_AVATAR_INDEX, (avatarGrid?.checkedItemPosition ?: 0))
        super.onSaveInstanceState(outState)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        firstNameView = view.findViewById&lt;EditText&gt;(R.id.first_name)
        lastInitialView = view.findViewById&lt;EditText&gt;(R.id.last_initial)
        doneFab = view.findViewById&lt;FloatingActionButton&gt;(R.id.done)
        avatarGrid = view.findViewById&lt;GridView&gt;(R.id.avatars)

        if (edit || (player != null &amp;&amp; player!!.valid())) {
            initContentViews()
            initContents()
        }
        hideEmptyView()
        super.onViewCreated(view, savedInstanceState)
    }

    private fun hideEmptyView() {
        view?.run {
            findViewById&lt;View&gt;(R.id.empty).visibility = View.GONE
            findViewById&lt;View&gt;(R.id.content).visibility = View.VISIBLE
        }
    }



    private fun initContentViews() {
        val textWatcher = object : TextWatcher by TextWatcherAdapter {

            override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {
                // hiding the floating action button if text is empty
                if (s.isEmpty()) {
                    doneFab?.hide()
                }
            }

            // showing the floating action button if avatar is selected and input data is valid
            override fun afterTextChanged(s: Editable) {
                if (isAvatarSelected() &amp;&amp; isInputDataValid()) doneFab?.show()
            }
        }

        firstNameView?.addTextChangedListener(textWatcher)
        lastInitialView?.addTextChangedListener(textWatcher)
        doneFab?.setOnClickListener {
            if (it.id == R.id.done) {
                var first = firstNameView?.text?.toString()
                var last = lastInitialView?.text?.toString()

                //
                try {
                    a.adduser(first,last,"string")

                }
                catch (e:Exception) {
                    // handler
                }



                activity?.run {
                    val toSave = player?.apply {
                        // either update the existing player object




                        firstName = first
                        lastInitial = last
                        avatar = selectedAvatar

                        a.adduser(first,last,avatar.toString())
                    } ?: Player(first, last, selectedAvatar) /* or create a new one */

                    login.savePlayer(this, toSave) {
                        Log.d(TAG, "Saving login info successful.")
                    }
                }
            }
            removeDoneFab {
                performSignInWithTransition(selectedAvatarView
                        ?: avatarGrid?.getChildAt(selectedAvatar!!.ordinal))
            }
        }
    }

    private fun removeDoneFab(endAction: () -&gt; Unit) {
        ViewCompat.animate(doneFab)
                .scaleX(0f)
                .scaleY(0f)
                .setInterpolator(FastOutSlowInInterpolator())
                .withEndAction(endAction)
                .start()
    }

    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    private fun performSignInWithTransition(v: View? = null) {
        if (v == null || ApiLevelHelper.isLowerThan(Build.VERSION_CODES.LOLLIPOP)) {
            // Don't run a transition if the passed view is null
            activity?.run {
                navigateToCategoryActivity()
            }
            return
        }

        if (ApiLevelHelper.isAtLeast(Build.VERSION_CODES.LOLLIPOP)) {
            activity?.run {
                window.sharedElementExitTransition.addListener(object :
                        Transition.TransitionListener by TransitionListenerAdapter {
                    override fun onTransitionEnd(transition: Transition) {
                        finish()
                    }
                })

                val pairs = TransitionHelper.createSafeTransitionParticipants(this, true,
                        Pair(v, getString(R.string.transition_avatar)))
                val options = ActivityOptionsCompat.makeSceneTransitionAnimation(this, *pairs)
                ActivityLaunchHelper.launchCategorySelection(this, options)
            }
        }
    }

    private fun initContents() {
        player?.run {
            valid().let {
                firstNameView?.setText(firstName)
                lastInitialView?.setText(lastInitial)
                avatar?.run { selectAvatar(this) }
            }
        }
    }

    private fun isAvatarSelected() = selectedAvatarView != null || selectedAvatar != null

    private fun selectAvatar(avatar: Avatar) {
        selectedAvatar = avatar
        avatarGrid?.run {
            requestFocusFromTouch()
            setItemChecked(avatar.ordinal, true)
        }
        showFab()
    }

    private fun showFab() {
        if (isInputDataValid()) doneFab?.show()
    }

    private fun isInputDataValid() =
            firstNameView?.text?.isNotEmpty() == true &amp;&amp;
                    lastInitialView?.text?.isNotEmpty() == true &amp;&amp;
                    selectedAvatar != null

    companion object {

        private const val ARG_EDIT = "EDIT"
        private const val KEY_SELECTED_AVATAR_INDEX = "selectedAvatarIndex"

        fun newInstance(edit: Boolean = false): SignInFragment {
            return SignInFragment().apply {
                arguments = Bundle().apply {
                    putBoolean(ARG_EDIT, edit)
                }
            }
        }
    }
}

when()
String
Int
Int
String
String
when()
val ids: List&lt;String&gt; = listOf("a", "b", "c")
val ints: Map&lt;String, Int?&gt; = mapOf("a" to 1, "b" to 2, "c" to null)

ids.map { id: String -&gt;
    Pair(id, ints[id])
}.filter { pair -&gt; pair.second != null}.map { pair: Pair&lt;String, Int&gt; -&gt;
    func(id, pair.second)  
}

Type inference failed: Cannot infer type parameter T in 
                       inline fun &lt;T, R&gt; kotlin.collections.Iterable&lt;T&gt;.map ( transform (T) -&gt; R ): kotlin.collections.List&lt;R&gt;

Iterable&lt;Pair&lt;String, Int?&gt;&gt;
Iterable&lt;Pair&lt;String, Int&gt;&gt;
filter
class di&lt;T&gt;(crea:T){
    var h:T=crea
    init{
        println("your class is ready")
    }
    fun diplay:&lt;T&gt;{
        return h
     }
}
fun main (args:Array&lt;String&gt;){
    var he2 =di&lt;Int&gt;(23)
    println(he.diplay())

}

Warning:(30, 14) Kotlin: Parameter 'args' is never used
Warning:(32, 9) Kotlin: Unreachable code

data class Person(
        val id: Int,
        val name: String
) {

    fun main(args: Array&lt;String&gt;) {
        val person = Person(1, "Nikolay")
        println("my name is ${person.name}")
    }
}

data class Person(
        val id: Int,
        val name: String,
        val gender: Int,
        val father: Int,
        val mother: Int,
        val children: List&lt;Int&gt;,
        val email: String,
        val homepage: String,
        val date_of_birth: String,
        val date_of_death: String,
        val is_living: Boolean,
        val place_of_birth: String,
        val place_of_death: String,
        val cemetery: String,
        val schools: List&lt;String&gt;,
        val jobs: List&lt;String&gt;,
        val work_places: String,
        val places_of_living: String,
        val general: String,
        val default_picture: String
)

fun main(args: Array&lt;String&gt;) {
     val person =Person(1, "Nikolay", 1, 10, 11, listOf(2), "mi@ya.ru", 
                        "mishin.narod.ru", "07.02.1976",
                        "", true, "Moscow", "", "", listOf("780", "MIIT"), 
                        listOf("luxoft", "lotus domino"), 
                        "Nagornaya", "Buninskaya Alleya", "perl and kotlin programmer", "")
    println("my name is ${person.name}")
}

abstract class A {

   init {
       initStuff()
   }

   fun initStuff() {
       additionalInit()
   }

   abstract fun additionalInit()
}

class B(val exParam: Int): A {

    init {
       println("$exParam") // This would give expected value.
    }

    override fun additionalInit() {
       println("$exParam") // Always zero even if exParam value is set.
    }
}

B(1000)
println
1000
val sum = fun Int.(other: Int): Int = this + other

1.sum(2)

sum(1, 2)

class TestExample {
      object Bell {
       fun  add(){

       }
   }

 Class B{
  TestExample.Bell.add()
}

class TestExample {
      companion object Bell {
       fun  add(){

       }
   }



Class B{
TestExample.add()
 }

apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'

android {
    compileSdkVersion 23
    buildToolsVersion "24.0.0 rc2"

    defaultConfig {
        applicationId "package.name"
        minSdkVersion 16
        targetSdkVersion 23
        versionCode 6
        versionName "2.0"
    }

    buildTypes {
        debug {
            minifyEnabled false
            signingConfig signingConfigs.debug
        }
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release
        }
    }
    sourceSets {
        main.java.srcDirs += 'src/main/kotlin'
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    testCompile 'junit:junit:4.12'
    compile "com.android.support:appcompat-v7:$support_version"
    compile "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"
    compile "org.jetbrains.anko:anko-sdk15:$anko_version"
    compile "org.jetbrains.anko:anko-support-v4:$anko_version"
    compile "com.android.support:recyclerview-v7:$support_version"
}

buildscript {
    ext.kotlin_version = '1.0.1-2'
    repositories {
        jcenter()
        mavenCentral()
    }
    dependencies {
        classpath "org.jetbrains.kotlin:kotlin-android-extensions:$kotlin_version"
    }
}
repositories {
    mavenCentral()
}

buildscript {
    ext.support_version = '23.2.1'
    ext.kotlin_version = '1.0.1'
    ext.anko_version = '0.8.3'
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:2.1.0-alpha3'
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

toMap(): MutableMap&lt;String, Any&gt;
fun add(key: String, value: Any): MutableMap&lt;String, Any&gt; {
    val map = asMap()
    map.put(key, value)
    return map
}

fun add(key: String, value: Any): MutableMap&lt;String, Any&gt;
    = asMap().magicPut(key, value)

asMap()
add
toMap()
asMap()
kotlinc create &lt;project_name&gt;

context
private lateinit var context: Context

fun context(appContext: Context) = apply {
    context = appContext
}

fun build(): MySdk {
    // this::context fails to compile because it cannot differentiate between the 
    // method `context()` vs property `context`
    require(this::context.isInitialized) {
        "context == null"
    }

::context.isInitialized
context()
context
const val myAngle = Math.toRadians(45.0)

Math.toRadians
const val myAngle = 45.0 / 180.0 * Math.PI

const val myAngle = Math.PI / 2 // 45.0 degrees

Math.toRadians
onView(withId(R.id.recyclerView)).perform(RecyclerViewActions.scrollTo(
    hasDescendant(withText(artistResult.getNameVariations().get(0)))));

onView(withId(R.id.recyclerView)).perform(RecyclerViewActions.scrollTo(
    hasDescendant(withText(artistResult.nameVariations[0]))))

Error:(63, 71) Type inference failed: Not enough information to infer parameter VH in fun &lt;VH : RecyclerView.ViewHolder!&gt; scrollTo(itemViewMatcher: Matcher&lt;View!&gt;!): RecyclerViewActions.PositionableRecyclerViewAction!
Please specify it explicitly.

val str = "hearty"
val arr = str.toCharArray()
println(arr.sort())

.split("")
.sort()
var heights = arrayOf(1,2,3,4,2,3,4)
var sortedHeights = heights.copyOf()
sortedHeights.sort()

for (i in 0..heights.size-1)
{
    println(sortedHeights[i])
}

var heights = arrayOf(1,2,3,4,2,3,4)
var sortedHeights = heights.copyOf().sort()

for (i in 0..heights.size-1)
{
    println(sortedHeights[i])
}

open class Payment(val amount: Int) 

class ChequePayment : Payment { 
    constructor(amount: Int, name: String, bankId: String) :  super(amount) { 
        this.name = name
        this.bankId = bankId 
    }

    var name: String
        get() = this.name
    var bankId: String
        get()  = this.bankId
} 


val c = ChequePayment(3, "me", "ABC")    
println("${c} ${c.amount} ${c.name}")

$ kotlinc -script class.kts 2&gt;&amp;1 | more
java.lang.StackOverflowError
    at Class$ChequePayment.getName(class.kts:10)
    at Class$ChequePayment.getName(class.kts:10)
    at Class$ChequePayment.getName(class.kts:10)

kotlin
fun main(args: Array&lt;String&gt;) {
    val generatePrimeFrom2 = generateSequence(3){ it + 2 }
    print(generatePrimeFrom2.toList().take(10))
}

take(10).toList()
print
fun main(args: Array&lt;String&gt;) {
    val generatePrimeFrom2 = generateSequence(3){ it + 2 }
    print(generatePrimeFrom2.take(10).toList())
}

class A{
    var name="Java"
    var age=26
    var gender="male"
    var address=Address()
}
class Address{
    var street ="Bakers street"
    var building = "221B"
    var city="London"
}

val actualA = A(
  actualA.apply {
            name="Kotlin"
           address.apply {
               street="No street"
               building="No building"
               city="Just another city"
           }
        }

package kt.notsamepackage_another

class NotSamePackageKotlin {

    fun call() {
    }
}

add
val elements = mutableListOf&lt;Int&gt;()

Flux.just(1, 2, 3, 4)
    .log()
    .subscribe(elements::add)

.subscribe({ elements.add(it) })
elements::add
 var delegatedProp: (Int) -&gt; Unit by Delegates.observable({ a-&gt; Unit }) { _, _, newVal -&gt;
        //This is never raised
        //Secondly how should I access the given Int ?
        //newVal.a doesn't seem to compile
    }

abstract class Animal(var name: String, var age: Int, var mother: Animal, 
                      var father: Animal, var friends: ArrayList&lt;Animal&gt;)

class Cat : Animal()

fun main(args: Array&lt;String&gt;) {
    var app = App()
    app.fibonacci(8, object : Process {
        override fun execute(value: Int) {
            println(value)
        }
    })
}

interface Process {
    fun execute(value: Int)
}

class App {
    fun fibonacci(limit: Int, action: Process) {
        var prev = 0
        var prevprev = 0
        var current = 1

        for (i: Int in 1..limit) {
            action.execute(current)

            var temp = current
            prevprev = prev
            prev = temp
            current = prev + prevprev
        }
    }
}

Exception in thread "main" java.lang.NoSuchMethodError: App.fibonacci(ILProcess;)V
    at HigherlevelKt.main(higherlevel.kt:3)

enum class Foo {
    BAR,
    BAZ { fun qux(foo: Any) {} }
}

qux()
val foo = Foo.BAZ
foo.qux("blah")

qux()
val list = listOf("one", "two", "2", "three")

"two"
"2"
list.filter {
  it in listOf("two", "2") // but that creates a new list every time... (didn't check though)
}

// extracting the list first, uses more code... and may hide the list somewhere sooner or later
val toCheck = listOf("two", "2")
list.filter { it in toCheck } 

// similar, but probably less readable due to naming ;-)
list.filter(toCheck::contains)

// alternative using when, but that's not easier for this specific case and definitely longer:
list.filter {
    when (it) {
        "two", "2" -&gt; true
        else -&gt; false
    } 
}

// probably one of the simplest... but not so nice, if we need to check more then 2 values
list.filter { it == "two" || it == "2" }

list.filter { it in ("two", "2") }
listOf("anything", "some", "other").filter { it in listOf("anything") }
listOf("anything")
Map
.filterKeys
list.filterNot { it in listOf("two", "2") }
?:
val list = mutableList ?: mutableListOf() 

val list = if (mutableList != null) mutableList else mutableListOf()

class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        setSupportActionBar(toolbar)

        var testUnit: TestUnit? = TestUnit()
        testUnit = null
    }
}

class TestUnit : TestSetup() {
    init {
        addTest("Add Numbers").setTestToRunSync {
            // Does creating this lambda function
            // keep the TestUnit class resident in memory?
            var x = 0
            x++
        }
    }
}

object TestRepository {
    val tests: MutableList&lt;TestInfo&gt; = mutableListOf()

    fun addTest(testName: String): TestInfo {
        val test = TestInfo(testName)
        tests.add(test)
        return test
    }

    fun getAllTests(): MutableList&lt;TestInfo&gt; {
        return tests
    }
}

open class TestSetup {
    fun addTest(testName: String): TestInfo {
        return TestRepository.addTest(testName)
    }
}

class TestInfo(private val name: String) {
    var testName: String = name

    private var testToRunSync: (suspend () -&gt; Unit)? = null

    fun setTestToRunSync(testToRun: suspend () -&gt; Unit): TestInfo {
        this.testToRunSync = testToRun
        return this
    }
}

Account
Account::class
Account::class.java
Account.javaClass
Account::javaClass

F#
Kotlin
//namespace SysIO

open System.Collections.Generic  // for Dictionary

printf "Hi, Let's start \n"

let series = [|30;21;29;31;40;48;53;47;37;39;31;29;17;9;20;24;27;35;41;38;
          27;31;27;26;21;13;21;18;33;35;40;36;22;24;21;20;17;14;17;19;
          26;29;40;31;20;24;18;26;17;9;17;21;28;32;46;33;23;28;22;27;
          18;8;17;21;31;34;44;38;31;30;26;32|]

let initialSeasonalComponents (series : int []) slen : IDictionary&lt;int, double&gt;  =
    let nSeasons = float  (series.Length / slen)
    let grouped = 
        series 
            |&gt; Array.map float 
            |&gt; Array.chunkBySize slen
    let seasonAverages = grouped |&gt; Array.map Array.average
    Array.init slen (fun i -&gt; i, (Array.zip grouped seasonAverages 
                                    |&gt; Array.fold (fun s (els, av) -&gt; els.[i] + s - av) 0.)
                                        / nSeasons) |&gt; dict

printfn "Seasons Averageß: \n %A" (initialSeasonalComponents series 12)

let initialTrend (series : int []) (slen : int) : double =
     series |&gt; Array.windowed slen
            |&gt; Array.fold (fun s x -&gt; 
                            (x |&gt; Array.rev |&gt; Array.head) -  (x |&gt; Array.head) + s) 0
            |&gt; float
            |&gt; fun x -&gt; x / (float slen)

printfn "Initial Trend: \n %A" (initialTrend series 12)

let tripleExponentialSmoothing series slen alpha beta gamma nPreds =
    let mutable smooth = 0.
    let mutable trend = 0.
    let seasonals = initialSeasonalComponents series 12 |&gt; Dictionary 
    seq {
        for i in 0..(series.Length+nPreds-1) do
          match i with
          | 0 -&gt;     // initial values        
              smooth &lt;- series |&gt; Array.head |&gt; float
              trend &lt;- initialTrend series slen
              yield series |&gt; Array.head |&gt; float
          | i when i &gt;= series.Length -&gt; // we are forecasting
              let m = i - series.Length + 1
              yield (smooth + float m * trend) + seasonals.[i%slen]
          | _ -&gt; 
              let v = series |&gt; Array.head  |&gt; float
              let lastSmooth = smooth
              smooth &lt;- alpha*(v-seasonals.Item(i%slen)) + (1.-alpha)*(smooth+trend)
              trend &lt;- beta * (smooth-lastSmooth) + (1.-beta)*trend
              seasonals.[i%slen] &lt;- gamma*(v-smooth) + (1.-gamma)*seasonals.[i%slen]
              yield smooth + trend + seasonals.Item(i%slen) }
   // result

let f = tripleExponentialSmoothing series 12 0.716 0.029 0.993 24
printfn "Forecast: \n %A" f

interface AuthApiService {
    @FormUrlEncoded
    @POST("api/auth/login")
    fun postLogin(@Field("username") username: String, @Field("password") password: String):
            io.reactivex.Observable&lt;LoginApiResponse&gt;

    companion object Factory {
        fun create(): AuthApiService {
            val gson = GsonBuilder().setLenient().create()

            val retrofit = Retrofit.Builder()
                    .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
                    .addConverterFactory(GsonConverterFactory.create(gson))
                    .baseUrl("http:192.168.24.188:8080")
                    .build()
            return retrofit.create(AuthApiService::class.java)
        }
    }
}


interface BBBApiService {
    companion object Factory {
        fun create(): BBBApiService {
            val gson = GsonBuilder().setLenient().create()

            val retrofit = Retrofit.Builder()
                    .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
                    .addConverterFactory(GsonConverterFactory.create(gson))
                    .baseUrl("http:192.168.24.188:8080")
                    .build()
            return retrofit.create(BBBApiService::class.java)
        }
    }
}

interface ApiFactory {
    companion object {
        inline fun &lt;reified T&gt;createRetrofit(): T {
            val gson = GsonBuilder().setLenient().create()

            val retrofit = Retrofit.Builder()
                    .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
                    .addConverterFactory(GsonConverterFactory.create(gson))
                    .baseUrl("http://192.168.24.188:8080")
                    .build()

            return retrofit.create(T::class.java)
        }


    }
}

interface AuthApiService {
    @FormUrlEncoded
    @POST("api/auth/login")
    fun postLogin(@Field("username") username: String, @Field("password") password: String):
            io.reactivex.Observable&lt;LoginApiResponse&gt;

    companion object Factory {
        fun create(): AuthApiService {
            return ApiFactory.createRetrofit()
        }
    }

fun &lt;T&gt; doSum(a: T, b: T) : T {
    val result : Number = when {
        a is Int &amp;&amp; b is Int -&gt; a + b
        a is Long &amp;&amp; b is Long -&gt; a + b
        a is Float &amp;&amp; b is Float -&gt; a + b
        a is Double &amp;&amp; b is Double -&gt; a + b
        else -&gt; throw IllegalArgumentException() 

    @Suppress("UNCHECKED_CAST")
    return result as T
}

fun &lt;T: Number&gt; doOperation(a: T, b: T, operationToPerform: (T, T) -&gt; T ) {
    println(operationToPerform(a, b))
}

fun main(args: Array&lt;String&gt;) {
    doOperation (2, 3, doSum)
}

Error:(15, 24) Kotlin: Function invocation 'doSum(...)' expected
Error:(15, 24) Kotlin: No value passed for parameter 'a'
Error:(15, 24) Kotlin: No value passed for parameter 'b'

State
CircularModel
class MainActivity : AppCompatActivity(), ViewMVC {

    private lateinit var presenter: Presenter
    private lateinit var model : Model

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        model = if(savedInstanceState == null ) { CircularModel(LinkedList&lt;State&gt;(Arrays.asList(
                State("First"),
                State("Second"),
                State("Third"),
                State("Fourth"),
                State("Fifth")

        )))
        } else {
            savedInstanceState.getParcelable&lt;Model&gt;("model")
        }
        presenter = PresenterImpl(this, model)
    }
    // Rest of Viewer's code...
}

CirciularModel
@Parcelize
@Parcelize
class CircularModel constructor(var states: @RawValue Deque&lt;State&gt;?) : Model, Parcelable {
    ...
}

Model
Model?
private lateinit var model : Model?
lateinit
interface IB {}
interface IC : IB {}

open class A {}
open class B : A() {}
open class C : B(), IC {}

fun main(args: Array&lt;String&gt;) {
  if (B::class == B::class) { println("B class is equal to B class") }
  if (IB::class == IB::class) { println("IB interface is equal to IB interface") }

  if (A::class ??? B::class) { println("A class is parent of B class") }
  if (A::class ??? C::class) { println("A class is superclass of C class") }

  if (C::class ??? IC) { println("C class is implement IC interface") }
  if (IC ??? IB) { println("IC interface is implement IB interface") }
}

?.let {}
fun convertAnswer(userAnswer: AnswerGson, answerResponse: AnswerResponseGson,
                  correctAnswerText: String): AnswerResponseUi? {
    return userAnswer.id?.let { userAnswerId -&gt;
        userAnswer.text?.let { userAnswerText -&gt;
            answerResponse.answer?.id?.let { correctAnswerId -&gt;
                answerResponse.points?.let { points -&gt;
                    answerResponse.discount?.let { discount -&gt;
                        answerResponse.booster?.let { booster -&gt;
                            return AnswerResponseUi(userAnswerId, correctAnswerId, userAnswerText,
                                    correctAnswerText, points, discount, booster.name ?: "")
                        }
                    }
                }
            }
        }
    }
}

package robokt.measurement

abstract class Measurement : Number() {
    /**
     * The abbreviation for this unit of measurement
     */
    abstract val units: String
    /**
     * The abbreviation for this unit of measurement
     */
    abstract val value: Number
}

unaryMinus()
package robokt.measurement.length

class Inches(override val value: Number) : Length() {
    override fun toCentimeters() = Centimeters(toDouble() * 2.54)

    override fun toFeet() = Feet(toDouble() / 12)

    override fun toInches() = this

    override fun toMeters() = Meters(toDouble() * 0.0254)

    override val units: String = "in"
}

-Inches(5)
Inches(-5)
-Degrees(30)
Degrees(-30)
  private fun handleSignInResult(result: GoogleSignInResult) {
    if (result.isSuccess) {
        val account = result.signInAccount
        idToken = account!!.idToken
        name = account.displayName
        email = account.email

        // you can store user data to SharedPreference
        val credential = GoogleAuthProvider.getCredential(idToken, null)
        firebaseAuthWithGoogle(credential)
    } else {
        // Google Sign In failed, update UI appropriately
        Log.e(TAG, "Login Unsuccessful. $result")
        CustomProgressDialog.HideProgressDialog()
        Toast.makeText(this, "Login Unsuccessful", Toast.LENGTH_SHORT).show()
    }

when_assert_no_else {
    CONDITION0 -&gt; {
        doSomething0()
    }
    CONDITION1 -&gt; {
        doSomething1()
    }
}

when {
    CONDITION0 -&gt; {
        doSomething0()
    }
    CONDITION1 -&gt; {
        doSomething1()
    }
    else -&gt; {
        throw RuntimeException()
    }
}

else
when
when_assert_no_else
fun doSomething(): List&lt;String&gt; {

    val test: List&lt;*&gt; = arrayListOf("test1", "test2")

    return test as List&lt;String&gt;
}

@SuppressWarnings("unchecked")
impl
impl
expect
interface Attachable
class Image: Attachable

val attachableList = listOf&lt;Attachable&gt;(Image(),Image(),Image())

var imageList = arrayListOf&lt;Image&gt;().addAll(attachableList)
// Error: Type mismatch. Required: Collection&lt;Image&gt;, Found: List&lt;Attachable&gt;

val imageList = arrayListOf&lt;Image&gt;().apply{addAll(attachableList.map{it as Image})}

createDummyString(1,'A') = 'A'
createDummyString(2.'A') = 'AA'

A
B: A
val a: Stream&lt;A&gt;

val b: Stream&lt;B&gt; = a.filter { it is B }
                    .map { it as B }

identity
def identity[A](x: A): A

{ it }
identity
identity
(Foo) -&gt; Foo
Foo
//TODO: use this to make the below classes generic?
sealed class AsyncResult{
  object InFlight : AsyncResult()
  data class Error(val errorMessage: String) : AsyncResult()
  data class Loaded&lt;out T&gt;(val users: T) : AsyncResult()
}

sealed class UserDataAppResult : AppResult() {
  object InFlight : UserDataAppResult()
  data class Error(val errorMessage: String) : UserDataAppResult()
  data class Loaded(val users: List&lt;User&gt;) : UserDataAppResult()
}

sealed class CreateUserResult : AppResult() {
  object InFlight : CreateUserResult()
  data class Error(val errorMessage: String) : CreateUserResult()
  data class Loaded(val users: User) : CreateUserResult()
}

sealed class AsyncResult{
  class InFlight : AsyncResult()
  data class Error(val errorMessage: String) : AsyncResult()
  data class Loaded&lt;out T&gt;(val users: T) : AsyncResult()
}

sealed class UserDataAppResult : AsyncResult()
sealed class CreateUserResult : AppResult()

val activeUsers: Flowable&lt;UserDataAppResult&gt; = appDatabase.userDao().getActiveUsers(appSettings.currentLanguage.ordinal)
    .map&lt;UserDataAppResult&gt; { UserDataAppResult.Loaded(it) }
    .onErrorReturn { UserDataAppResult.Error(it.localizedMessage) }
    .startWith(UserDataAppResult.InFlight)
    .observeOn(AndroidSchedulers.mainThread())
    .share()

fun createUser(): Flowable&lt;CreateUserResult&gt; {

  val userId = UUID.randomUUID().toString()
  val user = User()
  user.id = userId
  return appDatabase.userDao().insertAll(user)
      .map &lt;CreateUserResult&gt; { CreateUserResult.Loaded(user) }
      .onErrorReturn { CreateUserResult.Error(it.localizedMessage) }
      .startWith(CreateUserResult.InFlight)
}

insteadOf("search", "forest|ground") {
    println("Do something.");
}

call: () -&gt; Unit

insteadOf("search", "forest|ground", object : World.InsteadOf.Do {
     override fun invoke() {
          println("Do something")
     }
})

Exception in thread "main" com.esotericsoftware.kryo.KryoException: Class cannot be created (missing no-arg constructor): fi.starstuff.rogue.World$insteadOf$1
    This is an anonymous class, which is not serializable by default in Kryo. Possible solutions: 1. Remove uses of anonymous classes, including double brace initialization, from the containing class. This is the safest solution, as anonymous classes don't have predictable names for serialization.
    2. Register a FieldSerializer for the containing class and call FieldSerializer#setIgnoreSyntheticFields(false) on it. This is not safe but may be sufficient temporarily. Use at your own risk.
Serialization trace:
call (com.mygame.World$InsteadOf)
insteadOfs (com.mygame.World)
    at com.esotericsoftware.kryo.Kryo$DefaultInstantiatorStrategy.newInstantiatorOf(Kryo.java:1319)
    at com.esotericsoftware.kryo.Kryo.newInstantiator(Kryo.java:1127)
    at com.esotericsoftware.kryo.Kryo.newInstance(Kryo.java:1136)

class InsteadOf {
        var verbs: Array&lt;String&gt; = arrayOf()
        var nouns: Array&lt;String&gt; = arrayOf()
        var where: String = ""
        var call: (() -&gt; Unit)? = null
    }

imageView.setTag(R.id.TAG_ID, id)
imageView.setTag(R.id.TAG_PATH, path)

imageView.tag = null

imageView.tag?.let { //it: Any
    id = imageView.getTag(ID).toString()
    path = imageView.getTag(PATH).toString()
}

it
tag
null
setTag(R.id, value)
tag = null
imageView.tag?.let
with
forEach
with
forEach
fun main(args: Array&lt;String&gt;) : Unit {
    val l = listOf(listOf(1,2,3), listOf(4,5,6))
    val t = label@ with(l) {
        get(0).forEach {
            return@label 2
        }
    }
    println(t)
}

Base
Impl
Base
package mypackage

open class Base
class Impl : Base()

Impl
Base
class Test {
    private val myType = Impl()
        get():Base
}

public class Test {
    private Impl myImpl = new Impl();

    public Base getBase() {
        return myImpl;
    }
}

var value: Any?

value.toString().toInt() // works

FATAL EXCEPTION: main
java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer

  fun test ():Int {

        colors?.let { colorsArrayList -&gt;

            color1 = colorsArrayList.getOrNull(0)?.let {
                return if (HexColorValidator().validate(it)) {
                    Color.parseColor(it)
                } else {
                    Color.parseColor("#8DE7C1")
                }
            } ?: kotlin.run {
                return Color.parseColor("#8DE7C1")
            }

        } ?: run {
            return Color.parseColor("#8DE7C1")
        }

        return Color.parseColor("#8DE7C1")
    }
}

return Color.parseColor("#8DE7C1")

class A
class B {
    val property: A
        get() = A()
}

fun main(args: Array&lt;String&gt;) {
    val b = B()
    println(b.property)
    println(b.property)
}

A
B.property
Student (Id, Code, FirstName, LastName, Age, Birthday)` 

NewStudent(FirstName, LastName, Age)

map
filter
sortedWith(compareBy(String.CASE_INSENSITIVE_ORDER, { it.lastName })

it.lastName
it.firstName
Queue
var queue: Queue&lt;Int&gt; = Queue()

data class House(var name: String = "House", var door: Door = Door())
data class Door(var name: String = "Door")

fun test() {
   val testHouse = House("My house", Door(name = "My door"))
}

   val houseDoorName = House::door::name
   println(houseDoorName.get(testHouse)) //My door

House::door.nested(Door::name)
operator  infix fun  List&lt;Teacher&gt;.get(int: Int): Teacher {
    var t = Teacher()
    t.name = "asd"
    return t ;
}

b[0].teachers[1].name

Empty list doesn't contain element at index 1.
    var i = 1

    if(i  &lt; 5)
     button.setOnClickListener{
        i++
     }

{
"Response": "Success",
"Message": "Coin list succesfully returned!",
"BaseImageUrl": "https://www.cryptocompare.com",
"BaseLinkUrl": "https://www.cryptocompare.com",
"Data": {
    "LTC": {
        "Id": "3808",
        "Url": "/coins/ltc/overview",
        "ImageUrl": "/media/19782/ltc.png",
        "Name": "LTC",
        "CoinName": "Litecoin",
        "FullName": "Litecoin (LTC)",
        "Algorithm": "Scrypt",
        "ProofType": "PoW",
        "SortOrder": "2"
    }
    ...
},
"Type": 100

data
data class Data(@Json(name = "Data") val cryptoCoinMap: Map&lt;String, CryptoCoin&gt;)

CryptoCoin
RecyclerView
List
Map
CryptoCoin
Data
List
Map
var cryptoCoinList = mutableListOf&lt;CryptoCoin&gt;()
    coinRepository
            .getCoinList()
            .concatMapIterable { t: CryptoCoinList -&gt; t.data.cryptoCoinMap.toList() }
            .map { t: Pair&lt;String, CryptoCoin&gt; -&gt; cryptoCoinList.add(t.second) }
            // INSERT TRANSFORMATION HERE
            .observeOn(AndroidSchedulers.mainThread())
            .subscribeBy(onNext = {
                coinListData.postValue(it.second)
            })

fun &lt;A&gt; test(obj: X) where A: Class1, A: Interface1 {
}

fun testFunction(obj: Any) {
     if (obj is Class1 &amp;&amp; obj is Interface1) {
         // how to do this now??? smart casting is not working
         test(obj) // not working, compiler error
     }
}

obj
Class1
Interface1
val allColours = arrayOf(
    Pair(Color.RED, Color.WHITE), 
    Pair(Color.RED, Color.BLACK), 
    Pair(Color.YELLOW, Color.BLACK), 
    Pair(Color.GREEN, Color.WHITE), 
    Pair(Color.BLUE, Color.WHITE), 
    Pair(Color.BLUE, Color.WHITE), 
    Pair(Color.CYAN, Color.BLACK), 
    Pair(Color.WHITE, Color.BLACK))

pegColours
var pegColours: Array&lt;Pair&lt;Color,Color&gt;&gt; = //???

allColours.take
@author
@since
javadoc/kdoc
kotlin
@author
@since
fun main(args: Array&lt;String&gt;) {
    multipleCalls()
    wontCompile()
}

fun multipleCalls(){
    val arr = intArrayOf(1,2,3)
    val list = arr.filter{
        it.heavyLogic() != null
    }.map{
        it.heavyLogic()    //heavyLogic() called again
    }
    print(list)
}

fun wontCompile(){
    val arr = intArrayOf(1,2,3)
    val list = arr.map{
        val str = it.heavyLogic()
        if(str == null) continue //break and continue are only allowed inside a loop
        else str
    }
    print(list)
}

wontCompile()
map
null
list
List&lt;String?&gt;
filter
null
enum class Gender {
    Female,
    Male
}

Gender.Female

fun main() {
val myPhone = Myphone()
myPhone.phoneOn()
myPhone.onClick()
myPhone.onTouch()
myPhone.openApp()
myPhone.closeApp()
myPhone.brightMax()
myPhone.Something1.something()

}
interface Application {
    var appName: String
    var x1: Int

    fun something()

    fun brightMax() {
        println("Brightness level is on Max!")
    }

    fun openApp() {
        println("$appName is opening!")
    }

    fun phoneOn() {
        println("The phone is ON")
    }

    fun onClick() {
        println("App is running")
    }

    fun closeApp() {
        println("${Myphone.Something1.appName} App is closed!")
    }
}

interface Button {
    val x: Int
    var helloMessage: String

    fun brightMax() {
        println("Brightness is on $x")
    }

    fun phoneOn() {
        println("Power on button was pressed!")
    }

    fun onClick()

    fun onTouch() {
        println("The screen was touched!")
    }
}



class Myphone: Button, Application {
    override fun something() {
        println("Doing something")
    }

    object Something1 : Application {
        override var x1: Int = 100
        override var appName: String = "Instagram"
        override fun something() {
            println("He wants to die!")
        }

    }

    override var x1: Int = 12
    override var appName: String = "Facebook"
    override var x: Int = 100

    override fun phoneOn() {
        super&lt;Application&gt;.phoneOn()
    }

    override fun brightMax() {
        super&lt;Application&gt;.brightMax()
        super&lt;Button&gt;.brightMax()
    }
    override var helloMessage: String = "Hello"

    override fun onClick() {
         super.onClick()
    }
}

val k = " asdfasdf "
fun test() {
    if(k is String) {
     // Do something
    }
}

fun test(xxxx) {
    if(k is xxxx) {
    // do something
    }
}

open class TestClass {
    open inner class Back {
        open fun dd() { }
    }
}

class Manager: TestClass() {
    private val test = object : Back() {
        override fun dd() { }
    }
}

abstract class A(){
  init {
    println("Hello")
  }     
}

class B(): A()

fun main(args: Array&lt;String&gt;){
  B()
}

Hello
class SomeClass {
    init {
        someVar = 123  // Variable cannot be initialized before declaration 
    }
    var someVar : Int
        set(value) {
            field = value
        }

}

class SomeClass2 {
    var someVar : Int  // Property must be initialized  
        set(value) {
            field = value
        }
    init {
        someVar = 123
    }
}

class SomeClass3 {
    var someVar : Int = 123 // No errors here
        set(value) {
            field = value
        }
}

private fun getMonth(monthText: String): Int {
    var x = arrayOf("january", "february", "jumper").indexOf(monthText)

    if (x &gt;= 0)
        return x

    x = arrayOf("Januari", "Februari", "Maret").indexOf(monthText)

    if (x &gt;= 0)
        return x

    throw Exception("Not found")

}

@Rule @publicField val temp = TemporaryFolder()
@publicField
@publicField
lateinit
lateinit val
data class Person(name: String)

val person = Person().apply {
    name = "Tony Stark" 
}

map
mapNumber.map{ it.key }

map
val numbersInt = mapNumbers.map{ it.key }
val numbersStr = mapNumbers.map{ it.value }

fun main(args: Array&lt;String&gt;) {
    val mapNumbers = mapOf(Pair(1, "one"), Pair(2, "two"), Pair(3, "three"))

    val numbersInt = mutableListOf&lt;Int&gt;()
    val numbersStr = mutableListOf&lt;String&gt;()

    for ((key, value) in mapNumbers) {
        numbersInt.add(key)
        numbersStr.add(value)
    }

    print(numbersInt)
    print(numbersStr)   
}

mutableListOf
public class A {
    public interface I {
        public void f();
    }

    public I i;
}

public class B extends A {}

fun main(args: Array&lt;String&gt;) {
    A().i = B.I {}
}

Exception in thread "main" java.lang.NoSuchMethodError: B.I(Lkotlin/jvm/functions/Function0;)LA$I;
        at MainKt.main(Main.kt:2)

I
B
A
A.I
B
I
I
class C: B {
    constructor() {
        this.i = I {}
    }
}

Caused by: java.lang.NoSuchMethodError: No static method OnFocusChangeListener(Lkotlin/jvm/functions/Function2;)Landroid/view/View$OnFocusChangeListener; in class Landroid/widget/LinearLayout; or its super classes (declaration of 'android.widget.LinearLayout' appears in /system/framework/framework.jar:classes2.dex)

Class&lt;? extends Event&gt;
Class.forName(eventClass) as Class&lt;Event&gt; // The as should cast to Class extending Event

var type: Type

List&lt;UserInfo&gt;

var type = UserInfo::class.java

var type = Array&lt;UserInfo&gt;::class.java

var l=Array&lt;ArrayList&lt;Int&gt;()&gt;(5){};

val myHashMap: HashMap&lt;key, ValueClass&gt;

data class ValueClass(
    var a: Long = 0,
    var b: Long = 0
)

    if(!myHashMap.containsKey("x"))
    {
        map.put("x",new ValueClass());
    }
    map.get("x").a=newValue;

fun main(args: Array&lt;String&gt;) {

    val (two, three) = nextTwo(1) // Unresolved reference: nextTwo
    println("1, $two, $three")

    fun nextTwo(num: Int) : Pair&lt;Int, Int&gt; {
        return Pair(num+1, num+10)
    }

}

class StylingAndroidTextClassifier(
        private val context: Context,
        private val fallback: TextClassifier,
        private val factory: TextClassifierFactory = FrameworkFactory()
) : TextClassifier by fallback {

    private val stylingAndroid = "Styling Android"
    private val stylingAndroidUri = "https://blog.stylingandroid.com"
    private val regex = Regex("Styling\\s?Android", RegexOption.IGNORE_CASE)

    override fun suggestSelection(request: TextSelection.Request): TextSelection {
        return fallback.suggestSelection(request)

    }

    override fun classifyText(request: TextClassification.Request): TextClassification {
        return fallback.classifyText(request)
    }
}

 @SuppressLint("NewApi")
    override fun suggestSelection(request: TextSelection.Request): TextSelection {
        return suggestSelection(request)
       // return fallback.suggestSelection(request)
    }

FunctionImpl
invoke
{ (s: String): Int -&gt; s.length }

// is translated to

object : FunctionImpl(), Function1&lt;String, Int&gt; {
    override fun getArity(): Int = 1

    /* bridge */ fun invoke(p1: Any?): Any? = ...
    override fun invoke(p1: String): Int = p1.length
}

fun invoke(p1: Any?): Any?
Object invoke(Object p1)
import java.util.*

fun caseName(br: String, c: Int): String {
  if (c == 0) {
    return br.toLowerCase()
    } else {
    return br.toUpperCase()
    }
}
fun mapIt(ns: ArrayList&lt;String&gt;, f: (String, Int) -&gt; String): List&lt;String&gt; {
  val coll: List&lt;String&gt; = ns.map {it -&gt; f(it, _)}
  return coll
}

fun main(args: Array&lt;String&gt;) {
  val names = arrayListOf("Joe", "Bill", "Murrary")
  val cased = mapIt(names, (::caseName)(_, 0))
  println(cased.first())
}

mapIt
data class Borrower(val name: String, val maxBooks: Int) {
    companion object {

        fun getName(br: Borrower, c: Int): String {
          if (c == 0) {
            return br.name.toLowerCase()
            } else {
            return br.name.toUpperCase()
            }
        }

        fun findBorrower(n: String, brs: ArrayList&lt;Borrower&gt;, f: (Borrower) -&gt; String): Borrower? {
            val coll: List&lt;Borrower&gt; = brs.filter { it -&gt; f(it) == n }
            if (coll.isEmpty()) {
                return null
            } else return coll.first()
        }
    }
}

fun main(args: Array&lt;String&gt;) {
    val br1 = Borrower(name = "Borrower1", maxBooks = 1)
    val br2 = Borrower(name = "Borrower2", maxBooks = 2)
    val br3 = Borrower(name = "Borrower3", maxBooks = 3)
    val br4 = Borrower(name = "borrower4", maxBooks = 4)
    val br5 = Borrower(name = "BORROWER5", maxBooks = 5)
    val brs1 = arrayListOf(br1, br2, br3, br4, br5)

    val c = Borrower.findBorrower("borrower3", brs1, {Borrower.Companion::getName(it, 0)})
    println(c)
}

(T1,T2,..,Tn) -&gt; R
Function[n]&lt;T1,T2,..,Tn,R&gt;
tailrec fun passHeaders (xH: List&lt;Int&gt;) 
{
    while (xH.isNotEmpty())
    {
        passHeaders(xH.drop(1))
    }
}

interface A {
    fun test()
}
class B: A {
    override fun test() {
        println("test")
    }
}
class C: A by B() {
    override fun test() {
        // ??? how to get a reference to B's test() method? 
    }
}

post { req -&gt;
    with(req.objectBody&lt;Person&gt;()) {
        logger.info { "Attempt to save person $this" }
        with(require&lt;SessionFactory&gt;().openSession()) {
            save(this@with)
        }
    }
}

there is more than one label with such a name
save(this@with)

with(req.objectBody&lt;Person&gt;)
Person
class Person(val name: String, val age: Int)

Parent
val (name, age) = Person("name", 22)

Context
Problem
Response
class Response&lt;T&gt; {

    var data: T? = null
    var dataArray: List&lt;T&gt;? = null
    var errors: List&lt;String&gt;? = null
        get() {
            if (field == null) {
                this.errors = ArrayList()
            }
            return field
        }
}

API Controllers
val response = Response()
response.setData(someting)

Not enough information to infer parameter T
    if (subsriber?.isUnsubscribed &amp;&amp; isDataEmpty()) {
        loadData()
    }

    if (subsriber?.isUnsubscribed as Boolean &amp;&amp; isDataEmpty()) {
        loadData()
    }

kotlin 1.2.60

data class HeadDisk(var size: Float,
                    var manufacturer: Manufacturer)

data class Computer(var speed: Float = 0F,
                    var screenSize: Float = 0F,
                    var hardDisk: HeadDisk = HeadDisk())

data class Computer(var speed: Float = 0F,
                    var screenSize: Float = 0F,
                    var hardDisk: HeadDisk? = null)

data class Computer(var speed: Float = 0F,
                    var screenSize: Float = 0F) {

    var hardDisk: HeadDisk by Delegates.notNull()
}

data class Person(
    val id: UUID? = null,
    val name: String,
    val address: String?
)

    val familyId: UUID? = null,
    val pList: List&lt;Person&gt;

pList
copy()
family.pList.forEach {
    it.copy(address = ‘I am getting this value from a map’ )
}

if (variable != null) {
   doSomething(variable)
}

variable?.let { doSometing(it) }

if (variable != null) {
   doSomething(variable)
} else {
   doOtherThing()
}

    for (i in 0 until x - 1) {
        // Do something.
    }

i
i
class A(val i: Int)
sealed class S {
    class A(val i: Int)
}

fun &lt;T&gt; f(g: (Int) -&gt; T) = Unit

fun test() {
    f(::A)   // OK
    f(::S.A) // error: Unresolved reference A
}

val forecast = listOf(30, 21, 29, 31, 40, 48, 53, 47, 37, 39, 31, 29)
val actual = listOf(27, 31, 27, 26, 21, 13, 21, 18, 33, 35, 40, 36)

forecast-actual
var errors: MutableList&lt;Double&gt; = mutableListOf&lt;Double&gt;()

actual
      .forEachIndexed { index, d -&gt;  forecast[index] - d}
      .let { i -&gt; errors.add(i) }

i
forEachIndexed
Unit
Double
val input = arrayOf('b', 'b', 'c', 'd', 'e', 'e', 'e')

val output = groupOrSplit(input) // ['bb', 'c', 'd', 'eee']

val
private var _score: Int=0
val score: Int = _score
   get() = _score

list.filterIfNotEmpty(module) { it.name.contains(module!!, ignoreCase = true) }
    .filterIfNotEmpty(repoUrl) { it.repo.contains(repoUrl!!, ignoreCase = true) }
    .filterIfNotEmpty(owner) { it.owner.contains(owner!!, ignoreCase = true) }

fun &lt;T&gt; List&lt;T&gt;.filterIfNotEmpty(value: String?, predicate: (T) -&gt; Boolean): List&lt;T&gt; {
  return when {
    value.isNullOrBlank() -&gt; this
    else -&gt; filterTo(ArrayList&lt;T&gt;(), predicate)
  }
}

!!
list.filterIfCriteriaNotEmpty(module) { it.name }
    .filterIfCriteriaNotEmpty(repoUrl) { it.repo }
    .filterIfCriteriaNotEmpty(owner) { it.owner }

fun &lt;T&gt; List&lt;T&gt;.filterIfCriteriaNotEmpty(filter: String?, stringProducer: (T) -&gt; String): List&lt;T&gt; {
  return when {
    filter == null || filter.isBlank() -&gt; this
    else -&gt; this.filter { stringProducer(it).contains(filter, ignoreCase = true) }
  }
}

open class Base(val name: String) {

  init { println("Initializing Base") }

  open val size: Int = name.length.also { println("Initializing size in Base: $it") }
}

class Derived(
    name: String,
    val lastName: String
  ) : Base(name.capitalize().also { println("Argument for Base: $it") }) {

  init { println("Initializing Derived") }

  override val size: Int =
    (super.size + lastName.length).also { println("Initializing size in Derived: $it") }
}

fun main(args: Array&lt;String&gt;) {
  println("Constructing Derived(\"hello\", \"world\")")
  val d = Derived("hello", "world")
}

Constructing Derived("hello", "world")
Argument for Base: Hello
Initializing Base
Initializing size in Base: 5
Initializing Derived
Initializing size in Derived: 10
override val size: Int = (super.size + lastName.length).also { println("Initializing size in Derived: $it") }
Initializing size in Base: 5
Constructing Derived("hello", "world")
Argument for Base: Hello
Initializing Base
Initializing size in Base: 5
Initializing Derived
Initializing size in Base: 5 // Print because .also is called again ?
Initializing size in Derived: 10

class Mapped(var data:Map&lt;String,String&gt;){
    val firstName:String by data
}

Mapped
val mapped = Mapped(mapOf("firstName" to "initialFirstName"))
println(mapped.firstName); // prints "initialFirstName"

data
mapped.data = mapOf("firstName" to "updated");

firstName
"initialFirstName"
   fun getDiffWeek(year1: Int, month1: Int): Int {
        return getDiffWeek(year1, month1, 1)
    }

    fun getDiffWeek(year1: Int, month1: Int, day1: Int): Int {
        val calendar = GregorianCalendar.getInstance() as GregorianCalendar
        calendar.set(Calendar.YEAR, year1)
        calendar.set(Calendar.MONTH, month1 - 1)
        calendar.set(Calendar.DAY_OF_MONTH, day1)
        calendar.set(Calendar.HOUR_OF_DAY, 0)
        calendar.set(Calendar.MINUTE, 0)
        calendar.set(Calendar.SECOND, 0)
        calendar.set(Calendar.MILLISECOND, 0)

        val currCalendar = GregorianCalendar.getInstance() as GregorianCalendar
        currCalendar.timeInMillis = System.currentTimeMillis()
        currCalendar.set(Calendar.HOUR_OF_DAY, 0)
        currCalendar.set(Calendar.MINUTE, 0)
        currCalendar.set(Calendar.SECOND, 0)
        currCalendar.set(Calendar.MILLISECOND, 0)

        val diffTime = calendar.timeInMillis - currCalendar.timeInMillis
        return if (diffTime &lt; 0) {
            -1
        } else Math.ceil(diffTime / ONE_WEEK.toDouble()).toInt()

    }

fun foo(): String = "Hello World"

var foobar: String = "Hello Word"

(x, y)
y
[(3, 0), (3, 1), (5, 1)]
[(5, 0), (3, 1), (5, 1)]
[(1, 1), (3, 1), (5, 1)]
[(3, 0), (4, 0), (5, 1)]
[(5, 0), (4, 0), (5, 1)]
[(1, 1), (4, 0), (5, 1)]
[(3, 0), (3, 1), (5, 1)]
[(5, 0), (3, 1), (5, 1)]
[(1, 1), (3, 1), (5, 1)]

y = 0
fun tmp() = 1
fun tmp() = "" 

class Test&lt;T&gt;(a: T)
fun Test&lt;String&gt;.myFun() = Test(1)
fun Test&lt;Int&gt;.myFun() = Test("")

class Test&lt;T&gt;
fun Test&lt;String&gt;.myFun() = 1
fun Test&lt;Int&gt;.myFun() = ""

fun main() {

    val enginerName = mutableListOf("Mark", "Bill", "Jeff")
    val website = mutableListOf("Facebook","Microsoft","Amazone")
    val google = mutableMapOf(enginerName to website)

}

{
      'Question 1': 'Do you ...?',
      'answers': [
        {'text': 'Not at all', 'score': 0},
        {'text': 'Partly', 'score': 50},
        {'text': 'Mostly', 'score': 280},
        {'text': 'Completely', 'score': 500},
      ],
    },

Iterable
Sequence
asIterable()
asSequence()
Iterable
Sequence
...
import static org.mockito.Mockito.verify;
...
class FoobarTest {
     ...
     @Test public void testFoo() {
          verify(mock).doSomething();
     } 
}

Mockito.verify(mock).doSomething()
inline fun &lt;A, B, C&gt; Pair&lt;A, B&gt;.notNull(code: (A, B) -&gt; C) {
    if (this.first != null &amp;&amp; this.second != null) {
        code(this.first, this.second)
    }
}

Pair(username, password).notNull { user, pass -&gt; 
    // code to execute when username and password is not null
}

?.
inline fun &lt;C&gt; Pair&lt;Editable?, Editable?&gt;.notNull(code: (Editable, Editable) -&gt; C) {
    if (this.first != null &amp;&amp; this.second != null) {
        code(this.first!!, this.second!!)
    }
}

kotlinc sample.kt -include-runtime -d sample.jar

fun main(args: Array&lt;String&gt;){
      var a : Int
      a = getLength("Hello")
      println("length of word is $a")
  }

  fun getLength(word : Any) : Int? {
      if (word !is String) return null
      return word.length
  }

Kotlin version 1.2.21-release-88 (JRE 1.7.0_79-b15)
alist
A { 
  val b : Int
  val c1 : Int
  val c2 : Int
  val d1 : Int
  val d2 : Int
}

b
c1+c2
d1+d2
elist
E {
  val sum_of_c_types : Int
  val sum_of_d_types : Int
}

reduce
public class Common {
    public static ModelPengguna currentModelPengguna;
}

interface I
class A(i: I)
class C : I, A(this) // &lt;&lt; --- 'this' is not defined in this context

interface Pilot {
   fun informAboutObstacle()
}

abstract class Car(private val pilot: Pilot) {
    fun drive() {
        while (true) {
            // ....
            if (haveObstacleDetected()) {
                pilot.informAboutObstacle()
            }
            // ....
        }
    }
    fun break() {
        // stop the car
    }
}

class AutopilotCar : Pilot, Car(this) { // For example, Tesla :)
    override fun informAboutObstacle() {
        break() // stop the car
    }
}

class Pizza(name: String?) : Serializable {
    var name: String? by Delegates.observable(name, {_,_,_ -&gt; })
}

Caused by: java.io.NotSerializableException: com.xxx.xxx.Pizza$$special$$inlined$observable$1

data class Node(val ID : Long, val name : String)

0000 : A : 0
0001 : B : 1
0002 : C : 2
0003 : D : 2
0004 : E : 1
0005 : F : 2
0006 : G : 1
0007 : H : 1
0008 : I : 2

Map&lt;Node, Set&lt;Node&gt;&gt;
A - B - C
      - D
  - E - F
  - G
  - H - I

[1,2,3,4,5]
array = [1,2,3,4,5]
print(" ".join (str(n*n) for n in array))

Class&lt;Long&gt;
getDeclaredMethod
it.javaClass.getDeclaredMethod("myMethodName", Long.javaClass)

Long.javaClass
Class&lt;Long.companion&gt;
data class PlayerRegistration(
    @field: Email
    val email: String,
    @field: Pattern(regexp = NICK_REGEX)
    @field: Size(min = 5, max = 15)
    val nick: String,
    @field: Pattern(regexp = PASSWORD_REGEX)
    @field: Size(min = 8, max = 20)
    val password: String,
    val birthDate: LocalDate
)

data class PlayerRegistration(
    @field: Email
    val email: String,
    @field: ValidNick
    val nick: String,
    @field: ValidPassword
    val password: String,
    val birthDate: LocalDate
)

@Pattern(regexp = NICK_REGEX)
@Size(min = 5, max = 15)
@Target(AnnotationTarget.FIELD)
private annotation class ValidNick

@Pattern(regexp = EMAIL_REGEX)
@Size(min = 8, max = 20)
@Target(AnnotationTarget.FIELD)
private annotation class ValidPassword

io.jsonwebtoken.Claims
val claims = jwtUtil.getAllClaimsFromToken(authToken)
val rolesMap = claims.get("role", ArrayList::class.java)
val roles = ArrayList&lt;Role&gt;()
for (rolemap in rolesMap) {
    roles.add(Role.valueOf((rolemap as LinkedHashMap&lt;String, String&gt;)["authority"] as String))
}

String
class Test (
    val param1 : Long,
    val param2 : Long
)

class EqualityExpr&lt;T: Any&gt; (
    val lhs : KProperty&lt;T&gt;,
    val rhs : KProperty&lt;T&gt;
)

infix fun &lt;T: Any&gt; KProperty&lt;T&gt;.equals(KProperty&lt;T&gt; rhs) : EqualityExpr&lt;T&gt; {
    return EqualityExpr(this, rhs)
}

Test::param1 equals Test::param2
class Test (
    val param1 : Long?,
    val param2 : Long?
)

KProperty&lt;*&gt;
private fun invokeMethod(parameterTypes: Array&lt;Class&lt;*&gt;&gt;?, parameters: Array&lt;Any&gt;?, methodName: String?): Card? {
        try {
            //val method = javaClass.getDeclaredMethod(methodName, parameterTypes)
            for (x in parameterTypes!!) println("Parameter Types: $x")
            if (parameters != null) {
                for (x in parameters) print("Parameters: $x")
            }
            val method = javaClass.getDeclaredMethod(methodName, *parameterTypes)
            return method.invoke(this, parameters) as Card
        } catch (e: Exception) {
            println("Class Error ${e.message}")
        }

        return null
    }

val method = javaClass.getDeclaredMethod(methodName, *parameterTypes)

Test obj = new Test(); 
Class cls = obj.getClass();
cls.getDeclaredMethod("method2", int.class)

lazy
data class Geocode(var latitude: Double, var longitude: Double) : Comparable&lt;Geocode&gt; {


    override fun compareTo(other: Geocode): Int {
        var result = this.latitude.compareTo(other.latitude)
        if (result == 0)
            result = this.longitude.compareTo(other.longitude)
        return result
    }
}

data class HubKt(val position:Geocode) {
}

data class Example(val hubs:Collection&lt;HubKt&gt;) {

    val bounds:Any by lazy {
        object {
            val ne: this.hubs.map { h -&gt; h.position }.max()
            val sw: this.hubs.map { h -&gt; h.position }.min()
        }

    }
}

bounds
public Map&lt;String,Geocode&gt; getBounds() {
        Geocode ne = geos.stream().max(Geocode::compareTo).get();
        Geocode sw = geos.stream().min(Geocode::compareTo).get();
        return ImmutableMap.of("ne",ne,"sw",sw);
}

this
this@Authenticate
kotlin 1.2.71

android {
      compileSdkVersion 26
      buildToolsVersion "28.0.3"
}

it
infix fun Android.buildToolsVersion(...)
fun main(args: Array&lt;String&gt;) {

    val androidConfig = android {
        it buildToolsVersion  "28.0.3"
        it compileSdkVersion 26
    }

    println(androidConfig.toConsolePrint)
}

private fun android(block: Android.(Android) -&gt; Unit): Android {
    val android = Android()

    android.block(android)

    return android
}

class Android(var compileSdkVersion: Int = 0,
              var buildToolsVersion: String = "") {

    infix fun Android.buildToolsVersion(buildToolsVersion: String) {
        this.buildToolsVersion = buildToolsVersion
    }

    infix fun Android.compileSdkVersion(sdkVersion: Int) {
        compileSdkVersion = sdkVersion
    }
}

private val Android.toConsolePrint: String
    get() {
        return "compileSDK: $compileSdkVersion build tools: $buildToolsVersion"
    }

class Foo {
    fun bar() {}
}

bar
Foo::bar

class Foo {
    fun &lt;T&gt; bar() {}
}

fun Foo.barOfInt() = bar&lt;Int&gt;()

Foo::barOfInt

KClass&lt;*&gt;
fun KClass&lt;*&gt;.getGenericFunction(name: String): KFunction&lt;*&gt; {
    return members.single { it.name == name } as KFunction&lt;*&gt;
}

Foo::class.getGenericFunction("bar")

[TestEntity(applicationId=1, timestamp=2018-01-24T18:40:30, issueState=MA, product=test, status=sold, paymentMode=VISA, premium=null)]
Single&lt;List&lt;LocationData&gt;&gt;
override fun getDestinations(): Single&lt;List&lt;LocationData&gt;&gt; {
  //return ???
}

LocationData
@Parcelize
data class LocationData(val latitude: Double, val longitude: Double) : Parcelable

List
LocationData
public ArrayList&lt;LocationData&gt; getDestinations(){
  ArrayList&lt;LocationData&gt; data = new ArrayList&lt;&gt;();
  LocationData location1 = new LocationData( 43.21123, 32.67643 );
  LocationData location2 = new LocationData( 32.67643, 43.21123 );
  data.add( location1 );
  data.add( location2 );
  return data;
}

object CommonUtil {
    fun Int.dp(): Int = (this / Resources.getSystem().displayMetrics.density).toInt()
    fun Int.px(): Int = (this * Resources.getSystem().displayMetrics.density).toInt()
}

fun test() {
    10.dp()
}

CommonUtil.10.dp()
if (firstUnread == 0) {
    return
}

btn_login.setOnClickListener {
            val login = input_email.text.trim()
            val pass = input_password.text.trim()

            if( login.equals( pass ) ){
                startActivity&lt;MainActivity&gt;()
            }

            if (login?.equals(other = pass)){
                startActivity&lt;MainActivity&gt;()
            }

            if (login == pass){
                startActivity&lt;MainActivity&gt;()
            }

        }

fun main(args:Array&lt;String&gt;){
    var allByDefault:Int?
}

actual
actual
expect
package org.jetbrains.foo

expect class Foo(bar: String) {
    fun frob()
}

fun main(args: Array&lt;String&gt;) {
    Foo("Hello").frob()
}

package org.jetbrains.foo

actual class Foo actual constructor(val bar: String) {
    actual fun frob() {
        println("Frobbing the $bar")
    }
}

kotlinx.coroutines.experimental
launch
withContext
actual
expect
actual
expect
class XyzFragment : Fragment() {

    lateinit var adapter: ChatAdapter

    override fun onViewCreated(view: View?, savedInstanceState: Bundle?) {
        if (!::adapter.isInitialized) { &lt;-- This one
            adapter = ChatAdapter(this, arrayListOf())
        }
    }
}

::
if (!::adapter.isInitialized) {
object
interface Maker&lt;T : Thing&gt;

interface Thing

Thing
Maker
interface Thing {
    val maker: Maker&lt;this::class&gt; // ??
}

class BallMaker : Maker&lt;Ball&gt;

object Ball : Thing {
    override val maker = BallMaker
}

class AlternativeCustomerTwo(
    val name: String = "Name Not Provided",
    var age: Int? = null,
    var address: String = "Address not provided"
) 

var isApproved: Boolean = false

class AlternativeCustomerTwo(
    val name: String = "Name Not Provided",
    var age: Int? = null,
    var address: String = "Address not provided"
) {

   var isApproved: Boolean = false}

class AlternativeCustomerTwo(
    val name: String = "Name Not Provided",
    var age: Int? = null,
    var address: String = "Address not provided"
) { 
 var isApproved: Boolean = false
    set(value) {
            if(age &gt;= 21) {
                field = value
            }
    }
}

class AlternativeCustomerTwo(
    val name: String = "Name Not Provided",
    var age: Int? = null,
    var address: String = "Address not provided"
) {

   var isApproved: Boolean = false
    set(value) {
       age?.let {
           if(it &gt;= 21) {
               field = value
           }
       }
    }
}

val customer = AlternativeCustomerTwo(name = "John", age = 120)
customer.isApproved = true

val customer = AlternativeCustomerTwo(name = "John", age = 12)
    customer.isApproved = true

import
Companion
import Bar.toFoo
import Bar.Companion.toFoo
toFoo
Bar
class Bar {
  static Foo toFoo() {
    return new Foo();
  }
}

import Bar.toFoo;

// ...
    Bar().convert(toFoo()); // like a Java 8 Collector
// ...

Bar
class Bar {
  companion object {
    @JvmStatic fun toFoo() = Foo()
  }
}

import Bar.toFoo

import Bar.Companion.toFoo

class MyViewModel: ViewModel() {
    var progress: Int = 0
        set(value) = MathUtils.clamp(value, 0, 100)
}

Required: Unit but found: Int
abstract class BaseActivity&lt;VM : ViewModel&gt;(clazz: KClass&lt;VM&gt;) :
        AppCompatActivity() {

    @Inject
    protected lateinit var viewModelFactory: ViewModelProvider.Factory

    protected val viewModel  by lazy {
        ViewModelProviders
                .of(this, viewModelFactory).get(clazz.java)
    }
}

class MyActivity : BaseActivity&lt;MyViewModel&gt;(MyViewModel::class) {

    ...

    fun doSomething() {
     viewModel.someMethodSpecifToMyViewModel()
    }
}

abckey123
key
key
item.replaceBefore("key", "").replace("key", "")

item.split("key").last()

CS
kotlin.CharSequence
class CS  (val sequence: CharSequence = "") : CharSequence {
... override get/length in interface CharSequence 
    override fun equals(other: Any?): Boolean =
            (this === other) || ((other is String) &amp;&amp; this.sequence.equals(other))
}

CS("hello") == "hello"
CS("hello") == "hello" as Any
CS("hello").equals("hello")
Foo
Bar
"Foo"
Foo
Enum.Parse(...)
companion object {

        // For Singleton instantiation
        @Volatile
        private var instance: CarRepository? = null

        fun getInstance(carDao: CarDao) =
                instance ?: synchronized(this) {
                    instance ?: CarRepository(carDao).also { instance = it }
                }
    }

@Volatile
@Volatile
getInstance
instance ?: synchronized(this) {
    instance ?: CarRepository(carDao).also { instance = it }
}

Repository
"aws_acm_certificate_validation"

_
"aws" to "acm_certificate_validation"

MyIntList
java.util.AbstractList&lt;Int&gt;
AbstractList&lt;E&gt;
E remove(int index)
boolean remove(Object o)
class IntList() : AbstractList&lt;Int&gt;() {
    ....
    override fun remove(index: Int): Int {
        ....
    }
}

error: return type of 'remove' is not a subtype of the return type of the overridden member 'public open fun remove(element: kotlin.Int!): kotlin.Boolean defined in java.util.AbstractList'
    override fun remove(index: Int): Int {
E remove(int index)
remove(Int):Boolean
.this
MainActivity.this
'expression 'this' cannot be a selector(occur after a dot)'
interface Action1&lt;T&gt; {

    void call(T t);
}

interface Test&lt;T&gt; {

    void test(Action1&lt;? super T&gt; action)
}

interface A {
    fun go()
}

abstract class Main {

    abstract fun a(): Test&lt;out A&gt;

    fun main() {
        a().test(Action1 { it.go() })
        a().test { it.go() }
    }
}

main
it
Any?
A
out
Main
Test&lt;B&gt;
a()
B
A
class B : A {

    override fun go() {
        TODO()
    }
}

class MainImp : Main() {
    override fun a(): Test&lt;out A&gt; {
        val value: Test&lt;B&gt; = object : Test&lt;B&gt; {
            override fun test(action: Action1&lt;in B&gt;?) {
                TODO()
            }
        };

        return value
    }
}

import io.reactivex.Observable
import io.reactivex.functions.BiFunction
import java.util.concurrent.TimeUnit

    class ExpBackoff(
      private val jitter: Jitter,
      private val delay: Long,
      private val unit: TimeUnit,
      private val retries: Int = 0
    ) : Function&lt;Observable&lt;out Throwable&gt;, Observable&lt;Long&gt;&gt; {

      @Throws(Exception::class)
      override fun apply(observable: Observable&lt;out Throwable&gt;): Observable&lt;Long&gt; {
        return observable
            .zipWith(Observable.range(1, retries), BiFunction&lt;Throwable, Int, Int&gt; { _, retryCount -&gt;
              retryCount
            })
            .flatMap { attemptNumber -&gt; Observable.timer(getNewInterval(attemptNumber), unit) }
      }

      private fun getNewInterval(retryCount: Int): Long {
        var newInterval = (delay * Math.pow(retryCount.toDouble(), 2.0) * jitter.get()).toLong()
        if (newInterval &lt; 0) {
          newInterval = Long.MAX_VALUE
        }
        return newInterval
      }
    }

Function&lt;Observable&lt;out Throwable&gt;, Observable&lt;Long&gt;&gt;

       fun test() {
        bufferedReader.forEachLine {
            val nameParam = it.split(":")[0]
            if (name == "test")
                return // here i wan to return from function
        }
    }

fun main(args: Array&lt;String&gt;) {
    var itemList = "nice-lt,rice-pt"
    listOf(itemList)?.let {
        it.toString().split(",").forEach { line -&gt;
            {
                println(line)
            }
        }
    }
}

nice-rt
rice-se

Record
Record.size
interface Record {
    companion object{
        val size = 0
    }
}

Record
RecordA
RecordB
size
Record.size
fun find(key: Int) : DataItem {
    var hashValue = hashFunc(key)

    while (true) {
        if (hashArray[hashValue].key == key) {
            return hashArray[hashValue]
        } else {

        }
        ++hashValue
        hashValue %= arraySize
    }
}

BigDecimal(0.55).setScale(2, RoundingMode.FLOOR) //return 0.55
BigDecimal(0.56).setScale(2, RoundingMode.FLOOR) //return 0.56
BigDecimal(0.57).setScale(2, RoundingMode.FLOOR) //return 0.56
BigDecimal(**0.58**).setScale(2, RoundingMode.FLOOR) //return 0.57
BigDecimal(**0.59**).setScale(2, RoundingMode.FLOOR) //return 0.58
BigDecimal(**0.60**).setScale(2, RoundingMode.FLOOR) //return 0.59
BigDecimal(**0.61**).setScale(2, RoundingMode.FLOOR) //return 0.60
BigDecimal(**0.62**).setScale(2, RoundingMode.FLOOR) //return 0.61
BigDecimal(0.63).setScale(2, RoundingMode.FLOOR) //return 0.63

PsiTreeVisitor
fun test() {
    (1..10).forEach {
        println(it)
    }
}

forEach
IntRange
visitCallExpression
(1..10)
val dummyMap = mapOf (
    1 to 2,
    2 to 3
)

...

someByteArray[some index] = dummyMap[some value that can be only 1 or 2]

null
var arylst= arrayListOf&lt;String&gt;()
println("enter the elements of arraylist")

for(index in 0..arylst.size-1) {
arylst[index] = readLine()!!
if (arylst.contains("Ritika"))
println("element found")
else  
println("not found")

class StackX(size: Int) {
    private var maxSize: Int = size
    private var stackArray: Array&lt;Long&gt; = arrayOf(maxSize.toLong())
    private var top = -1

    fun push(data: Long) {
        stackArray[++top] = data
    }

    fun pop() : Long {
        return stackArray[top--]
    }

    fun peek() : Long {
        return stackArray[top]
    }

    fun isEmpty() : Boolean {
        return (top == -1)
    }

    fun isFull() : Boolean {
        return (top == maxSize -1)
    }
}

int a[] = new int[10];

data class Club(val name: String, val members: Int) {
fun isABigClub(code: Int.() -&gt; Boolean) : String {
        val isBig = code(this.members)
        return " Your club is a big club? ${isBig}"
    }
}

isABigClub
fun main() {
    val isBigClub = club.isABigClub { this &gt; 9 }
    println(isBigClub)

}

fun isTheBiggestClub(club: Int.(biggestClub: Int) -&gt; Boolean) : Boolean {
        return club(this.members, SOME_RECEIVED_VALUE )
    }

this &gt; 9
club.isTheBiggestClub { this(10) }
class Node(val next: Node?) {

    fun asSequence(): Sequence&lt;Node&gt; = sequence {
        var node: Node? = this@Node;
        while (node != null) {
            yield(node)
            node = node.next
        }
    }
}

Type inference failed. Expected type mismatch: inferred type is Sequence&lt;Node?&gt; but Sequence&lt;Node&gt; was expected

Sequence&lt;Node&gt;
Sequence&lt;Node?&gt;
yield()
yield(node)
yield(node!!)
yield(node as Node)
Unnecessary non-null assertion (!!) on a non-null receiver of type Node

Sequence&lt;Node&gt;
when (obj) {
    a == 1 -&gt; doAIsOne()
    a -&gt; doSomethingA()
    b -&gt; doSomethingB()
}

when (obj) {
    a -&gt; when(a) {
        1 -&gt; doAIsOne()
        else -&gt; doSomethingA()
    }
    b -&gt; doSomethingB()
}

Int
public class SomeAdapter(val friends: SomeAdapterProvider, val listener: OnItemClickedListener) : RecyclerView.Adapter&lt;SomeAdapter.ViewHolder&gt;() {

    trait OnItemClickedListener {
        fun onItemClicked(f: Friendship)
    }

    private inner class ViewHolder(v: View) : RecyclerView.ViewHolder(v), View.OnClickListener {
        override fun onClick(v: View) {
            listener.onItemClicked(somethings[getPosition()])
        }

        val text: TextView by inject(android.R.id.text1)
        val image: Picture by inject(R.id.imageview);

        {
            itemView setOnClickListener this
        }
    }

    {
        setHasStableIds(true)
    }
}

itemView setOnClickListener this
setHasStableIds(true)
BaseResponse
String
String.Companion
package com.touchsides.rxjavanetworking.network.model

import com.google.gson.annotations.SerializedName

class User: BaseResponse()
{

    @SerializedName("api_key")
    val apiKey = String

    fun getApiKey(): String
    {
        return  apiKey
    }
}

abstract class BaseResponse(var error: String?=null)
{


}

val List&lt;String?&gt; = listOf("Q", NULL, "W", "E", NULL, "E", "E", "R", "R", "T") [sic]

fun &lt;T : Any&gt; List&lt;T?&gt;.processList(action: (T) -&gt; T): List&lt;T&gt;

ListOf("Q", "W", "Egotcha", "E", "Rgotcha", "T")

val nL : ArrayList&lt;T&gt; = ArrayList&lt;T&gt;()
var indexThis : Int = 0
while ( indexThis &lt; intermediate.size-1 ) {
    if (intermediate[indexThis] != intermediate[indexThis + 1]) {
        nL.add(intermediate[indexThis]!!)
        indexThis += 1 }
    else {
        nL.add(processList(intermediate[indexThis]!!))
        indexThis += 2 }
}

 this.filter {a -&gt; a != null}

.map{b -&gt; b?.run{b ...  processList (b)}}

Any
val obj: Any = 123
val num: Int = obj as Int

Class&lt;Int&gt;
KClass&lt;Int&gt;
val obj: Any = 123
val kotlinClass = Int::class
val javaClass = Int::class.java

val num : Int = obj.castTo(kotlinClass)
val num2: Int = obj.castTo(javaClass)

val example = "package example\n" +
        "\n" +
        "fun main(args: Array&lt;String&gt;) {\n" +
        "    println(\"Hello World\")\n" +
        "}\n"

private fun updateImportantProperty(
    firstList: List&lt;MyObjectX&gt;?,
    secondList: List&lt;MyObjectX&gt;?
) {
    firstList?.forEach { item1 -&gt;
        secondList?.forEach { item2 -&gt;
            if (relatesInSomeWayToEachOther(item1, item2)) {
                item1.importantProperty = item2.importantProperty
            }
        }
    }
}

private class Person constructor(var name: String, var age: Int){
var profession: String = "Not mentioned"

init{
    println("$name's details are being held in this class object.")
}

constructor(name:String,age:Int, profession: String): this(name,age){
    this.profession = profession
}

fun printPersonDetails(){
    println("$name whose profession is $profession, is $age years old.")

}}

fun main(args: Array&lt;String&gt;){
val smith = Person("Smith",20)
smith.printPersonDetails()}

private class Person(val name:String, age:Int){

var age: Int = age
set(new_data){
    println("Setting age to $new_data")
    field  = new_data
}}

"${something}"
@Value("${some.property}) lateinit var foobar : String?

kotlin
.toFloat()
toInt()
val strDemo = "42.22"
val intDemo = strDemo.toInt()

NumberFormatException
val strDemo = "42.22"
val intDemo = strDemo.toFloat().toInt()

toFloat()
strDemo
Integer
val profile = loadProfiles()
profile.sortedWith(Comparator({ profile1, profile2 -&gt;
                if (profile1.age &gt; profile2.age) return@Comparator 1
                if (profile1.age &lt; profile2.age) return@Comparator -1
                return@Comparator 0
            }))

data class Developer(var age: Int)

fun loadProfiles(): List&lt;Developer&gt; {
    val listOfNumber = listOf&lt;Developer&gt;(Developer(2), Developer(5), Developer(3))

    return listOfNumber
}

    val jsonobj = JSONObject()

    loginBtn.setOnClickListener {

        jsonobj.put("mail", mailTxt.text)
        jsonobj.put("pass", passTxt.text)

        val que = Volley.newRequestQueue(this@MainActivity)
        val req = JsonObjectRequest(Request.Method.POST, url, jsonobj,
                Response.Listener{
                    response -&gt;
                    toast(response["error"].toString())

               }, Response.ErrorListener {
               toast("Error")
           })
        que.add(req)
      }
    }
  } 

val specials:Map&lt;String, (Any)-&gt;Unit&gt; = mapOf(
        "callMe1" to {asParam1()}, 
        "callMe2" to {asParam2()}
)

fun asParam1(num:Int) {
    println(num)
}

fun asParam2(text:String) {
    println(text)
}

fun caller() {
    specials["callMe1"]?.invoke("print me")
    specials["callMe2"]?.invoke(123)
}


fun main(args: Array&lt;String&gt;) {
    caller()
}

asParam1
asParam2
specials
Map
Group id-&gt; com.programming.kotlin

Artifact id-&gt;chapter01

Module name-&gt;chapter01

package-&gt;com.programming.kotlin.chapter01

class com.programming.kotlin.chapter01.Program2kt not found in module 'chapter01_main'

val name = "you"; println("Hello $name!")

tt.kts:1:19: error: unexpected tokens (use ';' to separate expressions on the same line)
val name = "you"; println("Hello $name!")
                  ^

[1, 2, 3, 4, 5, 6] =&gt; [[1, 2], [3, 4], [5, 6]]

swingElement.apply {
    minWidth = ENABLED_COLUMN_WIDTH
    maxWidth = ENABLED_COLUMN_WIDTH
    preferredWidth = ENABLED_COLUMN_WIDTH
}
with(swingElement) {
    minWidth = ENABLED_COLUMN_WIDTH
    maxWidth = ENABLED_COLUMN_WIDTH
    preferredWidth = ENABLED_COLUMN_WIDTH
}

fun createDate(day: Int, month: Int, year: Int, hour: Int = 0, minute: Int = 0, second: Int = 0) {
print("TEST", "$day-$month-$year $hour:$minute:$second")
}
createDate(1,7,1997)

error: none of the following functions can be called with the arguments supplied: 
@InlineOnly public inline fun print(message: Any?): Unit defined in kotlin.io
@InlineOnly public inline fun print(message: Boolean): Unit defined in kotlin.io
@InlineOnly public inline fun print(message: Byte): Unit defined in kotlin.io
@InlineOnly public inline fun print(message: Char): Unit defined in kotlin.io
@InlineOnly public inline fun print(message: CharArray): Unit defined in kotlin.io
@InlineOnly public inline fun print(message: Double): Unit defined in kotlin.io
@InlineOnly public inline fun print(message: Float): Unit defined in kotlin.io
@InlineOnly public inline fun print(message: Int): Unit defined in kotlin.io
@InlineOnly public inline fun print(message: Long): Unit defined in kotlin.io
@InlineOnly public inline fun print(message: Short): Unit defined in kotlin.io
print("TEST", "$day-$month-$year $hour:$minute:$second")

val array = arrayOf("abc","bcd","xyz","ghi","acd")

interface A {
    var name: String
}

interface B {
    var job: String
}

class C(
    override var name: String,
    override var job: String
) : A, B

class D() {
    private fun getList() {
        val list: List&lt;A&gt; = arrayListOf(
            C("user1", "job1"),
            C("user2", "job2"),
            C("user3", "job3")
        )
        // I want to init E() my constructor here 
    }
}

class E&lt;T&gt;(val list: List&lt;T&gt;) where T : A, T: B {
    fun display() {
        list.forEach {
            println("my name is ${list.get(i).name} and I am a ${list.get(i).job}")
        }
    }
}

var s = "20"
val myToast = Toast.makeText(this, s, Toast.LENGTH_SHORT)
myToast.show()
//20

val myToast2 = Toast.makeText(this, s.length, Toast.LENGTH_SHORT)
myToast2.show()
//The app crashes with the error: android.content.res.Resources$NotFoundException: String resource ID #0x2

kotlin
Command
Context
command.execute(JSONObject(jsonObj))
class AsyncService(val command: Command, val context: Context) {

    companion object {
        fun doGet(request: String) {
            doAsync {
                val jsonObj = java.net.URL(request).readText()
                command.execute(JSONObject(jsonObj))
            }
        }
    }
}

operator fun iterator()
Iterable
Iterable
operator fun iterator()
operator fun iterator()
Iterable
operator fun next()
operator fun hasNext()
Iterator
operator fun iterator()
Iterable
class Foo(val n: Int) {
    operator fun iterator() = FooIterator(this) 
    // Shouldn't the language figure out that Foo is iterable?
}

class FooIterator(val foo: Foo): Iterator&lt;Int&gt; {
    var seen = false
    // Implementation goes here
}

fun &lt;T&gt; printAll(iter: Iterable&lt;T&gt;) {
    for (x in iter) {
        println("$x")
    }
}

fun main() {
    printAll(Foo(2)) // Type mismatch: Foo is not Iterable
}

iterator()
next()
hasNext()
invoke
private Question[] questions = new Question[] {
    new Question(R.string.question_a, true)
    new Question(R.string.question_b, false)
};

public class Question {

  private int resultId;
  private boolean answerT;

  public Question(int resId, boolean theAnswer) {
    resultId = resId;
    answerT = theAnswer'
  }
}

class Question {
    private var resultId:Int  = 0
    private var answerT:Boolean = false

    fun Question(resId:Int, theAnswer:Boolean) {
        resultId = resId
        answerT = theAnswer
    }
}

....
private val questions:List&lt;Question&gt; {
    Question(R.string.question_a, true),
    Question(R.string.question_b, false)
}

x is String
Class.forName()
val x = "banana"
val specialClass = Class.forName("org.company.specialclass.at.runtime")

x is specialClass

object Auth {

     var mContext : Context ?= null

}

public static void initialize(@NonNull Activity activity, Settings... settings) {}

fun initialize(activity: Activity, vararg settings: settings) = JavaClass.initialize(activity, settings)

Settings
kotlin.Array&lt;out Settings&gt;
public static void initialize(@NonNull Activity activity, Settings settings) {}

public static void initialize(@NonNull Activity activity, Settings[] settings) {}

fun main(args: Array&lt;String&gt;) {
    val foo: String? = null
    val bar = "bar"

    println("__println(\"\$foo \$bar\")")
    println("$foo $bar")

    println("__println((if (foo != null) \"\$foo \" else \"\") + (if (bar != null) \"\$bar \" else \"\"))")
    println((if (foo != null) "$foo " else "") + (if (bar != null) "$bar " else ""))

    println("__println((\"\$foo \" ?: \"\") + (\"\$bar \" ?: \"\"))")
    println(("$foo " ?: "") + ("$bar " ?: ""))

    println("__println((foo ?: \"\") + (bar ?: \"\"))")
    println((foo ?: "") + (bar ?: ""))

    println("__println(foo + \" \" + bar)")
    println(foo + " " + bar)

    var string = ""
    if (foo != null) string += "$foo, "
    if (bar != null) string += "$bar"
    println("__println(string)")
    println(string)
}

__println("$foo $bar")
null bar
__println((if (foo != null) "$foo " else "") + (if (bar != null) "$bar " else ""))
bar 
__println(("$foo " ?: "") + ("$bar " ?: ""))
null bar 
__println((foo ?: "") + (bar ?: ""))
bar
__println(foo + " " + bar)
null bar
__println(string)
bar

class MainActivity : AppCompatActivity() {
private var REQUEST_CAMERA = 0
private var SELECT_FILE = 1
private var userChoosenTask: String? = null


override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)
    profileEdit.setOnClickListener {
        selectImage()
    }
}
private fun galleryIntent() {
    val intent = Intent()
    intent.action = Intent.ACTION_GET_CONTENT
    startActivityForResult(Intent.createChooser(intent, "Select File"), SELECT_FILE)
}

private fun cameraIntent() {
    val intent = Intent(MediaStore.ACTION_IMAGE_CAPTURE)
    startActivityForResult(intent, REQUEST_CAMERA)
}

for (arg in args)
    println(arg)

for (i in args.indices)
    println(args[i])

withIndex()
for ((index, value) in array.withIndex()) {
    println("the element at $index is $value")
}

filter
cur
numbersFrom
fun log(msg: String) = println("[${Thread.currentThread().name}] $msg")

fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; {
    var cur = numbersFrom(context, 2)
    for (i in 1..10) {
        val prime = cur.receive()
        println(prime)
        cur = filter(context, cur, prime)
    }
}

fun numbersFrom(context: CoroutineContext, start: Int) = produce&lt;Int&gt;(context) {
       var x = start
    while (true) {
        log("NumbersFrom Send: ${x}")
        send(x++)
    } // infinite stream of integers from start
}

fun filter(context: CoroutineContext, numbers: ReceiveChannel&lt;Int&gt;, prime: Int) = produce&lt;Int&gt;(context) {
    for (x in numbers) {
        log("filter ${x}, prime ${prime}")
        if (x % prime != 0) {
            send(x)
        }
    }
}

[main @coroutine#2] NumbersFrom Send: 2
[main @coroutine#2] NumbersFrom Send: 3
2
[main @coroutine#3] filter 3, prime 2
[main @coroutine#2] NumbersFrom Send: 4
[main @coroutine#2] NumbersFrom Send: 5
3
[main @coroutine#3] filter 4, prime 2
[main @coroutine#3] filter 5, prime 2
[main @coroutine#4] filter 5, prime 3
[main @coroutine#2] NumbersFrom Send: 6
[main @coroutine#3] filter 6, prime 2
5
[main @coroutine#2] NumbersFrom Send: 7
[main @coroutine#2] NumbersFrom Send: 8
[main @coroutine#3] filter 7, prime 2
[main @coroutine#3] filter 8, prime 2
[main @coroutine#4] filter 7, prime 3
[main @coroutine#2] NumbersFrom Send: 9
[main @coroutine#2] NumbersFrom Send: 10
[main @coroutine#5] filter 7, prime 5
[main @coroutine#3] filter 9, prime 2
[main @coroutine#3] filter 10, prime 2
7
[main @coroutine#4] filter 9, prime 3
[main @coroutine#2] NumbersFrom Send: 11
[main @coroutine#2] NumbersFrom Send: 12
[main @coroutine#3] filter 11, prime 2
[main @coroutine#3] filter 12, prime 2
[main @coroutine#4] filter 11, prime 3
[main @coroutine#2] NumbersFrom Send: 13
[main @coroutine#2] NumbersFrom Send: 14
[main @coroutine#5] filter 11, prime 5
[main @coroutine#3] filter 13, prime 2
[main @coroutine#3] filter 14, prime 2
[main @coroutine#6] filter 11, prime 7
[main @coroutine#4] filter 13, prime 3
[main @coroutine#2] NumbersFrom Send: 15
[main @coroutine#2] NumbersFrom Send: 16
11
[main @coroutine#5] filter 13, prime 5
[main @coroutine#3] filter 15, prime 2
[main @coroutine#3] filter 16, prime 2
[main @coroutine#6] filter 13, prime 7
[main @coroutine#4] filter 15, prime 3
[main @coroutine#2] NumbersFrom Send: 17
[main @coroutine#2] NumbersFrom Send: 18
[main @coroutine#7] filter 13, prime 11
[main @coroutine#3] filter 17, prime 2
[main @coroutine#3] filter 18, prime 2
13
[main @coroutine#4] filter 17, prime 3
[main @coroutine#2] NumbersFrom Send: 19
[main @coroutine#2] NumbersFrom Send: 20
[main @coroutine#5] filter 17, prime 5
[main @coroutine#3] filter 19, prime 2
[main @coroutine#3] filter 20, prime 2
[main @coroutine#6] filter 17, prime 7
[main @coroutine#4] filter 19, prime 3
[main @coroutine#2] NumbersFrom Send: 21
[main @coroutine#2] NumbersFrom Send: 22
[main @coroutine#7] filter 17, prime 11
[main @coroutine#5] filter 19, prime 5
[main @coroutine#3] filter 21, prime 2
[main @coroutine#3] filter 22, prime 2
[main @coroutine#8] filter 17, prime 13
[main @coroutine#6] filter 19, prime 7
[main @coroutine#4] filter 21, prime 3
[main @coroutine#2] NumbersFrom Send: 23
[main @coroutine#2] NumbersFrom Send: 24
17
[main @coroutine#7] filter 19, prime 11
[main @coroutine#3] filter 23, prime 2
[main @coroutine#3] filter 24, prime 2
[main @coroutine#8] filter 19, prime 13
[main @coroutine#4] filter 23, prime 3
[main @coroutine#2] NumbersFrom Send: 25
[main @coroutine#2] NumbersFrom Send: 26
[main @coroutine#9] filter 19, prime 17
[main @coroutine#5] filter 23, prime 5
[main @coroutine#3] filter 25, prime 2
[main @coroutine#3] filter 26, prime 2
19
[main @coroutine#6] filter 23, prime 7
[main @coroutine#4] filter 25, prime 3
[main @coroutine#2] NumbersFrom Send: 27
[main @coroutine#2] NumbersFrom Send: 28
[main @coroutine#7] filter 23, prime 11
[main @coroutine#5] filter 25, prime 5
[main @coroutine#3] filter 27, prime 2
[main @coroutine#3] filter 28, prime 2
[main @coroutine#8] filter 23, prime 13
[main @coroutine#4] filter 27, prime 3
[main @coroutine#2] NumbersFrom Send: 29
[main @coroutine#2] NumbersFrom Send: 30
[main @coroutine#9] filter 23, prime 17
[main @coroutine#3] filter 29, prime 2
[main @coroutine#3] filter 30, prime 2
[main @coroutine#10] filter 23, prime 19
[main @coroutine#4] filter 29, prime 3
[main @coroutine#2] NumbersFrom Send: 31
[main @coroutine#2] NumbersFrom Send: 32
23
[main @coroutine#5] filter 29, prime 5
[main @coroutine#3] filter 31, prime 2
[main @coroutine#3] filter 32, prime 2
[main @coroutine#6] filter 29, prime 7
[main @coroutine#4] filter 31, prime 3
[main @coroutine#2] NumbersFrom Send: 33
[main @coroutine#2] NumbersFrom Send: 34
[main @coroutine#7] filter 29, prime 11
[main @coroutine#5] filter 31, prime 5
[main @coroutine#3] filter 33, prime 2
[main @coroutine#3] filter 34, prime 2
[main @coroutine#8] filter 29, prime 13
[main @coroutine#6] filter 31, prime 7
[main @coroutine#4] filter 33, prime 3
[main @coroutine#2] NumbersFrom Send: 35
[main @coroutine#2] NumbersFrom Send: 36
[main @coroutine#9] filter 29, prime 17
[main @coroutine#7] filter 31, prime 11
[main @coroutine#3] filter 35, prime 2
[main @coroutine#3] filter 36, prime 2
[main @coroutine#10] filter 29, prime 19
[main @coroutine#8] filter 31, prime 13
[main @coroutine#4] filter 35, prime 3
[main @coroutine#2] NumbersFrom Send: 37
[main @coroutine#2] NumbersFrom Send: 38
[main @coroutine#11] filter 29, prime 23
[main @coroutine#9] filter 31, prime 17
[main @coroutine#5] filter 35, prime 5
[main @coroutine#3] filter 37, prime 2
[main @coroutine#3] filter 38, prime 2
29
[main @coroutine#10] filter 31, prime 19
[main @coroutine#4] filter 37, prime 3
[main @coroutine#2] NumbersFrom Send: 39

data class BgaResponse(val columnName: String, val restricted: Boolean, val predictionValue: Double)

val bgaResponse: List&lt;BgaResponse&gt;? = callBgaEndpoint(bgaRequest)

[{columnName=col1, restricted=false, predictionValue=0.9963}, {columnName=not_here, restricted=false, predictionValue=0.995941}]

bgaResponse?.forEach {
            println(it)
        }

for(i in 0 until bgaResponse!!.size) {
            println(bgaResponse[i])
        }

{columnName=col1, restricted=false, predictionValue=0.9963}
{columnName=not_here, restricted=false, predictionValue=0.995941}

bgaResponse[i].columnName
for(i in 0 until bgaResponse!!.size) {
            val x: BgaResponse= bgaResponse[i]
        }

org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to com.package.something.placeholder.model.BgaResponse

var array = arrayOf(1,2,3,4,5)

var list = listOf(1,2,3,4,5)

println(array[0]) // Outputs 1  
println(list[0]) // Outputs 1 

public &lt;T&gt; getMyProperty();

fun getMyProperty()

from zabbix_api import ZabbixAPI
zapi = ZabbixAPI(server="https://server/")
zapi.login("login", "password")
zapi.trigger.get({"expandExpression": "extend", "triggerids": range(0, 100)})

List
[a,1,b,2]
[(a,1),(b,2)]
zipWith
[(a,1),(1,b),(b,2)]
filter
Char.toInt()
class User{
   var name: String = "initial name"
}
class UserHolder{
   companion object{
      var INSTANCE: User
   }
}
class ClassA{
   fun doStuff(){
       val classB = ClassB(UserHolder.INSTANCE)
       classB.changeUser()
       val newName = UserHolder.INSTANCE.name // is it "initial name" or "My new name"?
   }
}
class ClassB(private val user: User){
   fun changeUser(){
       user.name = "My new name"
    }
}

//매게변수들 중 최대값을 구하는 함수를 작성하시오
fun whatIsTheMax(vararg factor: Int) {
    var famillyOfFactors = arrayOf(factor) //매게변수들(factor)을 저장하는 배열
    var Max = famillyOfFactors[0] //최대값은 위 변수의 첫 번째 값으로 초기화

    //만약 Max보다 famillyOfFactors[n]의 값이 더 크면 Max의 값이 famillyOfFactors[n]로 변함
    for (n in famillyOfFactors.indices) {
        if ((famillyOfFactors[n]) &gt; Max ) {
           //서로 비교 할 수 없는 타입임
           Max = famillyOfFactors[n]
        }
    }
}

val seq = sequenceOf("1")
val first = seq.firstOrNull()

Sequence&lt;T&gt;.firstOrNull
Stream&lt;T&gt;.firstOrNull
Sequence&lt;T&gt;
Stream&lt;T&gt;
Stream&lt;T&gt;
Sequence&lt;T&gt;
val seq = sequenceOf("1")
val first = seq.firstOrNull&lt;String?&gt;()

Stream&lt;T&gt;
val seq = sequenceOf("1")
val first = (seq as Stream&lt;String&gt;).firstOrNull()

kotlin
data class
data class MyModel (
    val key: String,
    val myValue: String
)

ArrayList
val myList: ArrayList&lt;MyModel&gt;

fun getPosition(key: String): Int = myList.indexOf(/* what to do here? */)

class MainActivityDataGenerator : ViewModel() {
    private lateinit var myRandomNumber : String

    fun getNumber(): String{
        Log.i(Tag, "Get Number")
        if (!::myRandomNumber.isInitialized){
            this.createNumber()
        }
        return myRandomNumber
    }

    fun createNumber(){
        Log.i(Tag, "create new Number")
        val  random = Random()

        myRandomNumber = " Number "+ (random.nextInt(10-1)+1)

    }

    companion object{
       private val  Tag : String = MainActivityDataGenerator::class.java.simpleName
    }


}

class NetworkManagerImpl : NetworkManager { }

protected class NetworkManagerImpl : NetworkManager { }

protected
file
fun &lt;A&gt; fourtyTwo(foo: A): Int = 42

val bar = listOf("candy", "chips", "drink").map(::fourtyTwo)

fourtyTwo

class Foo(private val whatever : Object = Object()) : BaseClass(whatever) {

    fun someFunction() {
        // Do something with "whatever"
        println(whatever.toString())
    }

}



class Foo() : BaseClass(whatever) {

    private val whatever = Object()

    fun someFunction() {
        // Do something with "whatever"
        println(whatever.toString())
    }

}


whatever
whatever
lateinit
class Test&lt;T&gt; {

   private lateinit var t : T

   private lateinit var s : String

}

Error:(7, 11) ''lateinit'' modifier is not allowed on nullable properties

T?
===
==
var str1 : String = "Hello World"
var str2 : String = "Hello World"

if( str1 == str2 ){ // yes
   print("Their contents are same\n")
{

if( str1 === str2 ){ // yes
   print("Their references are same\n")
}

class Foo {
    fun foo() = runBlocking {
        bar()
    }
}

inline suspend fun &lt;reified T&gt; T.bar() {
    coroutineScope {
        println(T::class.simpleName) // I want this to output 'Foo'
    }
}

public TargetTitleEntryController() { }

public &lt;T extends Controller &amp; TargetTitleEntryControllerListener&gt; TargetTitleEntryController(T targetController) {
        setTargetController(targetController);
}

class TargetTitleEntryController ()

class Test {

    @Test
    private fun printEmployeesInShipping(){
        val employeesByDepartment = getEmployeesByDepartment()
        for (department in employeesByDepartment) {
            if(department.get(0).department.equals("Shipping")){
                for (employee in department) println("Name:$employee")
            }
        }
    }

    private fun getEmployeesByDepartment(): List&lt;List&lt;Employee&gt;&gt;{
        val listOfEmployee = ArrayList&lt;Employee&gt;()
        listOfEmployee.add(Employee("Bob", "Shipping"))
        listOfEmployee.add(Employee("Stacy", "Shipping"))
        listOfEmployee.add(Employee("Tom", "Sales"))
        listOfEmployee.add(Employee("John", "Sales"))
        listOfEmployee.add(Employee("Jim", "Accounting"))
        listOfEmployee.add(Employee("Kim", "Accounting"))
        //What is the most efficient way to split this list into separate lists and return it

    }

}
data class Employee (
        val name: String? = null,
        val department:String? = null
) 

DATA: 30-11-19 

 private fun testDates() {
        val DATE_REGEXP = ".*?\\d{2}-\\d{2}-\\d{2}.*"
        val someText = "DATA: 30-11-19"
        if (DATE_REGEXP.toRegex().matches(someText)) {
            val replace = someText.replace(DATE_REGEXP.toRegex(), "$1");
            Debug.d(TAG, "testDates_replace = $replace")
        }
    }

01-14 18:50:29.862 E/AndroidRuntime(31161): Caused by: java.lang.reflect.InvocationTargetException
01-14 18:50:29.862 E/AndroidRuntime(31161):     at java.lang.reflect.Constructor.newInstance(Native Method)
01-14 18:50:29.862 E/AndroidRuntime(31161):     at androidx.lifecycle.ViewModelProvider$AndroidViewModelFactory.create(ViewModelProvider.java:267)
01-14 18:50:29.862 E/AndroidRuntime(31161):     ... 16 more
01-14 18:50:29.862 E/AndroidRuntime(31161): Caused by: java.lang.ArrayIndexOutOfBoundsException: length=2; index=2
01-14 18:50:29.862 E/AndroidRuntime(31161):     at java.util.regex.Matcher.group(Matcher.java:579)
01-14 18:50:29.862 E/AndroidRuntime(31161):     at java.util.regex.Matcher.appendEvaluated(Matcher.java:138)
01-14 18:50:29.862 E/AndroidRuntime(31161):     at java.util.regex.Matcher.appendReplacement(Matcher.java:111)
01-14 18:50:29.862 E/AndroidRuntime(31161):     at java.util.regex.Matcher.replaceAll(Matcher.java:319)
01-14 18:50:29.862 E/AndroidRuntime(31161):     at kotlin.text.Regex.replace(Regex.kt:143)
01-14 18:50:29.862 E/AndroidRuntime(31161):     at com.myproject.testDates(ScanCheckViewModel.kt:817)
01-14 18:50:29.862 E/AndroidRuntime(31161):     at com.myproject.&lt;init&gt;(ScanCheckViewModel.kt:98)
01-14 18:50:29.862 E/AndroidRuntime(31161):     ... 18 more

mapOf
listOf
setOf
val occupations = mapOf(Pair("Malcolm", "Captain"), Pair("Kaylee", "Mechanic"))
val shoppingList = listOf("catfish", "water", "tulips", "blue paint")
val favoriteGenres = setOf("Rock", "Classical", "Hip hop") 

var charSet = 1..10
var charSet = "A".."Z"
for (value in charSet) {    
  println("$value")  
}

before [[20,30],[40,50],[60,70]]

after  [[20,30],[40,50],[60,70],[20,30]]

before [[11,11],[22,22],[33,33],[44,44]]

after  [[11,11],[22,22],[33,33],[44,44],[11,11]]

errorMessage
errorCode
errorMessage
errorCode
class FooBaseClass{

constructor(errorMessage: String)                   // 1. Constructor
constructor(errorMessage: String, errorCode: Int)   // 2. Constructor

}

class FooDerivedClass(errorMessage: String, errorCode: Int) :
FooBaseClass(errorMessage, errorCode)

errorMessage
String a, b, c, d;
val a, b, c, d
Unexpected tokens
fun main() {
    val oddOrEven = { number: Int -&gt; (number % 2 == 0) ? "Even" : "Odd" }
    print(oddOrEven(2))
}

class ES {
    var issue: SomeClass? = null
}

class CSS {
   private val ref: Supplier&lt;SomeClass?&gt; = ES::issue
}

Type mismatch.
Required: Supplier&lt;SomeClass?&gt;
Found   : KMutableProperty1&lt;ES, SomeClass?&gt;

Function&lt;ES, SomeClass&gt; ref = ES::getIssue;

fun &lt;T&gt; doSomething(var1: T, var2: T) {}

doSomething(5, listOf&lt;Thread&gt;())

inline fun &lt;reified T&gt; doSomething(var1: T, var2: T) { }

doSomething(1,"2") &lt;-- unwanted compile
doSomething&lt;String&gt;(1,"2") &lt;-- Will not compile

fun &lt;T&gt; Sequence&lt;T&gt;.hasMinimum(threshold: Int): Boolean =
    take(threshold).toList().size == threshold

val key : String

import utilities.Constants
import java.util.*

class Action(val key: String,
        //val actionNode: ActionNode
             val date: Date,
             val stringValue: String,
             val autoRecognitionStatus: Constants.MeasurementAutoRecognized,
             val recognitionId: String,
             val method: Constants.MeasurementMethod,
             val userKey: String,
             val userName: String,
             val isInRange: Boolean) {


    var pictureUrl: String? = null
    var remotePictureUrl: String? = null



    constructor(key: String,
            // actionNode: ActionNode
                date: Date,
                stringValue: String,
                autoRecognitionStatus: Constants.MeasurementAutoRecognized,
                recognitionId: String,
                method: Constants.MeasurementMethod,
                userKey: String,
                userName: String,
                isInRange: Boolean,
                pictureUrl: String?,
                remotePictureUrl: String?)
            : this(key,
            // actionNode
            date,
            stringValue,
            autoRecognitionStatus,
            recognitionId,
            method,
            userKey,
            userName,
            isInRange) {
        this.pictureUrl = pictureUrl
        this.remotePictureUrl = remotePictureUrl

    }

}

aMethod(val1 , val2)
classObject.aMethod(null_if_Val1_NotAvailable,val2)
(String) -&gt; Boolean
filter
filterNot
Map
filterKeys
val myPredicate : (String) -&gt; Boolean = TODO()
val map : Map&lt;String, String&gt; = TODO()

map.filterKeys { !myPredicate(it) }

Collection
Map
Predicate.negate()
Predicate.not(..)
var list: MutableList&lt;String&gt;? = null

if (list.isNotEmpty()) {

}

var list: MutableList&lt;String&gt;? = null

if (list!!.isNotEmpty()) {

}

var list: MutableList&lt;String&gt;? = null

if ((list != null) &amp;&amp; list.isNotEmpty()) {

}

var color: Int = 0xFF0000FF

toInt()
var color: Int = 0xFF0000FF.toInt()

init
callSomeFunctionThatWillOnlyBeCalledByInit()
finalValue
val finalValue: String

init {
    callSomeFunctionThatWillOnlyBeCalledByInit()
}

fun callSomeFunctionThatWillOnlyBeCalledByInit() {
    finalValue = "Something"
}

val cannot be reassigned
callSomeFunctionThatWillOnlyBeCalledByInit()
init
val finalValue: String

init {
    finalValue = callSomeFunctionThatWillOnlyBeCalledByInit()
}

fun callSomeFunctionThatWillOnlyBeCalledByInit() : String {
    return "Something"
}

init
init
A
import kotlin.reflect.*
import javafx.event.ActionEvent

interface IA {}

class A {}

class B {
    fun test(a: A, ia: IA, event: ActionEvent) {
        println(a)
        println(ia)
        println(event)
    }
}

fun main(args: Array&lt;String&gt;) {
    for (function in B::class.declaredMemberFunctions) {
        for (parameter in function.parameters) {
            when (parameter.type) {
                is IA -&gt; println("Has IA interface parameter.")
                is ActionEvent -&gt; println("Has ActionEvent class parameter.")
                is A -&gt; println("Has A class parameter.") // &lt;---- compilation error in this line
            }
        }
    }
}

&gt; Error:(20, 19) Incompatible types: A and kotlin.reflect.KType

IA
ActionEvent
A
A
var
var greeting: String // Property must be initialized 
get() = "hello"

greeting
val
public class LobbySwitcherGui extends AGUI
{
    public LobbySwitcherGui()
    {
        super(27, "someTitle");

        setItem(0, new ItemStack(Material.NETHER_STAR), player -&gt; {
            player.sendMessage("Some message");
        });
    }
}

class LobbySwitcherGui : AGUI(27, "someTitle")
{
    init {
        setItem(0, ItemStack(Material.NETHER_STAR), { player -&gt; player.sendMessage("Some message") })
    }
}

var timestamp = (System.currentTimeMillis() - SystemClock.elapsedRealtime())
String time = Long.toString(time) // Error: Expecting an element
value.setText("" + time)

class Countries {
    var list: MutableList&lt;String&gt;? = null
}

val countries = Countries()

if (countries.list!!.isNotEmpty()) {

}

if ((countries.list != null) &amp;&amp; countries.list!!.isNotEmpty()) {

}

infix fun Any?.ifTrue(block: () -&gt; Unit) {
    if ((this != null) &amp;&amp; this == true) block()
}

countries.areInitialized ifTrue {

}

var name: String
var age: Int

property must be initialized or abstract.

data class Person(val _name: String,val _age: Int) {
  var name: String
  var age: Int

  init {
    name: String = _name.capitalize()
    age: Int = _age * 10;

    println("the name is: $name")
    println("the age is: $age")
  }

  /*override fun toString(): String {
    return "$name is $age years old."
  }*/
}

Type mismatch, found B require typeA
B
typeA
B
typeA
A&lt;C&gt;
class Test&lt;typeA : A&lt;C&gt;&gt; {

    fun returnB(): typeA {
        return B()
    }
}


open class A&lt;c : C&gt;

class B : A&lt;C&gt;()

open class C

bash: kotlinc: command not found
fun main(args: Array&lt;String&gt;) {

} 

class Day constructor(cal: Calendar, refCal: Calendar) {
    val cal: Calendar
    val isBefore: Boolean
    val isAfter: Boolean

    init {
        this.cal = cal.clone() as Calendar
        isBefore = 0 &lt; cal.compareTo(refCal)
        isAfter = 0 &gt; cal.compareTo(refCal)
    }
}

isBefore
isAfter
init
isBefore
isAfter
class Day constructor(cal: Calendar, refCal: Calendar) {
    val cal: Calendar

    init {
        this.cal = cal.clone() as Calendar
        this.refCal = refCal.clone() as Calendar
    }

    val isBefore: Boolean
        get() { return 0 &lt; cal.compareTo(refCal) }
    val isAfter: Boolean
        get() { return 0 &gt; cal.compareTo(refCal) }
}

init
fun setDates(refDate: Calendar) {
    val cal = Calendar.getInstance()
    cal.set(refDate.get(Calendar.YEAR), refDate.get(Calendar.MONTH), refDate.get(Calendar.DAY_OF_MONTH), 0, 0, 0)

    cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)
    val monday = Day(cal, refDate)
    //...

val getMoreFunction : (() -> FSDirResult)? = null
{}
null
java.util.function.Function&lt;T, R&gt;
public class A {
    Function&lt;String, String&gt; function;

    public A(Function&lt;String, String&gt; function) {
        super();
        this.function = function;
    }

public String convert(String input) {
    return function.apply(input);

}
}

package it.kfi.xml.binding.processor

import com.google.auto.service.AutoService
import com.squareup.kotlinpoet.*
import it.kfi.xml.binding.annotations.XmlClass
import it.kfi.xml.binding.annotations.XmlProperty
import java.io.File
import java.lang.reflect.Type
import javax.annotation.Nullable
import javax.annotation.processing.AbstractProcessor
import javax.annotation.processing.Processor
import javax.annotation.processing.RoundEnvironment
import javax.lang.model.SourceVersion
import javax.lang.model.element.Element
import javax.lang.model.element.ElementKind
import javax.lang.model.element.TypeElement
import javax.lang.model.element.VariableElement
import javax.lang.model.type.NullType
import javax.lang.model.type.TypeMirror
import javax.print.DocFlavor
import javax.tools.Diagnostic
import kotlin.reflect.KClass
import kotlin.reflect.full.createType



@AutoService(Processor::class)
class XmlBinder : AbstractProcessor() {

    companion object {

        const val KAPT_KOTLIN_GENERATED_OPTION_NAME = "kapt.kotlin.generated"
    }

    override fun getSupportedAnnotationTypes(): MutableSet&lt;String&gt; {

        return mutableSetOf(XmlClass::class.java.name)
    }

    override fun getSupportedSourceVersion(): SourceVersion = SourceVersion.latest()

    override fun process(annotations: MutableSet&lt;out TypeElement&gt;?, roundEnv: RoundEnvironment): Boolean {

        roundEnv.getElementsAnnotatedWith(XmlClass::class.java)
                .forEach {
                    if (it.kind != ElementKind.CLASS) {
                        processingEnv.messager.printMessage(Diagnostic.Kind.ERROR, "Only classes can be annotated")
                        return true
                    }
                    processClass(it)
                }

        return false
    }

    private fun processClass(element: Element) {

        val className = element.simpleName.toString() + "Model"
        val packageName = processingEnv.elementUtils.getPackageOf(element).toString()

        val classBuilder = TypeSpec.classBuilder(className)
        classBuilder.addModifiers(KModifier.PUBLIC)

        val initFromXml = FunSpec.builder("initFromXml")
        initFromXml.addModifiers(KModifier.PUBLIC)
        initFromXml.addParameter(ParameterSpec.builder("xml", String::class).build())

        val properties = element.enclosedElements

        var x: Int = 1

        //Look for elements annotated with XmlField and add those elements to the generated class
        for (property in properties) {

            val annotation = property.getAnnotationsByType(XmlProperty::class.java)

            val v = 10

            classBuilder.addProperty(PropertySpec.varBuilder(property.simpleName.toString(), String::class, KModifier.PUBLIC).initializer(v.toString()).build())
            initFromXml.addStatement("this.${property.simpleName} = \"${v.toString()}\"")

        }

        classBuilder.addFunction(initFromXml.build())

        val fileName = "kfi_generated_$className"
        val file = FileSpec.builder(packageName, fileName).addType(classBuilder.build()).build()

        val kaptKotlinGeneratedDir = processingEnv.options[KAPT_KOTLIN_GENERATED_OPTION_NAME]
        file.writeTo(File(kaptKotlinGeneratedDir))
    }


}

interface IData {

    fun getHash() : Int
    fun getUUID(): UUID

    ......
}

fun getUUID(): UUID
fun getHash() : Int
fun buidlDataList () : ArrayList&lt;IData&gt; {

    val dataList = ArrayList&lt;IData&gt;(0)

    dataList.add(object : IData {

        val hash: Int by lazy { dataFetchers.size+System.currentTimeMillis().toInt() } //&lt;=== get error
        override fun getHash(): Int {                                                  //&lt;=== get the same error
            return hash
        }

        val uuid: UUID by lazy { UUID.randomUUID() }
        override fun getUUID(): UUID {
            return uuid
        }
        ......
    }
}


Platform declaration clash:  The following declarations have the same JVM signature(getHash() I):
    * public final fun &lt;get-hash&gt;(): int  defined in com.data. buidlDataList &lt;no name provided&gt;
    * public open fun getHash(): int defined in defined in com.data. buidlDataList &lt;no name provided&gt;

class A {
    // public static factories
    // private constructors
    // public A methods
    // private A methods
    // private static helpers
}

class A private constructor(...) {
    companion object {
        // factories
    }
    // A methods
    // private A methods
}

// private helpers

AKt
class A private constructor(...) {
    companion object {
        // factories
        // private helpers
    }
    // A methods
    // private A methods
}

AKt
AKt
AKt a = new AKt();

error: cannot find symbol
AKt mk = new AKt();

public class User {

    String name;
    String id;
    int age;

    public User(String name) {
        this.name = name;
    }

    public User(String name, String id) {
        this.name = name;
        this.id = id;
    }

    public User(String id, int age) {
        this.id = id;
        this.age = age;
    }

    public User() {
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", id='" + id + '\'' +
                ", age=" + age +
                '}';
    }
} 

class User {

    var name: String?=null
    var id: String?=null
    var age: Int = 0

    constructor(name: String) {
        this.name = name
    }

    constructor(name: String, id: String) {
        this.name = name
        this.id = id
    }

    constructor(id: String, age: Int) {
        this.id = id
        this.age = age
    }

    constructor() {}

    override fun toString(): String {
        return "User{" +
                "name='" + name + '\'' +
                ", id='" + id + '\'' +
                ", age=" + age +
                '}'
    }
}

var buffer = StringBuffer();
var arr = arrayOf("1","2","3","4");
arr.forEach {buffer::append}

String[] b = new String[]{"c", "b"};
Arrays.stream(b).forEach(buffer::append);

@Document(collection = Approval.COLLECTION)
data class Approval(
    @Id
    val id: String,
    val detailId: &lt;UNSURE HERE&gt;
) {
    companion object {
        const val COLLECTION: String = "approval"
    }
}

detailID
String
data class AIDConfiguration(
    val sId: String,
    val cId: String
)

val detailId: AIDConfiguration | String

interface ParentConfiguration

data class AIDConfiguration(
    val sId: String,
    val cId: String
): ParentConfiguration


val detailId: ParentConfiguration

private val uiScope = CoroutineScope(Dispatchers.Main + viewModelJob)

interface Event {
    fun value(): Int
}

class Event1: Event {
    override fun value() = 1
}

class Event2: Event {
    override fun value() = 2
}

interface EventConsumer&lt;T&gt; where T: Event {
    fun consume(event: T)
}

class Event1Consumer: EventConsumer&lt;Event1&gt; {
    override fun consume(event: Event1) {
        println(event.value())
    }
}

class Event2Consumer: EventConsumer&lt;Event2&gt; {
    override fun consume(event: Event2) {
        println(event.value())
    }
}

class EventManager {
    private val consumers: Map&lt;KClass&lt;*&gt;, EventConsumer&lt;*&gt;&gt; = mapOf(
            Event1::class to Event1Consumer(),
            Event2::class to Event2Consumer()
    )

    fun consume(event: Event) {
        val consumer = consumers[event::class]

        consumer?.consume(event)
    }
}

var h = hash + inv(hash shl 9)

fun chararraytostr(inp1: CharArray): String{
    var arlen: Int = inp1.size //here lies the problem
    var out1: String = ""
    for(j in 0..arlen-1){
        var str = inp1[j].toString()
        out1+=str
    }
    return out1
}

fun uppercase(input: String): String{
    var temp1: CharArray = input.toCharArray()
    var len = input.size //here lies the problem
    var temp3: Char
    for(i in 0..len-1){
        var temp2: Char = temp1[i]
        var ascii: Int = temp2.toInt()
        if(ascii&lt;=122 &amp;&amp; ascii&gt;=97){
            ascii-=32
            temp3 = ascii.toChar()
            temp1[i] = temp3
        }else{}
    }
    var output = chararraytostr(temp1)
    return output
}

fun main(arg: Array&lt;String&gt;){
    var toupper = "Hi my friend!"
    println(uppercase(toupper))
}

data class Product(
    val id: Int,
    val name: String,
    val manufacturer: String)

equals()
hashCode()
override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other == null || javaClass != other.javaClass) return false
    val that = other as Product?
    return id == that.id &amp;&amp;
            name == that!!.name &amp;&amp;
            manufacturer == that.manufacturer
}

override fun hashCode(): Int {
    return Objects.hash(id, name, manufacturer)
}

id
equals()
hashCode()
toString()
compareTo()
val(found,notFound) = "abcd".partition { "abcdef".contains(it)}

found = "abcd" , notFound = "ef"
found="abcd" ,notFound=""
listOf(MyItem(1, listOf("Aus","Ame")), MyItem(2, listOf("Cha", "Tel")))

data class MyItem(val num: Int, val list: List&lt;String&gt;)

code
MyItem
listOf(MyItem(1, listOf("Aus")), MyItem(1, listOf("Ame")), MyItem(2, listOf("Cha")), MyItem(2, listOf("Tel")))

 class YLAService {


var context:Context?=null

class YLAService constructor(context: Context) {
    this.context=context;// do something

}}

public
package group.moduleA.service
internal class HiddenService() {

    fun someFunction {

    }
}

  package group.moduleA.service
    class Service(private val hiddenService: HiddenService) {

        fun someFunction {

        }
    }

public
internal
internal
Service
import java.util.*

data class BorrowerX(val name: String, val maxBooks: Int) {

    companion object {

        fun getName(br: BorrowerX): String = br.name

        fun findBorrowerX(n: String, brs: ArrayList&lt;BorrowerX&gt;): BorrowerX? {

            val coll: List&lt;BorrowerX&gt; = brs.filter { BorrowerX.getName(it) == n }

            if (coll.isEmpty()) {
                return null
            } else return coll.first()

        }

        fun findBorrowerX2(n: String, brs: ArrayList&lt;BorrowerX&gt;, f: (BorrowerX) -&gt; String): BorrowerX? {

            val coll: List&lt;BorrowerX&gt; = brs.filter { f(it) == n }

            if (coll.isEmpty()) {
                return null
            } else return coll.first()

        }

    }

}

import BorrowerX

val br1 = BorrowerX(name = "Borrower1", maxBooks = 1)
val br2 = BorrowerX(name = "Borrower2", maxBooks = 2)
val br3 = BorrowerX(name = "Borrower3", maxBooks = 3)

val brs1 = arrayListOf(br1, br2, br3)

BorrowerX.findBorrowerX("Borrower1", brs1)
BorrowerX(name=Borrower1, maxBooks=1)

BorrowerX.findBorrowerX("Borrower-Bad", brs1)
null

BorrowerX.findBorrowerX2("Borrower1", brs1, BorrowerX.getName(???))

def findBorrowerX2(n: String, brs: List[BorrowerX], f: BorrowerX =&gt; String): BorrowerX = {

  val coll: List[BorrowerX] = brs.filter(f(_) == n)

  if (coll.isEmpty) {
    null
  } else {
    coll.head
  }

}

scala&gt; BorrowerX.findBorrowerX2("Borrower3", brs1, BorrowerX.getName(_))
res1: BorrowerX = BorrowerX(Borrower3,3)

scala&gt; BorrowerX.findBorrowerX2("Borrower33", brs1, BorrowerX.getName(_))
res2: BorrowerX = null

interface A{
 fun test(foo:Int,bar:Int)
}

val aImpl:A? = .....

fun higherOrder(f:((a:Int,B:Int)-&gt; Unit)?){ ... }

higherOrder(aImpl::test)  // aImpl is nullable
higherOrder(aImpl?::test) // I'd expect reasonably this to work, but syntax is invalid

higherOrder(aImpl?.let{it::test}) 

fun main(args: Array&lt;String&gt;) {
    val x = BigInteger.ONE
    var y = BigInteger.TEN

    val z = x + y;
}

1.0.0-beta-1038-IJ143-19
Error:(7, 15) Kotlin: Unresolved reference. None of the following candidates is applicable because of receiver type mismatch: 
public operator fun &lt;T&gt; kotlin.Array&lt;???&gt;.plus(array: kotlin.Array&lt;out ???&gt;): kotlin.Array&lt;???&gt; defined in kotlin
public operator fun &lt;T&gt; kotlin.Array&lt;???&gt;.plus(collection: kotlin.Collection&lt;???&gt;): kotlin.Array&lt;???&gt; defined in kotlin
public operator fun &lt;T&gt; kotlin.Array&lt;java.math.BigInteger!&gt;.plus(element: java.math.BigInteger!): kotlin.Array&lt;java.math.BigInteger!&gt; defined in kotlin
public operator fun kotlin.BooleanArray.plus(element: kotlin.Boolean): kotlin.BooleanArray defined in kotlin
public operator fun kotlin.BooleanArray.plus(array: kotlin.BooleanArray): kotlin.BooleanArray defined in kotlin
public operator fun kotlin.BooleanArray.plus(collection: kotlin.Collection&lt;kotlin.Boolean&gt;): kotlin.BooleanArray defined in kotlin
public operator fun kotlin.ByteArray.plus(element: kotlin.Byte): kotlin.ByteArray defined in kotlin
public operator fun kotlin.ByteArray.plus(array: kotlin.ByteArray): kotlin.ByteArray defined in kotlin
public operator fun kotlin.ByteArray.plus(collection: kotlin.Collection&lt;kotlin.Byte&gt;): kotlin.ByteArray defined in kotlin
public operator fun kotlin.Char.plus(string: kotlin.String): kotlin.String defined in kotlin
public operator fun kotlin.CharArray.plus(element: kotlin.Char): kotlin.CharArray defined in kotlin
public operator fun kotlin.CharArray.plus(array: kotlin.CharArray): kotlin.CharArray defined in kotlin
public operator fun kotlin.CharArray.plus(collection: kotlin.Collection&lt;kotlin.Char&gt;): kotlin.CharArray defined in kotlin
public operator fun &lt;T&gt; kotlin.Collection&lt;???&gt;.plus(array: kotlin.Array&lt;out ???&gt;): kotlin.List&lt;???&gt; defined in kotlin
public operator fun &lt;T&gt; kotlin.Collection&lt;???&gt;.plus(collection: kotlin.Iterable&lt;???&gt;): kotlin.List&lt;???&gt; defined in kotlin
public operator fun &lt;T&gt; kotlin.Collection&lt;???&gt;.plus(sequence: kotlin.Sequence&lt;???&gt;): kotlin.List&lt;???&gt; defined in kotlin
public operator fun &lt;T&gt; kotlin.Collection&lt;java.math.BigInteger!&gt;.plus(element: java.math.BigInteger!): kotlin.List&lt;java.math.BigInteger!&gt; defined in kotlin
public operator fun kotlin.DoubleArray.plus(collection: kotlin.Collection&lt;kotlin.Double&gt;): kotlin.DoubleArray defined in kotlin
public operator fun kotlin.DoubleArray.plus(element: kotlin.Double): kotlin.DoubleArray defined in kotlin
public operator fun kotlin.DoubleArray.plus(array: kotlin.DoubleArray): kotlin.DoubleArray defined in kotlin
public operator fun kotlin.FloatArray.plus(collection: kotlin.Collection&lt;kotlin.Float&gt;): kotlin.FloatArray defined in kotlin
public operator fun kotlin.FloatArray.plus(element: kotlin.Float): kotlin.FloatArray defined in kotlin
public operator fun kotlin.FloatArray.plus(array: kotlin.FloatArray): kotlin.FloatArray defined in kotlin
public operator fun kotlin.IntArray.plus(collection: kotlin.Collection&lt;kotlin.Int&gt;): kotlin.IntArray defined in kotlin
public operator fun kotlin.IntArray.plus(element: kotlin.Int): kotlin.IntArray defined in kotlin
public operator fun kotlin.IntArray.plus(array: kotlin.IntArray): kotlin.IntArray defined in kotlin
public operator fun &lt;T&gt; kotlin.Iterable&lt;???&gt;.plus(array: kotlin.Array&lt;out ???&gt;): kotlin.List&lt;???&gt; defined in kotlin
public operator fun &lt;T&gt; kotlin.Iterable&lt;???&gt;.plus(collection: kotlin.Iterable&lt;???&gt;): kotlin.List&lt;???&gt; defined in kotlin
public operator fun &lt;T&gt; kotlin.Iterable&lt;???&gt;.plus(sequence: kotlin.Sequence&lt;???&gt;): kotlin.List&lt;???&gt; defined in kotlin
public operator fun &lt;T&gt; kotlin.Iterable&lt;java.math.BigInteger!&gt;.plus(element: java.math.BigInteger!): kotlin.List&lt;java.math.BigInteger!&gt; defined in kotlin
public operator fun kotlin.LongArray.plus(collection: kotlin.Collection&lt;kotlin.Long&gt;): kotlin.LongArray defined in kotlin
public operator fun kotlin.LongArray.plus(element: kotlin.Long): kotlin.LongArray defined in kotlin
public operator fun kotlin.LongArray.plus(array: kotlin.LongArray): kotlin.LongArray defined in kotlin
public operator fun &lt;K, V&gt; kotlin.Map&lt;???, ???&gt;.plus(pairs: kotlin.Array&lt;kotlin.Pair&lt;???, ???&gt;&gt;): kotlin.Map&lt;???, ???&gt; defined in kotlin
public operator fun &lt;K, V&gt; kotlin.Map&lt;???, ???&gt;.plus(pairs: kotlin.Iterable&lt;kotlin.Pair&lt;???, ???&gt;&gt;): kotlin.Map&lt;???, ???&gt; defined in kotlin
public operator fun &lt;K, V&gt; kotlin.Map&lt;???, ???&gt;.plus(map: kotlin.Map&lt;???, ???&gt;): kotlin.Map&lt;???, ???&gt; defined in kotlin
public operator fun &lt;K, V&gt; kotlin.Map&lt;???, ???&gt;.plus(pair: kotlin.Pair&lt;???, ???&gt;): kotlin.Map&lt;???, ???&gt; defined in kotlin
public operator fun &lt;K, V&gt; kotlin.Map&lt;???, ???&gt;.plus(pairs: kotlin.Sequence&lt;kotlin.Pair&lt;???, ???&gt;&gt;): kotlin.Map&lt;???, ???&gt; defined in kotlin
public operator fun &lt;T&gt; kotlin.Sequence&lt;???&gt;.plus(array: kotlin.Array&lt;out ???&gt;): kotlin.Sequence&lt;???&gt; defined in kotlin
public operator fun &lt;T&gt; kotlin.Sequence&lt;???&gt;.plus(collection: kotlin.Iterable&lt;???&gt;): kotlin.Sequence&lt;???&gt; defined in kotlin
public operator fun &lt;T&gt; kotlin.Sequence&lt;???&gt;.plus(sequence: kotlin.Sequence&lt;???&gt;): kotlin.Sequence&lt;???&gt; defined in kotlin
public operator fun &lt;T&gt; kotlin.Sequence&lt;java.math.BigInteger!&gt;.plus(element: java.math.BigInteger!): kotlin.Sequence&lt;java.math.BigInteger!&gt; defined in kotlin
public operator fun &lt;T&gt; kotlin.Set&lt;???&gt;.plus(array: kotlin.Array&lt;out ???&gt;): kotlin.Set&lt;???&gt; defined in kotlin
public operator fun &lt;T&gt; kotlin.Set&lt;???&gt;.plus(collection: kotlin.Iterable&lt;???&gt;): kotlin.Set&lt;???&gt; defined in kotlin
public operator fun &lt;T&gt; kotlin.Set&lt;???&gt;.plus(sequence: kotlin.Sequence&lt;???&gt;): kotlin.Set&lt;???&gt; defined in kotlin
public operator fun &lt;T&gt; kotlin.Set&lt;java.math.BigInteger!&gt;.plus(element: java.math.BigInteger!): kotlin.Set&lt;java.math.BigInteger!&gt; defined in kotlin
public operator fun kotlin.ShortArray.plus(collection: kotlin.Collection&lt;kotlin.Short&gt;): kotlin.ShortArray defined in kotlin
public operator fun kotlin.ShortArray.plus(element: kotlin.Short): kotlin.ShortArray defined in kotlin
public operator fun kotlin.ShortArray.plus(array: kotlin.ShortArray): kotlin.ShortArray defined in kotlin
public operator fun kotlin.String?.plus(other: kotlin.Any?): kotlin.String defined in kotlin

   private fun handleJson (jsonString: String?){

            val jsonObj = JSONObject(jsonString)
            val result = jsonObj.getJSONObject("result")
            val response = result.getJSONObject("response")
            val airport = response.getJSONObject("airport")
            val pluginData = airport.getJSONObject("pluginData")
            val schedule = pluginData.getJSONObject("schedule")
            val arrivals = schedule.getJSONObject("arrivals")
//        val data = arrivals.getJSONObject("data")
            val jsonArray = JSONArray(arrivals.get("data").toString())

            val list =  ArrayList&lt;FlightShdu&gt;()
            var x = 0
            while (x &lt; jsonArray.length()){

                val jsonObject = jsonArray.getJSONObject(x)



                list.add(FlightShdu(
                    jsonObject.getJSONObject("flight").getJSONObject("identification").getJSONObject("number").getString("default"),
                    jsonObject.getJSONObject("flight").getJSONObject("airline").getString("short"),
                    jsonObject.getJSONObject("flight").getJSONObject("status").getJSONObject("generic").getJSONObject("status").getString("text"),
                    jsonObject.getJSONObject("flight").getJSONObject("airline").getJSONObject("code").getString("icao"),
                    jsonObject.getJSONObject("flight").getJSONObject("time").getJSONObject("scheduled").getString("departure"),
                    jsonObject.getJSONObject("flight").getJSONObject("airport").getJSONObject("origin").getJSONObject("code").getString("iata"),
                    jsonObject.getJSONObject("flight").getJSONObject("aircraft").getJSONObject("model").getString("code"),
//                    for more information
                    jsonObject.getJSONObject("flight").getJSONObject("time").getJSONObject("real").getString("departure"),
                    jsonObject.getJSONObject("flight").getJSONObject("time").getJSONObject("estimated").getString("arrival")?: "N/A"
//                    jsonObject.getJSONObject("flight").getJSONObject("time").getJSONObject("estimated").getString("arrival"),
//                    jsonObject.getJSONObject("flight").getJSONObject("status").getJSONObject("generic").getJSONObject("status").getString("diverted")



                    ))


                x++
            }
            list.forEach(::println)

            val adapter = ListAdapte(this@MainActivity,list)
            flight_arrivel_list.adapter = adapter

        }

val  TimeArrival = bundle.getString("TimeArrival")?: "N/A"
    timearraiveId2.text=getDateTime(TimeArrival)

   fun getDateTime(s: String): String? {
        try {
            val sdf = SimpleDateFormat("KK:mm a")
            val netDate = Date(s.toLong() * 1000)
            return sdf.format(netDate)
        } catch (e: Exception) {
            return e.toString()

        }
    }

  if (TimeArrival==null) {
        timearraiveId2.setText("N/A")
    }

fun handleStrings(list: List&lt;String&gt;) {
    if (list is ArrayList) {
        // `list` is smart-cast to `ArrayList&lt;String&gt;`
    }
}

val a = mutableListOf(1, 2, 3)
val b = listOf(1, 2, 3)
println(a is List)   //error, should use List&lt;*&gt;
println(b is MutableList)   //can compile

println(listOf(1, 2, 3) is ArrayList)  //false
println(listOf(1, 2, 3) is MutableList)  //true

asList
interface SBoard {
    val size: Int
}

interface GBoard&lt;T&gt; : SquareBoard {
}

open class SBoardImpl (override val size: Int) : SBoard {
    lateinit var allCells: Array&lt;Array&lt;CellImpl&gt;&gt;

    init {
        println ("Parent Generator: " + this.size.toString())
    }

   ...
}

class GBoardImpl&lt;T&gt; (override val size: Int): SBoardImpl (size), GBoard&lt;T&gt;{
    lateinit var cellValues: Array&lt;Array&lt;Any?&gt;&gt;

    init {
        println ("Child Initialisation:" + super.size.toString())
    }

    ...
}

GameBoardImpl&lt;T&gt;(2)

val g = createGBoard&lt;Char&gt;(2)

class GBoardImpl&lt;T&gt; (override val size: Int): SBoardImpl (size)... 

result
fun main(args: Array&lt;String&gt;) {
    print("Enter two numbers: ")

    // nextDouble() reads the next double from the keyboard
    var first= readLine()!!.toDouble()
    var second = readLine()!!.toInt()

    print("Enter an choice(1-4)): ")
    val operator = readLine()!!.toInt()

    var result: Double

    when (operator) {
        1 -&gt; result = first + second
        2 -&gt; result = first - second
        3 -&gt; result = first * second
        4 -&gt; result = first / second

        else -&gt; {
            println("Error.")
        }
    }

    println("The result is :- " +result)
}

open class Base { }

class Derived : Base() { }

open class BaseCaller {
    open fun Base.printFunctionInfo() {
        println("Base extension function in BaseCaller")
    }

    open fun Derived.printFunctionInfo() {
        println("Derived extension function in BaseCaller")
    }

    fun call(b: Base) {
        b.printFunctionInfo()   // call the extension function
    }
}

class DerivedCaller: BaseCaller() {
    override fun Base.printFunctionInfo() {
        println("Base extension function in DerivedCaller")
    }

    override fun Derived.printFunctionInfo() {
        println("Derived extension function in DerivedCaller")
    }
}

fun main() {
    BaseCaller().call(Base())   // "Base extension function in BaseCaller"
    DerivedCaller().call(Base())  // "Base extension function in DerivedCaller" - dispatch receiver is resolved virtually
    DerivedCaller().call(Derived())  // "Base extension function in DerivedCaller" - extension receiver is resolved statically
}

fun main(args:Array&lt;String&gt;){
    val two=2
    val name:String?
    name="Mensh"
    println(two+name)
}

println(two+name)
Error:(8, 16) Kotlin: None of the following functions can be called with the arguments supplied: 
public final operator fun plus(other: Byte): Int defined in kotlin.Int 
public final operator fun plus(other: Double): Double defined in kotlin.Int 
public final operator fun plus(other: Float): Float defined in kotlin.Int 
public final operator fun plus(other: Int): Int defined in kotlin.Int 
public final operator fun plus(other: Long): Long defined in kotlin.Int 
public final operator fun plus(other: Short): Int defined in kotlin.Int

fun main(args: Array&lt;String&gt;) {
val a = 20
val h = 30
val area = a * h / 2
println("Triangle area = $area.toFixed(2)")
}

String?
String
data class Person(var name: String?) {
//... 
}
data class Person(var name: String) {
//...
}

class Box&lt;T&gt;(val value: T)


val box1: Box&lt;Int&gt; = Box&lt;Int&gt;(1)

val box2: Box&lt;Int&gt; = Box(1)

val box3 = Box(1)

SparkConsumer
@BeforeAll
@BeforeEach
SparkConsumer
SparkConsumer
    SUT = SparkConsumer(PORT, object : IEventsService {
        override fun create(eventRequest: Event.Request)
            = eventsServiceMock.create(eventRequest)
    })

    SUT = SparkConsumer(PORT, object : IEventsService by eventsServiceMock {})

private val eventsServiceMockByLazy: IEventsService by object {
    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): IEventsService = eventsServiceMock
}
    SUT = SparkConsumer(PORT, object : IEventsService by eventsServiceMockByLazy {})

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class SparkConsumerIntegrationTest {
    val PORT = 28411

    private lateinit var SUT: SparkConsumer
    private lateinit var eventsServiceMock: IEventsService
    private val eventsServiceMockByLazy: IEventsService by object { // For Option C only
        operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): IEventsService = eventsServiceMock
    }

    @BeforeAll
    fun beforeAll() {
        // Option A
        SUT = SparkConsumer(PORT, object : IEventsService {
            override fun create(eventRequest: Event.Request)
                = eventsServiceMock.create(eventRequest)
        })
        // Option B
        SUT = SparkConsumer(PORT, object : IEventsService by eventsServiceMock {})
        // Option C
        SUT = SparkConsumer(PORT, object : IEventsService by eventsServiceMockByLazy {})
    }

    @AfterAll
    fun afterAll() {
        SUT.kill()
    }

    @BeforeEach
    fun setUp() {
        eventsServiceMock = mock { }
    }

    @Test
    fun `should events-create pass`() {
        // S
        val requestObj = Event.Request("Some device", "Some statement")
        eventsServiceMock.stub {
            on {
                create(Event.Request("Some device", "Some statement"))

            }.doReturn(Event.Data("0123", "Some device", "Some statement"))
        }

        // ...
    }

    // ...
}

SparkConsumer(PORT, object : IEventsService by this::eventsServiceMock {})

apply
run
let
also
takeIf
with
// private lateinit var someAdapter: SomeAdapter

recycler_view.apply {
    this.layoutManager = LinearLayoutManager(context)
    if (this::someAdapter.isInitialized) { // Compilation error.
        this.adapter = someAdapter
    }
}

someAdapter
interface A

interface Factory&lt;in SpecType: Factory.Spec&gt; {
    interface Spec
    fun create(spec: SpecType): A
}

class DefaultFactory : Factory&lt;DefaultFactory.Spec&gt; {
    data class Spec(
        val message: String
    ) : Factory.Spec

    override fun create(spec: Spec): A {
      // Do stuff here to create an instance of A using spec
    }
}

var factory: Factory&lt;???&gt; = DefaultFactory()

???
Spec
@Suppress("UNCHECKED_CAST")
var factory: Factory&lt;Factory.Spec&gt; = DefaultFactory() as Factory&lt;Factory.Spec&gt;

val something = {
  val temp1 = ...
  val temp2 = ...
  temp1 + temp2
}

val something = {
  val temp1 = ...
  val temp2 = ...
  temp1 + temp2
}()

_myid
whereSimple("$_myid = ? ",_id.toString())
val _myid:String=DBRecordTable._ID
_id
whereSimple("$_id = ? ",_id.toString())
val _id:String=DBRecordTable._ID
fun getRecordByID(_id:Long)
class DBRecordHandler(val mDBRecordHelper: DBRecordHelper =DBRecordHelper.instance,
                      val tableName:String =DBRecordTable.TableNAME,
                      val _myid:String=DBRecordTable._ID
                      ) {


      fun getRecordByID(_id:Long):MDBRecord? = mDBRecordHelper.use{
          select(tableName)
              .whereSimple("$_myid = ? ",_id.toString())
              .parseOpt{MDBRecord(HashMap(it)) }
      }
}

class DBRecordHandler(val mDBRecordHelper: DBRecordHelper =DBRecordHelper.instance,
                      val tableName:String =DBRecordTable.TableNAME,
                      val _id:String=DBRecordTable._ID
                      ) {


      fun getRecordByID(_id:Long):MDBRecord? = mDBRecordHelper.use{
          select(tableName)
              .whereSimple("$_id = ? ",_id.toString())
              .parseOpt{MDBRecord(HashMap(it)) }
      }
}

class DBRecordHandler(val mDBRecordHelper: DBRecordHelper =DBRecordHelper.instance,
                      val tableName:String =DBRecordTable.TableNAME,
                      val _id:String=DBRecordTable._ID
                      ) {


      fun getRecordByID(_id:Long):MDBRecord? = mDBRecordHelper.use{
          select(tableName)
              .whereSimple("${this._id}= ? ",_id.toString())
              .parseOpt{MDBRecord(HashMap(it)) }
      }

}

val
class FeedAdapter(context: Context, val resource: Int, val applications: List&lt;FeedEntry&gt;)

class FeedAdapter(context: Context, resource: Int, applications: List&lt;FeedEntry&gt;)

private fun assertEquals&lt;T&gt;(actual : T?, expected : T?, message : Any? = null) {
    if (actual != expected) {
        errors++
        println("Test failed")
        val trace = Thread.currentThread()?.getStackTrace()!!
        if (trace.size &gt; 6) {
            // Finding relevant stack frames
            val location = trace.getFrameAfter("runs.Tester", "expect") // ERROR HERE
            val function = trace.getFrameAfter("runs.TesterRunner", "forFunction") // AND HERE
            println("at ${function?.getClassName()}.${function?.getMethodName()}(line:${location?.getLineNumber()})")
        }
        if (message != null)
            println(message)
    }
    else if (!skipSuccessful)
        println("OK")
}

 Type mismatch: inferred type is kotlin.Array&lt;java.lang.StackTraceElement&gt; but
 kotlin.Array&lt;java.lang.StackTraceElement?&gt; was expected

val strings = listOf("One", null, "Three")

val noNulls: (String?) -&gt; Boolean = { value -&gt; value != null }
strings.filter(noNulls)

fun noNulls(value: String?): Boolean = value != null
strings.filter(::noNulls)

class MainActivity: AppCompatActivity() {

   class TextView totalTextView;    //This is where I am having the error 

        override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        setSupportActionBar(toolbar)

val pair: Pair&lt;Char,Char&gt; = 'z' to 'z'
val comparison = pair.first.compareTo(pair.second)
println(comparison)

Pair&lt;Char, Char&gt;
'z'.compareTo('z')
public class Main {
    static class Account {
        private Long id;
        private String name;
        private Book book;

        public Account(Long id, String name, Book book) {
            this.id = id;
            this.name = name;
            this.book = book;
        }

        public String getName() {
            return name;
        }
    }
    public static void main(String[] args) {
        List&lt;Account&gt; data1 = new ArrayList&lt;&gt;();
        data1.add(new Account(1L,"name",null));
        List&lt;String&gt; collect = data1.stream().map(account -&gt; account.getName()).collect(Collectors.toList());

        System.out.println(collect);
    }
}

List&lt;String&gt; collect = data1.stream().map(account -&gt; account.getName()).collect(Collectors.toList());

 val collect = data1.stream().map({ account-&gt; account.getName() }).collect(Collectors.toList())
    println(collect)

&lt;Button
        android:id="@+id/firstButton"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:onClick="firstClicked"
        android:text="Color 1"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintHorizontal_bias="0.117"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintVertical_bias="0.499" /&gt;

var
get
field
var
set
class Banana {
    var ripeness = 1

    var color: String = "green"
        get() = when {
            ripeness &gt; 80 -&gt; "brown"
            ripeness &gt; 50 -&gt; "yellow"
            else -&gt; "green"
        }
}

val b = Banana()
b.color = "blue"

println(b.color)

println
color
package test;

public class InitFieldJava {

    private final static String SECRET = "secret";
    private String mySecret;

    public String getMySecret() {
        if(mySecret == null) initMySecret();
        return mySecret;
    }

    private void initMySecret() {
        System.out.println("Initializing Secret ....");
        mySecret = SECRET;
    }

    public static void main(String[] args) {
        InitFieldJava field = new InitFieldJava();
        System.out.println(field.getMySecret());
    }
}

package test

class InitFieldKotlin {
    private val SECRET = "secret"
    private var mySecret: String? = null
    get() {
        if (mySecret == null) initMySecret() //Infinite Recursion!!!
        return mySecret
    }

    private fun initMySecret() {
        println("Initializing Secret ....")
        mySecret = SECRET
    }

    companion object {
        @JvmStatic
        fun main(args: Array&lt;String&gt;) {
            val field = InitFieldKotlin()
            println(field.mySecret)
        }
    }
}

Exception in thread "main" java.lang.StackOverflowError
    at test.InitFieldKotlin.getMySecret(InitFieldKotlin.kt:7)
    at test.InitFieldKotlin.getMySecret(InitFieldKotlin.kt:7)
    at test.InitFieldKotlin.getMySecret(InitFieldKotlin.kt:7)
    at test.InitFieldKotlin.getMySecret(InitFieldKotlin.kt:7)

sealed class Option&lt;T&gt;

object None : Option&lt;Nothing&gt;() // &lt;-- like this

class Some&lt;T&gt; : Option&lt;T&gt;()

Nothing
Option
None
Option[Nothing]
Nothing
Nothing
Foo.()-&gt;Unit
val myLambda: Foo.()-&gt;Unit = { ... }
val myLambda = Foo.{ ... }
import java.util.*

class Graph&lt;Class&gt;(connectionProb: Double) {
    // a general network class
    val nodes = mutableListOf&lt;Class&gt;()
    val connectionProb = connectionProb
    val connections = hashMapOf&lt;Class, MutableList&lt;Class&gt;&gt;()

    var nextID = 0

    private fun createNode() {
        // Here is where I need help
    }
}

nextID
typealias NewKittiesReceived = (Kitty) -&gt; Unit

class KittyRepository {
    private val timer = Timer()
    private val random = Random()
    private val period = TimeUnit.SECONDS.toMillis(1)

    internal fun receiveNewKitties(newKittiesReceived: NewKittiesReceived) {
        timer.schedule(object : TimerTask() {
            override fun run() {
                val nameRandom = random.nextInt(KittyNames.values().size)
                val ageRandom = random.nextInt(5)

                newKittiesReceived.invoke(Kitty(KittyNames.values()[nameRandom].name, ageRandom))
            }
        }, period, period)
    }
}

Error:(25, 12) Kotlin: Type inference failed. Expected type mismatch: found: kotlin.Pair&lt;kotlin.Collection&lt;kotlin.String!&gt;, kotlin.Collection&lt;kotlin.String!&gt;&gt; required: kotlin.Pair&lt;kotlin.List&lt;kotlin.String&gt;, kotlin.List&lt;kotlin.String&gt;&gt;
Error:(30, 12) Kotlin: Type inference failed. Expected type mismatch: found: kotlin.Pair&lt;kotlin.Collection&lt;kotlin.Char!&gt;, kotlin.Collection&lt;kotlin.Char!&gt;&gt; required: kotlin.Pair&lt;kotlin.Set&lt;kotlin.Char&gt;, kotlin.Set&lt;kotlin.Char&gt;&gt;

java.lang.String!
kotlin.String!
fun List&lt;String&gt;.partitionWordsAndLines(): Pair&lt;List&lt;String&gt;, List&lt;String&gt;&gt; {
    return partitionTo(ArrayList&lt;String&gt;(), ArrayList&lt;String&gt;()) { s -&gt; !s.contains(" ") }
}
fun Set&lt;Char&gt;.partitionLettersAndOtherSymbols(): Pair&lt;Set&lt;Char&gt;, Set&lt;Char&gt;&gt; {
    return partitionTo(HashSet&lt;Char&gt;(), HashSet&lt;Char&gt;()) { c -&gt; c in 'a'..'z' || c in 'A'..'Z'}
}
inline fun &lt;reified T&gt; Collection&lt;T&gt;.partitionTo(first: MutableCollection&lt;T&gt;, second: MutableCollection&lt;T&gt;, predicate: (T) -&gt; Boolean): Pair&lt;Collection&lt;T&gt;, Collection&lt;T&gt;&gt; {
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
}

    val db = this.writableDatabase
    // Delete Caption by ID
    db.delete(
        TABLE_CAPTION,"$COLUMN_CAPTION_ID = ?",
        arrayOf(caption.id.toString())
    )
    db.close()
}

array.indexOf(item)
array.indexOfBy { lambda }
find
fun &lt;T : Any&gt; indexOfBy(items: Array&lt;T&gt;, predicate: (T) -&gt; Boolean): Int {
    for (i in items.indices) { // or (i in 0..items.size-1)
        if (predicate(items[i])) {
            return i
        }
    }
    return -1
}

forEach
fun &lt;T : Any&gt; indexOfBy(items: Array&lt;T&gt;, predicate: (T) -&gt; Boolean): Int {
    (items.indices).forEach {
        if (predicate(items[it])) {
            return it
        }
    }
    return -1
}

val slowAndSilly = people.indexOf(people.find { it.name == "David" })

fun &lt;T: Any&gt; Array&lt;T&gt;.indexOfBy(predicate: (T)-&gt;Boolean): Int =
        this.withIndex().find { predicate(it.value) }?.index ?: -1
fun &lt;T: Any&gt; Collection&lt;T&gt;.indexOfBy(predicate: (T)-&gt;Boolean): Int =
        this.withIndex().find { predicate(it.value) }?.index ?: -1
fun &lt;T: Any&gt; Sequence&lt;T&gt;.indexOfBy(predicate: (T)-&gt;Boolean): Int =
        this.withIndex().find { predicate(it.value) }?.index ?: -1

class Generic&lt;T : SuperType&gt;()

fun typeCheck(s: SuperType): Unit {
            when(s){
                is T -&gt; //do some thin
            }
        }

s
T
s as T
s
T
when(a)
{
   x    -&gt; doNothing()
   y    -&gt; doSomething()
   else -&gt; doSomethingElse()
}

x -&gt;        //doesn't compile
x -&gt; null   //Android Studio warning: Expression is unused
x -&gt; {}     //does work, but my corporate codestyle places each '{‘ in a new line, looking terrible
            //also, what is this actually doing?

x -&gt;
else -&gt; doSthElse()
x -&gt; Unit
objectA.objectB?.objectC?.objectD?.property = 1234

if (objectA.objectB == null) {
    objectA.objectB = ObjectB().apply {
        objectC = ObjectC().apply {
            objectD = ObjectD().apply {property = 1444}
        }
    }
} else {
    if (objectA.objectB.objectC == null) {
        objectA.objectB.objectC = ObjectC().apply {
            objectD = ObjectD().apply {property = 144}
        }
    }
}

abstract class Baz&lt;T : Baz&lt;T&gt;&gt; : Foo&lt;T&gt; {
    override fun bar(t: T): T = this
}

interface Foo&lt;Y&gt; {
    fun bar(t: Y): Y
}

Type mismatch: inferred type is Baz&lt;T&gt; but T was expected

Baz.bar
Baz&lt;T&gt;
abstract class Baz&lt;T : Baz&lt;T&gt;&gt; : Foo&lt;T&gt; {
    override fun bar(t: T): Baz&lt;T&gt; = this
}

Return type of 'bar' is not a subtype of the return type of the overridden member 'public abstract fun bar(t: Y): Y defined in Foo'

this as T
abstract class Baz&lt;T : Baz&lt;T&gt;&gt; : Foo&lt;Baz&lt;T&gt;&gt; {
    override fun bar(t: Baz&lt;T&gt;): Baz&lt;T&gt; = this
}

Baz&lt;T&gt;
T
onCheckedChanged()
var numberOfPlayers: Int = 0

override fun onCheckedChanged(group: RadioGroup?, checked: Int) {
    val chosen = activity?.findViewById&lt;RadioButton&gt;(checked)?.text
    numberOfPlayers = chosen.toString().toInt()
}

numberOfPlayers
chosen
null
toString()
null
NullPointerException
fun main(args: Array&lt;String&gt;) {
  var F = "32";
  var C = (F - 32) * .5555556;
  var conversion = "F  degrees Fahrenheit = C degrees Celsius"
  println(conversion);
}

data class Vec3i(
  override var x: Int = 0,
  override var y: Int = 0,
  override var z: Int = 0
) : Vec3t(x, y, z)

constructor(v: Vec3t&lt;Number&gt;) : this(v.x.toInt(), v.y.toInt(), v.z.toInt())

data class Vec3ub(
  override var x: Ubyte = Ubyte(0),
  override var y: Ubyte = Ubyte(0), 
  override var z: Ubyte = Ubyte(0)
) : Vec3t(x, y, z)

abstract class Vec3t&lt;T : Number&gt;(
  override var x: T, 
  override var y: T, 
  open var z: T
) : Vec2t(x, y)

Vec3i(vec3ub)

class Student(val id: Int, val name: String)

fun main() {
    val list = arrayListOf&lt;Student&gt;(Student(200, "Lim"), Student(100, "Kim"), Student(300, "Park"))

    println(list.map { Student::name })
    println(list.map { student -&gt; student.name })
}

[val Student.name: kotlin.String, val Student.name: kotlin.String, val Student.name: kotlin.String]
[Lim, Kim, Park]

a = listOf(1, 2, 3, 4)
println(a[-2])

IndexOutOfBoundsException
get
List
operator fun &lt;T&gt; List&lt;T&gt;.get(index: Int): T =
        // Here this should call the non-overridden version of
        // get. 
        get(index % size)

fun &lt;T&gt; List&lt;T&gt;.safeGet(index: Int): T = get(index % size)

index % size
%
fun getItem(value: Int): String = when (getPosition(value)) {
   0 -&gt; "Zero"
   1 -&gt; "One"
   2 -&gt; "Two"
   else -&gt; "Other"
}

&gt;0 -&gt; "Positive"

0-10 -&gt; "Postively small"

public inline fun &lt;T&gt; intrinsicSync(block: () -&gt; T): T {
    return synchronized(intrinsicLockOfTheObjectUsingTheFunction) {
        block()
    }
}

fun someFunction(parameter: SomeClass) {
    intrinsicSync(sharedResource.operation(parameter))
}

fun someFunction(parameter: SomeClass) {
    synchronized(this) {
        sharedResource.operation(parameter)
    }
}

someLock.withLock {
    sharedResource.operation()
}

synchronized(someLock) {
    sharedResource.operation()
}

Pair&lt;Int, String&gt;
list.sortedWith(Comparator.comparingInt&lt;Pair&lt;String, Int&gt;&gt; { it.second }
    .thenComparing { it -&gt; it.first })

{ it -&gt;
it -&gt;
var c = Comparator
    .comparingInt&lt;Pair&lt;String, Int&gt;&gt; { it.second }
    .thenComparing { it -&gt; it.first }

it
 var c = Comparator
     .comparingInt&lt;Pair&lt;String, Int&gt;&gt; { it.second }
     .thenComparing { it.first }

     class FilterActivity : AppCompatActivity() {
        private fun setPrice(value: Int) {

        }

        var priceUpdateFloat: Float= 0.0f

        object pricelistener : OnRangeChangedListener {
            override fun onStartTrackingTouch(view: RangeSeekBar?, isLeft: Boolean) {


                //To change body of created functions use File | Settings | File Templates.
            }

            override fun onRangeChanged(view: RangeSeekBar, leftValue: Float, rightValue: Float, isFromUser: Boolean) {

                priceUpdateFloat = leftValue  //error here unresolved reference
                setPrice(leftValue) //error here unresolved reference

                Log.d(TAG, "left value is" + view.leftSeekBar + "isFromUser_" + isFromUser)

            }

            override fun onStopTrackingTouch(view: RangeSeekBar?, isLeft: Boolean) {
                //To change body of created functions use File | Settings | File Templates.
            }


    }

    ...
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.fragment_filter)


  price_seek_bar1.setOnRangeChangedListener(
                pricelistener
        )

    ...
    }

        var value1: Float? = null
        var value2: Float? = null
        var suma: Boolean = false
        var resta: Boolean = false
        var multi: Boolean = false
        var div: Boolean = false

        plus.setOnClickListener {
            if (expression == null) {
                expression.text = ""
            } else {
                value1 = expression.text.toString().toFloat()
                suma = true
                expression.text = ""
            }
        }

        mul.setOnClickListener {
            if (expression == null) {
                expression.text = ""
            } else {
                value1 = expression.text.toString().toFloat()
                multi = true
                expression.text = ""
            }
        }

        minus.setOnClickListener {
            if (expression == null) {
                expression.text = ""
            } else {
                value1 = expression.text.toString().toFloat()
                resta = true
                expression.text = ""
            }
        }

        divide.setOnClickListener {
            if (expression == null) {
                expression.text = ""
            } else {
                value1 = expression.text.toString().toFloat()
                div = true
                expression.text = ""
            }
        }

        dot.setOnClickListener {
            expression.text = expression.text.toString() + "."
        }

        clear.setOnClickListener {
            expression.text = ""
            value1 = null
            value2 = null
        }

        equal.setOnClickListener {
            value2 = expression.text.toString().toFloat()

            if (suma) {
                var s = value1 + value2
                expression.text = s.toString()
            }
            if (resta) {
                var r = value1 - value2
                expression.text = r.toString()
            }
            if (div) {
                var d = value1 / value2
                expression.text = d.toString()
            }
            if (multi) {
                var m = value1 * value2
                expression.text = m.toString()
            }
        }

value1.plus(value2)
only save or non-null asserted calls are allowed on a nullable reciever of type Float?
var value1: Float? = null
var value2: Float? = null

.kt
Operation.kt
sub()
add()
class Operation {
    fun add(x: Int, y: Int): Int {
        return x + y
    }
}

fun sub(x: Int, y: Int): Int {
   return x + y
}

myString.isEmpty()
myString == ""
myString.isEmpty()
myString.isBlank()
Pair&lt;User, User&gt;
Pair&lt;User, User&gt;
private fun findUsers(instanceWrapper: ExceptionInstanceWrapper): Any {
    return object {
        val sender = userCrud.findOne(instanceWrapper.fromWho)
        val receiver = userCrud.findOne(instanceWrapper.toWho)
    }
}

// ...
val users = findUsers(instanceWrapper)
users.sender // ...
users.receiver // ...
// ...

open class KotlinBase {
    companion object {
        const val TAG = "testing"
    }
}

class KotlinChild : KotlinBase()

public class JavaOther {
    String test1 = KotlinBase.TAG; // This is okay
    String test2 = KotlinChild.TAG; // This is okay
}

class KotlinOther {
    val test1 = KotlinChild.TAG  // Compile/Syntax error
    val test2 = KotlinBase.TAG   // This is okay
}

TAG
KotlinChild
fun main(args: Array&lt;String&gt;) {
    "test1, test2, test3".split(", ")
            .toCustomString(StringBuilder(), StringBuilder::append)
}

fun &lt;T, R&gt;Iterable&lt;T&gt;.toCustomString(obj: R, thing: R.(T) -&gt; Unit): R {
    this.forEach {
        obj.thing(it)
    }
    return obj
}

StringBuilder::append
val ls = arrayListOf&lt;Int&gt;(0,0,0,0,0)

// can create zero padding array list but not looks smart
val ls = arrayListOf&lt;Int&gt;()
for (i in 0..n){
  ls.add(0)
}

String
Int
val a: Unit = { _: Any -&gt; String }(Int)

val a: Unit = { x: Any -&gt; x.toString() }(Unit)

val map = listOf(Pair("a", 1), Pair("b", null), Pair("c", 3), Pair("d", null))
    .associateBy({ it.first }, { it.second })
println(map)

val map2 = listOf(Pair("a", 1), Pair("b", null), Pair("c", 3), Pair("d", null))
    .mapNotNull {
        if (it.second != null) it else null
    }.toMap()    
println(map2)

Map&lt;String, Int&gt;
Map&lt;String, Int?&gt;
Transformations
val allTransformations = ArrayList&lt;Transformation&gt;().apply {
    for (moveZ in 0..4)
        for (moveY in 0..4)
            for (moveX in 0..4)
                for (rotateZ in 0..3)
                    for (rotateY in 0..3)
                        for (rotateX in 0..3)
                            add(Transformation(rotateX, rotateY, rotateZ, moveX, moveY, moveZ))
}

interface Query&lt;T&gt;

@PublishedApi
@PublishedApi
internal class QueryImpl&lt;T&gt; : Query&lt;T&gt;

typealias MatchQuery = Query&lt;MatchQueryProperties&gt;

inline fun match(init: MatchQuery.() -&gt; Unit) {
    // It would look nicer if I could use MatchQueryImpl().init()
    QueryImpl&lt;MatchQueryProperties&gt;().init()
}

QueryImpl&lt;PropertiesType&gt;
// fails because it needs to be internal
typealias MatchQueryImpl = QueryImpl&lt;MatchQueryProperties&gt;

// can't be used in public inline functions
internal typealias MatchQueryImpl = QueryImpl&lt;MatchQueryProperties&gt; 

// annotation can't be used on typealias
@PublishedApi internal typealias MatchQueryImpl = QueryImpl&lt;MatchQueryProperties&gt;

@PublishedApi internal typealias
var value1: Float = 0f
var value2: Float = 0f
var operator: String = "n"

val input = expression.text.toString().trim()

//this is the adding button the subtracting, multiplying, and dividing are basically the exact code 
plus.setOnClickListener {
    if (input.isNullOrBlank()) {
        expression.text = ""
    } else {
        operator = "sum"
        value1 = expression.text.toString().toFloat()
        expression.text = ""
    }
}

//equals button
equals.setOnClickListener {
    val input2 = expression.text.toString().trim()

    if (!input2.isNullOrBlank()) {
        value2 = expression.text.toString().toFloat()

        // this is the textView and it always shows up as n
        expression.text = operator 

        //it never goes in any of these, I don't know if I'm setting it up wrong in the action buttons (add, sub, multi, div)
        if (operator == "sum") {
            var s = value1 + value2
            expression.text = s.toString()
            operator = "n"
        }    
        if (operator == "sub") {
            var r = value1 - value2
            expression.text = r.toString()
            operator = "n"
        }
        if (operator == "div") {
            var d = value1 / value2
            expression.text = d.toString()
            operator = "n"
        }
        if (operator == "multi") {
            var m = value1 * value2
            expression.text = m.toString()
            operator = "n"
        }
    }
}

val String.extProp: String
    get() = "Some get code"

fun foo() {
    val prop: KProperty&lt;String&gt; = String::extProp
}

class Example() {

    val String.extProp: String
        get() = "Some get code"

    fun foo() {
        val prop: KProperty&lt;String&gt; = String::extProp // error
    }

}

val s: String? = "test"

if (s != null) {
   s.startsWith("3") // This works
}

if (!s.isNullOrEmpty()) {
    s.startsWith("3") // Not working
}

size
elements
for
fun listOfLists(size: Int, vararg elements: String): List&lt;List&lt;String&gt;&gt; {
    var amountOfElements = elements.size
    var currentSubList: List&lt;String&gt; = mutableListOf&lt;String&gt;()
    val numberOfLists: Int = amountOfElements / size + 1

    for (n in 0..numberOfLists) {
        // Code for creating the total number of lists needed
    }

    for (e in elements) {
        if (amountOfElements % size == 0) {
            // Code for switching lists
        }
        amountOfElements--
    }

data class Constraint(val hint: String)

class Validation(val constraints: List&lt;Constraint&gt;) {

    companion object {
        operator fun invoke(init: (ValidationBuilder.() -&gt; Unit)): Validation {
            return ValidationBuilder().apply(init).build()
        }
    }

    class ValidationBuilder {
        private var constraints: MutableList&lt;Constraint&gt; = mutableListOf()

        operator fun Constraint.unaryPlus() {
            constraints.add(this)
        }

        fun build() = Validation(constraints)
    }
}

val validation = Validation {
    +Constraint("First constraint")
    val secondConstraintHint = "Second constraint"
    +Constraint(secondConstraintHint)
}

unaryPlus
Constraint
val validation = Validation {
    Constraint("First constraint")
    val secondConstraintHint = "Second constraint"
    Constraint(secondConstraintHint)
}

Validation&lt;User&gt; {
    User::firstName {
        val min = 2
        minLength(min) hint "Please provide a first name"
        maxLength(200) // uses default hint
    }
}

var x : String = "str"

// here do some with x, but not assign new value to it

val
var
var
val
x
val
val
var
var
val
fun copyAddress(address: Address): Address {
    val result = Address() // there's no 'new' keyword in Kotlin
    result.name = address.name // accessors are called
    result.street = address.street
    // ...
    return result
}

var
val
f
bar
open class Bar(val b: Int)

class Foo(val f: Int) {
    object bar : Bar(f)
//                   ^
//         Unresolved reference: f

}

bar
open class Bar(val b: Int)

class Foo(val f: Int) {
    val bar = Bar(f)
}

private data class TestData(var i: String, var j: Int) : Any() {}
private var mlist = mutableListOf&lt;TestData&gt;()

fun main(args: Array&lt;String&gt;) {

    mlist.add(TestData("Hi", 5))
    mlist.add(TestData("There", 53))
    mlist.add(TestData("Test", 2345))
    for ((i, v) in mlist.withIndex()) {

       println(i.toString() + " ok " + v.i + " " + v.component2())//Why does this line compile? 

       println("${i::class.qualifiedName}") // Printed classname is Int
   }
}

fun &lt;T&gt; Array&lt;out T&gt;.withIndex(): Iterable&lt;IndexedValue&lt;T&gt;&gt; (source)

v.i
//defines environment variables and functions that are not dependant on the dev, prod and acc builds of the app

struct Environment {

    //defines constants that are independant of the environment
    struct Constants {
        static let unInitializedId          = "unInitializedId"
        static let userLanguageKey          = "userlanguage"
        struct IAP {
            static let prodId_PackagePrefix     = "com.example.packprefix"
            static let prodId_Package_Custom    = "com.example.custom"
            static let prodId_Package_Favorites = "com.example.fav"
        }
    }
    //different storyboards used in the app
    struct StoryBoard {
        static let main       = "main"
        static let exercises  = "exercises"
        static let trainings  = "trainings"
        static let packages   = "packages"
        static let videos     = "videos"
        static let common     = "common"
        static let alerts     = "alerts"
    }

    static let downloadManager = DownloadManager(diskCacheFolder: "cache_downloadmanager")
    static let remoteConfig    = RemoteConfig.remoteConfig()
}


//defines environment stuff special for PROD builds
//this is included in a seperate file (only included to build for PROD builds)
extension Environment {

    static let remoteConfig = RemoteConfig.remoteConfig()

    struct Constants {
        static let appId = 1010123
    }

    static func start() {
        //...some prod environment init code here
    }
}


func howItsUsed() {
    //initialize the build dependant environment
    Environment.start()
    //get build independant constant and obj out of the environment
    let buildIndependant_var = Environment.Constants.unInitializedId
    let buildIndependant_iap = Environment.Constants.IAP.prodId_PackagePrefix
    let buildIndependant_obj = Environment.downloadManager
    //get build specific constant &amp;object
    let buildspecific_var = Environment.Constants.appId
    let buildspecific_obj = Environment.remoteConfig
}

sealed class Environment {

    companion object {
        const val name: String = "development"

        fun start() {
           //...some prod environment init code here
        }
    }
}

kotlin_version = '1.2.30'

40
saveDirection(Direction.Right.code)

 enum class Direction(val code: Int) {
        UP(10),
        DOWN(20),
        LEFT(30),
        RIGHT(40),
        NONE(0)
    }

sealed class Direction {
    abstract val code: Int

    data class Up(override val code: Int): Direction()
    data class Down(override val code: Int): Direction()
    data class Left(override val code: Int): Direction()
    data class Right(override val code: Int): Direction()
    data class None(override val code: Int): Direction()
}

saveDirection(direction: Int)
saveDirection(Direction.Right(40))

public class Test {
  public A a = new A();

  private class A {
  }
}

A
public
class Test {
    var a = A()
//      ^  
// 'public' property exposes its private type 'A'

    private inner class A
}

fun foo(m: String, bar: (m: String) -&gt; Unit) {
    bar(m)
}

foo("a message", { println("this is a message: $it") } )
//or 
foo("a message")  { println("this is a message: $it") }

fun buz(m: String) {
   println("another message: $m")
}

foo("a message", buz)

t.let{}
return@map
fun listAllMoviesBy(actor: String, client: DatabaseClient) {
    client.execute()
            .sql { "SELECT fin.id, full_name, movie_title, make_year, celeb_id, birth_date " +
                    "FROM featured_in fin JOIN film_celeb fc ON " +
                    " fin.celeb_id = fc.id WHERE fc.full_name = $1"
            }.bind(0, actor).map { t, u -&gt;
                t.let {
                   val featuredIn = FeaturedIn(it.get("id") as Int, it.get("movie_title") as String, it.get("make_year") as Int)
                   val celeb = MovieCeleb(it.get("celeb_id") as Int, it.get("full_name") as String, it.get("birth_date") as LocalDate, featuredIn)
                    return@map celeb
                }
            }.all()
            .subscribe{
                println(it)
            }
}

@Suppress
@Suppress
@Suppress
class Foo {

    public static Foo instance;
    public Foo() {
        instance = this;
    }

}

fun someFun(x: Any) {

}

fun foo(bar: (val x: Any) -&gt; Unit) {

}

fun baz() {
    foo(::someFun)
}

class Test {
    fun someFun(x: Any) {

    }

    fun foo(bar: (val x: Any) -&gt; Unit) {

    }

    fun baz() {
        foo(::someFun)
    }
}

foo
var temp: Byte = 0
var temp2: Byte = 1
temp += temp2

kotlin 1.3.61

copy
class Marketing {
    data class Model(
        val title: String = "",
        val description: String = "",
        val icon: Int,
        val background: Int)

    class Builder() {
        private var title: String = ""
        private var description: String = ""

        private val PRODUCT = Model(
            icon = 111111,
            background = 333333)

        private val SALES = Model(
            icon = 222222,
            background = 444444)

        fun title(title: String): Builder {
            this.title = title
            return this
        }

        fun description(description: String): Builder {
            this.description = description
            return this
        }

        fun buildProduct(): Model {
            return PRODUCT.copy(title = title, description = description)
        }

        fun buildSales(): Model {
            return SALES.copy(title = title, description = description)
        }
    }
}

val product = Marketing.Builder()
    .description("this is the description of the product")
    .title("this is the title of the product")
    .buildProduct()

val sales = Marketing.Builder()
    .description("this is the description of the sales")
    .title("this is the title of the sales")
    .buildSales()

buildProduct()
buildSales()
{
  "result": {
    "response": {
      "data": [
        {
          "identification": {
            "id": null,
            "number": {
              "default": "IA224",
              "alternative": null
            },
            "callsign": null,
            "codeshare": null
          }
        }
      ]
    }
  }
}

data :  null

Caused by: org.json.JSONException: Value null of type org.json.JSONObject$1 cannot be converted to JSONArray

val jsonArray = JSONArray(response.get("data").toString())

            if(jsonArray.isNull(0)){
               jsonArray.getJSONObject(0).getString("data");
            }

data class PhoneNumber(val prefix: String, private val lineNumber: String)

lineNumber
val phoneNumber = PhoneNumber("0676", "123456")
// toString() = PhoneNumber(prefix=0676, lineNumber=123456)

toString()
lineNumber
toString()
lineNumber
toString()
val(firstList, secondList) = listOfPairs.unzip()
// listOfPairs: List&lt;Pair&lt;String, Long&gt;&gt;

Triple
viewModel.allCheeses.observe(this, Observer(adapter::submitList))
viewModel.allCheeses.observe(this, Observer { adapter.submitList(it) })
override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        val adapter = CheeseAdapter()
        cheeseList.adapter = adapter

        viewModel.allCheeses.observe(this, Observer { adapter.submitList(it) })
        //viewModel.allCheeses.observe(this, Observer(adapter::submitList))


        initAddButtonListener()
        initSwipeToDelete()
}



public interface Observer&lt;T&gt; {
    /**
     * Called when the data is changed.
     * @param t  The new data
     */
    void onChanged(T t);
}

    fun method1(par: Boolean){}
    fun method2(par: Boolean) : Int{return 1}
    fun method3(par: Boolean, par2: Boolean) : Int{return 1}

    var funtionHolder : ((Any)-&gt;Any) ?= null  //What should I write here?? so to hold any type of function

   fun method4(){
        .........
        funtionHolder = ::method1  //getting compile time error
        .........
        funtionHolder = ::method2  //getting compile time error
        .........
        funtionHolder = ::method3  //getting compile time error
    }

fun destroyBrains(justKillMe: BaseClass &amp; IListener) {
}

BaseClass
IListener
int i = 65;
char c = (char) i; // 'A'

Button.setOnAction {
File.Open(*//specified file path*)  
        }

Kotlin
class Bar {
    fun bazz() {
        UtilClass.instance.foo()
        UtilClassObject.UtilClassObject.foo()
        UtilCompanionObject.foo()
        UtilFileObject.foo()
        foo() // from UtilFile
    }
}

public class Qux {
    public void bazz() {
        UtilClass.Companion.getInstance().foo();
        UtilClassObject.UtilClassObject.INSTANCE.foo();
        UtilFileKt.foo();
        UtilFileObject.INSTANCE.foo();
        UtilCompanionObject.Companion.foo();
    }
}

class UtilClass {
    fun foo() { ... }

    companion object {
        val instance = UtilClass()
    }
}

class UtilClassObject {
    object UtilClassObject {
        fun foo() { ... }
    }
}

class UtilCompanionObject {
    companion object {
        fun foo() { ... }
    }
}

fun foo(){ ... }

object UtilFileObject {
    fun foo() { ... }
}

listOfChecklist.clearAndAddAll()
listOfChecklist.clear()
listOfChecklist.addAll(newList)

fun &lt;E&gt; MutableCollection&lt;E&gt;.clearAndAddAll(replace: MutableSet&lt;E&gt;) {
    clear()
    addAll(replace)
}

Weekdays
entity
Weekdays
   Weekdays(entity.isMonday,
            entity.isTuesday,
            entity.isWednesday,
            entity.isThursday,
            entity.isFriday,
            entity.isSaturday,
            entity.isSunday)

entity
entity
       var p = person {
            age = 22
            gender = "male"
            name {
                first = "Ali"
                last = "Rezaei"
            }
        }

data class Person(var age: Int? = null, var gender: String? = null
                      , var name : Name? = null) {
    }

    fun name(init: Name.() -&gt; Unit): Name {
        val n = Name()
        n.init()
        return n
    }

    data class Name(var first: String? = null, var last : String? = null)

    fun person(init: Person.() -&gt; Unit): Person {
        val p = Person()
        p.init()
        return p
    }

Person(age=22, gender="male", name=null)

_
val _ = 3
Names _, __, ___, ..., are reserved in Kotlin

fun &lt;T, R&gt; Iterable&lt;T&gt;.firstNonNullMapping(transform: (T) -&gt; R?): R? {
    for (element in this) {
        val result = transform(element)
        if (result != null) {
            return result
        }
    }
    return null
}

val firstNonNullMapping = listOf(null, 'a', 'b')
        .firstNonNullMapping {
            assertNotEquals(it, 'b') // Mapping should be stopped before reaching 'b'
            it
        }
assertEquals(firstNonNullMapping, 'a')

return this
        .map { transform(it) }
        .firstOrNull { it != null }

class A {
   var initFunc: B.() -&gt; Unit
   fun initWith(func: B.() -&gt; Unit) {
        this.initFunc = func
    } 
    fun test() {
      val b = B()
      b.apply{ initFunc }
    }
}

class B {
    fun init() {...}
}
...
val a = A()
a.initWith{ init() }
a.test()

class IsTesting(val myProperty: Int) {
    override fun equals(other: Any?): Boolean = when(other) {
        is IsTesting -&gt; this.myProperty == other.myProperty
        else -&gt; false
    }
}

fun main() {
    val a = IsTesting(42)
    val b = IsTesting(42)
    if (a == b)
        println("equal")
    else
        println("not equal")
}

        is this::class -&gt; this.myProperty == other.myProperty

Error:(3, 12) Kotlin: Type expected

Expression&lt;Func&lt;T, ...&gt;&gt;
import java.util.*

fun main(args: Array&lt;String&gt;) {
    val foo = Foo&lt;Model&gt;()
    foo.bar { it.age }
    // Should print "age"
}

data class Model(val id: UUID, val name: String, val age: Int)

class Foo&lt;T&gt; {
    fun bar(expression: (x: T) -&gt; Any) {
        println(/*The name of the parameter*/)
    }
}

@JsonInclude(JsonInclude.Include.NON_EMPTY)
open class AbstractDto : Serializable {

    open var id: Long? = null
    open var created: LocalDateTime? = null
    open var updated: LocalDateTime? = null
}

open class UserDto : AbstractDto() {

    open var height: Int? = null
    open var weight: Double? = null
    open var gender: String? = null
    open var birthDate: LocalDateTime? = null
    open val contacts: List&lt;ContactDto&gt; = ArrayList()
}

@RestController
@RequestMapping("/user")
@ControllerImpl
class UserController : AbstractController&lt;User, UserDto, UserMapper, UserRepository, UserServiceImpl&gt;()

open class AbstractController&lt;
        E : AbstractEntity,
        D : AbstractDto,
        M : AbstractMapper&lt;E, D&gt;,
        R : CommonRepository&lt;E&gt;,
        S : AbstractService&lt;E, D, M, R&gt;
        &gt; : CommonController&lt;D&gt; {

    private val service: S? = null

    override fun save(dto: D?): ResponseEntity&lt;D&gt; = ResponseEntity.ok(service!!.save(dto)!!)

    override fun update(dto: D): ResponseEntity&lt;D&gt; = ResponseEntity.ok(service!!.update(dto)!!)

    override fun get(id: Long): ResponseEntity&lt;D&gt; = ResponseEntity.ok(service!!.get(id)!!)

    override fun getAll(pageable: Pageable): ResponseEntity&lt;Page&lt;D&gt;&gt; = ResponseEntity.ok(service!!.getAll(pageable))

    override fun delete(id: Long): ResponseEntity&lt;Boolean&gt; = ResponseEntity.ok(service!!.delete(id))
}

interface CommonController&lt;D : AbstractDto&gt; {

    @PostMapping
    fun save(dto: D?): ResponseEntity&lt;D&gt;

    @PutMapping
    fun update(dto: D): ResponseEntity&lt;D&gt;

    @GetMapping("/all")
    fun get(id: Long): ResponseEntity&lt;D&gt;

    @GetMapping
    fun getAll(pageable: Pageable): ResponseEntity&lt;Page&lt;D&gt;&gt;

    @DeleteMapping
    fun delete(id: Long): ResponseEntity&lt;Boolean&gt;
}

{
    "height": 180,
    "weight": 75,
    "user": 1
}

class Foo {
   public fun bar(i: Int = 0): Int = 2 * i
}

def f = new Foo()
f.bar() //throws:  java.lang.IllegalArgumentException: Parameter specified as non-null contains null

null
null
null
class MyClass : Any {

}

open class Person(open var firstname: String, open var surname: String,
          open var age: Int) {

val thisyear: Int = Calendar.getInstance().get(Calendar.YEAR)

val dob = thisyear - age

fun printperson() {

    println("$firstname $surname was born in $dob")

}
}

class Student(override var firstname: String, override var surname: 
                String, override var age: Int, val studentID: Int):    
                    Person(firstname, surname, age) {

fun returnDetails() {

    println("Hello $firstname, your Student ID is: $studentID")
}
}

fun main(args: Array&lt;String&gt;) {

val studentMike = Student(firstname = "Mike", 
                  surname = "Stand", age = 67, studentID = 8899)

studentMike.printperson()
studentMike.returnDetails()

val personBill = Person(firstname = "Bill", surname = "Hook", age = 34)
personBill.printperson()

}

Mike Stand was born in 2018
Hello Mike, your Student ID is: 8899
Bill Hook was born in 1984

private val listenersUpdateState: HashMap&lt;WeakReference&lt;IStatusesListener&gt;, Boolean&gt; = HashMap()

private fun setAllListenersToReadyToUpdate() {
    listenersUpdateState.keys.forEach { key -&gt; 
        listenersUpdateState[key] = false
    }
}

 fun getRoamingStatusErrorItem(): SettingItem {
        return SettingRoamingItem(
            isRoaming = false,
            processingText = "",
            isEnabled = false,
            isErrorVisible = true,
            isProgressVisible = false)
    }

    fun getRoamingStatusProgressItem(): SettingItem {
        return SettingRoamingItem(
            isRoaming = false,
            processingText = "",
            isEnabled = false,
            isErrorVisible = false,
            isProgressVisible = true)
    }

    fun getRoamingStatusProcessingItem(text: String): SettingItem {
        return SettingRoamingItem(
            isRoaming = false,
            processingText = text,
            isEnabled = false,
            isErrorVisible = false,
            isProgressVisible = false)
    }

metadataOf(
   "sId" to "123",
   "uId" to "456"
)

metadataOf()
fun &lt;VALUE&gt; metadataOf(vararg pairs: Pair&lt;String, VALUE&gt;) =
    MetaData.from(pairs.toMap())!!

metadataOf(
   "sId" to "123",
   "uId" to "456"
)

metadata.message
metadataFrom(message)
interface Foo {
  fun bar(parameter: Int = 1)
}

class Baz : Foo {
  override fun bar(parameter: Int) { // OK
    println(parameter)
  }
}

val baz = Baz()

baz.bar() // OK
baz.bar(2) // OK

Foo
class Person(name: String) {
}

val person = Person("Name")
person.name

val matrix: FloatArray = emptyArray&lt;Float&gt;().toFloatArray()
XXXArray
fun main(Args : Array&lt;String&gt;){
  var list = listOf(1,2,3)
  for(x in list){
    print(x.toChar())
  }
}

String
map
strings.map { gson.fromJson(it, Model::class.java) }
// .doOtherStuff

doOtherStuff
Sequence
Sequence
generateSequence(0) { it + 1 }.windowed(size = 100, step = 1)

distinct()
return ArrayList(originalItems)
    .sortedWith(compareBy({ it.localHits }, { it.title }))

compareByDescending()
fun leftPad(value: String, length: Int = 3, char: Char = ' '): String = value.padStart(length, char)

length: Int? = getLength()
char: Char? = getChar()
leftPad(value, length = length, char = char)

fun leftPad(value: String, length: Int? = null, char: Char? = null): String {
        val length = length ?: 4
        val char = char ?: ' '
        return value.padStart(length, char)
    }

private companion object
Companion
@Deprecated public
private
class MyClassWithCompanion {
    private companion object {
        private val FOO = "FOO"
    }
}

// DEPRECATED
// access flags 0x20019
public final static LMyClassWithCompanion$Companion; Companion
@Ljava/lang/Deprecated;()

table = Map&lt;K, V&gt;
f: (K) -&gt; M?
Map&lt;M, V&gt;
table.mapKeys{ f(it.key) }.filter{it != null} as Map&lt;M, V&gt;
Map&lt;M?, V&gt;
Map&lt;M, V&gt;
table.filterKeys(f(it) != null).mapKeys(f)
f
table.mapNotNull { f(it.key)?.let {res -&gt; res to it.value} }.toMap()
MutableMap
open
open
buildscript {
  dependencies {
    classpath "org.jetbrains.kotlin:kotlin-allopen:$kotlin_version"
  }
}

apply plugin: "kotlin-allopen"

allOpen {
  annotation("com.mycompany.myapp.annotation")
}

package com.mycompany.myapp.annotation
annotation class AllOpenAnnotation

@AllOpenAnnotation
class Model {
  var id: Int = -1,
  var title: String = "",
  var desc: String? = null
}: RealmObject()

error: cannot inherit from final Model
Class&lt;?&gt; clazz = Class.forName("com.mydomain.myapp.someclass");
Constructor&lt;?&gt; ctor = clazz.getConstructor(String.class);
Object object = ctor.newInstance(new Object[] { ctorArgument });

fun &lt;VALUE&gt; metadataOf(vararg pairs: Pair&lt;String, VALUE&gt;) =
    MetaData.from(pairs.toMap())!!

 metadataOf(
   "sId" to message.sId,
   "userId" to message.userId
)

message
metadataOf(vararg pairs: Pair&lt;String, VALUE&gt;)
fun metadataFrom( message: CommandMessage&lt;Any&gt; ): Pair&lt;String, Any&gt; {
     return  (
        "sId" to message.sId,
        "userId" to message.userId
        )
}

ByteArray?
String?
null
null
fun toBase64String(array: ByteArray?): String? = if(array == null) null else 
    Base64.getEncoder().encodeToString(array)

ByteArray
String?
val base64 = toBase64String(ByteArray(4))

base64
String
String?
lateinit
class Foo() {

    private lateinit var myFile: File

    fun bar(path: String?) {
        path?.let { myFile = File(it) }
    }

    fun bar2() {
        myFile.whateverMethod()
        // May crash since I don't know whether myFile has been initialized
    }
}

 class InstituteSearchDetails (var centerId: String) {


lateinit var centerId: String;
lateinit var instituteName: String;
lateinit var city: String;

init {
    this.centerId=centerId
}
constructor( instituteName: String, city: String)
{
    this.instituteName=instituteName;
    this.city=city;

}
}

fun&lt;T&gt; doSomething(value: T, action: (value: T) -&gt; String = Any::toString){
  //do something
}

Kotlin: Type mismatch: inferred type is KFunction1&lt;Any, String&gt; but (T) -&gt; String was expected

fun&lt;T&gt; doSomething(value: T, action: (t: T) -&gt; String = {t -&gt; t.toString()}) = action(value)

propA=valueA
propB=valueB

data class Test(var propA: String = "", var propB: String = ""){}

val test: Test = Test()
rawResp?.split('\n')?.forEach { item: String -&gt;
    run {
         val keyValue = item.split('=')
         TODO
    }
}

response.split('\n').forEach(item =&gt; {
    let keyValue = item.split('=');
    this.test[keyValue[0]] = keyValue[1];
 });

"Alex": [Work(workPlace="workPlace", years=1),
        Work(workPlace="workPlace", years=4),
        Work(workPlace="workPlace", years=5),
        Work(workPlace="workPlace", years=1)],

"John": [Work(workPlace="workPlace", years=2),
        Work(workPlace="workPlace", years=2),
        Work(workPlace="workPlace", years=1),
        Work(workPlace="workPlace", years=6)]

val wordArray = arrayOf("empowered", "leveraged", "aligned", "targeted")
val intArray = arrayOf(1, 2, 3, 4)

val myObjectArray = arrayOf(2, "Dos", 2.2F)

val newPhrase = "myObjectArray[0] = ${myObjectArray[0]}, " +
            "myObjectArray[1] = ${myObjectArray[1]}, " +
            "myObjectArray[2] = ${myObjectArray[2]}"
println(newPhrase)
for(item in myObjectArray){
     println(item.javaClass.toString())
}

myObjectArray[0] = 2, myObjectArray[1] = Dos, myObjectArray[2] = 2.2 
class java.lang.Integer 
class java.lang.String 
class java.lang.Float

myObjectArray[0] = 4.4       // It doesn't compile
myObjectArray[1] = 'c'       // It doesn't compile
myObjectArray[1] = 4         // It compiles
myObjectArray[1] = 4.4      // It doesn't compile
myObjectArray[2] = 4        // It compiles
myObjectArray[2] = "cadena" // It compiles   
myObjectArray[2] = 4L       // It doesn't compile

myObjectArray[0] = 2, myObjectArray[1] = 4, myObjectArray[2] = cadena
class java.lang.Integer
class java.lang.Integer
class java.lang.String

var byteArray1 = byteArrayOf(1,2,3)
var byteArray2:Array&lt;Byte&gt; = arrayOf(1,2,3)

Date
NoData
val dateOfTheFinancialStatementsAtUnderwriting: Date || NoData

Error:(191, 39) Kotlin: Unresolved reference: JSBot

public abstract class JSBot extends Evaluable implements Name {
...
}

 Destructuring declaration initializer of type Int must have a 'component1()' function

val pathXRanges = listOf&lt;(Int) -&gt; List&lt;Int&gt;&gt;(
                {(extX) -&gt; ((extX - (board.k - 1))..(extX + board.k - 1)).toList()}, // diagonal 1 (y = -x)
                {(extX) -&gt; ((extX - (board.k - 1))..(extX + board.k - 1)).toList()}, // diagonal 2 (y = x)
                {(extX) -&gt; List(board.k * 2 - 2) { extX } }, // x = x
                {(extX) -&gt; ((extX - (board.k - 1))..(extX + board.k - 1)).toList()} // y = y
        )

interface IPrinter {
    fun print()
}

open class Printer: IPrinter {

    companion object {
        private var printers = mutableMapOf&lt;String, IPrinter&gt;()

        @Synchronized
        fun getInstance(key: String, lambda: (key: String) -&gt; IPrinter): IPrinter {
            if (printers[key] == null) {
                printers[key] = lambda(key)
            }
            return printers[key]!!
        }
    }

    private constructor(key: String) { // can use init too here.
        // some initializers
    }

    override fun print() {
        print("default implementation")
    }

    // ... other methods
}

// it has to extend PrinterHost to inherit methods, problem -&gt; Printer()
class PrinterImplementation: Printer(), IPrinter {

    companion object {
        fun getInstance(key: String): IPrinter {
            return Printer.getInstance(key) { key -&gt; PrinterImplementation() }
        }
    }

    override fun print() {
        println("Print page from printer")
    }

}

// Usage: PrinterImplementation.getInstance("myPrinter")

class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView)

public abstract static class ViewHolder {


    public ViewHolder(View itemView) {
        if (itemView == null) {
            throw new IllegalArgumentException("itemView may not be null");
        }
        this.itemView = itemView;
    }

Database
import com.github.davidmoten.rx.jdbc.ConnectionProviderFromUrl
import com.github.davidmoten.rx.jdbc.Database

object DbManager {
    val database : Database =
            Database.from(ConnectionProviderFromUrl("jdbc:sqlite:C:/Users/Thomas/OneDrive/Data/finance_rx.db").get())
}

database
import com.github.davidmoten.rx.jdbc.ConnectionProviderFromUrl
import com.github.davidmoten.rx.jdbc.Database

private val database : Database =
        Database.from(ConnectionProviderFromUrl("jdbc:sqlite:C:/Users/Thomas/OneDrive/Data/finance_rx.db").get())

fun db(): Database = database;

MySingleton.getInstance().getDb()
@Volatile private var INSTANCE: SomeClass? = null

fun getInstance(someValue: SomeType): SomeClass{
    return INSTANCE ?: synchronized(this) {
        INSTANCE ?: SomeClass(someValue).also { INSTANCE = it }
    }
}

object SomeClass {
    ....
}

stringList: MutableList&lt;String&gt;
stringList.sortWith(String.CASE_INSENSITIVE_ORDER)

places: MutableList&lt;Place&gt;
Place
name: String
id: Int
name
places.sortedWith(compareBy { it.name })
get() = login_email.txt.toString()
email
class Composition(val name: String, ...)
class Track(name: String): Composition(name)
class Album(name: String, val tracks: List&lt;Track&gt;): Composition(name)

abstract class Composition(...){
    abstract fun getDuration(): Int
}

class Track(..., private val duration: Int): Composition(...){
    override fun getDuration() = duration
}

class Album(..., val tracks: List&lt;Track&gt;): Composition(...){
    override fun getDuration() = tracks.sumBy { it.getDuration() }
}

tracks.sumBy { it.duration }
getDuration
Composition
composition.duration
Artist
Composition
class Artist(
    val nom: String,
    private val _compositions: MutableList&lt;Composition&gt; = ArrayList()
) {

    // HERE (I wrote the extension method List&lt;E&gt;.toImmutableList)
    fun getCompositions() : List&lt;Composition&gt; = _compositions.toImmutableList()
}

val artist = Artist("Mozart")
artist.getCompositions() // Legal
artist.compositions      // Illegal

List&lt;E&gt;
add
List
MutableList&lt;E&gt;
ImmutableList
List
MutableList
private final String s
val s
s = RemoteService.result()
fun simpleFunc(x: Int): Int {

// do stuff

}

fun Int simpleFunc(Int x) {

// do stuff

}

class Foo&lt;T&gt; where T: Comparable&lt;T&gt;
class Foo&lt;T&gt; where T: Comparable&lt;T?&gt;
class Foo&lt;T&gt; where T: Comparable&lt;T&gt;?
class Foo&lt;T&gt; where T: Comparable&lt;T?&gt;?

class Foo&lt;T&gt; where T: Comparable&lt;T&gt;? {
// If a class is declared like above, is a type 'T' already nullable?

// Then, 
fun bar(value: T?) { // Should I declare a member function like this to accept null or
// do something
}

fun bar(value: T) { // Should I declare like this instead?
}
}

import Foo.x

object Foo {
    var x = 5
}

fun main(args: Array&lt;String&gt;) {
    ++x // or x += 1
}

++x
x = x + 1
val strings = arrayOfNulls&lt;String&gt;(10000)
strings.fill("hello")
val upper = strings.map { it!!.toUpperCase() } // requires it!!
val lower = upper.map { it.toLowerCase() } // doesn't require !!

val strings = Array(10000, {"string"})
val upper = strings.map { it.toUpperCase() } // doesn't require !!

strings.fill("hello")
Random().nextInt()
val rnds = (0..10).random()

 fun main() {
        println("Please enter size of line: ")
    var size = readLine()!!.toInt()

    for (i in 1..size) {
        print("*")
        for (i in 1..(size-1)) {
            print(" ")

        }
        println("*")
        size++
    }


    for( i in 1..size) {
        print("*")
    }
}

*
**
* *
*  *
*   *
*    *
*     *
********

"mypackage.MyClass"
KClass
Char
MAX_CODE_POINT
$ kotlinc-jvm
Welcome to Kotlin version 1.3.50 (JRE 1.8.0_212-b04)
Type :help for help, :quit for quit
&gt;&gt;&gt; Char.MAX_CODE_POINT
error: unresolved reference: MAX_CODE_POINT
Char.MAX_CODE_POINT
     ^

&gt;&gt;&gt; Char.Companion.MAX_CODE_POINT
error: unresolved reference: MAX_CODE_POINT
Char.Companion.MAX_CODE_POINT
               ^

with
run
with
run
adapter.run {
    notifyDataSetChanged()
    if (activityDetails.isEmpty())
        emptyText.visibility = View.VISIBLE
    else 
       emptyText.visibility = View.GONE
}


with(adapter){
   notifyDataSetChanged()
   if (activityDetails.isEmpty())
       emptyText.visibility = View.VISIBLE
   else 
       emptyText.visibility = View.GONE
}

val streetNumber: Int = {
        num: Int -&gt; num / 4
}

error: type mismatch: inferred type is (Int) -&gt; Int but Int was expected
val streetNumber: Int = {
                        ^

Int
Int
Int
num
Int
private final Base $$delegate_0
Derived
b
zero boilerplate
public abstract class Request&lt;T, R extends Request&gt; implements Serializable {}

\n\thttp://exam\nple.com/\t\n\r. 

public class MyFactory {
   private static MyFactory instance = null;
   private Properties props = null;
   private FirstClass firstInstance = null;
   private SecondClass secondInstance = null;

   private MyFactory() {
     props = new Properties();
     try {
       props.load(new FileInputStream("path/to/config"));

       String firstClass = props.getProperty(“first.class”);
       String secondClass = props.getProperty(“second.class”);
       firstInstance = (FirstClass) Class.forName(firstClass).newInstance();
       secondInstance = (SecondClass) Class.forName(secondClass).newInstance();
     } catch (Exception ex) {
        ex.printStackTrace();
     }
  }
  static {
    instance = new MyFactory();
  }
  public static MyFactory getInstance() {
    return instance;
  }

  public FirstClass getFirstClass() {
    return firstInstance;
  }

  public SecondClass getSecondClass() {
    return secondInstance;
  }

}

class MyFactory private constructor() {
  private var props: Properties? = null

  private var firstInstance: FirstClass? = null
  private var secondInstance: SecondClass? = null

  init {
      try {
          props!!.load(FileInputStream("path/to/conf"))

          val firstClass = props!!.getProperty("prop")
          val secondClass = props!!.getProperty("prop")

          firstInstance = Class.forName(firstClass).newInstance() as FirstClass
          secondInstance = Class.forName(secondClass).newInstance() as SecondClass
      } catch (ex: Exception) {
          ex.printStackTrace()
      }
  }

  companion object {
      var instance: MyFactory? = null

      init{
          instance = MyFactory()
     }
   }
}

getInstance()
  Platform declaration clash: The following declarations have the same JVM signature:
fun &lt;get-instance&gt;(): my.package.MyFactory?
fun getInstance(): my.package.MyFactory?

    @Test
    internal fun test() {

        val result = createBoolean()
        val recentYear : Int = 200
        val finalResult = result ?: recentYear == 200

        print(finalResult) // result is false

    }

    private fun createBoolean(): Boolean? {
        return true
    }

fun main() {
  println("Hello."
}

Hello.kt:2:54: error: expecting ')'
  println("Hello."
                                                     ^

plus
plusAssign
plus
plusAssign
Point
plus
Point
 data class Point(var x: Int, var y: Int)
{
    operator fun plus(other: Point): Point
    {
        return Point(x + other.x, y + other.y)
    }
} 

Point
plusAssign
Point
data class Point(var x: Int, var y: Int)
{
    operator fun plusAssign(other: Point): Unit
    {
       this.x+=other.x
        this.y+=other.y
    }
}

data class Point(var x: Int, var y: Int)
{
    operator fun plus(other: Point): Point
    {
       this.x+=other.x
        this.y+=other.y

        return this;
    }
}

plusAssign
plusAssign
plus
[
  {
    "AWBNo": "1326217373504",
    "AuthKey": "Valid",
    "OrderNo": "SGHRGR15073TCC",
    "ReturnMessage": "Successful",
    "ShipmentSummary": [
      {
        "PickUpDate": "08-10-2017",
        "PickUpTime": "0015",
        "OriginLocation": "DEL/WDL, Delhi NCR, DELHI",
        "DestinationLocation": "",
        "Weight": "0",
        "ExpectedDeliveryDate": "10/11/2017 12:21:32 AM",
        "Status": "Delivered",
        "StatusCode": "DLVD",
        "StatusDate": "11-10-2017",
        "StatusTime": "1316",
        "Location": "Berhampur, Berhampur, ORISSA",
        "Comment": "Shipment Delivered by SR: RAKESH, DeliveryDate:2017-10-11 1316, Receiver Name: Manmandir  Mobile Accessories  Remarks : "
      },
      {
        "PickUpDate": "08-10-2017",
        "PickUpTime": "0015",
        "OriginLocation": "DEL/WDL, Delhi NCR, DELHI",
        "DestinationLocation": "",
        "Weight": "0",
        "ExpectedDeliveryDate": "10/11/2017 12:21:32 AM",
        "Status": "Out for Delivery",
        "StatusCode": "OFD",
        "StatusDate": "11-10-2017",
        "StatusTime": "0858",
        "Location": "Berhampur, Berhampur, ORISSA",
        "Comment": "Out for delivery: 39031-RAKESH-PDS1728408582139031"
      }
    ]
  }
]

Line 15: Char 23: error: type inference failed. Expected type mismatch: inferred type is Array&amp;lt;Int&amp;gt; but IntArray was expected
        return result.toTypedArray()
                  ^ 

fun intersection(nums1: IntArray, nums2: IntArray): IntArray {
            val set: MutableSet&lt;Int&gt; = mutableSetOf()
            val result: MutableList&lt;Int&gt; = mutableListOf()

            for(num in nums1) set.add(num)

            for(num in nums2) {
                if(set.contains(num)) {
                    result.add(num)
                    set.remove(num)
                }
            }

            return result.toTypedArray()
        }

class Test {
  var a: Double? = null
  var b: Double? = null;
  var c: Double? = null;
}

a
b
c
a / b
null
null
fun calculateValues() {
  ...
  val a = test.a
  val b = test.b
  if (a != null &amp;&amp; b != null) 
    test.c = a / b
  ...
}

fun hello(name: String)

name
hello(bob!!) // bob is a nullable string

bob
KotlinNullPointerException
if(bob != null) {
    hello(bob!!)
}

class NumWithSuccessor {
    var num = 1
    val successor
        get() = num + 1
}

num
class NumsWithSuccessors {
    var nums = Array&lt;Int&gt;(3){ 1 }
    val successor
        get() = /* What? */
}


get() = { Array&lt;Int&gt;(3){ nums[it] + 1 } }

// Need to go from this...
private val _dayWiseEventsList =             // For internal use
        MediatorLiveData&lt;List&lt;Event&gt;&gt;()

val dayWiseEventsList: LiveData&lt;List&lt;Event&gt;&gt; // For immutable, external observation
        get() = _dayWiseEventsList


// ... to this
private val _dayWiseEventsListArray =        // For internal use
        Array&lt;MediatorLiveData&lt;List&lt;Event&gt;&gt;&gt;(DAYS) { MediatorLiveData() }

val dayWiseEventsListArray                   // For immutable, external observation
        // Need an alternative for this
        get() = Array&lt;LiveData&lt;List&lt;Event&gt;&gt;&gt;(DAYS) { _dayWiseEventsListArray[it] }

fun isNumber(obj: Any) {

    when (obj) {
        !is Long, Int, Float, Double -&gt; {
            println("No it's not a number")
        }
        else -&gt; {
            println("Yes it's a number")
        }
    }
}

fun main(args: Array&lt;String&gt;) {

    isNumber(19.10)
    isNumber(19L)
    isNumber(19)
    isNumber(19.10F)

}

No it's not a number
Yes it's a number
No it's not a number
No it's not a number

private
// `private` and `constructor()` are redundant.
sealed class Expr private constructor()

// Above Kotlin 1.1
data class Const(val number: Double) : Expr()
data class Sum(val e1: Expr, val e2: Expr) : Expr()

private
private
myValue.number?.setScale(2).toString() ?: ""

""
null
null
for (int i = 0; i &lt; arr.length - 1; i++)

IndexOutOfBoundException
A.indices
class Solution {
    fun isMonotonic(A: IntArray): Boolean {
        var increasing : Boolean = false
        var decreasing : Boolean = false

        for (i in A.indices) {
            if (A[i] &lt;= A[i+1]) increasing = true
            if (A[i] &gt;= A[i+1]) decreasing = true
        }

        return increasing &amp;&amp; decreasing
    }
}

data class AddItemDTO(
    val name: String,
    val insertIndex :Int?
)

myService.insertItem(parentId, addItemDTO.name, addItemDTO.insertIndex)

data class Parent() {
    ... other stuff
    private lateinit var _items: MutableList&lt;Item&gt;

    fun addItem(item: Item, insertIndex: Int = _items.size) {
        _items.add(insertIndex, item)
    }
}

fun insertItem(parentId: UUID, name: String, insertIndex: Int?) {
    val parent = parentRepository.getOne(parentId)
    val item = Item(name)
    if (insertIndex == null) parent.addItem(item)
    else parent.addItem(item, insertIndex)
}

parent.addRound(item, insertIndex ?: void)

override
interface Base {
    val message: String
    fun print()
}

class BaseImpl(val x: Int) : Base {
    override val message = "BaseImpl: x = $x"
    override fun print() { println(message) }
}

class Derived(b: Base) : Base by b {
    // This property is not accessed from b's implementation of `print`
    override val message = "Message of Derived"
}

fun main(args: Array&lt;String&gt;) {
    val b = BaseImpl(10)
    val derived = Derived(b)
    derived.print()
}

var example = "Long string to split in the last space"

var result = "Long string to split in the last"

x as? String

x as String?

String?
as?
x
T
x as? T
x as T?
fun &lt;K, V&gt; Map&lt;out K, V&gt;.forEach(
action: (Entry&lt;K, V&gt;) -&gt; Unit)

listItems
data class Item(val name: String, val description: String, val price: String, val index: Int)

listItems
var total: Int = 0
listItems.forEach {
       total += parseInt(value.price)
    }

value
V
var width:Int=0
get() {
    return field*10;
}
set(value) {
    field=value/10;
}

private var _width=0;
var width:Int
get() {
    return _width*10;
}
set(value) {
    _width=value/10;
}

data class Test (
    var id : Long? = null
)

data class TestOther (
    var id : Long = 0,
    var isCool : Boolean = false
}

infix fun &lt;T : Any?&gt; KProperty&lt;T&gt;.equal(rhs : KProperty&lt;T&gt;) = BinaryExpression&lt;Boolean&gt;(this, rhs, EQUALS)

Test::id equal TestOther::id

Test::id equal TestOther::isCool

var num: Float = 0.0f
num = 2.4 * 3.5 / 3.8

num
num.toFixed(2)
"%.2f".format(num)
num.format(2)
fun Double.format(digits: Int) = java.lang.String.format("%.${digits}f", this)

fun main(args: Array&lt;String&gt; = arrayOf("abc")) {
    val a = args[0]
}

fun processAll(items: Map&lt;Int, CustomObject&gt;) {
        items.forEach {
            process(anotherSet[it.key])
        }
    }

anotherSet
items
interface Car{
    fun getModel(): Int
}

class Honda(val model: Int): Car {
    override fun getModel(): Int {

    }
}

Honda
getModel()
Accidental Override
Honda
getModel()
Platform declaration clash
Honda
interface Car{
    fun getModel(): Int
}

class Honda(val modelParam: Int): Car {
    override fun getModel() = modelParam
}

Long.toInt()
Math.toIntExact()
fun Long.toIntExact(): Int {
    return Math.toIntExact(this)
}

pkg
into
Overload resolution ambiguity:
public fun &lt;Fiz&gt; Boo.into(block: FizMorphBuilder.() -&gt; Unit): FizMorphBuilder defined in com.ltrojanowski.morph
public fun &lt;Foo&gt; Boo.into(block: FooMorphBuilder.() -&gt; Unit): FooMorphBuilder defined in com.ltrojanowski.morph

boo.into&lt;Foo&gt;{}.morph()
class FooMorphBuilder(
    var a: String?,
    var b: Double?,
    var c: Int?,
    var d: Float?,
    var e: List&lt;String&gt;?
) : MorphBuilder&lt;Foo&gt; {
    override fun morph(): Foo = Foo(a = a!!, b = b!!, c = c!!, d = d!!, e = e!!)
}

fun &lt;Foo&gt; Boo.into(block: FooMorphBuilder.() -&gt; Unit): FooMorphBuilder = FooMorphBuilder(this.a,
        this.b, this.c, this.d, this.e).apply(block)

class FizMorphBuilder(
    var a: String?,
    var b: Double?,
    var c: Int?,
    var d: Float?,
    var e: List&lt;String&gt;?
) : MorphBuilder&lt;Fiz&gt; {
    override fun morph(): Fiz = Fiz(a = a!!, b = b!!, c = c!!, d = d!!, e = e!!)
}

fun &lt;Fiz&gt; Boo.into(block: FizMorphBuilder.() -&gt; Unit): FizMorphBuilder = FizMorphBuilder(this.a,
        this.b, this.c, this.d, this.e).apply(block)

"'this' is not defined in this context"
val result1 = str.let { arg -&gt;
    print(String.format(format, "let", arg, this, result))
    result
}
println(String.format("%-10s", result1))

val result2 = str.also { arg -&gt;
    print(String.format(format, "also", arg, this, result))
    result
}
println(String.format("%-10s", result2))

&lt;String, Object&gt;
val mapA = HashMap&lt;String, A&gt;
val mapB = HashMap&lt;String, B&gt;
val mapC = HashMap&lt;String, C&gt;

fun printHashMap(hashMap: HashMap&lt;String, (any type here, for example A, B or C)&gt;){
    // print each element of hashmap
}

fun printHashMap(hashMap: HashMap&lt;Any, Any&gt;){
   // print HashMap here
}

Type mismatch
&lt;Any, Any&gt;
&lt;String, A&gt;
object M {
    class C (val x: Int, val y: Int = 5)
}

class N(val x: Int, val y: Int = 5)

fun main(args: Array&lt;String&gt;) {
    val p = N(3)
    val q = (M::C)(3)
}

val q =
def primeStream(s: Stream[Int]): Stream[Int] = s.head #:: primeStream(s.tail filter(_ % s.head != 0))
val primes = primeStream(Stream.from(2))

// first 20 primes
primes.take(20).toList 

fun primes(seq: Sequence&lt;Int&gt;):Sequence&lt;Int&gt; = sequenceOf(seq.first()) + primes(seq.drop(1).filter {it % seq.first() != 0})
val primes = primes(sequence(2) {it + 1})

primes.take(20).toList()

private fun generateKey(params: Array&lt;Any&gt;): String {
    val genericCollection  = if (params.isNotEmpty() &amp;&amp; params[0] is Collection&lt;*&gt;) params[0] as Collection&lt;*&gt;
                    else throw Exception("no params provided for keyGenerator")

    return genericCollection.sortedBy { it }.joinToString(separator = "_")
}

open class YesNoDialog(context: Context, styleRes: Int) : Dialog(context, styleRes) {


protected fun setTexts() {

}

class MultiSelectDialog(context: Context, styleRes: Int):YesNoDialog(context, styleRes) {

}

inner class ComPort() {

val portName: String = "something"

... }

...


ComPortSelectBox.setItems(*getComPortNames())

...

private fun getComPortNames(): Array&lt;String&gt; {
  val names: ArrayList&lt;String&gt; = ArrayList()

  for(comPort in availableComPorts)
    { names + comPort.portName }

  return names.toTypedArray()
}

getComPortNames()
getComPortNames
.setItems(...)
oldList
updateList
oldList
id
id
oldData
data class Item (val id: String, val text: String)

fun main() {

    val oldList: List&lt;Item&gt; = listOf(
        Item("aaa1", "aaa2"),
        Item("bbb1", "bbb2"),
        Item("ddd1", "ddd2"))

    val updateList: List&lt;Item&gt; = listOf(
        Item("aaa1", "aaa3"),
        Item("ccc1", "ccc2"))

    val resultList = oldList.toMutableList()

    for (item in updateList) {
        val index = oldList.indexOfFirst { it.id == item.id }
        if (index &lt; 0) {
            resultList.add(item)
        } else {
            resultList[index] = item
        }
    }

    println(resultList)
}

Kotlin
class Employee{
    var data: String // because there are default implementation of get set
                    // so there will be a back-end field.
}

class Employee{
    var data: String
    get() = "default value"
}

yet
class Employee{

    var data: String
    get() = "default value"
    set(value){
        field = value
    }

}

field
class Employee{

    var data: String
    get() = "default value"
    set(value){

    }

}

field
getter
setter
object Foo : CharSequence by Foo.X {
    val X = ""
}

Variable 'X' must be initialized

object Foo : CharSequence {
    val X = ""
    override val length get() = Foo.X.length
    override operator fun get(index: Int): Char = Foo.X[index]
    override fun subSequence(startIndex: Int, endIndex: Int) = Foo.X.subSequence(startIndex, endIndex)
}

Foo
object
class
    override fun onOptionsItemSelected(item: MenuItem?): Boolean {
    when (item?.itemId) {
        R.id.action_crop -&gt; {
            val bitmap = capturedReceiptImageView.bitmap

            val bitmapCropped = BitmapHelper.cropBitmap(bitmap, capturedReceiptImageView.getDimensions())

            capturedReceiptImageView.setImageBitmap(bitmapCropped)
            capturedReceiptImageView.invalidate()

            bitmap.recycle()
        }
        R.id.action_rotate_left -&gt; {
            val bitmap = capturedReceiptImageView.bitmap

            val bitmapRotated = BitmapHelper.rotateBitmap(bitmap, -90.0f)

            capturedReceiptImageView.setImageBitmap(bitmapRotated)
            capturedReceiptImageView.invalidate()

            bitmap.recycle()
        }
        R.id.action_rotate_right -&gt; {
            val bitmap = capturedReceiptImageView.bitmap

            val bitmapRotated = BitmapHelper.rotateBitmap(bitmap, 90.0f)

            capturedReceiptImageView.setImageBitmap(bitmapRotated)
            capturedReceiptImageView.invalidate()

            bitmap.recycle()
        }
        R.id.action_increase_contrast -&gt; {
            val bitmap = capturedReceiptImageView.bitmap

            val bitmapChangedContrast = BitmapHelper.changeBitmapContrast(bitmap, 1.10f)

            capturedReceiptImageView.setImageBitmap(bitmapChangedContrast)
            capturedReceiptImageView.invalidate()

            bitmap.recycle()
        }
        R.id.action_decrease_contrast -&gt; {
            val bitmap = capturedReceiptImageView.bitmap

            val bitmapChangedContrast = BitmapHelper.changeBitmapContrast(bitmap, 0.90f)

            capturedReceiptImageView.setImageBitmap(bitmapChangedContrast)
            capturedReceiptImageView.invalidate()

            bitmap.recycle()
        }
        R.id.action_save -&gt; {
            val bitmap = capturedReceiptImageView.bitmap
            BitmapHelper.saveBitmap(bitmap, capturedReceiptUri)
        }
        else -&gt; { return false }
    }

    return true
}

myArrayList.sortByDescending { it.enums.ordinal }

class s(val b: t) : t by b {
    fun f1(): Int = b.f3 + 1
    override fun f2(g: Int): Any? = when {
        g == 0 -&gt; null
        else -&gt; b.f2(g - 1)
    }
    override fun l(g: Int, h: k?, z: m):
            k = when {
        g == 0 -&gt; z.f1.f2.f3(1, z, true)
        else -&gt; b.l(g - 1, h, z)}}
    override fun f4 (g: Int): Short = when {
        g == 0 -&gt; 0
        else -&gt; b.f4(g - 1)}}}

window.addMouseListener(object : MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) { ... }

    override fun mouseEntered(e: MouseEvent) { ... }
})

fun foo() {
    val adHoc = object {
        var x: Int = 0
        var y: Int = 0
    }
    print(adHoc.x + adHoc.y)
}

open class A(x: Int) {
    public open val y: Int = x
}

interface B { ... }

val ab: A = object : A(1), B {
    override val y = 15
}

${ab.y}
15
${ab.A.y}
${ab.A.y}
1
private var mSectionsStatePageAdapter : SectionsStatePagerAdapter? = null
private val mViewPager : ViewPager? = null

class MainActivity : AppCompatActivity() {
   private var mSectionsStatePageAdapter : SectionsStatePagerAdapter? = null
   private val mViewPager : ViewPager? = null

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)

    val mytoolbar:Toolbar = findViewById(R.id.top_toolbar)
    setSupportActionBar(mytoolbar)

    mSectionsStatePageAdapter =  SectionsStatePagerAdapter(getSupportFragmentManager())
    mViewPager = findViewById(R.id.viewpager1)


    setupViewPager(mViewPager)
}



 fun setupViewPager(viewPager :ViewPager):Unit {
        var adapter : SectionsStatePagerAdapter = SectionsStatePagerAdapter(getSupportFragmentManager())
        adapter.addFragment(Fragment1(),"Fragment1")
        viewPager.setAdapter(adapter)
    }

val s = "a"
val subSequence = s.subSequence(0, 1)
println("$subSequence == ${subSequence.reversed()}: ${subSequence == subSequence.reversed()}")

a == a: false

subSequence.reversed() == subSequence.reversed()
false
org.apache.commons.validator.routines.UrlValidator
trait
trait
trait
class Dog(animalType: DogType) : Animal(animalType) {
    fun doSomething() {
        animalType.runDogTypeFunction() // error but animalType is always DogType
    }
}

abstract class Animal(val animalType: AnimalType)
interface AnimalType

enum class DogType() : AnimalType {
    DOG1, DOG2;
    fun runDogTypeFunction() {}
}

enum class CatType() : AnimalType {
    CAT1, CAT2;
    fun runCatTypeFunction() {}
}


fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; {
val job = launch {
    repeat(1000) { i -&gt;
        println("I'm sleeping $i ...")
        delay(500L)
    }
}
delay(1300L) // delay a bit
println("main: I'm tired of waiting!")
job.cancel() // cancels the job
job.join() // waits for job's completion 
println("main: Now I can quit.")

fun BufferedReader.readStars(n: Int): Set&lt;Star&gt; {
    return Array(n) {
        val (l1, l2) = readLine().split(" ").map { it.toInt() }
        Star(l1, l2)
    }.toHashSet()
}

HashSet
HashSet
n
  def invoke(block: =&gt; Boolean) = block

  // usage
  var exposure = 0
  invoke(exposure == 1)

fun waitFor(condition: () -&gt; Boolean) = condition()

// usage
var exposure = 0
waitFor { exposure == 1 }

waitFor(exposure == 1) // I want its usage to look like this, but it does not compile


waitFor
        private fun loadList() {
            try {
        val fileInputStream = activity?.openFileInput("starWarsList.dat")
        val objectInputStream = ObjectInputStream(fileInputStream)

        @Suppress("UNCHECKED_CAST")
        val list = objectInputStream.readObject() as? MutableList&lt;StarWarsItem&gt;
        if (list != null) {
            adapter.list = list
        }
        objectInputStream.close()
        fileInputStream?.close()
    } catch (e: java.io.FileNotFoundException) {
        Toast.makeText(activity, "no existing list found", Toast.LENGTH_LONG).show()
    }
}

2019-02-11 08:14:51.432 19116-19116/com.example.assignment E/AndroidRuntime: FATAL EXCEPTION: main
    Process: com.example.assignment, PID: 19116
    java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:503)
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858)
     Caused by: java.lang.reflect.InvocationTargetException
        at java.lang.reflect.Method.invoke(Native Method)
        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493)
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858) 
     Caused by: java.io.EOFException
        at java.io.ObjectInputStream$PeekInputStream.readFully(ObjectInputStream.java:2344)
        at java.io.ObjectInputStream$BlockDataInputStream.readShort(ObjectInputStream.java:2813)
        at java.io.ObjectInputStream.readStreamHeader(ObjectInputStream.java:804)
        at java.io.ObjectInputStream.&lt;init&gt;(ObjectInputStream.java:301)
        at com.example.assignment.StarWarsList.loadList(StarWarsList.kt:52)
        at com.example.assignment.StarWarsList.onActivityCreated(StarWarsList.kt:46)
        at android.support.v4.app.Fragment.performActivityCreated(Fragment.java:2460)
        at android.support.v4.app.FragmentManagerImpl.moveToState(FragmentManager.java:1483)
        at android.support.v4.app.FragmentManagerImpl.moveFragmentToExpectedState(FragmentManager.java:1784)
        at android.support.v4.app.FragmentManagerImpl.moveToState(FragmentManager.java:1852)
        at android.support.v4.app.FragmentManagerImpl.dispatchStateChange(FragmentManager.java:3269)
        at android.support.v4.app.FragmentManagerImpl.dispatchActivityCreated(FragmentManager.java:3229)
        at android.support.v4.app.FragmentController.dispatchActivityCreated(FragmentController.java:201)
        at android.support.v4.app.FragmentActivity.onStart(FragmentActivity.java:620)
        at android.support.v7.app.AppCompatActivity.onStart(AppCompatActivity.java:178)
        at android.app.Instrumentation.callActivityOnStart(Instrumentation.java:1391)
        at android.app.Activity.performStart(Activity.java:7157)
        at android.app.ActivityThread.handleStartActivity(ActivityThread.java:2937)
        at android.app.servertransaction.TransactionExecutor.performLifecycleSequence(TransactionExecutor.java:180)
        at android.app.servertransaction.TransactionExecutor.cycleToPath(TransactionExecutor.java:165)
        at android.app.servertransaction.TransactionExecutor.executeLifecycleState(TransactionExecutor.java:142)
        at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:70)
        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1808)
        at android.os.Handler.dispatchMessage(Handler.java:106)
        at android.os.Looper.loop(Looper.java:193)
        at android.app.ActivityThread.main(ActivityThread.java:6669)
        at java.lang.reflect.Method.invoke(Native Method) 
        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493) 
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858) 
2019-02-11 08:14:51.513 19116-19116/com.example.assignment I/Process: Sending signal. PID: 19116 SIG: 9

private static Object invokeMethod(Object target, String methodName, Class&lt;?&gt;[] parameterClasses, Object[] paramterValues)
            throws IllegalAccessException, NoSuchMethodException, IllegalArgumentException, InvocationTargetException {
        Class&lt;?&gt; clazz = target.getClass();
        Method method = clazz.getDeclaredMethod(methodName, parameterClasses);
        return method.invoke(target, paramterValues);
    }

 @Throws(IllegalAccessException::class, NoSuchMethodException::class, IllegalArgumentException::class, InvocationTargetException::class)
    private fun invokeMethod(target: Any, methodName: String, parameterClasses: Array&lt;Class&lt;*&gt;&gt;?, paramterValues: Array&lt;Any&gt;?): Any {
        val clazz = target.javaClass
        val method = clazz.getDeclaredMethod(methodName, *parameterClasses)
        return method!!.invoke(target, paramterValues)
    }

fun main(args : Array&lt;String&gt;) {
    println("Async" == MetricCategory.Async.toString())
    println("Async" === MetricCategory.Async.toString())
}

true
true

true
false

true
fun execute(afterDay: Long, listeners: Array&lt;(List&lt;String&gt;) -&gt; Unit&gt;)

fun updateMovies(ids: Array&lt;String&gt;){

}

fun getNewIds() {
    GetImdbIds(kodein).execute(daysBack.toEpochDay(), [::updateMovies])
}

Error:(29, 59) Kotlin: Type inference failed. Expected type mismatch: inferred type is Array&lt;KFunction1&lt;@ParameterName Array&lt;String&gt;, Unit&gt;&gt; but Array&lt;(List&lt;String&gt;) -&gt; Unit&gt; was expected
Error:(29, 59) Kotlin: Unsupported [Collection literals outside of annotations]

Welcome to Kotlin version 1.1.0 (JRE 1.6.0_65-b14-468-11M4833)
Type :help for help, :quit for quit
&gt;&gt;&gt; val (a:String, b:Int) = Pair(1,2)
&gt;&gt;&gt; 

val (a:String, b:Int) = Pair(1,2) // 'component1() function returns 'Int', but 'String' is expected

var _id: Long by map
MutableMap&lt;String, Any?&gt;
Long
class CityForecast(val map: MutableMap&lt;String, Any?&gt;, val dailyForecast: List&lt;DayForecast&gt;) {
    var _id: Long by map
    var city: String by map
    var country: String by map

    constructor(id: Long, city: String, country: String, dailyForecast: List&lt;DayForecast&gt;)
            : this(HashMap(), dailyForecast) {
        this._id = id
        this.city = city
        this.country = country
    }
}

class CityForecast(val map: MutableMap&lt;String, Any?&gt;, val dailyForecast: List&lt;DayForecast&gt;) {
    var _id: Long by map
    var city: String by map
    var country: String by map   
}

val map: MutableMap&lt;String, Any?&gt;
var _id: Long by map
map=hashMapOf("_id" to 123)  
println(_id) 

navigateToDetails
class ListViewModel : ViewModel {

    private val _navigateToDetails = MutableLiveData&lt;Event&lt;String&gt;&gt;()    
    val navigateToDetails : LiveData&lt;Event&lt;String&gt;&gt;  get() = _navigateToDetails

    fun userClicksOnButton(itemId: String) {
        _navigateToDetails.value = Event(itemId)  // Trigger the event by setting a new Event as a new value
    }
}

class ListViewModel : ViewModel {

    private val _navigateToDetails = MutableLiveData&lt;Event&lt;String&gt;&gt;()    
    val navigateToDetails : LiveData&lt;Event&lt;String&gt;&gt; = _navigateToDetails

    fun userClicksOnButton(itemId: String) {
        _navigateToDetails.value = Event(itemId)  // Trigger the event by setting a new Event as a new value
    }
}

class aaa{
    var DenomList: MutableList&lt;TextView&gt; = mutableListOf()
    var DenomPCSList: MutableList&lt;TextView&gt; = mutableListOf()
    var DenomAmountList: MutableList&lt;TextView&gt; = mutableListOf()
    var DenomNotationList: MutableList&lt;TextView&gt; = mutableListOf()
    var DenomAmountNotationList: MutableList&lt;TextView&gt; = mutableListOf().
}

fun convertFromDomain(forecast: ForecastList) = with(forecast) {...}

fun My(forecast: ForecastList):Boolean {
   ... 
   return true;
}

data class ForecastList(val id: Long, val city: String, val country: String, val dailyForecast: List&lt;Forecast&gt;) {

    val size: Int
        get() = dailyForecast.size

    operator fun get(position: Int) = dailyForecast[position]
}

data class Forecast(val id: Long, val date: Long, val description: String, val high: Int, val low: Int,
                    val iconUrl: String)



fun convertFromDomain(forecast: ForecastList) = with(forecast) {
    val daily = dailyForecast.map { convertDayFromDomain(id, it) }
    CityForecast(id, city, country, daily)
}

val wholeYear2017 = Date(2017,1,1)..Date(2017,12,31)

class DateRange&lt;Date: Comparable&lt;Date&gt;&gt;(override val start: Date, override val endInclusive: Date)
    : ClosedRange&lt;Date&gt;

class Date (val year: Int, val month: Int, val day: Int) {

    operator fun compareTo(other: Date): Int {
        if (this.year &gt; other.year) return 1
        if (this.year &lt; other.year) return -1
        if (this.month &gt; other.month) return 1
        if (this.month &lt; other.month) return -1
        if (this.day &gt; other.day) return 1
        if (this.day &lt; other.day) return -1
        return 0
    }

    operator fun rangeTo(that: Date): DateRange = DateRange(this, that)
}

One type of argument expected for class DateRange&lt;Date: Comparable&lt;Date&gt;&gt; : ClosedRange&lt;Date&gt;

companion object
// compiler error: Modifier 'companion' is not applicable inside 'file'
companion object { init { println("Loaded!") } }
fun main(args: Array&lt;String&gt;) { println("run!") }

init
static
val
val static_init = {
    println("ugly workaround")
}()

main
pow
pow
package experiments

import java.math.BigInteger

infix fun BigInteger.pow(x: BigInteger): BigInteger {
    return this.pow(x);
}

fun main(args : Array&lt;String&gt;) {
    val a = BigInteger("2");
    val b = BigInteger("3");

    println(a + b)
    println(a pow b)
}

Exception in thread "main" java.lang.StackOverflowError
    at kotlin.jvm.internal.Intrinsics.checkParameterIsNotNull(Intrinsics.java:126)
    at experiments.KotlinTestKt.pow(KotlinTest.kt)
    at experiments.KotlinTestKt.pow(KotlinTest.kt:6)

class membership ()
      {
        var number: Int? = null
        var name: String? = null
        var address: String? = null
        var zip: String? = null
        var phone: String? = null
        var memberSince: String? = null
        var memberType: Char? = null

    }

fun main(args: Array&lt;String&gt;) {

var Members: MutableList&lt;membership&gt; = mutableListOf()

    var member1 = membership()
    member1.number = 1
    member1.name = "George Jetson"
    member1.address ="123 Main St."
    member1.zip = "99207"
    member1.memberSince = "12/01/1997"
    member1.memberType = 'L'

Members[0] = member1

    println(Members[0].name)
}

// I have more members.

Exception in thread "main" java.lang.IndexOutOfBoundsException: Index: 0, Size: 0
 at java.util.ArrayList.rangeCheck (ArrayList.java:653) 
 at java.util.ArrayList.set (ArrayList.java:444) 
 at FileKt.main (File.kt:45)

return today + YEAR * 2 + WEEK * 3 + DAY * 5  

operator fun MyDate.plus(timeInterval: TimeInterval): MyDate {   
    return addTimeIntervals(timeInterval, 1)  
} 

MyDate
+
timeInterval
myDate + YEAR
operator fun MyDate.plus(timeIntervals: RepeatedTimeInterval) 
    = addTimeIntervals(timeIntervals.timeInterval, timeIntervals.number)  

MyDate
*
RepeatedInterval
timeInterval
number
class RepeatedTimeInterval(val timeInterval: TimeInterval, val number: Int)  

RepeatedInterval
import TimeInterval.*  

data class MyDate(val year: Int, val month: Int, val dayOfMonth: Int)  

enum class TimeInterval { DAY, WEEK, YEAR }  

operator fun MyDate.plus(timeInterval: TimeInterval): MyDate {  
    return addTimeIntervals(timeInterval, 1)  
}  

class RepeatedTimeInterval(val timeInterval: TimeInterval, val number: Int)    
operator fun TimeInterval.times(number: Int) = RepeatedTimeInterval(this,   number)  



operator fun MyDate.plus(timeIntervals: RepeatedTimeInterval)   
    = addTimeIntervals(timeIntervals.timeInterval, timeIntervals.number)  




fun task1(today: MyDate): MyDate {    
    return today + YEAR + WEEK  
}  

fun task2(today: MyDate): MyDate {   
    return today + YEAR * 2 + WEEK * 3 + DAY * 5   
}  

import java.util.Calendar  

fun MyDate.addTimeIntervals(timeInterval: TimeInterval, number: Int): MyDate {   
    val c = Calendar.getInstance()  
    c.set(year, month, dayOfMonth)  
    when (timeInterval) {  
        TimeInterval.DAY -&gt; c.add(Calendar.DAY_OF_MONTH, number)  
        TimeInterval.WEEK -&gt; c.add(Calendar.WEEK_OF_MONTH, number)  
        TimeInterval.YEAR -&gt; c.add(Calendar.YEAR, number)  
    }  
    return MyDate(c.get(Calendar.YEAR), c.get(Calendar.MONTH),   c.get(Calendar.DATE))  
}  

fun &lt;T&gt; foo(bar: T): T = bar

val t: Int = foo(1) // No need to declare foo&lt;Int&gt;(1) explicitly

fun &lt;T&gt; foo() = fun(bar: T): T = bar

val t: Int = foo()(1) // Compile error: Type inference failed...

val t = foo&lt;Int&gt;()(1)

foo
fun &lt;T&gt; foo(): (T) -&gt; T = fun(bar: T): T = bar

val t: Int = foo()(1) // Compile error: Type inference failed...

fun &lt;T&gt; foo(baz: T) = fun (bar: T): T = bar

val t: Int = foo(1)(1) // Horray! But I want to write foo()(1) instead...

foo
foo()(1)
bar
inline fun &lt;T : Any, R&gt; ifNotNull(input: T?, callback: (T) -&gt; R): R? {
    return input?.let(callback)
}

fun ClosedRange&lt;Int&gt;.random() = Random().nextInt(endInclusive - start) +  start
fun generateRandomNumberList(len: Int, low: Int = 0, high: Int = 255): List&lt;Int&gt; {
  (0..len-1).map {
    (low..high).random()
  }.toList()
}

List
fun List&lt;Char&gt;.random() = this[Random().nextInt(this.size)]

fun generateRandomString(len: Int = 15): String{
  val alphanumerics = CharArray(26) { it -&gt; (it + 97).toChar() }.toSet()
      .union(CharArray(9) { it -&gt; (it + 48).toChar() }.toSet())
  return (0..len-1).map {
      alphanumerics.toList().random()
  }.joinToString("")
}

list = {
  "XLabel", 
  "XDescription", 
  "YLabel", 
  "YDescription", 
  "ZLabel", 
  "ZDescription"
}

list = { 
  MyClass("XLabel", "XDescription"), 
  MyClass("YLabel", "YDescription"), 
  MyClass("ZLabel", "ZDescription")
}

fold()
list.partition().zip()
map
mapChunks( it1, it2 -&gt; MyClass(it1, it2))
[{date_time: 2019-02-07 10:09:01, vital_code : S1, vital_value :25, created_at : 2019-02-07 04:39:09, id = 1}, {date_time: null, vital_code : S2, vital_value :150, created_at : null, id = null}]

 Process: com.example.healthpassport, PID: 21563
java.lang.IndexOutOfBoundsException: Index: 2, Size: 2
    at java.util.ArrayList.get(ArrayList.java:411)
    at com.example.healthpassport.activity.HealthMetrics$onCreate$1$override.onResponse(HealthMetrics.kt:31)
    at com.example.healthpassport.activity.HealthMetrics$onCreate$1$override.access$dispatch(HealthMetrics.kt)
    at com.example.healthpassport.activity.HealthMetrics$onCreate$1.onResponse(HealthMetrics.kt)
    at retrofit2.ExecutorCallAdapterFactory$ExecutorCallbackCall$1$1.run(ExecutorCallAdapterFactory.java:68)
    at android.os.Handler.handleCallback(Handler.java:751)
    at android.os.Handler.dispatchMessage(Handler.java:95)
    at android.os.Looper.loop(Looper.java:154)
    at android.app.ActivityThread.main(ActivityThread.java:6780)
    at java.lang.reflect.Method.invoke(Native Method)
    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1496)
    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1386)

 val call=RetrofitClient.instance.api.getVitals("Bearer "+token)
    call.enqueue(object : Callback&lt;List&lt;VitalsResponse&gt;&gt; {
        override fun onResponse(call: Call&lt;List&lt;VitalsResponse&gt;&gt;?, response: Response&lt;List&lt;VitalsResponse&gt;&gt;?) {

                Log.e("Response", response!!.body().toString())

                for (i in 0..response.body().size) {
                    if (response.body() != null) {
                        Log.e("Response", response!!.body()[i].getVital_value())
                        Log.e("Response", response!!.body()[i].getVital_code())
                    }
                    else{
                        Log.e("Response", "No Response")
                    }
                }
            }


        override fun onFailure(call: Call&lt;List&lt;VitalsResponse&gt;&gt;?, t: Throwable?) {
            Log.e("VitalResponse", t!!.message)
            TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
        }

    })

private fun filterForShop(
        list: MutableList&lt;WidgetItem&gt;
    ): List&lt;WidgetItem&gt; {
        val result = list.map {
            it.compList.filter { comp -&gt;
                comp.id != "square"
            }
        }
    }

data class WidgetItem(
    val id: String,
    val title: String,
    val kind: String,
    val compList: List&lt;CompItem&gt;
) 

fun testA(str: String, listner: (lstr: String) -&gt; Void) {

}

testA("hello") { lstr -&gt;
    print(lstr)
}

Void
Int
Map&lt;Class&lt;?&gt;, Integer&gt;
inline fun &lt;T&gt; rest(request: () -&gt; T): T = try {
    request()
} catch (e: HttpException) {
    val requestId = e.response().raw().request().header(REQUEST_ID_HEADER) 
    if (requestId != null) {
        Dialog(requestId, R.string.oops).show(fragmentManager, null)
    } else {
        throw e
    }
}

request
T
Unit
T?
null
enum class FooEnum(val key : String, val value : Any) {
    FOO1("FOO_KEY", "FOO_VALUE"),
    FOO2("FOO_KEY2", 0);

    companion object {
        fun getKeyValuesMap(): Map&lt;String, Any&gt; {
            val defaults = HashMap&lt;String, Any&gt;()

            for (v in values())
                defaults[v.key] = v.value

            return defaults
        }
    }
}

getKeyValuesMap()
M
1.4-M2
class Test1 {
    var name: String? = null
    var isMarried: Boolean = false
}

   val test1 = Test1()
   test1.name = "Name1"
   test1.isMarried = true
   System.out.println("name = " + test1.name + ", isMarried = " + test1.isMarried)

Test1
name
isMarried
class Test2 {
    private var name: String? = null
    private var isMarried: Boolean = false

    fun getName(): String? {
        return name
    }

    fun setName(name: String) {
        this.name = name
    }

    fun isMarried(): Boolean {
        return isMarried
    }

    fun setMarried(isMarried: Boolean) {
        this.isMarried = isMarried
    }
}

 val test2 = Test2()
 test2.setName("Name2")
 test2.setMarried(false)
 System.out.println("name = " + test2.getName() + ", isMarried = " + test2.isMarried())

name
isMarried
    fun execRequest(endpoint: String, method: String = "GET", body: String? = ""): String =
            defaultHttpRequestBuilder()
                    .uri(URI.create(endpoint))
                    .method(method, HttpRequest.BodyPublishers.ofString(body))
                    .header("Content-Type", "application/x-www-form-urlencoded")
                    .build()
                    .run { httpClient.send(this, HttpResponse.BodyHandlers.ofString()) }
                    .let { it.body() }

    fun processLoginRequest(challenge: String) =
            execRequest(buildEndpoint("login", challenge))
                    .let {
                        mapper.readValue&lt;LoginResponse&gt;(it)
                    }
                    .let {
                        val authSituation = Auth(it.skip, it.challenge)
                        if (it.skip) {
                            val acceptResponse = acceptLoginRequest(challenge, it.subject)
                            authSituation.redirectTo = acceptResponse.redirectTo
                        }
                        authSituation
                    }


val funLit = lambda@ fun String.() {}

it
data class Course(var weekday: Int, var time: Int, var duration: Int)
var list1 = mutableListOf&lt;Course&gt;()
var list2 = mutableListOf&lt;Course&gt;()
// populate list1 and list2
// exclude any element from list1 if it has the same time and weekday as any element from list2
list1.filter { list2.none{it.weekday == it.weekday &amp;&amp; it.time == it.time} }

HttpRequest
val headers1 = hashMapOf("Content-type" to "application/json")
val headers2 = listOf("Content-type=application/json")

String=String
HttpRequest.newBuilder()
    .version(HttpClient.Version.HTTP_1_1)
    .timeout(Duration.ofSeconds(1))
    .uri(URI.create(endpoint))
    .method(method.value, HttpRequest.BodyPublishers.ofString(body))
    .header(&lt;inject headers here&gt;)
    .build()

MyDate.plus()
import TimeInterval.*
import java.util.Calendar

data class MyDate(val year: Int, val month: Int, val dayOfMonth: Int)

enum class TimeInterval { DAY, WEEK, YEAR }

operator fun MyDate.plus(timeInterval: TimeInterval) = addTimeIntervals(timeInterval, 1)

class FullTimeInterval(val timeInterval: TimeInterval, val number: Int) 
operator fun TimeInterval.times(number: Int) = FullTimeInterval(this, number)

operator fun MyDate.plus(timeIntervals: FullTimeInterval) 
= addTimeIntervals(timeIntervals.timeInterval, timeIntervals.number)

fun task1(today: MyDate): MyDate {
    return today + YEAR + WEEK 
}

fun task2(today: MyDate): MyDate {
    return today + YEAR * 2 + WEEK * 3 + DAY * 5
}  

@Throws(Exception::class)
fun getB(): B {
    return retryTemplate.execute { retryContext -&gt; fooA.getB()}
}

for (i in 1..1000) print(i)

int C(int n) {
    if (n == 0)
        return 1;
    int result = 0;
    for (int i = 0; i &lt; n; i++)
        result += C(i) * C(n - i - 1);
    return result;
}

tailrec fun C(n: Int): Int = if (n == 0) 1 else { /* for loop? */}

val month = "(JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)"
fun getPattern(): String = """\d{2} ${month} \d{4}"""
${month}
file.walk
File.walk(FileWalkDirection.BOTTOM_UP).forEach()

FileWalkDirection.BOTTOM_UP
emergency-support/digital/beginner/.category.yml
emergency-support/digital/.category.yml
emergency-support/physical/beginner/.category.yml
emergency-support/physical/.category.yml
emergency-support/.category.yml

emergency-support/.category.yml
emergency-support/physical/.category.yml
emergency-support/physical/beginner/.category.yml
emergency-support/digital/.category.yml
emergency-support/digital/beginner/.category.yml

Foo
Bar
Bar
Foo
class Foo {
    var data: Int = 0 // meh: This implementation detail should not be exposed to the public.
    fun add(x: Int) {
        data += x
    }
}

class Bar(foo: Foo) {
    private var data: Int = 2 * foo.data
    fun show() = println(data + 10)
}

fun main() {
    val myFoo = Foo()
    myFoo.add(3)
    myFoo.add(4)
    val myBar = Bar(myFoo)
    myBar.show()
}

Foo::data
class Foo {
    private var data: Int = 0
    fun add(x: Int) {
        data += x
    }

    fun makeBar() = Bar(2 * data)
}

class Bar(private val data: Int) { // meh: Bar should only be instantiated from a Foo.
    fun show() = println(data + 10)
}

fun main() {
    val myFoo = Foo()
    myFoo.add(3)
    myFoo.add(4)
    val myBar = myFoo.makeBar()
    myBar.show()
}

Bar
Foo
Bar
Foo
friend
data class OldFormat(ShiftId: Int, NozzleValue: Int, NozzleId: Int , UserId: Int)

data class NewFormat(ShiftId: Int, NozzleValue: Int, UserId: Int)

listOfOldFormat -&gt; groupby(shiftId, userId) -&gt; sum(maximumValue-minimumValue) -&gt; listOfNewFormat

val x: Int? = null as Int?

val x: Int? = null as? Int?

val (set, list, map) = CollectionsGenerator(arg1, arg2)

num % 1 !== 0

val percentResult: Double() = result.toDouble() * 0.01
  if(percentResult % 1 != 0) {
   result = (NumberFormat.getInstance().format(percentResult)).toString()
  } else {
   result = percentResult.toInt().toString()
  }

x: SomeClass??
prefetchedRecord
public Optional&lt;SomeClass&gt; fetchRecord(Long id) {
   ...
}

public void process(
    Long id,
    Optional&lt;Optional&lt;SomeClass&gt;&gt; prefetchedRecord
) {
  Optional&lt;SomeClass&gt; fetchedRecord = prefetchedResult.orElseGet( () -&gt; fetchRecord(id) )
  if (fetchedRecord.isPresent()) { ... process ... }
  else { ... do something else ... }
}

prefetchedRecord
process
data class FetchResult&lt;T&gt;(val result: T, val fetched: boolean)

var map=HashMap()
val nozzleSaleReport = nozzleStateList.groupBy {
                {it.shift.id},{it.createUser.id},{it.nozzle.id} // Here I need to add these three fields for grouping operation
            }.map { entry -&gt;
                val max: Float = (entry.value.maxBy { it.nozzleState.finalLitreMechanical }?.nozzleState!!.finalLitreMechanical ?: 0).toString().toFloat()
                val min: Float = (entry.value.minBy { it.nozzleState.finalLitreMechanical }?.nozzleState!!.finalLitreMechanical ?: 0).toString().toFloat()

                NozzleSaleReport(entry.value[0].createUser.name, entry.value[0].shift.name,  (max - min).toInt(),entry.value[0].shift.id, entry.value[0].nozzle.id, entry.value[0].nozzle.name)
            }.let {
                println(it) 
            }

data class NozzleState(val shiftId: Int, val nozzleValue: Int, val nozzleId: Int, val userId: Int, nozzleStateDate: String)

val nozzleSaleReport = nozzleStateList
                .sortedByDescending { item-&gt; item.nozzleStateDate }.groupBy {
            it.nozzleId}

(10, 8, 6, 3) 

(10-8, 8-6, 6-3, 3-0)

val randomNumber: String = Random().nextInt(10).toString()
var guess= true
println("Welcome to the Number Guess Game")
println("Please guess number between 1 to 10")


do{
    val User=readLine()!!.toString()
    if(User==randomNumber){
        guess=false
    }
    else{"Sorry Please Try Again"}

}while(guess)
println("Congratulation You have guessed the right number.")

until
for (x in 0 until bodies.size) bodies[x]()

int...int
for (x in 0..bodies.size-1) bodies[x]()

Int.until
this .. to
public infix fun Int.until(to: Int): IntRange {
    val to_  = (to.toLong() - 1).toInt()
    if (to_ &gt; to) throw IllegalArgumentException("The to argument value '$to' was too small.")
    return this .. to_
}

private lateinit var port: Int;

private lateinit var port: BigInteger;

MutableList&lt;Pair&lt;String,String&gt;&gt;
 override fun getPlaylistsNameAndId(userCategory: String):MutableList&lt;Pair&lt;String,String&gt;&gt; {
    val abc = mutableListOf&lt;Pair&lt;String,String&gt;&gt;()
        addPlaylistViewModel.getPlaylistsForChips(userCategory).observe(this, Observer { it -&gt;
            it.forEach {
                abc.add(Pair(it.playlistName,it.playlistId))
            }
            //i'm called
        })
   // return if (observer called) else wait for calling.
}

val spices = listOf("curry", "pepper", "cayenne", "ginger", "red curry", "green curry", "red pepper" )    
spices.filter { it }.sortedBy { it.length }

public class PhotoController : Typed2EpoxyController&lt;ArrayList&lt;TowerOrUnitData&gt;, Boolean&gt;() {

  override fun buildModels(activityData: ArrayList&lt;TowerOrUnitData&gt;?, data2: Boolean?) {
    TODO("not implemented") //To change body of created functions use File | Settings | File Templates.

    activityData!!.forEach {

      val activityDataArrayList:ArrayList&lt;ActivityData&gt;

      for (i in 1..5) {
        activityDataArrayList.add(ActivityData("activityName" + i,"activityStatus" + i,"70","25","Open x|Close y|For Review z"))
      }

      TowerOrUnitData{"nil";"nil";activityDataArrayList}
    }
  }
}

data class TowerOrUnitData(val towerOrUnitName:String, val activity:String, var activityData:ArrayList&lt;ActivityData&gt;)

abstract class ExampleClass {
    abstract val foo: Int
    init {
        println("Here is foo times 2!: ${foo * 2}")
    }
}

class ChildClass : ExampleClass() {
    override val foo = 5
}

abstract class ExampleClass {
    abstract val foo: Int
    fun bar() {
        println("Here is foo times 2!: ${foo * 2}")
    }
}

class ChildClass : ExampleClass() {
    override val foo = 5
    init {
       bar()
    }
}

bar()
Activity#onBackPressed
activity?.onBackPressed()

val onBackPressedRef = activity::onBackPressed

!!
val onBackPressedRef = activity!!::onBackPressed

activity?::onBackPressed
val onBackPressedRef = activity?.let { it::onBackPressed } 

?::
Single&lt;out Response&lt;T&gt;&gt;
Single&lt;Exception&gt;
class ThrowableObservableFunc1&lt;T&gt; : Function1&lt;Throwable, Single&lt;out Response&lt;T&gt;&gt;&gt; {

    override fun invoke(throwable: Throwable): Single&lt;out Response&lt;T&gt;&gt; {
        val clientConnectionException = Exception(throwable.message)

        return when (throwable) {
            is ConnectException, is UnknownHostException, is SSLException -&gt;
                Single.error(clientConnectionException)
            is SocketTimeoutException -&gt;
                Single.error(TimeoutConnectionException(throwable.message))
            else -&gt; Single.error(UnexpectedException(throwable.message))
        }
    }
}

fun main() {
  val kotlin = "Kotlin".getFirstAndLast()
  val amazing= "Amazing".getFirstAndLast()

  val kotlinFirstChar = kotlin["first"]
  val kotlinLastChar = kotlin["last"]

  val amazingFirstChar = amazing["first"]
  val amazingLastChar = amazing["last"]

  println("First char Kotlin is $kotlinFirstChar and $kotlinLastChar for second letter")
  println("First char Amazing is $amazingFirstChar and $amazingLastChar for second letter")

}
// TODO
fun String.getFirstAndLast(): Map&lt;String, Char&gt;{

    return mapOf()
}

First char Kotlin is K and n for second letter
First char Amazing is A and g for second letter

package ch07.ImplementingDelegatedProperties

import java.beans.PropertyChangeSupport
import java.beans.PropertyChangeListener

open class PropertyChangeAware {
    protected val changeSupport = PropertyChangeSupport(this)

    fun addPropertyChangeListener(listener: PropertyChangeListener) {
        changeSupport.addPropertyChangeListener(listener)
    }

    fun removePropertyChangeListener(listener: PropertyChangeListener) {
        changeSupport.removePropertyChangeListener(listener)
    }
}

class Person(
    val name: String, age: Int?, salary: Int
)
    : PropertyChangeAware()
{

    var age: Int? = age
        set(newValue) {
            println("age changed")

            val oldValue = field
            field = newValue
            changeSupport.firePropertyChange(
                "age", oldValue, newValue)
        }

    var salary: Int = salary
        set(newValue) {
            val oldValue = field
            field = newValue
            changeSupport.firePropertyChange(
                "salary", oldValue, newValue)
        }

    operator fun plus (older: Int) :Person {
        println("age changed by operator")
        val oldValue = age
        val newValue = (oldValue?: 0) + older
        changeSupport.firePropertyChange( // don't know why this dosn't fire repeatedly
            "age", oldValue, newValue)
        println("age chg by operator, $oldValue -&gt; $newValue")
        this.age = (oldValue?: 0) + older
        // this._attributes = _attributes
        return Person(name, age = age, salary = salary)
    }

}



fun main(args: Array&lt;String&gt;) {
    var p = Person("Dmitry", 34, 2000)
    p.addPropertyChangeListener(
        PropertyChangeListener { event -&gt;
            println("Property ${event.propertyName} changed " +
                    "from ${event.oldValue} to ${event.newValue}")
        }
    )
    println(p.age)
    p.age = 35
    println(p.age.toString())
    p.age = 36
    println(p.age.toString())
    p = p + 1
    println(p.age.toString())
    p = p + 1
    println(p.age.toString())
    p.salary = 2100
}

34
age changed
Property age changed from 34 to 35
35
age changed
Property age changed from 35 to 36
36
age changed by operator
Property age changed from 36 to 37
age chg by operator, 36 -&gt; 37
age changed
Property age changed from 36 to 37
37
age changed by operator
age chg by operator, 37 -&gt; 38
age changed
38

34
age changed
Property age changed from 34 to 35
35
age changed
Property age changed from 35 to 36
36
age changed by operator
Property age changed from 36 to 37
age chg by operator, 36 -&gt; 37
age changed
Property age changed from 36 to 37
37
age changed by operator
age chg by operator, 37 -&gt; 38
age changed
Property age changed from 37 to 38  &lt;&lt; This line expected but not appearing
38

package ch07.ExpandoObject

import java.beans.PropertyChangeListener
import java.beans.PropertyChangeSupport
import kotlin.properties.Delegates
import kotlin.reflect.KProperty


class Person(

    val name: String = "",
    age: Int? = null,
    var isMarried: Boolean? = null  ,_attributes: kotlin.collections.HashMap&lt;String,String&gt;? = hashMapOf&lt;String, String&gt;()
)
    :PropertyChangeAware()
{
    var _attributes : kotlin.collections.HashMap&lt;String,String&gt;? = hashMapOf&lt;String, String&gt;()
    fun setAttribute(attrName: String, value: String) {
        _attributes!!.set(attrName, value)
        _attributes!!.set("name", this.name)
    }


    override fun toString() = "Person(name=\"${name?:""}\", age=${age?:99999}, isMarried=$isMarried) " +
            "${_attributes?.get("name")} " + "$name " +
            this._attributes!!.forEach { (attrName, value) -&gt; println("$attrName = $value") } +
            {
                for ((attrName, value) in this._attributes!!) {
                    println("attribute $attrName = ${this._attributes!![attrName]}")
                }

            }

    val _age = ObservableProperty(propName = "age", propValue = age, changeSupport = changeSupport)

    private val observer = {
            prop: KProperty&lt;*&gt;, oldValue: Int, newValue: Int -&gt;
        changeSupport.firePropertyChange(prop.name, oldValue, newValue)
    }

    var age: Int by Delegates.observable(initialValue = age?:99999,onChange = observer)



}

class ObservableProperty(val propName: String,
                         var propValue: Int?, val changeSupport: PropertyChangeSupport
) {
    fun getValue(): Int? = propValue

    fun setValue( newValue: Int) {
        val oldValue = propValue
        propValue = newValue
        changeSupport.firePropertyChange(propName, oldValue, newValue)
    }
}

open class PropertyChangeAware {
    val changeSupport = PropertyChangeSupport(this)

    fun addPropertyChangeListener(listener: PropertyChangeListener) {
        changeSupport.addPropertyChangeListener(listener)
    }

    fun removePropertyChangeListener(listener: PropertyChangeListener) {
        changeSupport.removePropertyChangeListener(listener)
    }
}


fun main(args: Array&lt;String&gt;) {
    val p = Person("Bob", 89, isMarried = false)
    val data = mapOf("lastname" to "Jones", "company" to "JetBrains")
    for ((attrName, value) in data)
        p.setAttribute(attrName, value)
    println(p)

}

name = Bob
company = JetBrains
lastname = Jones
Person(name="Bob", age=89, isMarried=false) Bob Bob kotlin.Unit() -&gt; kotlin.Unit

?.
foo.get()
open class Bar
class BarImpl: Bar()

class Foo&lt;T : Bar&gt; 

inline fun &lt;reified T : Bar&gt; Foo&lt;T&gt;.get(): T {
    return SomeMap(this).get(T::class)
}

class Activity {
    lateinit var foo: Foo&lt;BarImpl&gt;
    val barImpl = foo.get()
}

Foo&lt;T&gt;.get()
class Foo&lt;T : Bar&gt; {
    inline fun &lt;reified T : Bar&gt; get(): T {
        return SomeMap(this).get(T::class)
    }
}

class Activity {
    lateinit var foo: Foo&lt;BarImpl&gt;
    val barImpl = foo.get()
}

   val vm = foo.get()
                ^

fun matchVariable(x: Variable, y: Term, m: MutableMap&lt;Variable, Term&gt;): Boolean {
    if (typeOf(x) != typeOf(y)) return false
    val x1 = m[x]?:{
        m[x] = y
        return true
    }
    return x1 == y
}

when
when (activeRequest.verb to activeRequest.resourceType) {
    GET to "all" -&gt; allGet()
    PUT to "foo" -&gt; fooPut()
    GET to "foo" -&gt; fooGet()
    POST to "bar" -&gt; barPost()
    GET to "bar" -&gt; barGet()
    COPY to "bar" -&gt; barCopy()
    DELETE to "bar" -&gt; barDelete()
    else -&gt; logMismatch()
}

to
for ((key, value) in hashMap) {
    println("$key $value)
}

when
when (activeRequest.verb, activeRequest.resourceType) {
    (GET, "all") -&gt; allGet()
    (PUT, "foo") -&gt; fooPut()
   ...
    else -&gt; logMismatch()
}

fun addDetail(...)
fun addDetail(...)
aMListDetail
aMListDetail?.innerListDetail
data class MDetail (
        val _id: Long
)


class DetailsHandler(mContext: Context = UIApp.instance) {

    data class MListDetail(val innerListDetail: MutableList&lt;MDetail&gt;)

    private var aMListDetail: MListDetail?

    var mJson: String by PreferenceTool(mContext,"mySavedJson", "")

    init {
        aMListDetail= Gson().fromJson(mJson,MListDetail::class.java)
    }

    fun addDetail(aMDetail:MDetail){
        if (aMListDetail==null){
            aMListDetail=MListDetail(mutableListOf(aMDetail))
        }else{
            if (aMListDetail?.innerListDetail==null){
                aMListDetail=MListDetail(mutableListOf(aMDetail))
            }else {
                aMListDetail?.innerListDetail?.add(aMDetail)
            }
        }

        mJson = Gson().toJson(aMListDetail)
    }

}

val padding = 25
val threshold = 0.1
for (y in 0 until yArr.size) {
    for (x in 0 until xArr.size) {
        val xVal = xArr[x]
        val yVal = yArr[y]
        val subMat = getSubmatrix(yVal - padding, yVal + padding, 
                                  xVal - padding, xVal + padding)

        var out = processSubMatrix(subMat)

        if (x%2 == 1) {
        // do some stuff with array
        } else {
            if(out.max() &lt; threshold) {
                x+=2 // cannot do that because x is immutable
                continue
             } else {
              // do some stuff with array
             }
        }
    }
}

for(int x = 0; x &lt; xArr.size; x++) {
    if(someRunTimeCondition) {
        x+=2;
        continue;
    } else { ... }
}

val (name, age) = person 

for ((a, b) in collection) { ... }

    @Parcelize
data class MyModel(
        var name: String = "",
        var is_locked: Boolean = true,
        var is_one_size: Boolean = false,
) : Parcelable

private fun initMyModelList(model: MutableList&lt;MyModel&gt;) {
 //i want to access is_locked from here with destruction but i cant ? IDE telling me the type is an int but its clearly defined as a Boolean
        for((is_locked) in model){
          //what i want to do in here is access the is_locked var of the model list and change all of them in a loop. im trying to use Destructuring in loop as a conveience. why is it not working ?
//how can i make the call signature look like this--- &gt; is_locked = true instad of model.is_locked =true 
        }
}

BaseDAO
interface BaseDAO&lt;T&gt; {

    /**
     * Insert an object in the database.
     *
     * @param obj the object to be inserted.
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insert(obj: T) : Long

    /**
     * Insert multiple objects in the database.
     *
     * @param obj the objects to be inserted.
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insert(obj: List&lt;T&gt;) : List&lt;Long&gt;

    /**
     * Update an object from the database.
     *
     * @param obj the object to be updated
     */
    @Update
    fun update(obj: T)

    /**
     * Delete an object from the database
     *
     * @param obj the object to be deleted
     */
    @Delete
    fun delete(obj: T)
}

@Dao
interface SingleDAO : BaseDAO&lt;SingleDO&gt; {

    @Query("SELECT count(*) from single limit 1")
    fun count(): Long

    /**
     * Insert single object in the database.
     *
     * @param obj the object to be inserted.
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insert(obj: SingleDO) : Long
}

'insert' hides member of supertype 'BaseDAO' and needs 'override' modifier

'insert'
'@JvmOverloads'
insert
`'@JvmOverloads'` annotation cannot be used on interface methods

IntRange
public class IntRange(start: Int, endInclusive: Int) : IntProgression(start, endInclusive, 1), ClosedRange&lt;Int&gt;

IntProgression
ClosedRange
Iterator
IntRange
Iterator
forEach
public inline fun &lt;T&gt; Iterable&lt;T&gt;.forEach(action: (T) -&gt; Unit): Unit {
    for (element in this) action(element)
}

package foo

private fun bar() = println("This is bar!!!")

package foo.baz

import foo.bar

fun main(args: Array&lt;String&gt;) = bar()

private fun wrapLogIfNeeded(buildMessageOnCurrentThread: Boolean, log: () -&gt; String): () -&gt; String
  return if(buildMessageOnCurrentThread) {
    val message = log() // Type mismatch: Required () -&gt; String Found: Unit
    { message }
  }
  else {
     log
  }
}

private fun wrapLogIfNeeded(buildMessageOnCurrentThread: Boolean, log: () -&gt; String): () -&gt; String
  return if(buildMessageOnCurrentThread) {
    val message = lazy { log() }.value
    { message }
  }
  else {
     log
  }
}

fun SomeClass.fooBuilder(vararg x: String, fn: ((String) -&gt; Unit)? = null): Result.Builder = TODO()
fun SomeClass.foo(vararg x: String, fn: ((String) -&gt; Unit)? = null): Result = fooBuilder(*x, fn).build()

fooBuilder
foo
build()
fooBuilder
fooBuilder(*x, fn).build()
Error:(28, 143) Kotlin: Type mismatch: inferred type is ((String) -&gt; Unit)? but String was expected

x
fn
SomeClass().foo("x") { str -&gt; println("Hello $str") }

kotlin
valid = listOf('A', 'B', 'C')

fcn
'ABCDEBCA' --&gt; 'ABCBCA'
'AEDC'     --&gt; 'AC'

import kotlin.text.filter

class Test(){
    val VALID = listOf("A", "B", "C")

    fun filterString(expression: String): String{
         expression.filter(x --&gt; !VALID.contains(x)) #Doesn't work
    }
}

val clickedBlock: Block? = when (event.action) {
    ...
    Action.RIGHT_CLICK_AIR -&gt; {
        p.getLineOfSight(null, 5).forEach { block -&gt;
            if (block.type != Material.VOID_AIR) {
                block // I want to assign the variable with this
            }
        }
        null // and not always with this
    }
    else -&gt; null
}

clickedBlock
interface A {
  fun getFoo()
}

class B: A {
  val foo
}

sizes = ["UK7","UK8","UK9","UK10"]

val listSizes= sizes?.split(",").toTypedArray()

[]
data class MyDataCass(val x: String, val y: String, 
                      val something: Something = Something(),
                      val somethingElse : SomethingElse = SomethingElse())

something
somethingElse
data class MyDataCass(val x: String, val y: String, 
                      val something: Something = Something(), 
                      val somethingElse : SomethingElse = SomethingElse()) {

    class Builder() {
        private lateinit var x: String
        private lateinit var y: String
        private var something: Something? = null
        private var somethingElse: SomethingElse? = null

        // builder functions to set the properties defined above
        ...

        fun build() = MyDataCass(x, y, something = ??, somethingElse = ??)
    }
}

something
somethingElse
null
fun build() = if (something == null &amp;&amp; somethingElse == null) {
        MyDataCass(x, y)
    } else if(somethingElse == null) {
        MyDataCass(x, y, something = something)
    } else {
        MyDataClass(x,y, somethingElse = somethingElse)
    }
}

val value : Long = 8_000_000L
println(value)
8 000 000
val html = response.body()?.string()

class Foo&lt;T&gt;

fun &lt;T&gt; Foo&lt;Iterable&lt;T&gt;?&gt;.bar(i: Iterable&lt;T&gt;) {
    ...
}

Foo
bar
Iterable&lt;T&gt;?
val x = listOf(123, 456)
val f = Foo&lt;Iterable&lt;Int&gt;&gt;()

f.bar(x)

f
val f = Foo&lt;Iterable&lt;Int&gt;&gt;
val f = Foo&lt;Iterable&lt;Int&gt;?&gt;
dependencies { 
    compile "org.jetbrains.anko:anko-commons:$anko_version" 
} 

dependencies { 
    compile "org.jetbrains.anko:anko-common:$anko_version" 
} 


class A {
    fun runA() {

    }
    inner class B {
        fun runB() { // Proxy method for runA()
            runA() // its okay to call it here
        }
    }
}

fun test() {
    val obj = A().B()
    obj.runA() // how to call this one??
    obj.runB() // i do not want to add a proxy method for everything in A
}

runA()
    inner class B {
        fun a(): A = this@A
        fun runB() {
            runA()
        }
    }

obj.a().runA()
obj.runA()
MyDataClass
data class MyDataClass(val a: Int, val b: Int)

MyClass
MyDataClass
a
b
MyClass
class MyClass {

  val a: Int
  val b: Int

  init {
    val mdc = MyDataClass(1, 4)
    (a, b) = mdc //error
  }

}

val b = "Kotlin"
if (b != null &amp;&amp; b.length &gt; 0) {
    print("String of length ${b.length}")
} else {
    print("Empty string")
}

b = null
app.kt
main()
fun main() {
    val b = null
    if (b != null &amp;&amp; b.length &gt; 0) {
        print("String of length ${b.length}")
    } else {
        print("Empty string")
    }
}

Information:Kotlin: kotlinc-jvm 1.3.20 (JRE 11+28)
Information:2019-02-02 15:07 - Compilation completed with 2 errors and 0 warnings in 1 s 921 ms
/Users/kurtpeek/IdeaProjects/HelloWorld/src/app.kt
Error:(3, 24) Kotlin: Unresolved reference: length
Error:(4, 37) Kotlin: Unresolved reference: length

b.length
b != null
false
b.length
In [1]: "foo" == "bar" and what.the.heck
Out[1]: False

what
and
"foo"
"bar"
println
println
fun helloWorld() { 
   println("Hello World!")
   println("Hello World!")
   println("Hello World!")
}

Hello World!
Hello World!

fun helloWorld() { 
   println("Hello World! 1")
   println("Hello World! 2")
   println("Hello World! 3")
}

Hello World! 1
Hello World! 2
Hello World! 3

it
${it?.getLevel()}
it
  billingViewModel.gasTankLiveData.observe(this, Observer {
        gasLevel = it
        Log.d(LOG_TAG,"showGasLevel called from billingViewModel with level ${it?.getLevel()}")
        showGasLevel()
    })

    data class Someone(var name: String, var age: Int)

    val someoneList = listOf&lt;Someone&gt;(Someone("Joe", 12), Someone("Bill", 15), Someone("Nancy", 12))

null
sealed class Expr
data class HasValue&lt;out T&gt;(val value: T)
object IsNull: Expr()

/* inside a class */
fun filter(v1: Expr&lt;Int&gt;? = null, v2: Expr&lt;String&gt;? = null): Collection&lt;T&gt; {
    when (v1) {
        is HasValue -&gt; /* Filter collection elements that have some attr set to given value */
        is IsNull -&gt; /* filter collection elements that have some attr set to null */
        is null -&gt; /* do nothing, return all elements */
    }

    when (v2) /* so on */
}

/* call site */
myObj.filter(v1=IsNull&lt;Int&gt;(), v2=HasValue&lt;String&gt;("string"))

sealed class Expr&lt;out T&gt; {
    abstract val value: T?
}
data class WithValue&lt;out T&gt;(override val value: T?) : Expr&lt;T&gt;()

/* usage */
fun filter(v1: Expr&lt;Int&gt;? = null) {
    when (v1) {
        is WithValue -&gt; println(if ((v1.value ?: 0) &gt; 10) "10 and above" else "less") /* Type safe, explicit null handling */
        null -&gt; println("isNull") /* parameter was omitted */
    }
}
filter(WithValue&lt;Int&gt;(null)) /* will match explicit null elements */
filter() /* will ignore v1 from filtering */

class DiscountProduct(
productName: String,
basePrice: Double,
salesPrice: Double,
description: String) :
Product(productName, basePrice, salesPrice, description) {
val discount = mutableListOf(DiscountType.SUMMER, DiscountType.SHORT, DiscountType.ALLAWAY, DiscountType.NODISC)

}

open class Product(
  val productName: String,
  var basePrice: Double,
  open var salesPrice: Double,
  val description: String) {...}


enum class DiscountType(disc:Int) {
  SUMMER(20),
  SHORT(10),
  ALLAWAY(50),
  NODISC(0)
}

fun Enum.Companion.myFun() = 1

State
State.myFun()

Enum.myFun()
abstract class Vec2t&lt;T : Number&gt; {    

    abstract var x: T    
    abstract var y: T
    ...
}

data class Vec2(override var x: Float, override var y: Float) : Vec2t&lt;Float&gt;()

val f = v.x

v.x = f

float f = v.getX();

v.setX(f);

fun x(x: T) {
    this.x = x
}
fun y(y: T) {
    this.y = y
}

float f = v.x();

v.x(f);

float f = v.x;

v.x = f;

@JvmField
abstract
Vec2t
open class Vec2t&lt;T : Number&gt; {

    @JvmFiled open var x: T // error

    @JvmField open var x by Delegates.notNull&lt;T&gt;()

    @JvmField open var x = 0 as T

originalArray=[requiredDevices, providedDevices]
           =[["A","B","C"],["B,"C","A","A","D"]]

requiredDevices=["A","B","C"]
providedDevices=["B,"C","A","A","D"]

list1=[] (empty array)
list2=["A","D"]

originalArray=[[],["A","D"]]

val temp = mutableListOf&lt;MutableList&lt;String&gt;&gt;()
fun compareArray(requiredDevices: MutableList&lt;String&gt;, providedDevices: MutableList&lt;String&gt;): List&lt;MutableList&lt;String&gt;&gt; {

    for (i in 1 until requiredDevices.size) {
        for (j in 0 until providedDevices.size) {

            try {
                if (requiredDevices[i] == providedDevices[j]) {
                    requiredDevices.removeAt(i)
                    providedDevices.removeAt(j)

                    compareArray(requiredDevices, providedDevices)

                    temp.add(requiredDevices)
                    temp.add(providedDevices)
                }
            } catch (e: IndexOutOfBoundsException) {
            }
        }
    }

    return temp.distinct()
}

originalArray=[["A","B","C"],["B,"C","A","D"]]

var itemDecorators: MutableList&lt;ItemDecorator&gt;? = null

private fun draw(c: Canvas, rv: RecyclerView, vh: ViewHolder) {
    val decorators = itemDecorators ?: return
    if (decorators.isEmpty()) return

null
return
let
var str = "Hello World"
str.let { println("$it!!") }

var str = "Hello World"
println("$str!!")

let
class SmartCast {
    var array: MutableList&lt;Int&gt;? = null

    fun processArray() {
        if (array != null &amp;&amp; !array.isEmpty()) {
            // process
        }
    }
}

array
null
@Synchronized
array != null
!array.isEmpty()
@Synchronized
fun processArray() {

fun processArray() {
    array?.takeUnless { it.isEmpty() }?.also {
        for (elem in it)
            // process elements
    }
}

Optional&lt;String&gt;
String?
String
Optional&lt;String&gt;
override fun getCurrentAuditor(): Optional&lt;String&gt; {
    val userName = SecurityUtils.currentUserLogin
    return userName ?: SYSTEM_ACCOUNT
}

userName
String?
SYSTEM_ACCOUNT
String
Optional&lt;String&gt;
import java.lang.Long as JLong
import java.lang.Byte as JByte
import java.nio.ByteBuffer

fun Long.toByteArray1() = 
    ByteBuffer.allocate(JLong.SIZE / JByte.SIZE)
        .putLong(this)
        .array()

fun Long.toByteArray2() =
    this.toString()
        .toByteArray(Charsets.UTF_8)

fun main(args: Array&lt;String&gt;) {
    val a1: ByteArray = 10L.toByteArray1()
    val a2: ByteArray = 10L.toByteArray2()
    println("a1 = ${a1.toString()}")
    println("a1 = ${ByteBuffer.wrap(a1).getLong()}")
    println("a2 = ${a2.toString()}")
    println("a2 = ${String(a2, Charsets.UTF_8)}")
}

def l = ['a', 'b', 'c'];

use()
printWriter()
    File("test2.txt").printWriter().use { out -&gt;
        {
            println("hmmm")
            out.println("what's up")
            log.info { "finished writing" }
        }
    }

writeText()
    File("test3.txt").writeText("testing")

use()
Person
Person
name, id
return persons.filter {
    it.name != null &amp;&amp; it.id != null
  }.map {
    it.id to it.name
  }.toMap()

class CsvFile(pathToFile : String)
{
    init 
    {
        if (!File(pathToFile).exists())
            return
        // Do something useful here
    }
}

val
fun SLLNode?.sumListWith(node: SLLNode?, carry: Int = 0): SLLNode? =
    when {
        this == null &amp;&amp; node == null -&gt; if (carry == 0) null else SLLNode(carry)
        this == null -&gt; node.also { it!!.value += carry } // Smart cast doesn't work here.
        node == null -&gt; this.also { value += carry } // Works here.
        else -&gt; {
            ...
        }
    }

import java.io.File

fun main(args: Array&lt;String&gt;) {
    fun markdownToHtmlSimple(inputName: String) {
        val writer = File("out.txt").bufferedWriter()
        val str = File(inputName).readLines()
        var countTagI = 0
        var countTagB = 0
        var countTagS = 0
        var openedTagI = false
        var openedTagB = false
        var openedTagS = false
        writer.write("&lt;html&gt;\n\t&lt;body&gt;\n\t\t&lt;p&gt;")
        for (i in 0..str.size) {
            if (str[i] == "") writer.newLine()
            else {
                Regex("""\*\*""").replace(str[i], "☺") //временная замена для облегчения поиcка
                Regex("""\~\~""").replace(str[i], "☻") //аналогично
                val currentStr = str[i].toList()
                for (j in 0..currentStr.size) {
                    when {
                        currentStr[j] == '*' -&gt; countTagI++
                        currentStr[j] == '☺' -&gt; countTagB++
                        currentStr[j] == '☻' -&gt; countTagS++
                    }
                }
                if ((countTagB % 2 == 0) &amp;&amp; (countTagI % 2 == 0) &amp;&amp; (countTagS % 2 == 0)) for (j in 0..currentStr.size) {
                    when {
                        (currentStr[j] == '*') &amp;&amp; !openedTagI -&gt; {
                            writer.write("&lt;i&gt;")
                            openedTagI = true
                        }
                        (currentStr[j] == '*') &amp;&amp; openedTagI -&gt; {
                            writer.write("&lt;/i&gt;")
                            openedTagI = false
                        }
                        (currentStr[j] == '☺') &amp;&amp; !openedTagB -&gt; {
                            writer.write("&lt;b&gt;")
                            openedTagI = true
                        }
                        (currentStr[j] == '☺') &amp;&amp; openedTagB -&gt; {
                            writer.write("&lt;/b&gt;")
                            openedTagI = false
                        }
                        (currentStr[j] == '☻') &amp;&amp; !openedTagS -&gt; {
                            writer.write("&lt;s&gt;")
                            openedTagS = true
                        }
                        (currentStr[j] == '☻') &amp;&amp; openedTagS -&gt; {
                            writer.write("&lt;/s&gt;")
                            openedTagS = false
                        }
                        else -&gt; writer.write(currentStr[j].toString())
                    }
                }
            }

        }
    }
    markdownToHtmlSimple("input.txt")

}

For example, lorem ipsum *dolor sit amet* consectetur **adipiscing** elit.

* is for &lt;i&gt;
** is for &lt;b&gt;

Lorem ipsum &lt;i&gt;dolor sit amet&lt;/i&gt;, consectetur &lt;b&gt;adipiscing&lt;/b&gt; elit.

val input = "Lorem ipsum *dolor sit amet*, consectetur **adipiscing** elit."                                      

val tagMap = mapOf(                                                                                               
        '*' to "&lt;i&gt;",                                                                                             
        '♥' to "&lt;b&gt;",                                                                                             
        '♦' to "&lt;s&gt;"                                                                                              
)                                                                                                                 

val tagMapClose = mapOf(                                                                                          
        '*' to "&lt;/i&gt;",                                                                                            
        '♥' to "&lt;/b&gt;",                                                                                            
        '♦' to "&lt;/s&gt;"                                                                                             
)                                                                                                                 

fun tagCheck(obj: String): String {                                                                               
    var str = Regex("""\*\*""").replace(obj, "♥")                                                                 
    str = Regex("""~~""").replace(str, "♦")                                                                       
    str = Regex("""\*\*\*""").replace(str, "♥*")                                                                  
    val charList = str.toList()                                                                                   
    var res = ""                                                                                                  
    val indexMap = mutableMapOf&lt;Int, String&gt;()                                                                    
    var ct = 0                                                                                                    

    for ((tag, define) in tagMap) {                                                                               
        val tagIndex = mutableListOf&lt;Int&gt;()                                                                       
        var status = true                                                                                         
        for (char in charList) if (char == tag) tagIndex.add(charList.indexOf(char))                              
        ct = if (tagIndex.size % 2 == 1) tagIndex.size                                                            
        else tagIndex.size + 1                                                                                    

         for (i in 0 until ct - 1) {                                                                               
           if (status) {                                                                                         
                indexMap[tagIndex[i]] = tagMap.getValue(tag)                                                      
                status = false                                                                                    
            }                                                                                                     
            else if (!status) {                                                                                   
                indexMap[tagIndex[i]] = tagMapClose.getValue(tag)                                                 
                status = true                                                                                     
            }                                                                                                     
        }                                                                                                         
                                                                        }                                                                                                             
for (item in charList) {                                                                                      
        res += if (indexMap.keys.contains(charList.indexOf(item))) indexMap[charList.indexOf(item)]               
        else item                                                                                                 
    }                                                                                                             
    return res                                                                                                    
    }                                                                                                                 

Lorem ipsum &lt;/i&gt;dolor sit amet&lt;/i&gt;, consectetur &lt;/b&gt;adipiscing&lt;/b&gt; elit.

var str = "Hello Kotlin"
str
strHello
var foo: String? // These variable declarations are out of your control
var foo2: String? // they are part of a bean and an api contract
var foo3: String?
var foo4: String?

var bars: Array&lt;String&gt; = Array(NUMBER_OF_BARS) { "" }

foo = bars[0]
foo2 = bars[1]
foo3 = bars[2]
foo4 = bars[3] // &lt;- Invalid

const val BAR_1 = 0
const val BAR_2 = 1
const val BAR_3 = 2
const val BAR_4 = 3

public class User {

    //one-to-one
    private Profile profile = new Profile(this);        

}

public class Profile {

    private User user;

    public Profile(User user) {
        user.setProfile(this);
        this.user = user;
    }

}

class User(

    var profile: Profile = Profile(this) //error, since `this` is not in that context

)

class Profile (

    var user: User?

) {

    constructor(user: User): this(user)

}

Handler
SimpleHandler
onSuccess
onFail
SimpleHandler
super.onFail()
interface Handler
{
    fun onFinished(result:Int);
}

abstract class SimpleHandler:Handler
{
    override fun onFinished(result: Int)
    {
        if(result==0)
        {
            onSuccess();
        }
        else
        {
            onFail();
        }
    }

    open fun onSuccess()
    {
        println("The developer is so lazy that he did not do anything.");
    }
    open fun onFail()
    {
        println("The developer is so lazy that he did not do anything.");
    }
}

fun doSomething(handler:Handler)
{
    handler.onFinished(10);
}

fun main(args: Array&lt;String&gt;)
{

    doSomething(object: SimpleHandler(){
        override fun onSuccess() {
            println("I won! I won!");
        }

        override fun onFail() {
            //super.onFail();
            println("Me fail English?");
        }
    })
}

[group : {name:"group1", 
  student :[student1:{age:10},student2:{age:11},student3:{age:12}]},
group : {name:"group2", 
  student :[student1:{age:11},student2:{age:12},student3:{age:14}]},
]

[group : {name:"group1", 
  student :[student2:{age:11},student3:{age:12}]},
group : {name:"group2", 
  student :[student1:{age:11},student2:{age:12}]}
]

URLClassLoader
val list = listOf(A(id = 1), A(1), A(2), A(3), A(2))

Container
data class Container(
   val id: Long // The id passed into A.
   val elementList: List&lt;A&gt; // The elements that contain the ID.
)

"="
":"
button.setOnClickListener(object : OnClickListener{
    override fun onClick(view: View){
    doSomething() }
})    

class Car(val make:String ,var  model : String){

fun start(noise : String = "Wroom Wroom"){
    println(noise)
 }
}
fun main(args: Array&lt;String&gt;) {

val carOne = Car("Toyota","Avalon")
var car2:Car("Telsa","S")
car3:Car("Benz","C")

}

noise : String = "Wroom Wroom "
"noise"
newsRepository.getAllNewsFeeds().observeForever { newsFeeds -&gt;

    listNewsFeedUrls = newsFeeds.mapNotNull { newsFeed -&gt;

        if (newsFeed.newsfeedURL?.toUri()?.path.isNullOrEmpty()) {
            newsFeed.newsfeedURL + "/us/json/news"
        } else {
            newsFeed.newsfeedURL
        }
    }

}

@field:SerializedName("valrep_landimp_dos_cml3_total_adjustment")
val valrepLandimpDosCml3TotalAdjustment: String? = null,

@field:SerializedName("valrep_landimp_dos_cml4_contact_no")
val valrepLandimpDosCml4ContactNo: String? = null,

@field:SerializedName("valrep_landimp_dos_dsl1_source")
val valrepLandimpDosDsl1Source: String? = null,

@field:SerializedName("valrep_landimp_dos_dsl3_source")
val valrepLandimpDosDsl3Source: String? = null,

 ... imagine 800 more

private fun test() : Double {
    val a : Double? = 15.0
    val b : Double? = 20.0
    return if (a == null &amp;&amp; b == null) {
        0
    } else if (a != null &amp;&amp; b == null) {
        a
    } else if (a == null &amp;&amp; b != null) {
        b
    } else {
        a+b
    }
}

UsersService {
    @GET("some/path")
    fun getPath(): Call&lt;SomeObject&gt;
}

fun getPath(): SomeObject {
    val result = myUsersService.getPath().execute()
    if(result.code()!=201) throw SomeException("")
    return result.body()!!
}

UsersService {
    @SuccessCode(201)
    @GET("some/path")
    fun getPath(): Call&lt;T&gt;
}

fun someGeneratedFunction(fn: ()-&gt;Call&lt;T&gt;): T {
    val result = fn.execute()
    if(result.code() != 201) throw SomeException("")
    return result
}

var str: String? = null
str ?: null

import PackageA.* as MyA
import PackageB.* as MyB

val aFoo = MyA.FooClass()
val bFoo = MyB.FooClass()

fun doIt(content: String, fInter: FInter) {
    fInter.doItForString(content)
}

@FunctionalInterface
interface FInter {
    fun doItForString(string: String)
}

fun main() {

    doIt("abc") {
        println(it) // why it error
    }

}

FInter
package com.linuxea.javalin

/**
 * @author linuxea
 * @date 2019/9/2 11:58
 */

@FunctionalInterface
interface StringHandler {
    fun handle(content: String): String
}

class ToUpperCaseStringHandler : StringHandler {

    override fun handle(content: String): String {
        return content.toUpperCase()
    }

}

fun go(string: String, stringHandler: StringHandler) {
    println(stringHandler.handle(string))
}


fun go(string: String, stringHandler: (String) -&gt; String) {
    println(stringHandler(string))
}

fun main() {
    go("abc", ToUpperCaseStringHandler())

    go("dfalkdjkskf") {
        it.toLowerCase()
    }

    go("abcdefg") {
        println(it)
        it.toUpperCase()
    }

    // lambda argument should be moved out of parentheses
    go("xyz", {
        it.toUpperCase()
    })
}

object DataProviderManager {
  fun registerDataProvider(provider: DataProvider) {
    //
  }
}

array1["a", "b", "c", "d"]

array2["b", "d", "e", "f"]

duplicatesFound = findDuplicates(array1, array2) //will return ["b", "d"]

"220 + 224 %+ 228 %- 230 + 232 %%- 234 %".// result in 230
"226 +" // result is 226
"???" // result is -1
fun bestHighJump(jumps: String): Int {
    var result = 0
    val jumpsSplitted = jumps.split(" ")
    val regStr = Regex("""[.+\d]""")
    for (item in jumpsSplitted) {
        if (regStr.containsMatchIn(item)) result += item
    }
    //Don't know what to do next
}

list.remove(SampleClass("Village"))
internal fun checkNullVariables ( var x, var y , ..... ) : MutableList&lt;String&gt;{

    // yada yada

    return listOfNamesOfNullVariables
}

fun sayHello(greet:String,itemsToGreet:List&lt;String&gt;){
    itemsToGreet.forEach { itemsToGreet -&gt;
        println("$greet, $itemsToGreet")
    }
}

fun main() {
    val interestingThings = listOf("kotlin","program","comic")
    sayHello(greet="hi", interestingThings)
}

data class ForecastList(val id: Long, val city: String, val country: String, val dailyForecast: List&lt;Forecast&gt;) {

    val size: Int
        get() = dailyForecast.size

    operator fun get(position: Int) = dailyForecast[position]
}

data class ForecastList(val id: Long, val city: String, val country: String, val dailyForecast: List&lt;Forecast&gt;) {

    val size: Int = dailyForecast.size

    operator fun get(position: Int) = dailyForecast[position]
}

class SettingsActivity : AppCompatActivity() {

    companion object {
        val ZIP_CODE = "zipCode"
        val DEFAULT_ZIP = 94043L
    }

    var zipCode: Long by DelegatesExt.preference(this, ZIP_CODE, DEFAULT_ZIP)
}

object DelegatesExt {
    fun &lt;T&gt; notNullSingleValue() = NotNullSingleValueVar&lt;T&gt;()
    fun &lt;T&gt; preference(context: Context, name: String, default: T) = Preference(context, name, default)
}

class NotNullSingleValueVar&lt;T&gt; {

    private var value: T? = null

    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T {
        return value ?: throw IllegalStateException("${property.name} not initialized")
    }

    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) {
        this.value = if (this.value == null) value
        else throw IllegalStateException("${property.name} already initialized")
    }
}

class Preference&lt;T&gt;(val context: Context, val name: String, val default: T) {

    val prefs: SharedPreferences by lazy { context.getSharedPreferences("default", Context.MODE_PRIVATE) }

    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T {
        return findPreference(name, default)
    }

    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) {
        putPreference(name, value)
    }

    @Suppress("UNCHECKED_CAST")
    private fun findPreference(name: String, default: T): T = with(prefs) {
        val res: Any = when (default) {
            is Long -&gt; getLong(name, default)
            is String -&gt; getString(name, default)
            is Int -&gt; getInt(name, default)
            is Boolean -&gt; getBoolean(name, default)
            is Float -&gt; getFloat(name, default)
            else -&gt; throw IllegalArgumentException("This type can be saved into Preferences")
        }

        res as T
    }

    private fun putPreference(name: String, value: T) = with(prefs.edit()) {
        when (value) {
            is Long -&gt; putLong(name, value)
            is String -&gt; putString(name, value)
            is Int -&gt; putInt(name, value)
            is Boolean -&gt; putBoolean(name, value)
            is Float -&gt; putFloat(name, value)
            else -&gt; throw IllegalArgumentException("This type can't be saved into Preferences")
        }.apply()
    }
}

class SettingsActivity : AppCompatActivity() {

    companion object {
        val ZIP_CODE = "zipCode"
        val DEFAULT_ZIP = 94043L
    }

   DelegatesExt.Preference(this, ZIP_CODE, DEFAULT_ZIP).putPreference( ZIP_CODE,"99999L");
}

@Target( { TYPE })
@Retention(RUNTIME)
public @interface View {
    String[] url() default "";
    Class&lt;? extends Component&gt; parent() default Component.class;
}

@View(url="/", parent=RootView.class)
public class FrontView extends Component {
}

[View(url=Array&lt;String&gt;("/"), parent=Class&lt;RootView&gt;)]
class FrontView : Component() {
}

Type mismatch.  
Required: jet.Array&lt;jet.String?&gt;?  
Found: jet.Array&lt;T&gt;

Type mismatch
Required: java.lang.Class&lt;out net.contextfw.web.application.component.Component?&gt;?
Found: java.lang.Class&lt;T&gt;

class Pitch(var width: Int = 3, var height: Int = 5) {

    constructor(capacity: Int): this()

}

class Pitch(var width: Int = 3, var height: Int = 5, capacity: Int)

class Team (val name: String, val aggressive: Boolean = true) {

    val attendance: Int

    init {
        if (aggressive){
            attendance = 25000
        } else {
            attendance = 20000
        }
    }

}

fun chooseTeam() {
    val homeTeam = Team(name = "Everton")
    println("the home team is $homeTeam.aggressive so they are ${if ($homeTeam == "aggressive") "angry" else "timid" }") 
}

$homeTeam.aggressive
class SomeClass&lt;E&gt; {
    data class Data(val str: String, val int: Int, val e: E) //the last value is invalid

    val map: MutableMap&lt;String, Data&gt; = mutableMapOf()

}

val LOGGER : Logger = LoggerFactory.getLogger(Foo::class.java);

val LOGGER : Logger = LoggerFactory.getLogger(Foo::javaClass);

getLogger
Class&lt;Foo&gt;
var list = mutableListOf(5, 700, 8, 9, 660, 53, 90, 36)
if(0 in list)
  println("in list")
fun Int.test(value: Int) {}

1.test(2)

infix fun Int.test(value: Int) {}

1 test 2

class myclass {
    fun main() {
        test(1)
    }
    fun test(value: Int) {}
}

class myclass {
    fun main() {
        test 1
    }
    infix fun test(value: Int) {}
}

class myclass {
    fun main() {
        this test 1
    }
    infix fun test(value: Int) {}
}

this
test
private lateinit var allList: MutableList&lt;MSetting&gt;

allList=SettingHandler().getListAllSetting().toMutableList()
mCustomAdapter= CustomAdapter(allList)
mRecyclerView.adapter= mCustomAdapter

class CustomAdapter (val backupItemList: List&lt;MSetting&gt;) : RecyclerView.Adapter&lt;CustomAdapter.ViewHolder&gt;() {
}

class Manager (var name: String, var nationality: String) {

    constructor(agent: String): this() {}
}

None of the following functions can be called with the arguments supplied.

&lt;init&gt;(String) defined in Manager
&lt;init&gt;(String, String) defined in Manager

&lt;RelativeLayout android:layout_width="match_parent"
                android:layout_height="match_parent"
                xmlns:android="http://schemas.android.com/apk/res/android"
                xmlns:app="http://schemas.android.com/apk/res-auto"&gt;

    &lt;com.airbnb.lottie.LottieAnimationView android:layout_width="match_parent"
                                           android:layout_height="match_parent"
                                           android:id="@+id/newActivityAnimation"
                                           app:lottie_fileName="transitionAnimation.json"
                                           android:scaleType="centerCrop"
                                           android:elevation="5dp"
                                           android:transitionName="sharedNewActivityTransition"

    /&gt;

&lt;RelativeLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:context=".ui.MenuActivity"&gt;

    &lt;com.airbnb.lottie.LottieAnimationView android:layout_width="match_parent"
                                           android:layout_height="match_parent"
                                           app:lottie_fileName="transitionAnimation.json"
                                           android:scaleType="centerCrop"
                                           android:id="@+id/changeActivityAnimationMenu"
                                           android:elevation="5dp"
                                           android:transitionName="sharedNewActivityTransition"

    /&gt;

&lt;/RelativeLayout&gt;

   override fun onLanguageClickListener(position: Int) {
        animateCollapseMenuSlide(isMenuCollapsed)
        newActivityAnimation.setMaxFrame(19)
        delay.delayedFunction({newActivityAnimation.playAnimation()},200)
        delay.delayedFunction({changeActivity()},1000)


    }


.
.
.


 private fun changeActivity() {
        val intent = Intent(this,MenuActivity::class.java)
        intent.flags = Intent.FLAG_ACTIVITY_NO_ANIMATION
        val options = ActivityOptionsCompat.makeSceneTransitionAnimation(this,activityTransitionAnimation,
            "sharedNewActivityTransition")
        startActivity(intent,options.toBundle())
    }


val id = Integer.MAX_VALUE.toLong() + 2000
val a = id.toInt()
val b = (id shr 32).toInt()

data class Flight(val duration: Int)

val flights = listOf(Flight(10), Flight(5), Flight(5), Flight(15), Flight(20))

val double = 1.2345

ByteArray
Array&lt;Byte&gt;
00111111 11110011 11000000 10000011
00010010 01101110 10010111 10001101

Double.doubleToLongBits()
Kotlin.Double
Kotlin.Double
inline fun test(noinline f: () -&gt; Unit) {
    thread(block = f)
}

inline fun test(crossinline f: () -&gt; Unit) {
    thread(block = f)
}

inline fun test(noinline f: () -&gt; Unit) {
    thread { f() }
}

inline fun test(crossinline f: () -&gt; Unit) {
    thread { f() }
}

noinline
crossinline
"time": ["1507457400000", "1507458600000"] //Strings

new Date(1507457400000)             // return Sun Oct 08 2017 12:10:00 GMT+0200
new Date(1507457400000).getHours()   // return 12
new Date(1507457400000).getMinutes() // return 10

class SecretsManager(region: String) {
    private val gson = Gson()
    private val smClient = AWSSecretsManagerClientBuilder.standard().withRegion(region).build()

    fun &lt;T&gt; getSecret(id: String): T {
        val req = GetSecretValueRequest().withSecretId(id)
        val json = smClient.getSecretValue(req).getSecretString()
        return gson.fromJson(json, T::class.java)
    }
}


val myInstance = SecretsManager("eu-west-2").getSecret&lt;MyDataClass&gt;("myId")

class Person(var name:String? = null, var age:Int? = null){
    fun test(){
        if(name != null &amp;&amp; age != null)
            doSth(name, age) //smart cast imposible
    }

    fun doSth (someValue:String, someValue2:Int){

    }
}

name?.let{ doSth(it) } 

MatrixStack
inline infix fun run(block: MatrixStack.() -&gt; Any): MatrixStack {
    push()
    block()
    pop()
    return this
}

block()
fun getSphereOrbitPos(modelMatrix: MatrixStack, orbitCenter: Vec3, orbitAxis: Vec3, orbitRadius: Float, orbitAlpha: Float): Vec3 {

    modelMatrix run {

        translate(orbitCenter)
        rotate(orbitAxis, 360.0f * orbitAlpha)

        var offsetDir = orbitAxis cross Vec3(0.0f, 1.0f, 0.0f)
        if (offsetDir.length() &lt; 0.001f)
            offsetDir = orbitAxis cross Vec3(1.0f, 0.0f, 0.0f)

        offsetDir.normalize_()

        translate(offsetDir * orbitRadius)

        // this is what I'd like to return, top() = MatrixStack.top()
        return (top() * Vec4(0.0f, 0.0f, 0.0f, 1.0f)).toVec3()
    }
} // return error

fun getSphereOrbitPos(..): Vec3 {

    var result =  Vec3()

    modelMatrix run {
        ..
        result = (top() * Vec4(0.0f, 0.0f, 0.0f, 1.0f)).toVec3() // error
    }

MatrixStack.run{ }
push()
block()
pop()
val myArray = arrayOf(
    MyObj("String 1", mapOf(Pair(MyEnum.apple, "String 2"))),
    MyObj("String 2", mapOf(Pair(MyEnum.orange, "String 1"),
            Pair(MyEnum.apple, "String 3"))),
    MyObj("String 3", mapOf(Pair(MyEnum.orange, "String 2")))
)

val myObj = myArray[1]

fun main(args: Array&lt;String&gt;) {
    getValue(MyEnum.apple)
}

fun getValue(myEnum: MyEnum) {
    myObj.myMap.forEach { (enum, str) -&gt;
        if (enum == myEnum) {
            myArray.forEach {obj -&gt;
                if (obj.name == str) {
                    if (checkStuff(obj)) {
                        println("checkStuff returned true")
                        return // this continues to printLn
                    }
                    println("returned false")
                    return // This appears to return as expected
                }
            }
        } else {
            println("Should not be hit")
        }
    }
}

fun checkStuff(obj: MyObj): Boolean {
    return obj.name == "String 1"
}

data class MyObj (val name: String, val myMap: Map&lt;MyEnum, String&gt;)

enum class MyEnum {
    apple, orange, pear
}

fun max(a: Int, b: Int): Int {
    return if (a &lt; b) a else b
}

fun max(a: Int, b: Int): Int = if (a &lt; b) a else b

val sequence = sequence {
    val start = 0
    // yielding a single value
    yield(start)
    // yielding an iterable
    yieldAll(1..5 step 2)
    // yielding an infinite sequence
    yieldAll(generateSequence(8) { it * 3 })
}

        val stringRequest = object : StringRequest(Request.Method.POST, EndPoints.URL_ADD_ARTIST,
            Response.Listener&lt;String&gt; { response -&gt;
                try {
                    val obj = JSONObject(response)
                    Toast.makeText(applicationContext, obj.getString("message"), Toast.LENGTH_LONG).show()
                } catch (e: JSONException) {
                    e.printStackTrace()
                }
            },
            object : Response.ErrorListener {
                override fun onErrorResponse(volleyError: VolleyError) {
                    Toast.makeText(applicationContext, volleyError.message, Toast.LENGTH_LONG).show()
                }
            }) {
            @Throws(AuthFailureError::class)
            override fun getParams(): Map&lt;String, String&gt; {
                val params = HashMap&lt;String, String&gt;()
                params.put("user", user)
                params.put("password", password)
                params.put("email", email)
                return params
            }
        }

        VolleySingleton.instance?.addToRequestQueue(stringRequest)
    }

val stringRequest = object : StringRequest(Request.Method.POST, EndPoints.URL_ADD_ARTIST,
                Response.Listener&lt;String&gt; { response -&gt;
val obj = JSONObject(response)

null
null
var someField: Boolean?
lateinit var someField: Boolean
class Result&lt;T, E&gt;(val data: T? = null, val error: E? = null)

fun &lt;T, E&gt; wrapResult(errorInfoFactory: (Throwable) -&gt; E): (Observable&lt;T&gt;) -&gt; Observable&lt;Result&lt;T, E&gt;&gt; = { it.map { Result&lt;T, E&gt;(it) }.onErrorReturn { Result&lt;T, E&gt;(error = errorInfoFactory(it)) } }

Observable
Observable
Result
onError
fun dangerousOperation() = 0

fun getErrorMessage(t: Throwable) = "error occurred"

fun test() {
    val resultObservable = Observable.fromCallable(::dangerousOperation).compose(wrapResult(::getErrorMessage))
}

test
fun test() {
    val resultObservable = Observable.fromCallable(::dangerousOperation).compose(wrapResult&lt;Int, String&gt;(::getErrorMessage))
}

wrapResult
interface IIMSIdentifiable {
    fun setImsId(id : String)
    fun getImsId() : String
}

interface IIMSConsumer : IIMSIdentifiable {
    fun consumeAsync(message : GRLMessage)
}

IIMSConsumer
class IMSObject&lt;IIMSConsumer&gt; : Thread {
    constructor(component : IIMSConsumer) {
        obj = component
        // IMSContext.instance.registerObject(this) // hm type mismatch
    }

    val objectMessageQueue = LinkedBlockingDeque&lt;GRLMessage&gt;()
    val obj : IIMSConsumer
    var isRunning = true

    override fun run() {
        while(isRunning) {
            processMessages()
        }
    }

    fun stopProcessing() {
        isRunning = false
    }

    fun processMessages() {
        objectMessageQueue.forEach {
            obj.consumeAsync(it)
        }
    }

    fun getObjectId() : String {
        return obj.getImsId()
    }
}

fun processMessages() {
    objectMessageQueue.forEach {
        obj.consumeAsync(it) // cannot resolve reference !!!
    }
}

fun getObjectId() : String {
    return obj.getImsId() // cannot resolve reference !!!
}

com.lapots.game.journey.ims.domain.IMSObject
com.lapots.game.journey.ims.api.IIMSConsumer

unresolved reference
interface IConsumer {
    fun consume() : String
}

class Generic&lt;IConsumer&gt;(val consumer : IConsumer) {
    fun invoke() {
        print(consumer.consume()) // unresolved reference
    }

}

fun main(args: Array&lt;String&gt;) {
    val consumer = object : IConsumer {
        override fun consume() : String {
            return "I consume"
        }
    }
    val generic = Generic&lt;IConsumer&gt;(consumer)
    generic.invoke()
}

Kotlin
@Component
@ConfigurationProperties("rest")
@Data
public class RestProperties {
    private final Client client = new Client();

    @Data
    public static class Client {
        private int defaultMaxTotalConnections;
        private int defaultMaxConnectionsPerRoute;
        private int defaultReadTimeout;
    }
}

@Component
@ConfigurationProperties("rest")
class RestProperties {
    val client = Client()

    class Client() {
        constructor(
            defaultMaxTotalConnections: Int, 
            defaultMaxConnectionsPerRoute: Int, 
            defaultReadTimeout: Int
        ) : this()
    }
}

@Component
@ConfigurationProperties("rest")
class RestProperties {
    val client = Client()

    class Client {
        var defaultMaxTotalConnections: Int = 50
            set(defaultMaxTotalConnections) {
                field = this.defaultMaxTotalConnections
            }

        var defaultMaxConnectionsPerRoute: Int = 10
            set(defaultMaxConnectionsPerRoute) {
                field = this.defaultMaxConnectionsPerRoute
            }

        var defaultReadTimeout: Int = 15000
            set(defaultReadTimeout) {
                field = this.defaultReadTimeout
            }
    }
}

class A(
    val id: Int
)

class B(
    val id: Int,
    val className: String
)

A
fun printClassFields(classObject: A){

}

B
fun printClassFieldsB(classObject: B){

}

Activity
TextView
tvAuthNum
Fragment
TextView
tvAuthNum
Activity
Fragment
Fragment
fun evaluate(first:Int?, second:Int?) {
    var result = 0
    if (v.equals('*')) {
        result = (first ?: 0) * (second ?: 0)
    } else if (v.equals('+')) {
        result = (first ?: 0) + (second ?: 0)
    } else if (v.equals('-')) {
        result = (first ?: 0) - (second ?: 0)
    } else if (v.equals('/')) {
        result = (first ?: 0) / (second ?: 0)
    }
    return result   
}

fun evaluate(first:Int?, second:Int?, op: () -&gt; Unit):Int {
    return (first ?: 0).op(second ?: 0)
}

inline
val foo: Foo
    inline get() = Foo()

var bar: Bar
    get() = ...
    inline set(v) { ... }

kotlin 1.2.31

let
kotlin.unit
fun replaceSpace(quote: String, ch: Char): String {
    return quote.toCharArray().let {
        for (i in it.indices) {
            if(it[i] == ' ') {
                it[i] = ch
            }
        }
    }.toString()
}

toString()
kotlin.unit
String(it)
let
toString()
fun replaceSpace(quote: String, ch: Char): String {
    return quote.toCharArray().let {
        for (i in it.indices) {
            if(it[i] == ' ') {
                it[i] = ch
            }
        }
        String(it)
    }
}

var currentStatus = MutableLiveData&lt;List&lt;Int&gt;&gt;()

private var sellerIds: List&lt;Int&gt;? = null
private var subSellerIds: List&lt;Int&gt;? = null
private var partnerIds: List&lt;Int&gt;? = null
private var productTypeIds: List&lt;Int&gt;? = null
private var brunchIds: List&lt;Int&gt;? = null
private var contractDateFrom: String? = null
private var contractDateTo: String? = null
private var completeDateFrom: String? = null
private var completeDateTo: String? = null

private var totalStatusCnt: Int = 10

val isSearching = ObservableField&lt;Boolean&gt;(false)

private fun checkIfSearchConditions() {
    if (currentStatus.value != null &amp;&amp; currentStatus.value!!.isNotEmpty() &amp;&amp;
            currentStatus.value?.size != totalStatusCnt) {
        isSearching.set(true)
    } else if (keyword != null &amp;&amp; keyword!!.isNotEmpty()) {
        isSearching.set(true)
    } else if (sellerIds != null &amp;&amp; sellerIds!!.isNotEmpty()) {
        isSearching.set(true)
    } else if (subSellerIds != null &amp;&amp; subSellerIds!!.isNotEmpty()) {
        isSearching.set(true)
    } else if (partnerIds != null &amp;&amp; partnerIds!!.isNotEmpty()) {
        isSearching.set(true)
    } else if (productTypeIds != null &amp;&amp; productTypeIds!!.isNotEmpty()) {
        isSearching.set(true)
    } else if (brunchIds != null &amp;&amp; brunchIds!!.isNotEmpty()) {
        isSearching.set(true)
    } else if (contractDateFrom != null &amp;&amp; contractDateFrom!!.isNotEmpty()) {
        isSearching.set(true)
    } else if (contractDateTo != null &amp;&amp; contractDateTo!!.isNotEmpty()) {
        isSearching.set(true)
    } else if (completeDateFrom != null &amp;&amp; completeDateFrom!!.isNotEmpty()) {
        isSearching.set(true)
    } else if (completeDateTo != null &amp;&amp; completeDateTo!!.isNotEmpty()) {
        isSearching.set(true)
    } else {
        isSearching.set(false)
    }
}

private fun checkIfNotEmpty(field: Any?): Boolean {
    return field != null &amp;&amp; field!!.isNotEmpty() // isNotEmpty is not unsolved reference
}

class User

interface Repository&lt;T, ID&gt;

interface UserRepository : Repository&lt;User, Long&gt;

abstract class RepositoryTest&lt;T, ID&gt; {

    abstract var repository: Repository&lt;T, ID&gt;

}

class UserRepositoryTest : RepositoryTest&lt;User, Long&gt;() {

    //Error: Var-property type is "UserRepository", which is not a type of overriden 
    lateinit override var repository: UserRepository

}

Repository
RepositoryTest
UserRepositoryTest
UserRepository
Repository
public class Person {
    private String name;
    public Person(String name) { this.name = name; }
    public String getName() { return name; }
    public static void main(String[] args) {
        Person p = new Person("me");
        System.out.println(p.getName());
    }
}

// Person.kt
open class Person(var name: String)

$ kotlinc Person.kt &amp;&amp; javap -p Person.class
Compiled from "Person.kt"
public class Person {
  private java.lang.String name;
  public final java.lang.String getName();
  public final void setName(java.lang.String);
  public Person(java.lang.String);
}

open class Person(var name: String)
fun main(args: Array&lt;String&gt;) {
    val p = Person("me")
    println(p.getName())
}

$ kotlinc Person.kt 
Person.kt:4:15: error: unresolved reference: getName
    println(p.getName())
              ^

p.name
// PersonDemo.kt in same dir as Person.kt
object PersonDemo {
    fun main(args: Array&lt;String&gt;) {
        val p = Person("me")
    }
}

$ kotlinc PersonDemo.kt || (kotlinc Person.kt &amp;&amp; kotlinc PersonDemo.kt)
PersonDemo.kt:3:17: error: unresolved reference: Person
        var p = Person("me")
                ^
PersonDemo.kt:3:17: error: unresolved reference: Person
        var p = Person("me")
                ^

.toChar()
readLine()!!
//An Array Of Characters
    var CharAr= Array&lt;Char&gt;(5){' '}
    for(i in 0..4){
        println("Please Enter The character Number ${i+1}")
        CharAr[i]= readLine()!!.toChar()
    }

//Normal readLine()
var CharacterNum1:Char
    println("Please Enter a Character")
    CharacterNum1= readLine()!!.toChar()

fun  validateDetails(jabberId:String, passwordText: String) {

            if(jabberId.isEmpty()){
                jabber_id.requestFocus()
                jabber_id.error="Jabber id can't be null."
                 return false
            }else if(jabberId.isBlank()){
             jabber_id.requestFocus()
             jabber_id.error="Jabber id can't be blank."
              return false
            }else if (passwordText.isNotEmpty()){
                password.requestFocus();
                password.error="Password can't be null."
                 return false
            }
             else{
                 return true
            }   

    }

val evenDigits = intArrayOf(0, 2, 4, 6, 8)
for (digit in evenDigits)
    println(digit)

intArrayOf(0, 2, 4, 6, 8).forEach { println(it) }

@Module(includes = {AModule.class, XModule.class})

@Module(includes = [AModule::class, XModule::class])

Class&lt;?&gt;[] classArray = {AModule.class, XModule.class};

val classArray = arrayOf(AModule::class.java, XModule::class.java)

{AModule.class, XModule.class}
[]
arrayOf
public class WordRepository {

   private WordDao mWordDao;
   private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;

   WordRepository(Application application) {
       WordRoomDatabase db = WordRoomDatabase.getDatabase(application);
       mWordDao = db.wordDao();
       mAllWords = mWordDao.getAllWords();
   }

   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() {
       return mAllWords;
   }


   public void insert (Word word) {
       new insertAsyncTask(mWordDao).execute(word);
   }

   private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; {

       private WordDao mAsyncTaskDao;

       insertAsyncTask(WordDao dao) {
           mAsyncTaskDao = dao;
       }

       @Override
       protected Void doInBackground(final Word... params) {
           mAsyncTaskDao.insert(params[0]);
           return null;
       }
   }
}

class WordRepository internal constructor(application:Application) {
  private val mWordDao:WordDao
  internal val allWords:LiveData&lt;List&lt;Word&gt;&gt;
  init{
    val db = WordRoomDatabase.getDatabase(application)
    mWordDao = db.wordDao()
    allWords = mWordDao.getAllWords()
  }
  fun insert(word:Word) {
    insertAsyncTask(mWordDao).execute(word)
  }
  private class insertAsyncTask internal constructor(dao:WordDao):AsyncTask&lt;Word, Void, Void&gt;() {
    private val mAsyncTaskDao:WordDao
    init{
      mAsyncTaskDao = dao
    }
    protected fun doInBackground(vararg params:Word):Void {
      mAsyncTaskDao.insert(params[0])
      return null
    }
  }
}

WordRoomDatabase.getDatabase(application)

WordRoomDatabase.getInstance(application)

abstract class WordRoomDatabase: RoomDatabase(){

    companion object {
        private var INSTANCE: WordRoomDatabase? = null

        fun getInstance(context: Context): WordRoomDatabase? {
            if (INSTANCE == null){
                synchronized(WordRoomDatabase::class){
                    INSTANCE = Room.databaseBuilder(context.getApplicationContext(),
                            WordRoomDatabase::class.java, "sps.db")
                            .build()
                }
            }
            return INSTANCE
        }

        fun destroyInstance(){
            INSTANCE == null
        }
    }
}

mWordDao = db.wordDao();

data class DocData(
val i:Int=3,
val s:String="test",
val d:Double=0.2) 

fun checkTypesAndValues() {
    val docData = DocData()
    val fields = docData.javaClass.declaredFields
    for (i in 0..fields.lastIndex) {
        val f = fields[i]
        when (f.type) {
            is Int -&gt; System.out.println(f.value)
            is String -&gt; System.out.println(f.value)
            is Double -&gt; System.out.println(f.value)
        }
    }
}

val lambda: (Long, Long) -&gt; Long = { x, y -&gt; for (i in x..y) {x * y}//I don't know what to fix in this block }

class MyFragment : BaseMvpFragment&lt;MvpView, MvpPresenter&gt;(), MvpView {}

MvpView
MvpPresenter
MyFragment
BaseMvpFragment&lt;MvpView, MvpPresenter&gt;()
&lt;MvpView, MvpPresenter&gt;
fun getType(obj: Any?): String {
    if (obj != null)
        println("$obj -&gt; isArray:${isArray(obj)}")

    return when (obj) {
        null -&gt; "null"
        [...]
        isArray(obj) -&gt; "Array"
        else -&gt; "Other object"
    }
}

private fun isArray(obj: Any): Any = 
        obj is Array&lt;*&gt; ||
        [...]
        obj is IntArray

assertEquals("Array", getType(intArrayOf(1,2,3,4)))
[I@1e25b76 -&gt; isArray:true

org.junit.ComparisonFailure: 
Expected :Array
Actual   :Other object

isArray
true
when
"Array"
when
    char array[] = &quot;This is not a question.&quot;;
    char *ptr = strchr(array, ' '); // points to the first space

class Foo {
  var id = 1
}

class Bar {
  var foos = listOf(Foo())

  fun printFooIds() {
    foos.forEach { println(it.id) }       // works
    foos.forEach { println(it.getId()) }  // error "Unresolved reference: getId"
  }
}

class Foo {
  companion object {
    enum class Type { A, B, C }
  }
}

class Bar {
  val typeA = Foo.Companion.Type.A  // works
  val typeB = Foo.Type.B            // error: "Unresolved reference: Type"
}

continue
for (i in 0..10) {
    // .. some initial code
    if (i == something) continue
    // .. some other code
}

forEach
(0 .. 10).forEach {
    // .. some initial code
    if (i == something) continue
    // .. some other code
}

continue
forEach
object
object Buffer
binding(bufferName[Buffer.VERTEX] to GL_ARRAY_BUFFER) {
    ... // calling Buffer functions
}

object Buffer
GL_ARRAY_BUFFER
binding
inline fun &lt;T, R&gt; binding(pair: Pair&lt;Int, Int&gt;, block: T.() -&gt; R)

fun Boolean.then(action: () -&gt; Unit): Boolean {
    if (this)
        action.invoke()
    return this
}

fun Boolean.otherwise(action: () -&gt; Unit) {
    if (!this)
        action.invoke()
}

fun &lt;T&gt; Boolean.then(func: () -&gt; T): T? {
    if (this)
        return func.invoke()
    return null
}

fun &lt;T&gt; T?.otherwise(action: () -&gt; T): T {
    return this ?: action.invoke()
}

(check).then { doHello() }.otherwise { doWorld() }

val answer = (check).then { "hello" }.otherwise { "world" }

 val visibility: Int = (show).then { View.VISIBLE }.alt { View.GONE }

@Throws(IOException::class)
private fun readAll(rd: Reader): String {
    val sb = StringBuilder()
    var cp: Int
    while ((cp = rd.read()) != -1) {
        sb.append(cp.toChar())
    }

    return sb.toString()
}

while ((cp = rd.read()) != -1)

    fun itsAfunction() = 10
    fun check(function:()-&gt;Int):Int{
        return function() + 9
    }

    val result = check(itsAfunction)

val result = check({itsAfunction})

image_view.viewTreeObserver.addOnGlobalLayoutListener{
};

image_view.viewTreeObserver.addOnGlobalLayoutListener
{
};

data class Customer (val id: Int) : Comparable by id
id
interface Animal {}

class Dog : Animal {}

interface Leash&lt;in T: Animal&gt; {
    fun attachToCollarOf(animal: T)
}

class DogLeash : Leash&lt;Dog&gt; {
    override fun attachToCollarOf(animal: Dog) {
        TODO("Not yet implemented")
    }
}

val foo: Leash&lt;Animal&gt; = DogLeash


foo
DogLeash()
error: type mismatch: inferred type is DogLeash but Leash&lt;Animal&gt; was expected
in
out
with
val array1 = byteArrayOf(1,2,4, ...)
val array2 = byteArrayOf(1,2,3, ...)

val (smaller, bigger) = array1.zip(array2)
    .dropWhile { it.first == it.second }
    .firstOrNull()?.let {
        when (it.first &lt; it.second) {
            true -&gt; array1 to array2
            else -&gt; array2 to array1
        }
    } ?: array1 to array2

fun a(x:Int):List&lt;List&lt;Int&gt;&gt;{
  var a = 1.rangeTo(x);
  var b: List&lt;List&lt;Int&gt;&gt; = emptyList();
  for (i in a){
    var num1 = if(i&lt;=3) i else 4;
    var list_a= 0.rangeTo(num1 - 1);
    b.add(list_a);
  }
  return b
}

b.add(list_a)
error(unresolved reference)
println(a(2))
[[0],[0,1]]
IRepository.kt
interface IRepository
{
    fun &lt;T&gt;Save(model:T)
    fun &lt;T&gt;Delete(model:T)
    fun &lt;T&gt;Get(id:Long):T
}

Repolmpl.kt
class Repolmpl:IRepository
{

  override fun &lt;T&gt;Delete(model:T)
  {
      println("$model  : Save}")
  }

  override fun &lt;T&gt;Get(id:Long):T
  {
      return T //ERROR here I want to return T...
  }

  override fun &lt;T&gt; Save(model: T) 
  {
      println("$model : Delete")
  }
}

fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; {
    // ...
}

&lt;T&gt;
List&lt;T&gt;
&lt;T&gt;
// Not valid Kotlin code.
fun &lt;T : Summable&gt; myFunction ...

T : Summable
T
+
.plus
items.map { async(executor) process(it) }.forEach { it.await() }

abstract class ConsumerStub&lt;TYPE&gt;{

    val receivedMessages: MutableMap&lt;String, TYPE&gt; = ConcurrentHashMap()

    open fun processMessage(@Payload payload: TYPE, record: ConsumerRecord&lt;String, *&gt;) {
        this.receivedMessages[record.key()] = payload
    }

    fun receivedMessageWithKey(key: String): Boolean = this.receivedMessages.contains(key)

    fun receivedMessageWithKeyCallable(key: String): Callable&lt;Boolean&gt; = Callable { receivedMessageWithKey(key) }

    fun getReceiveMessageWithKey(key: String): TYPE? = this.receivedMessages[key]

    fun reset() {
        this.receivedMessages.clear()
    }
}

open class WorkflowRequestConsumerStub: ConsumerStub&lt;InternalWorkflowRequest&gt;() {

    @KafkaListener(
        id = "xyzRequestConsumerStub",
        topics = ["abc-workflow-requests"]
    )
    override fun processMessage(
        @Payload payload: InternalWorkflowRequest,
        record: ConsumerRecord&lt;String, *&gt;
    ) {
        super.processMessage(payload, record)
    }

}

"b23c77126dd924bf".toLong(16)
java.lang.NumberFormatException
0xb23c77126dd924bf
-5603472915319675713
if (people.job == Job.Developer || people.job == Job.Scientist) {
    // do Something
}

if (people.job in (Job.Developer, Job.Scientist)) {
}

open class B {
    fun b() = this
}

open class C : B() {
    fun c() = 0
}

fun test(c: C) {
    c.b().c() // error: c.b() returns B, not C
}

c.b()
C
String
public class String : Comparable&lt;String&gt;, CharSequence {
    companion object {}        
    public operator fun plus(other: Any?): String    
    public override val length: Int    
    public override fun get(index: Int): Char    
    public override fun subSequence(startIndex: Int, endIndex: Int): CharSequence    
    public override fun compareTo(other: String): Int
}

StringsJVM.kt
public inline fun String(bytes: ByteArray, offset: Int, length: Int): String =
    java.lang.String(bytes, offset, length, Charsets.UTF_8) as String

java.lang.String
kotlin.String
CharSequence
length
DatePickerDialog.OnDateSetListener {
            _: DatePicker, year: Int, month: Int, day: Int -&gt;

        val resultDate : Date = GregorianCalendar(year, month, day).time

        targetFragment?.let { fragment -&gt;
            (fragment as Callbacks).onDateSelected(resultDate)
        }
}

interface HasChildren {
    val children: Sequence&lt;HasChildren&gt;
}

class Branch(val children: Sequence&lt;Branch&gt;) : HasChildren

Branch
Branch
Self
protocol HasChildren {
    let children : Sequence&lt;Self&gt; { get }
}

val userid = FirebaseAuth.getInstance().currentUser!!.uid
for(element in 0..2 )
{
    val storage = Firebase.storage
    var storageRef = storage.reference

    val uri = userSelectedImageUriList!!.get(element)
    val fullrefernce = storageRef.child(&quot;images&quot;)
                          .child(userid)
                          .child(category)
            .child(category+&quot;_&quot;+userid+&quot;_&quot;+System.currentTimeMillis()+&quot;.png&quot;)
            val uploadtask = fullrefernce.putFile(uri!!)
            uploadtask.continueWith { task -&gt;
                if (!task.isSuccessful) {
                    task.exception?.let {
                        throw it
                    }

                }
                fullrefernce.downloadUrl
            }.addOnCompleteListener { task -&gt;

                if (task.isSuccessful) {
                    task.result!!.addOnSuccessListener { task -&gt;
                        var myuri =  task.toString()

                        imagesurlist!!.add(myuri)


                    }
                }
            }
        }
//uploadurl(imagesurlist,name,description,datetext,category,address)
        Log.d(&quot;firs&quot;,imagesurlist.toString())

    }

::function
fun isOdd(x: Int) = x % 2 != 0
val numbers = listOf(1, 2, 3)
println(numbers.filter(::isOdd)) // here.

fun isOdd(x: Int) = x % 2 != 0
val numbers = listOf(1, 2, 3)
println(numbers.filter(isOdd)) // simple and makes more sense

ObjectName.INSTANCE.iAmStaticMethod();

ClassName.Companion.iAmStaticMethod();

new Thread("Cute Thread") {
  public void run() {
    int a = 3;
  }
}.start();

object : Thread("Cute Thread") {
  override fun run() {
     val a = 3
  }
}.start()

  Thread("Cute Thread") { val a = 3 }.start()

package com.forplay.a4play.`interface`

interface SongListListener {
    fun refreshItems()

    fun listToggleShuffle()

    fun listToggleSongRepetition()
}


package com.forplay.a4play.activity

import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import com.forplay.a4play.R
import com.forplay.a4play.dialog.ConfirmationDialog
import com.forplay.a4play.extension.*
import com.forplay.a4play.util.Const.Permissions.PERMISSION_WRITE_STORAGE

abstract class BaseActivity : AppCompatActivity() {

    companion object {
        var funAfterSAFPermission: ((success: Boolean) -&gt; Unit)? = null
    }

    private val GENERIC_PERM_HANDLER = 100
    var actionOnPermission: ((granted: Boolean) -&gt; Unit)? = null
    private var isAskingPermissions: Boolean = false

    override fun onResume() {
        super.onResume()

        handlePermission(PERMISSION_WRITE_STORAGE) {
            if (!it) {
                toast("Has No Permissions")
            }
        }
    }

    protected fun handlePermission(permissionId: Int, callback: (granted: Boolean) -&gt; Unit) {
        actionOnPermission = null
        if (hasPermission(permissionId)) {
            callback(true)
        } else {
            isAskingPermissions = true
            actionOnPermission = callback
            ActivityCompat.requestPermissions(
                this,
                arrayOf(getPermissionString(permissionId)),
                GENERIC_PERM_HANDLER
            )
        }
    }

    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array&lt;String&gt;,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        isAskingPermissions = false
        if (requestCode == GENERIC_PERM_HANDLER &amp;&amp; grantResults.isNotEmpty()) {
            actionOnPermission?.invoke(grantResults[0] == 0)
        }
    }

    fun handleSAFDialog(path: String, callback: (success: Boolean) -&gt; Unit): Boolean {
        return if (!packageName.startsWith("com.forplay")) {
            callback(true)
            false
        } else if (isShowingSAFDialog(path) || isShowingOTGDialog(path)) {
            funAfterSAFPermission = callback
            true
        } else {
            callback(true)
            false
        }
    }

    fun checkAppOnSDCard() {
        if (!config.wasAppOnSDShown &amp;&amp; isAppInstalledOnSDCard()) {
            config.wasAppOnSDShown = true
            ConfirmationDialog(this, "", R.string.app_on_sd_card, R.string.ok, 0) {}
        }
    }
}

    class MainActivity : BaseActivity(), SongListListener {
    private var isThirdPartyIntent:Boolean = false
    private var songs = ArrayList&lt;Song&gt;()
    private var searchMenuItem: MenuItem? = null
    private var isSearchOpen = false
    private var wasInitialPlaylistSet = false
    private var lastFilePickerPath = ""
    private var artView: ViewGroup? = null

    private var actionbarSize = 0
    private var topArtHeight = 0

    private var storedTextColor = 0
    private var storedShowAlbumCover = true

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        appLaunched(BuildConfig.APPLICATION_ID)
        isThirdPartyIntent = intent.action == Intent.ACTION_VIEW

        BusProvider.getInstance().register(this)
        initSeekbarChangeListener()

        actionbarSize = getActionBarHeight()
        artView = layoutInflater.inflate(R.layout.item_transparent, null) as ViewGroup
        setTopArtHeight()
        songs_fastscroller.measureItemIndex = LIST_HEADERS_COUNT

        handlePermission(PERMISSION_WRITE_STORAGE) {
            if (it) {
                initializePlayer()
            } else {
                toast(R.string.no_storage_permissions)
            }
        }

        shuffle_btn.setOnClickListener { toggleShuffle() }
        previous_btn.setOnClickListener { sendIntent(PREVIOUS) }
        play_pause_btn.setOnClickListener { sendIntent(PLAYPAUSE) }
        next_btn.setOnClickListener { sendIntent(NEXT) }
        repeat_btn.setOnClickListener { toggleSongRepetition() }
        song_progress_current.setOnClickListener { sendIntent(SKIP_BACKWARD) }
        song_progress_max.setOnClickListener { sendIntent(SKIP_FORWARD) }

        songs_playlist_empty_add_folder.setOnClickListener { addFolderToPlaylist() }
        volumeControlStream = AudioManager.STREAM_MUSIC
        storeStateVariables()

//        songs_list.recyclerScrollCallback = object : RecyclerScrollCallback {
//            override fun onScrolled(scrollY: Int) {
//                top_navigation.beVisibleIf(scrollY &gt; topArtHeight &amp;&amp; !isSearchOpen)
//                val minOverlayTransitionY = actionbarSize - topArtHeight
//                art_holder.translationY =
//                    Math.min(0, Math.max(minOverlayTransitionY, -scrollY / 2)).toFloat()
//                song_list_background.translationY = Math.max(0, -scrollY + topArtHeight).toFloat()
//            }
//        }

        if (savedInstanceState != null) {
            songs_list.onGlobalLayout {
                songs_list.scrollToPosition(0)
            }
        }

        checkAppOnSDCard()
    }

 // Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    ext.kotlin_version = '1.3.50'
    repositories {
        google()
        jcenter()

    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.5.2'
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        google()
        jcenter()
        maven { url "https://maven.google.com" }
        maven { url "https://jitpack.io" }
        maven { url "https://kotlin.bintray.com/kotlinx"}
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

This is gradle (APP)
    apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'
apply plugin: 'kotlin-kapt'

android {
    compileSdkVersion 28
    buildToolsVersion "29.0.2"
    defaultConfig {
        applicationId "com.forplay.a4play"
        minSdkVersion 21
        targetSdkVersion 28
        versionCode 1
        versionName "1.0"
        setProperty("archivesBaseName", "music-player")
    }

    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }

    sourceSets {
        main.java.srcDirs += 'src/main/kotlin'
    }

    lintOptions {
        checkReleaseBuilds false
        abortOnError false
    }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
    implementation 'androidx.appcompat:appcompat:1.1.0'
    implementation 'androidx.core:core-ktx:1.1.0'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    implementation 'androidx.core:core:1.1.0'
    implementation 'androidx.media:media:1.1.0'
    implementation 'com.squareup:otto:1.3.8'

    implementation 'androidx.swiperefreshlayout:swiperefreshlayout:1.0.0'
    implementation 'androidx.documentfile:documentfile:1.0.1'
    implementation 'com.google.android.material:material:1.0.0'

    kapt "androidx.room:room-compiler:2.2.2"
    implementation "androidx.room:room-runtime:2.2.2"

    implementation 'com.github.bumptech.glide:glide:4.10.0'
    kapt 'com.github.bumptech.glide:compiler:4.10.0'

    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test.ext:junit:1.1.1'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'
}

    Executing tasks: [:app:assembleDebug] in project /Users/nirisraelhen/Dev/Android/Projects/4Play

    &gt; Task :app:preBuild UP-TO-DATE
    &gt; Task :app:preDebugBuild UP-TO-DATE
    &gt; Task :app:checkDebugManifest UP-TO-DATE
    &gt; Task :app:generateDebugBuildConfig UP-TO-DATE
    &gt; Task :app:mainApkListPersistenceDebug UP-TO-DATE
    &gt; Task :app:compileDebugAidl NO-SOURCE
    &gt; Task :app:compileDebugRenderscript NO-SOURCE
    &gt; Task :app:generateDebugResValues UP-TO-DATE
    &gt; Task :app:generateDebugResources UP-TO-DATE
    &gt; Task :app:mergeDebugResources UP-TO-DATE
    &gt; Task :app:createDebugCompatibleScreenManifests UP-TO-DATE
    &gt; Task :app:processDebugManifest UP-TO-DATE
    &gt; Task :app:processDebugResources UP-TO-DATE
    &gt; Task :app:kaptGenerateStubsDebugKotlin

    &gt; Task :app:kaptDebugKotlin FAILED
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:6: error: &lt;identifier&gt; expected
    public final class MainActivity extends com.forplay.a4play.activity.BaseActivity implements com.forplay.a4play.interface.SongListListener {
                                                                                                                   ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:6: error: illegal start of type
    public final class MainActivity extends com.forplay.a4play.activity.BaseActivity implements com.forplay.a4play.interface.SongListListener {
                                                                                                                            ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:6: error: ';' expected
    public final class MainActivity extends com.forplay.a4play.activity.BaseActivity implements com.forplay.a4play.interface.SongListListener {
                                                                                                                                             ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:7: error: illegal start of expression
        private boolean isThirdPartyIntent;
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:8: error: illegal start of expression
        private java.util.ArrayList&lt;com.forplay.a4play.model.Song&gt; songs;
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:9: error: illegal start of expression
        private android.view.MenuItem searchMenuItem;
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:10: error: illegal start of expression
        private boolean isSearchOpen;
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:11: error: illegal start of expression
        private boolean wasInitialPlaylistSet;
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:12: error: illegal start of expression
        private java.lang.String lastFilePickerPath;
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:13: error: illegal start of expression
        private android.view.ViewGroup artView;
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:14: error: illegal start of expression
        private int actionbarSize;
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:15: error: illegal start of expression
        private int topArtHeight;
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:16: error: illegal start of expression
        private int storedTextColor;
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:17: error: illegal start of expression
        private boolean storedShowAlbumCover;
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:18: error: illegal start of expression
        private java.util.HashMap _$_findViewCache;
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:21: error: ';' expected
        protected void onCreate(@org.jetbrains.annotations.Nullable()
                               ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:22: error: ';' expected
        android.os.Bundle savedInstanceState) {
                                            ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:26: error: ';' expected
        protected void onResume() {
                               ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:30: error: ';' expected
        protected void onPause() {
                              ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:34: error: ';' expected
        protected void onStop() {
                             ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:38: error: ';' expected
        protected void onDestroy() {
                                ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:41: error: illegal start of expression
        private final void storeStateVariables() {
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:41: error: ';' expected
        private final void storeStateVariables() {
                                              ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:45: error: ';' expected
        protected void onNewIntent(@org.jetbrains.annotations.NotNull()
                                  ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:46: error: ';' expected
        android.content.Intent intent) {
                                     ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:49: error: illegal start of expression
        private final void setTopArtHeight() {
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:49: error: ';' expected
        private final void setTopArtHeight() {
                                          ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:52: error: illegal start of expression
        private final void setupSearch(android.view.Menu menu) {
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:52: error: ';' expected
        private final void setupSearch(android.view.Menu menu) {
                                      ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:52: error: ';' expected
        private final void setupSearch(android.view.Menu menu) {
                                                             ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:55: error: illegal start of expression
        private final void showSortingDialog() {
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:55: error: ';' expected
        private final void showSortingDialog() {
                                            ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:58: error: illegal start of expression
        private final void toggleShuffle() {
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:58: error: ';' expected
        private final void toggleShuffle() {
                                        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:61: error: illegal start of expression
        private final void toggleSongRepetition() {
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:61: error: ';' expected
        private final void toggleSongRepetition() {
                                               ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:64: error: illegal start of expression
        private final void removePlaylist() {
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:64: error: ';' expected
        private final void removePlaylist() {
                                         ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:67: error: illegal start of expression
        private final void openPlaylist() {
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:67: error: ';' expected
        private final void openPlaylist() {
                                       ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:70: error: illegal start of expression
        private final void showPlaylists(java.util.ArrayList&lt;com.forplay.a4play.model.Playlist&gt; playlists) {
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:70: error: ';' expected
        private final void showPlaylists(java.util.ArrayList&lt;com.forplay.a4play.model.Playlist&gt; playlists) {
                                        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:70: error: ';' expected
        private final void showPlaylists(java.util.ArrayList&lt;com.forplay.a4play.model.Playlist&gt; playlists) {
                                                                                                         ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:73: error: illegal start of expression
        private final void addFolderToPlaylist() {
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:73: error: ';' expected
        private final void addFolderToPlaylist() {
                                              ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:76: error: illegal start of expression
        private final java.util.ArrayList&lt;java.lang.String&gt; getFolderSongs(java.io.File folder) {
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:76: error: ';' expected
        private final java.util.ArrayList&lt;java.lang.String&gt; getFolderSongs(java.io.File folder) {
                                                                          ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:76: error: ';' expected
        private final java.util.ArrayList&lt;java.lang.String&gt; getFolderSongs(java.io.File folder) {
                                                                                              ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:80: error: illegal start of expression
        private final void addFileToPlaylist() {
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:80: error: ';' expected
        private final void addFileToPlaylist() {
                                            ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:83: error: illegal start of expression
        private final void createPlaylistFromFolder() {
        ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:83: error: ';' expected
        private final void createPlaylistFromFolder() {
                                                   ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:86: error: illegal start of expression
        private final void createPlaylistFrom(java.lang.String path) {
        ^

    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:111: error: ';' expected
        private final void fillSongsListView(java.util.ArrayList&lt;com.forplay.a4play.model.Song&gt; songs) {
                                            ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:111: error: ';' expected
        private final void fillSongsListView(java.util.ArrayList&lt;com.forplay.a4play.model.Song&gt; songs) {
                                                                                                     ^
    e: /Users/nirisraelhen/Dev/Android/Projects/4Play/app/build/tmp/kapt3/stubs/debug/com/forplay/a4play/activity/MainActivity.java:114: error: illegal start of expression
        private final int getSongIndex(com.forplay.a4play.model.Song song) {
        ^
org.jetbrains.kotlin.cli.jvm.compiler.KotlinToJVMBytecodeCompiler.compileModules$cli(KotlinToJVMBytecodeCompiler.kt:182)
        at org.jetbrains.kotlin.cli.jvm.K2JVMCompiler.doExecute(K2JVMCompiler.kt:164)
        at org.jetbrains.kotlin.cli.jvm.K2JVMCompiler.doExecute(K2JVMCompiler.kt:54)
        at org.jetbrains.kotlin.cli.common.CLICompiler.execImpl(CLICompiler.kt:84)
        at org.jetbrains.kotlin.cli.common.CLICompiler.execImpl(CLICompiler.kt:42)
        at org.jetbrains.kotlin.cli.common.CLITool.exec(CLITool.kt:104)
        at org.jetbrains.kotlin.daemon.CompileServiceImpl.compile(CompileServiceImpl.kt:1558)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:357)
        at sun.rmi.transport.Transport$1.run(Transport.java:200)
        at sun.rmi.transport.Transport$1.run(Transport.java:197)
        at java.security.AccessController.doPrivileged(Native Method)
        at sun.rmi.transport.Transport.serviceCall(Transport.java:196)
        at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:573)
        at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:834)
        at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$0(TCPTransport.java:688)
        at java.security.AccessController.doPrivileged(Native Method)
        at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:687)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at java.lang.Thread.run(Thread.java:748)
    Caused by: java.lang.IllegalStateException: processingEnv must not be null
        at androidx.room.RoomProcessor.getSupportedOptions(RoomProcessor.kt:57)
        at org.jetbrains.kotlin.kapt3.base.incremental.IncrementalProcessor.getSupportedOptions(incrementalProcessors.kt)
        at org.jetbrains.kotlin.kapt3.base.incremental.IncrementalProcessor.createDependencyCollector(incrementalProcessors.kt:44)
        at org.jetbrains.kotlin.kapt3.base.incremental.IncrementalProcessor.access$createDependencyCollector(incrementalProcessors.kt:22)
        at org.jetbrains.kotlin.kapt3.base.incremental.IncrementalProcessor$dependencyCollector$1.invoke(incrementalProcessors.kt:24)
        at org.jetbrains.kotlin.kapt3.base.incremental.IncrementalProcessor$dependencyCollector$1.invoke(incrementalProcessors.kt:22)
        at kotlin.SynchronizedLazyImpl.getValue(LazyJVM.kt:74)
        at org.jetbrains.kotlin.kapt3.base.incremental.IncrementalProcessor.getRuntimeType(incrementalProcessors.kt:69)
        at org.jetbrains.kotlin.cli.jvm.compiler.KotlinToJVMBytecodeCompiler.compileModules$cli(KotlinToJVMBytecodeCompiler.kt:177)
        ... 23 more


    FAILURE: Build failed with an exception.

    * What went wrong:
    Execution failed for task ':app:kaptDebugKotlin'.
    &gt; Internal compiler error. See log for more details

    * Try:
    Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.

    * Get more help at https://help.gradle.org

    BUILD FAILED in 3s
    10 actionable tasks: 2 executed, 8 up-to-date

class FirstVeryLongName {
  object ObjectA
  object ObjectB
  object ObjectC
}
class SecondVeryLongName {
  object ObjectB
  object ObjectD
}

operation1(FirstVeryLongName.ObjectA, FirstVeryLongName.ObjectB)
operation2(SecondVeryLongName.ObjectB, SecondVeryLongName.ObjectD)

FirstVeryLongName.run {
  operation1(ObjectA, ObjectB)
}

ObjectA
ObjectB
FirstVeryLongName
FirstVeryLongName.Companion.run { ... }

val
FirstVeryLongName
ObjectA
ObjectB
1
2
[1,1,1,2,2,1,1,1,1,2,2,3]

[1,2,1,2,3]

abstract class Action {
  fun sleep(body: Person.() -&gt; Unit){
    var p = Person("a");
    p.body()
    println(p.name + " is zzzzzzz...")
  }
}

class Person(var name:String =""){
  companion object:Action();
}

inline fun &lt;reified T&gt; test(){
  val companionObject = T::class.companionObject
  if (companionObject != null) {
    println(companionObject.javaObjectType)
    val functionEx = companionObject.functions.filter { it.name.equals("sleep") }.first()
    // How to invoke functionEx with block and "this"
  }
}

fun main(args: Array&lt;String&gt;) {
  Person.sleep {
    this.name = "abc"
  }
  test&lt;Person&gt;()
}

sleep
functionEx
this
Action
Person
test
import org.junit.Test
import org.testng.Assert


class SomeTest {

    @Test
    fun testIt() {

        // GIVEN a list of 2 items, all field values are zero
        val items = listOf(Item(0, 0), Item(0,0))

        // AND a function to increment field 1
        val itemProcessor1: (Item) -&gt; Item = {item -&gt; item.copy(field1 =  item.field1.inc())}

        // AND a function to increment field 2
        val itemProcessor2: (Item) -&gt; Item = {item -&gt; item.copy(field2 =  item.field2.inc())}

        // WHEN
        val actual = applyProcessors(items, listOf(itemProcessor1, itemProcessor2))

        // THEN we expect all fields to be incremented
        val expected = listOf(Item(1, 1), Item(1, 1))
        Assert.assertEquals(expected, actual)

    }

    private fun applyProcessors(items: List&lt;Item&gt;, itemProcessors: List&lt;(Item) -&gt; Item&gt;): List&lt;Item&gt; {

        // ??? How to combine the list of itemProcessor functions so that each processed Item is passed on to the next processor?
        return items.map { it }

    }

}

data class Item(val field1: Int, val field2: Int)

native
class Person {
@JsonProperty("name")
var name: String? = null

@JsonProperty("id")
lateinit var id: String}

 val person = Person()
 person.name = "someName"
 person.id = "SomeId"

val person = Person {name = "someName" , id = "someId"}

val a: Int = 100
val boxedA: Int? = a
val anotherBoxedA: Int? = a

val b: Int = 10000
val boxedB: Int? = b
val anotherBoxedB: Int? = b

println(boxedA === anotherBoxedA) // true
println(boxedB === anotherBoxedB) // false

boexA === andotherBoxedA
boexB === andotherBoxedB
val a: Int = 100
val boxedA: Int? = a
val anotherBoxedA: Int? = a

val b: Int = 100
val boxedB: Int? = b
val anotherBoxedB: Int? = b

println(boxedA === anotherBoxedA) // true
println(boxedB === anotherBoxedB) // true

import kotlin.test.assertTrue
fun main(args: Array&lt;String&gt;) {
    assertTrue(false)
}

$ kotlinc -d MyCode.jar MyCode.kt 
MyCode.kt:1:15: error: unresolved reference: test
import kotlin.test.assertTrue
              ^

interface Things {
  fun size(): Int
}

List
class Cars : ArrayList&lt;String&gt;, Things {}

size
var
interface Things {
    var size: Int
}

IllegalStateException
ArrayList
int size()
get
Things
operator
java.lang.IllegalStateException: Backend Internal error: Exception during code generation
Cause: Concrete fake override public open fun &lt;set-size&gt;(&lt;set-?&gt;: kotlin.Int): kotlin.Unit defined in org.blah.Stuff[PropertySetterDescriptorImpl@673f2280] should have exactly one concrete super-declaration: []
File being compiled at position: file:///blah/Stuff.kt
The root cause was thrown at: bridges.kt:122
    at org.jetbrains.kotlin.codegen.CompilationErrorHandler.lambda$static$0(CompilationErrorHandler.java:24)
    at org.jetbrains.kotlin.codegen.PackageCodegenImpl.generate(PackageCodegenImpl.java:76)
    at org.jetbrains.kotlin.codegen.DefaultCodegenFactory.generatePackage(CodegenFactory.kt:96)
    at org.jetbrains.kotlin.codegen.DefaultCodegenFactory.generateModule(CodegenFactory.kt:67)
    at org.jetbrains.kotlin.codegen.KotlinCodegenFacade.doGenerateFiles(KotlinCodegenFacade.java:47)
    at org.jetbrains.kotlin.codegen.KotlinCodegenFacade.compileCorrectFiles(KotlinCodegenFacade.java:39)
    at org.jetbrains.kotlin.cli.jvm.compiler.KotlinToJVMBytecodeCompiler.generate(KotlinToJVMBytecodeCompiler.kt:476)
    at org.jetbrains.kotlin.cli.jvm.compiler.KotlinToJVMBytecodeCompiler.compileModules$cli(KotlinToJVMBytecodeCompiler.kt:164)
    at org.jetbrains.kotlin.cli.jvm.K2JVMCompiler.doExecute(K2JVMCompiler.kt:166)
    at org.jetbrains.kotlin.cli.jvm.K2JVMCompiler.doExecute(K2JVMCompiler.kt:56)
    at org.jetbrains.kotlin.cli.common.CLICompiler.execImpl(CLICompiler.kt:84)
    at org.jetbrains.kotlin.cli.common.CLICompiler.execImpl(CLICompiler.kt:42)
    at org.jetbrains.kotlin.cli.common.CLITool.exec(CLITool.kt:104)
    at org.jetbrains.kotlin.incremental.IncrementalJvmCompilerRunner.runCompiler(IncrementalJvmCompilerRunner.kt:349)
    at org.jetbrains.kotlin.incremental.IncrementalJvmCompilerRunner.runCompiler(IncrementalJvmCompilerRunner.kt:105)
    at org.jetbrains.kotlin.incremental.IncrementalCompilerRunner.compileIncrementally(IncrementalCompilerRunner.kt:237)
    at org.jetbrains.kotlin.incremental.IncrementalCompilerRunner.access$compileIncrementally(IncrementalCompilerRunner.kt:37)
    at org.jetbrains.kotlin.incremental.IncrementalCompilerRunner$compile$2.invoke(IncrementalCompilerRunner.kt:79)
    at org.jetbrains.kotlin.incremental.IncrementalCompilerRunner.compile(IncrementalCompilerRunner.kt:91)
    at org.jetbrains.kotlin.daemon.CompileServiceImpl.execIncrementalCompiler(CompileServiceImpl.kt:579)
    at org.jetbrains.kotlin.daemon.CompileServiceImpl.access$execIncrementalCompiler(CompileServiceImpl.kt:102)
    at org.jetbrains.kotlin.daemon.CompileServiceImpl$compile$$inlined$ifAlive$lambda$2.invoke(CompileServiceImpl.kt:455)
    at org.jetbrains.kotlin.daemon.CompileServiceImpl$compile$$inlined$ifAlive$lambda$2.invoke(CompileServiceImpl.kt:102)
    at org.jetbrains.kotlin.daemon.CompileServiceImpl$doCompile$$inlined$ifAlive$lambda$2.invoke(CompileServiceImpl.kt:1005)
    at org.jetbrains.kotlin.daemon.CompileServiceImpl$doCompile$$inlined$ifAlive$lambda$2.invoke(CompileServiceImpl.kt:102)
    at org.jetbrains.kotlin.daemon.common.DummyProfiler.withMeasure(PerfUtils.kt:138)
    at org.jetbrains.kotlin.daemon.CompileServiceImpl.checkedCompile(CompileServiceImpl.kt:1047)
    at org.jetbrains.kotlin.daemon.CompileServiceImpl.doCompile(CompileServiceImpl.kt:1004)
    at org.jetbrains.kotlin.daemon.CompileServiceImpl.compile(CompileServiceImpl.kt:454)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:346)
    at sun.rmi.transport.Transport$1.run(Transport.java:200)
    at sun.rmi.transport.Transport$1.run(Transport.java:197)
    at java.security.AccessController.doPrivileged(Native Method)
    at sun.rmi.transport.Transport.serviceCall(Transport.java:196)
    at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:568)
    at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:826)
    at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$0(TCPTransport.java:683)
    at java.security.AccessController.doPrivileged(Native Method)
    at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:682)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.IllegalStateException: Concrete fake override public open fun &lt;set-size&gt;(&lt;set-?&gt;: kotlin.Int): kotlin.Unit defined in org.blah.Stuff[PropertySetterDescriptorImpl@673f2280] should have exactly one concrete super-declaration: []
    at org.jetbrains.kotlin.backend.common.bridges.BridgesKt.findConcreteSuperDeclaration(bridges.kt:122)
    at org.jetbrains.kotlin.backend.common.bridges.BridgesKt.generateBridges(bridges.kt:59)
    at org.jetbrains.kotlin.codegen.JvmBridgesImplKt.generateBridgesForFunctionDescriptorForJvm(JvmBridgesImpl.kt:92)
    at org.jetbrains.kotlin.codegen.FunctionCodegen.generateBridges(FunctionCodegen.java:1041)
    at org.jetbrains.kotlin.codegen.ClassBodyCodegen.generateBridges(ClassBodyCodegen.java:138)
    at org.jetbrains.kotlin.codegen.ClassBodyCodegen.generateBody(ClassBodyCodegen.java:116)
    at org.jetbrains.kotlin.codegen.MemberCodegen.generate(MemberCodegen.java:129)
    at org.jetbrains.kotlin.codegen.MemberCodegen.genClassOrObject(MemberCodegen.java:302)
    at org.jetbrains.kotlin.codegen.MemberCodegen.genClassOrObject(MemberCodegen.java:286)
    at org.jetbrains.kotlin.codegen.PackageCodegenImpl.generateClassesAndObjectsInFile(PackageCodegenImpl.java:118)
    at org.jetbrains.kotlin.codegen.PackageCodegenImpl.generateFile(PackageCodegenImpl.java:137)
    at org.jetbrains.kotlin.codegen.PackageCodegenImpl.generate(PackageCodegenImpl.java:68)
    ... 44 more


&gt; Task :app:buildInfoGeneratorDebug 

class Player (private var playerName: String,
                  private var playerSkill: Int,
                  private var playerType: String) {


        var playerID = 0

      }

   override fun onBindViewHolder(holder: ViewHolder, position: Int) {

        val item = getItem(position)
        context=this.context
        item.address="Otra dir"
        item.clickListener=View.OnClickListener {
          /* Code to do on clickListener*/
        }
        holder.bind(item)
    }

Toast.makeText(this.context,"test",Toast.LENGTH_LONG).show()
            Navigation.findNavController(holder.itemView)
                .navigate(R.id.loginFragment, bundleOf(REQUEST_ID to item.id))

data class Asset(val id: Int?, val name: String?, var address: String?, var clickListener:View.OnClickListener)

 private val resources = LockApp.instance.resources
    init {

        viewModelScope.launch {

            _showLoading.postValue(true)
            delay(3000)
            _assets.postValue(
                listOf(
                    Asset(1, "Nombre 1", "Dirección 1", View.OnClickListener {  }),
                    Asset(2, "Nombre 2", "Dirección 2", View.OnClickListener {  }),
                    Asset(3, "Nombre 3", "Dirección 3", View.OnClickListener {  }),
                    Asset(4, "Nombre 4", "Dirección 4", View.OnClickListener {  }),
                    Asset(5, "Nombre 5", "Dirección 5", View.OnClickListener {  })
                )
            )
            _showLoading.postValue(false)
        }
    }

override fun onCallback(name: String?) {

}

override fun onCallback(name: String) {

}

onCallback(null)
if (p?.company?.industries?.size &gt; 0)
   job.industryName = p?.company?.industries!![0]

val a: Int = 1
val a_D: BigDecimal = a.toBigDecimal()
val b_D: BigDecimal = a.toBigDecimal()

!1 // false
!0 // true
!{foo: "bar"} // false

!true // false

!
 private fun sendNotification(remoteMessage: RemoteMessage?) {
     if (remoteMessage?.notification != null) {
        // Setup Intent to Open Home
        val intent = Intent(this, Home::class.java)
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
        val pendingIntent = PendingIntent.getActivity(this, 0, intent,
                PendingIntent.FLAG_ONE_SHOT)

        // Parse the remoteMessage
        val body : String? = remoteMessage.notification?.body
        var builder = Notification.Builder(this, CHANNEL_ID)
                .setSmallIcon(R.drawable.notify_icon_small_white)
                .setColor(Color.parseColor(bgColor))
                .setContentIntent(pendingIntent)
                .setContentTitle("strive.ai")
                .setContentText(body)

        with(getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager) {
            val notificationId = getNextNotificationId(applicationContext)
            notify(notificationId, builder.build())
            Log.d(TAG, "sendNotification($notificationId)")
        }
    }
}

void f() {
  {
    int x = 1
    // do something with x
  }

  // x not visible here anymore
}

public class Request {
    protected String vin;

    public String getVin() {
        return vin;
    }

    public void setVin(String value) {
        this.vin = value;
    }
}

override fun search(request: Request): Response {
  log.info("search(vin={})", request.vin);
  ...

Error:(59, 64) Kotlin: Cannot access 'vin': it is 'protected/*protected and package*/' in 'SmvSearchRequest'

request.getVin()
listOf("a", "A", "A  ", "B")
listOf("a", "B")
val list = listOf("a", "A", "A  ", "B")
        .distinctBy { it.toLowerCase() }
        .distinctBy { it.trim() }

println("list = ${list}")

distinctBy
val list = listOf("a", "A", "A  ", "B")
        .distinctBy { it.trim() }
        .distinctBy { it.toLowerCase() }

println("list = ${list}")

   val list = listOf("a", "A  ", "A", "B")
            .distinctBy { it.toLowerCase() }
            .distinctBy { it.trim() }

    println("list = ${list}")

class kotlass(var propOne:String, var propTwo:String) {...}

var t = 0
fun sumIntMap(hm: HashMap&lt;Int,Int&gt;) = hm.forEach{ x -&gt; t+=x.value 
}.let { t }

File("data").walk().filter { it.isFile }.flatMap { file -&gt;
    println(file.toString())
    file.inputStream().bufferedReader().lineSequence()
}. // now I have lines

.map { line -&gt;
    val (key, stuff, matchCount) = line.split(",")
    Triple(key, stuff, matchCount.toInt())
}.

eachCount()
.groupingBy { (key, _, _) -&gt;
    key
}.aggregate { (key, _, matchCount) -&gt;
    ??? something with matchCount ???
}

mutableList.add(foo)

mutableList.size - 1
ArrayList
mutableList.indexOf(foo)
apply plugin: 'com.android.application'

apply plugin: 'kotlin-android'

apply plugin: 'kotlin-android-extensions'

apply plugin: 'io.fabric'

apply plugin: 'kotlin-kapt'
buildscript {
repositories {
    maven { url 'https://maven.fabric.io/public' }
}
dependencies {
    // You can find the lastest version number here: 
https://docs.fabric.io/android/changelog.html#fabric-gradle-plugin
    classpath 'io.fabric.tools:gradle:1.+'
}
}

project.ext {
supportLibraryVersion = "26.1.0"
androidArchVersion = "1.0.0-rc1"
daggerVersion = "2.11"
butterKnifeVersion = "8.7.0"
rxJavaVersion = "2.1.0"
rxAndroidVersion = "2.0.1"
timberVersion = "4.5.1"
priorityJobQueueVersion = "2.0.1"
playServicesVersion = "11.4.2"
retrofitVersion = "2.1.0"
okHttpVersion = "3.4.1"
rxRelayVersion = "2.0.0"
rxLintVersion = "1.6"
}

android {
compileSdkVersion 27
defaultConfig {

javaCompileOptions.annotationProcessorOptions.includeCompileClasspath = 
true
    vectorDrawables.useSupportLibrary true
    applicationId "***"
    minSdkVersion 21
    targetSdkVersion 27
    versionCode 1
    versionName "1.0"
    resConfigs "en"
    testInstrumentationRunner 
"android.support.test.runner.AndroidJUnitRunner"
}
splits {
    density {
        enable true

    }
}
buildTypes {
    release {
        minifyEnabled false
        proguardFiles getDefaultProguardFile('proguard-android.txt'), 
'proguard-rules.pro'
    }
    debug {
        // Disable fabric build ID generation for debug builds
        ext.enableCrashlytics = false
    }
}
}

kapt {
generateStubs = true
}

dependencies {
implementation fileTree(dir: 'libs', include: ['*.jar'])
implementation "org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version"
implementation 'com.android.support.constraint:constraint-layout:1.0.2'
implementation 'uk.co.chrisjenx:calligraphy:2.2.0'
implementation 'com.github.bumptech.glide:glide:3.7.0'
implementation 'com.android.support:design:27.0.2'
implementation 'com.intuit.sdp:sdp-android:1.0.5'

implementation('com.crashlytics.sdk.android:crashlytics:2.9.0@aar') {
    transitive = true
}



implementation 'com.android.support:support-v4:27.0.2'
testImplementation 'junit:junit:4.12'
androidTestImplementation 'com.android.support.test:runner:1.0.1'
androidTestImplementation 'com.android.support.test.espresso:espresso-
core:3.0.1' 

implementation "com.android.support:appcompat-
v7:$project.supportLibraryVersion"

// Retrofit
implementation 'com.squareup.retrofit2:retrofit:2.4.0'
// GSON Converter
implementation 'com.squareup.retrofit2:converter-gson:2.3.0'
implementation 'com.squareup.retrofit2:adapter-rxjava2:2.3.0'
//OkHttp Logging Interceptor
implementation 'com.squareup.okhttp3:okhttp:3.10.0'
implementation 'com.squareup.okhttp3:logging-interceptor:3.9.1'
implementation 'com.google.code.gson:gson:2.8.2'
// ReactiveX
implementation "io.reactivex.rxjava2:rxjava:$project.rxJavaVersion"
implementation 
"io.reactivex.rxjava2:rxandroid:$project.rxAndroidVersion"
//Room database
implementation "android.arch.persistence.room:runtime:1.1.1"
implementation "android.arch.persistence.room:rxjava2:1.1.1"
kapt "android.arch.persistence.room:compiler:1.1.1"
implementation "android.arch.paging:runtime:1.0.0-alpha3"
// Lifecycle
implementation 
"android.arch.lifecycle:runtime:$project.androidArchVersion"
implementation 
"android.arch.lifecycle:extensions:$project.androidArchVersion"
annotationProcessor 
"android.arch.lifecycle:compiler:$project.androidArchVersion"
// RxRelay
implementation 
"com.jakewharton.rxrelay2:rxrelay:$project.rxRelayVersion"
// RxLint
implementation "nl.littlerobots.rxlint:rxlint:$project.rxLintVersion"
// GCM Network Manager
implementation "com.google.android.gms:play-services-
gcm:$project.playServicesVersion"
// Priority Job Queue
implementation "com.birbit:android-priority-
jobqueue:$project.priorityJobQueueVersion"
// ButterKnife
implementation "com.jakewharton:butterknife:$project.butterKnifeVersion"
annotationProcessor "com.jakewharton:butterknife-
compiler:$project.butterKnifeVersion"
// Dagger
def daggerVer = 2.14
implementation "com.google.dagger:dagger:$daggerVer"
implementation "com.google.dagger:dagger-android-support:$daggerVer"
kapt "com.google.dagger:dagger-android-processor:$daggerVer"
kapt "com.google.dagger:dagger-compiler:$daggerVer"
// Timber
implementation "com.jakewharton.timber:timber:$project.timberVersion"

class App : Application(), HasActivityInjector {
@Inject
lateinit var dispatchingAndroidInjector: DispatchingAndroidInjector&lt;Activity&gt;

override fun onCreate() {
    super.onCreate()
    if (BuildConfig.DEBUG) {
        Timber.plant(Timber.DebugTree())
    }


    DaggerAppComponent
            .builder()
            .application(this)
            .build()
            .inject(this)
    JobManagerFactory().getJobManager(this)
}

override fun activityInjector(): AndroidInjector&lt;Activity&gt; {
    return this.dispatchingAndroidInjector
}

fun &lt;A, B, ...&gt;mergeWhenValid(
    arg1: Either&lt;Problem, A&gt;,
    arg2: Either&lt;Problem, B&gt;,
    ...,
    closure: (A, B, ...) -&gt; T
): Either&lt;Problem, T&gt; {
    // do stuff and call closure(a, b, ...)
}

#file1.kt
package test
fun main(args: Array&lt;String&gt;) {}

#file2.kt
package test
fun main(args: Array&lt;String&gt;) {}

class X {
    fun f() {...}
    fun g() {...}
    ...
}

val callback : KCallable&lt;*&gt;? = X::class.members.firstOrNull { it.name == predVar }
if (callback != null) {
    callback.call(obj, ...)

var booleanDerivatives = hashMapOf&lt;String, () -&gt; Boolean&gt;(
    "breaksAfterComma" to fun (): Boolean {
        return options[breaksComma] === Breaks.After
    }
    ,"breaksBeforeComma" to fun (): Boolean {
        return options[breaksComma] === Breaks.Before
    }
    ,"breaksAfterLogicalConjunction" to fun (): Boolean {
        return options[breaksAroundLogicalConjunctions] === Breaks.After 
            || options[breaksAroundLogicalConjunctions] === Breaks.BeforeAndAfter
    }
)

String.format()
DecimalFormat
val value = 23.695f
Timber.e("format: ${"%.2f".format(value)}")

arguments
Bundle()
!!
arguments
private fun openPinCodeFragment(mode: PinView.Mode) {
    currentFragment = PinCodeFragment()
    currentFragment?.run {
        arguments = Bundle()
        arguments!!.putSerializable(MODE, mode)
    }
    openFragment(currentFragment)
}

!!
@IntDef({CASH,WITHDRAW}) 
@Retention(RetentionPolicy.SOURCE) 
public @interface TransTypeJava { 
int CASH = 1; int WITHDRAW = 2;
}

const val CASH = 1 const val WITHDRAW = 2 
@IntDef(CASH, WITHDRAW) 
@kotlin.annotation.Retention(AnnotationRetention.SOURCE) 
internal annotation class TransTypeKotlin

override fun onCreate(savedInstanceState: Bundle?) { 
super.onCreate(savedInstanceState) 
setContentView(R.layout.activity_main) 
demo(TransTypeJava.CASH)// Working 
demo(1) // Showing compile time error 
} 
fun demo(@TransTypeJava type:Int){}

TransTypeJava.CASH
TransTypeJava.WITHDRAW
TransTypeJava
override fun onCreate(savedInstanceState: Bundle?) { 
super.onCreate(savedInstanceState) 
setContentView(R.layout.activity_main) 
demo(TransTypeKotlin.CASH) //Working 
demo(1) // Working 
} 
fun demo(@TransTypeKotlin type: Int){} 

interface Repository

// This class contains some common stuff for LocalRepository and RemoteRepository. I'm never going to use this class outside this file, so I make it private
private abstract  class BasicRepositoryImpl

// these classes are designed to be instantiated in other files    
class LocalRepository : BasicRepositoryImpl(), Repository // error

class RemoteRepository : BasicRepositoryImpl(), Repository // error

BasicRepositoryImpl
private
LocalRepository
RemoteRepository
class Presenter(val repo: Repository)

val p = Presenter(LocalRepository())

Map&lt;String,Pair&lt;String,Any&gt;&gt;
 for ((key, (k, v)) in map)

 for ((key, k, v) in map)

data class FileHeader(
    val relativePath: String,
    val orderNumber: Long,
    val bodySize: Int
) : Serializable {
@Transient
var headerSize: Int = 0
    get() = relativePath.length + 8
}

object Foo {
    fun Int.negate() = -this
    fun negateInt(n: Int) = -n
}

negate
Foo
with
fun main() {
  println(with(Foo) { 5.negate() }) // prints -5
}

Foo
fun main2() {
    println(Foo.negateInt(5)) // prints -5
}

with(Foo) { 5.negate() }
Foo.negateInt(5)
Foo::negate
(Int) -&gt; Int
this
val f = Int::toString
(Int) -&gt; String
f(42)
42.toString()
(Foo::negate)(5)
with(Foo) { ... }
serialVersionUID
BaseModel
Project
abstract class BaseModel&lt;T&gt;(
        var id: Int? = null,
        private val fileName: String,
        private val data: MutableList&lt;T&gt;,
        private val indices: MutableMap&lt;Int, T&gt;
) : Serializable {

  ...

   protected fun writeToDisk() {
       val oos = ObjectOutputStream(BufferedOutputStream(FileOutputStream(fetchFileName()))   )
       oos.writeObject(fetchData());
       oos.close();
   }


}

class Project(
        var name: String = "",
        var repo: String = ""

) : BaseModel&lt;Project&gt;(
        data = Data.projects,
        indices = Data.projectsIndex,
        fileName = "data/projects.dat"
), Serializable {

    ...

    override fun toString(): String {
        return "Project: id=${id}, name=${name}, repo=${repo}"
    }

}

private val serialVersionUID: Long = 1 

serialVersionUid
@JvmStatic
object
PhoneAppItem
PhoneAppItem
abstract class AbstractPhoneAppItem : Parcelable {
    constructor() {

    }
    constructor(packageName: String?) {
        this.packageName = packageName
    }   
}


@Parcelize
class PhoneAppItem : AbstractPhoneAppItem {
    constructor() : super()
    constructor(packageName: String?) : super(packageName)
}

override fun countForTicket(dbc: SQLiteDatabase, ticketId: Long): Int {
    var ret: Int

    dbc.query(
        TABLE_SECOND_CHANCE_PRIZES, arrayOf("count(id)"),
        "ticket = ?", arrayOf(ticketId.toString()),
        null, null, null
    ).use { c -&gt;
        ret = if (c.moveToFirst()) {
            c.getInt(0)
        } else {
            0
        }
    }


    return ret
}

return ret
ret
ret
for (i in 1..2) {
    val i = "a"
    print(i)
}

aa
val a: Int = 10000
print(a identityEquals a)

===
interface Counter {
    var count: Int
    fun increment() {
        count = count + 1
    }
}

class WeirdCounter: Counter {
    override var count: Int = 0
        get() = field
        set(value) {println(&quot;ignore the value&quot;)}
}

byteArrayOf(0xA1.toByte(), 0x2E.toByte(), 0x38.toByte(), 0xD4.toByte(), 0x89.toByte(), 0xC3.toByte())

0xA1
.toByte()
integer literal does not conform to the expected type Byte
class Foo&lt;T&gt;(val t : T?)

fun &lt;T : Any, R : Any&gt; Foo&lt;T?&gt;.transform(transformer : (T) -&gt; R) : Foo&lt;R?&gt; {
  return when (t) {
    null -&gt; Foo(null)
    else -&gt; Foo(transformer(t))
  }
}

fun main(args : Array&lt;String&gt;) {
  val foo = Foo(args.firstOrNull())

  val bar = foo.transform&lt;String, Int&gt; { t -&gt; t.length }

  val baz = bar.transform&lt;Int, IntRange&gt; { t -&gt; t..(t + 1) }
}

Type mismatch. Required: Foo&lt;String?&gt; Found: Foo&lt;String&gt;
?
Foo&lt;T&gt;.transform
Type mismatch. Required: Foo&lt;Int&gt; Found: Foo&lt;Int?&gt;
Int?
Int
String
String?
class Foo&lt;T&gt;
class Foo&lt;out T&gt;
t
transform
fun &lt;T : Any, U : T?, R : Any&gt; Foo&lt;U&gt;.transform(transformer : (T) -&gt; R) : Foo&lt;R?&gt;

foo.transform
bar.transform&lt;Int, Int?, IntRange&gt;
t
var
val
t
transform
!!
?:
?.
fun main(args: Array&lt;String&gt;) {
    println(max(20, 10))
}

fun max(a: Int, b: Int) = if (a &gt; b) a else b

fun max(a: Int, b: Int): Int?{
    if(a &gt; b)
        return a
    else
        return b
}

package br.com.xp.operation

import java.util.ArrayList

abstract class Operation(vararg values: Value) : Value {
    protected var values: MutableList&lt;Value&gt; = ArrayList()

    internal abstract val operator: String
}

package br.com.xp.operation

class SubtractionOperation private constructor(vararg values: Value) : Operation(values) {
    override val operator: String
        get() = "-"
}

number
Pair (-1, -1)
fun findSumOfTwo(list: List&lt;Int&gt;, number: Int): Pair&lt;Int, Int&gt; {
    for (item in list) {
        for (digit in list - 1) {
            if (item + digit == number) return Pair (list[item], list [digit])
        }
    }
    return Pair (-1, -1)
}

kotlin
dsl
GRLMessage
data class GRLMessage(var method: GRLMethod, var headers: Map&lt;String, String&gt;, var multipart: Object) {

    fun message(init: GRLMessage.() -&gt; Unit) : GRLMessage {
        init()
        return this
    }

    fun method(init: GRLMessage.() -&gt; GRLMethod) : GRLMessage {
        method = init()
        return this
    }

    fun headers(init: GRLMessage.() -&gt; Unit) : GRLMessage {
        init()
        return this
    }

    fun header(init: GRLMessage.() -&gt; Pair&lt;String, String&gt;) : GRLMessage {
        headers.plus(init())
        return this
    }

    fun multipart(init: GRLMessage.() -&gt; Object) : GRLMessage {
        multipart = this.init()
        return this
    }
}

import org.junit.Assert.*
import org.junit.*

class GRLMessageTest {

    data class DummyMultipart(val field: String) {}

    @Test fun grlMessageBuilderTest() {
        val grlMessage = GrlMessage().message {
            method { GRLMethod.POST }
            headers {
                header { Pair("contentType", "object") }
                header { Pair("objectType", "DummyMultipart") }
            }
            multipart { DummyMultipart("dummy") }
        }

        val multipart = DummyMultipart("dummy")
        val headers = mapOf(
                Pair("contentType", "object"),
                Pair("objectType", "DummyMultipart")
        )
        val method = GRLMethod.POST

        assertEquals(multipart, grlMessage.multipart)
        assertEquals(headers, grlMessage.headers)
        assertEquals(method, grlMessage.method)
    }
}

src/main/kotlin
src/test/kotlin
gradle build
compileTestKotlin
GRLMessageTest.kt: (13, 26): Unresolved reference: GrlMessage
GRLMessageTest.kt: (14, 13): Unresolved reference: method
GRLMessageTest.kt: (15, 13): Unresolved reference: headers
GRLMessageTest.kt: (17, 17): Unresolved reference: header
GRLMessageTest.kt: (19, 13): Unresolved reference: multipart

build.gradle
dsl
class GRLMessage {
    var headerMap : MutableMap&lt;String, String&gt; = mutableMapOf()
    lateinit var methodType : GRLMethod
    lateinit var multipartObject : IGRLMultipart

    fun message(closure: GRLMessage.() -&gt; Unit) : GRLMessage {
        closure()
        return this
    }

    fun method(closure: GRLMessage.() -&gt; GRLMethod) : GRLMessage {
        methodType = closure()
        return this
    }

    fun headers(closure: GRLMessage.() -&gt; Unit) : GRLMessage {
        closure()
        return this
    }

    fun header(closure: GRLMessage.() -&gt; Pair&lt;String, String&gt;) : GRLMessage {
        var pair = closure()
        headerMap.put(pair.first, pair.second)
        return this
    }

    fun multipart(closure: GRLMessage.() -&gt; IGRLMultipart) : GRLMessage {
        multipartObject = closure()
        return this
    }
}

class GRLMessageTest {

    data class DummyMultipart(val field: String) : IGRLMultipart {
        override fun getContent() {
            this
        }
    }

    @Test fun grlMessageBuilderTest() {
        val grlMessage = GRLMessage().message {
            method { GRLMethod.POST }
            headers {
                header { Pair("contentType", "object") }
                header { Pair("objectType", "DummyMultipart") }
            }
            multipart { DummyMultipart("dummy") }
        }

        val multipart = DummyMultipart("dummy")
        val headers = mapOf(
                Pair("contentType", "object"),
                Pair("objectType", "DummyMultipart")
        )
        val method = GRLMethod.POST

        assertEquals(multipart, grlMessage.multipartObject)
        assertEquals(method, grlMessage.methodType)
        assertEquals(headers, grlMessage.headerMap)
    }
}

header { Pair("contentType", "object") }

closure
header
put
MutableMap
fun header(closure: GRLMessage.() -&gt; Pair&lt;String, String&gt;) : GRLMessage {
    var pair = closure()
    headerMap.put(pair.first, pair.second)
    return this
}

Map
serverBuilder().withHost("localhost")
         .withPort(8080)
         .withContext("/something")
         .build()

serverBuilder().withHost("localhost")
         .withSsl()
         .withKeystore("mystore.kstore")
         .withContext("/secured")
         .build()

withKeystore
withSsl()
serverBuilder().withHost("localhost")
         .withPort(8080)
         .withContext("/something")
         .withKeystore("mystore.kstore")   &lt;------ SHOULD BE ERROR!
         .build()

Duration
toString()
7_340_032
7 MBytes
7 MB
7M
Duration
Method m = XposedHelpers.findMethodBestMatch(WebView.class, "getWebViewClient");

val m = XposedHelpers.findMethodBestMatch(WebView::class.java, "getWebViewClient")

@FunctionalInterface
public interface Foo&lt;T extends Bar&gt; {
    String something(T arg);
}

Person
Bar

Foo&lt;Person&gt; f = p -&gt; p.toString();


typealias Foo&lt;T&gt; = (T) -&gt; String

typealias Foo&lt;T: Bar&gt; = (T) -&gt; String  // Error: Bounds are not allowed on type alias parameters

interface Foo&lt;T: Bar&gt; : (T) -&gt; String

class Something: Foo&lt;Person&gt; {
    override fun invoke(p: Person): String {
        return p.toString()
    }
}

val f = Something()

if (obj?.bool == true)
fun main() {
    val a: Int = 100
    val boxedA: Int? = a
    val anotherBoxedA: Int? = a

    val b: Int = 100000
    val boxedB: Int? = b
    val anotherBoxedB: Int? = b

    println(boxedA === anotherBoxedA) // true
    println(boxedB === anotherBoxedB) // false
}

class LogHandler(val mDBHandle:DBLogHandler=DBLogHandler()) {
}
class DBLogHandler() {
}

class LogHandler(val mDBHandle=DBLogHandler()) {
}
class DBLogHandler() {
}

class LogHandler(val mDBHandle:DBLogHandler()) {
}
class DBLogHandler() {
}

this
var pos: Int?
    set(value) : IPosItem {
        this.pos = value
        return this
    }

setters
getters
var _pos: Int?
fun getPos(): Int? = _pos
fun setPos(value: Int?): IPosItem {
    _pos = value
    return this
}

EditText
caserCipher()
viewText.text
fun caserCipher(plainText: String, key: Int): CharArray {
        val alphabet: String = "abcdefghijklmnopqrstuvwxyz"
        val alphachar = alphabet.toCharArray()
        val arrofChar = plainText.toCharArray()
        var sizze:Int = plainText.length
        var cipher = CharArray(sizze)
        var ch :Char
        var oriIndex:Int
        var newIndex:Int
        for (i in arrofChar.indices) {
            if (Character.isLetter(arrofChar[i])) {
                ch=arrofChar[i]
                oriIndex= alphachar.indexOf(ch)
                newIndex = ((oriIndex+key)%26)
                ch= alphachar[newIndex]
                cipher[i]=ch
            } else {
                cipher[i]=' '
            }
        }

        return cipher
    }

    button.setOnClickListener {
       val enteredText:String=editText.text.toString()
       val key  = editText2.text.toString()
        val r = key.toInt()
       val cipher=caserCipher(enteredText , r)
         textView.text=cipher.toString()

}

  private var tempTime = interval.apply {
    if (this.equals(0L)) tempTime = interval
  }

tempTime
interval
tempTime
if equals 0L
fun example(first: String?, second: String?) {
    first?.let {
        second?.let {
            // Do something just if both are != null
        }
    }
}

fun example(first: String?, second: String?) {
    first?.let &amp;&amp; second?.let { 
        // Do something just if both are != null
    }
}

void ThisMethodDoesNothing() { }

fun ThisMethodDoesNothing() = Unit

fun foo(type: Type){
    var myList = ArrayList&lt;type&gt;
}

open class Team (val country: String = "England",
            val aggressive: Boolean = true, 
             name: String, squadSize: Int = 24) {

    val attendance: Int

    init {
        if (aggressive){
            attendance = 25000
        } else {
            attendance = 20000
        }
    }

}

fun chooseTeam(team: String) {
    val homeTeam = Team(name = "Blue Team")
    println("the home team is ${homeTeam.name} so they are ${if(homeTeam.aggressive) "angry" else "timid" }")
}

Unresolved reference: name
${homeTeam.name}
name
val homeTeam = Team(name = "Blue Team")
val list = listOf(Pair(1,2),Pair(2,3))

list.forEach { first, second -&gt;
     first + second
}

list.forEach { (first, second) in it -&gt;
         first + second
}

kotlinc-jvm hello.kt -include-runtime -d hello.jar

private fun readFirstLine(): String {
    BufferedReader(FileReader("test.file")).use { return it.readLine() }
}

val streamIn = resources.openRawResource(rawResId)
val streamOut = FileOutputStream(destFilename)

streamIn.use { input -&gt;
    streamOut.use { output -&gt;
        input.copyTo(output)
    }
}

open class BankAccount(val accountCode: String, val accountName: String, 
var balance : Double = 0.0) {}

open class BankAccount(val accountCode: String, val accountName: String) {}
var balance : Double = 0.0

abstract class SuperClass {
    init {
        toOverride()
    }

    abstract fun toOverride()
}

class ChildClass : SuperClass() {
    private val innerClass = InnerClass()

    override fun toOverride() {
        innerClass.doSomething()
    }

    class InnerClass {
        fun doSomething() = Unit
    }
}

class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        val superClass = ChildClass()
        superClass.toOverride()
    }
}

public interface Interface1 {
    void setValue1(boolean value);
    boolean getValue1();
}

class Class1: Interface1 {
    var value1 = false
} 

class User {
  var name: String = ""
}

fun processUser(userClass: User) {
  // Create an instance of User
  val user = userClass()
  user.name = "John Doe"
}

// Call the function. Something like this...
processUser(User.java)

fun testLocalFunctions() {
    aLocalFun() //compiler error: unresolved reference at aLocalFun
    fun aLocalFun() {}
    aLocalFun() //no error
}

n
Int
var map=HashMap&lt;Int,String&gt;()
var map=HashMap&lt;Int,String&gt;(n)
fun main() {
val myphone = Myphone()
myphone.phoneOn()
myphone.onClick()
myphone.onTouch()
myphone.openApp()
myphone.closeApp()
}

interface Application {
    var AppName: String

    fun openApp()

    fun closeApp() {
        println("$AppName App is closed!")
    }
}

interface Button {
    var helloMessage: String

    fun phoneOn()

    fun onClick()

    fun onTouch() {
        println("The screen was touched!")
    }
}


class Myphone: Button, Application {
    override var AppName: String = "Facebook"

    override fun openApp() {
        println("$AppName Is Open!")
    }
    override var helloMessage: String = "Hello"

    override fun onClick() {
        println("The screen was clicked!")
    }

    override fun phoneOn() {
        println("$helloMessage !")
    }
 }

import kotlin.math.sqrt
import kotlin.math.pow

fun Formule(a:Int):Double{
    //no working
    //rs = a.pow(1/3)
    //function
    retun rs
}

fun main(args: Array&lt;String&gt;){
    val calc = Formule(9)
}

sealed class Alphabet(val name: String) {
  object A : Alphabet("A")
  object B : Alphabet("B")
  object C : Alphabet("C")
  object D : Alphabet("D")
  object E : Alphabet("E")

  companion object {
    val array = arrayOf(A, B, C, D, E)
    val list = listOf(A, B, C, D, E)
  }

  override fun toString(): String {
    return name
  }
}

class AlphabetMap {

  companion object {
    val map = mapOf(
      Alphabet.A to 1,
      Alphabet.B to 2,
      Alphabet.C to 3,
      Alphabet.D to 4,
      Alphabet.E to 5
    )
  }
}

class AlphabetTest {

  @Test
  fun printValues() {
    Alphabet.array.forEach { print("$it ") };println()
    Alphabet.list.forEach { print("$it ") };println()
  }
}

A B C D E 
A B C D E

AlphabetMap
class AlphabetTest {

  val m = AlphabetMap()

  @Test
  fun printValues() {
    Alphabet.array.forEach { print("$it ") };println()
    Alphabet.list.forEach { print("$it ") };println()
  }
}

null B C D E 
null B C D E 

val m = AlphabetMap

  @Test
  fun printValues() {
    val m = AlphabetMap()  // or val m = AlphabetMap
    Alphabet.array.forEach { print("$it ") };println()
    Alphabet.list.forEach { print("$it ") };println()
  }

null B C D E 
null B C D E 

  @Test
  fun printValues() {
    Alphabet.array.forEach { print("$it ") };println()
    val m = AlphabetMap() // or val m = AlphabetMap
    Alphabet.list.forEach { print("$it ") };println()
  }

A B C D E 
A B C D E 

class AlphabetMap {
  companion object {
    val map = mapOf(
      //Alphabet.A to 1,
      Alphabet.B to 2,
      Alphabet.C to 3,
      Alphabet.D to 4,
      Alphabet.E to 5
    )
  }
}

A null C D E 
A null C D E 

class AlphabetMap {
  companion object {
    val map = mapOf(
      Alphabet.E to 5
    )
  }
}

A B C D null 
A B C D null 

&lt;kotlin.version&gt;1.2.0&lt;/kotlin.version&gt;
&lt;kotlin.compiler.jvmTarget&gt;1.8&lt;/kotlin.compiler.jvmTarget&gt;
&lt;kotlin.compiler.incremental&gt;false&lt;/kotlin.compiler.incremental&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
  &lt;artifactId&gt;kotlin-stdlib&lt;/artifactId&gt;
  &lt;version&gt;${kotlin.version}&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
  &lt;artifactId&gt;kotlin-stdlib-jdk8&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
  &lt;artifactId&gt;kotlin-reflect&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.jetbrains.kotlinx&lt;/groupId&gt;
  &lt;artifactId&gt;kotlinx-coroutines-core&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
  &lt;artifactId&gt;kotlin-test-junit&lt;/artifactId&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
  &lt;artifactId&gt;kotlin-test&lt;/artifactId&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

fun File.copyInputStreamToFile(inputStream: InputStream) {
    val buffer = ByteArray(1024)

    inputStream.use { input -&gt;
        this.outputStream().use { fileOut -&gt;

            while (true) {
                val length = input.read(buffer)
                if (length &lt;= 0)
                    break
                fileOut.write(buffer, 0, length)
            }
            fileOut.flush()
        }
    }
}

Boolean
type mismatch
var bool: Boolean? = true

if(bool) 
  println("foo") 
else 
  println("bar")

Boolean is expected
Boolean?
@Document
data class Category(
    @Id val id: Id? = null,
    val label: String
)

val
val categ = Category(label = "Test")
println(categ.label) // --&gt; TEST

fun main() {
    mergePhoneBooks(mapOf(&quot;Emergency&quot; to &quot;112&quot;),
        mapOf(&quot;Emergency&quot; to &quot;911&quot;, &quot;Police&quot; to &quot;02&quot;))
}
fun mergePhoneBooks(mapA: Map&lt;String, String&gt;, mapB: Map&lt;String, String&gt;): Map&lt;String, String&gt; {
    val result = mutableMapOf&lt;String, String&gt;()
    for ((keyA, valueA) in mapA) {
        for ((keyB, valueB) in mapB) {
            result[keyA] = valueA
            result[keyB] = valueB
            if (keyA == keyB) {
                if (valueA != valueB) {
                    result[keyA] = &quot;$valueA, $valueB&quot;
                }
            }
        }
    }
    println(result)
    return result
}

{Emergency=112, 911, Police=02},

{Emergency=112, Police=02}

===
true
-128
127
false
val a: Int = 10000
val boxedA: Int? = a            // Integer@445
val anotherBoxedA: Int? = a     // Integer@447 why?
print(boxedA === anotherBoxedA) // false

a
-128
127
true
val a: Int = -128
val boxedA: Int? = a            // Integer@445
val anotherBoxedA: Int? = a     // Integer@445 why?
print(boxedA === anotherBoxedA) // true!

Int
-128
127
fun runTests() {
    GlobalScope.launch {
        for (testSetup in testSetupClasses) {
            val setup = testSetup()
            runningSetups.add(setup)

            for (test in setup.tests) {
                val testInfo = test.value

                async {
                    testInfo.getTestToRunAsync()?.invoke { testResult -&gt;
                        testInfo.testResult = testResult
                    }
                }
            }
        }
    }
}

fun runTests() {
    GlobalScope.launch {
        for (testSetup in testSetupClasses) {
            val setup = testSetup()
            runningSetups.add(setup)

            for (test in setup.tests) {
                val testInfo = test.value
                runTestAsync(testInfo)
            }
        }
    }
}

suspend fun runTestAsync(testInfo: TestInfo) {
    async {
        testInfo.getTestToRunAsync()?.invoke { testResult -&gt;
            testInfo.testResult = testResult
        }
    }
}

 suspend fun runTestAsync(testInfo: TestInfo) {
        GlobalScope.launch {
            async {
                testInfo.getTestToRunAsync()?.invoke { testResult -&gt;
                    testInfo.testResult = testResult
                }
            }
        }
    }

@PutMapping("/rename")
fun rename(@RequestBody @Valid renameRequest: RenameRequest) {
    return imageService.rename(renameRequest.company, 
renameRequest.name, renameRequest.newName)
}

@NotNull
val company: Company? = null

    fun p() : Unit 
{
    println("Hello P")
}

fun y() : () -&gt; Unit = 
{
    println("Hello Y")

}

p() //--&gt;  will print out "Hello P"

y() //--&gt; doesn't print out anything

y()() //--&gt; will print out "Hello Y"

table
ArrayList&lt;IntArray&gt;?
for
        tables?.let {
            for (table in it) {
                for (value in table) {
                    Assert.assertEquals(1, value)
                }
             }
        }

IntArray
.let {}
fun method(): Int {
  if (anyObject != null) {
    val calculatedValue = anObject!!.awesome()
    val magicTrick = calculatedValue + randomMethodName()

    return magicTrick
  } 
  return false
}

fun method(): Int {
  val tempObject = anObject
  if (tempObject != null {
    val calculatedValue = tempObject.awesome()
    val magicTrick = calculatedValue + randomMethodName()

    return magicTrick
  } else {
    return false
  }
}

fun method(): Int {
  if let tempObject = anObject {
    let calculatedValue = tempObject.awesome()
    let magicTrick = calculatedValue + randomMethodName()

    return magicTrick
  } else {
    return false
  }
}

object TAG {
    var MainActivity : String? = null
}

class MainActivity : AppCompatActivity(){  
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        //Cannot find TAG.MainActivity as static variable like in Java
        TAG.MainActivity = MainActivity::class.java.canonicalName as String
    }
}

inline fun &lt;reified T : Any&gt; eventHandler(crossinline handler: (T) -&gt; Unit) = object {
    @Handler
    fun event(event: T) = handler(event)
}

eventHandler&lt;ExampleEvent&gt; { println(it.data); }
public final void event(example.ExampleEvent);
    descriptor: (Ljava/lang/Object;)V
    [...]
    Signature: #53 // (Lexample.ExampleEvent;)V

thatEventMethod.getParameterTypes()
Object
ExampleEvent
  fun update(
    financialMethods: List&lt;FinancialMethods&gt;
  ): CompletableFuture&lt;List&lt;ApvFinancialMethods&gt;&gt; {
    return post&lt;List&lt;ApvFinancialMethods&gt;&gt;(
      "/apv-financial-methods",
      financialMethods,
      List::class.java
    )
  }

restTemplate
  protected &lt;T&gt; CompletableFuture&lt;T&gt; post(String path, Object obj, Class&lt;T&gt; clazz, Object... uriVariables) {
    return post(path, obj, clazz, new RequestParams(), uriVariables);
  }


  protected &lt;T&gt; CompletableFuture&lt;T&gt; post(String path, Object obj, Class&lt;T&gt; clazz, RequestParams requestParams, Object... uriVariables) {

    String paramString = getParamString(requestParams, true, true);

    T t = cubsWsRestTemplate.exchange(path + paramString, HttpMethod.POST, new HttpEntity&lt;&gt;(obj, headers), clazz, uriVariables).getBody();

    return CompletableFuture.completedFuture(t);
  }

List::class.java
Type inference failed. Expected type mismatch
List&lt;*&gt;
List::class.java
1: 10, 20, 30
2: 50, 30, 25
3: 5
...

var map = mutableMapOf&lt;Int, MutableList&lt;Int&gt;&gt;()

Int
MutableList
var id = 2
// assuming the map has already has [2]: 10, 3, this would mutate it to [2]: 10, 3, 5
map[id].add(5)

    val Video_ID : String = &quot;&quot;;
    val YOUTUBE_API_KEY : String = &quot;AIzaSyAwjN3PZaiQBTeEK0LlLijs&quot;;
}

    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_vista_biografia)

    initUI()

    var people = intent.getSerializableExtra(&quot;noti&quot;) as TablaBiografia

    Glide.with(this).load(people.i1).into(i1)
    Glide.with(this).load(people.i2).into(i2)
    a1.text = people.a1
    t1.text = people.t1
    t2.text = people.t2
    fe.text = people.fe
    lu.text = people.lu
    c1.text = people.c1
    c2.text = people.c2
    tags.text = people.tag

    val Vid = people.you;
}

Supertype initialization is impossible without primary constructor

class InternetConnectivityHelper : ConnectivityManager.NetworkCallback() {

    constructor(context: Context, internetStatusChangedListener: InternetStatusChangedListener): super(){

    }
}

class InternetConnectivityHelper : ConnectivityManager.NetworkCallback() {

    constructor(context: Context, internetStatusChangedListener: InternetStatusChangedListener): this(){

    }
}

funB()
class A {
    lateinit var funA: () -&gt; Unit
    lateinit var funB: () -&gt; Unit

    fun funC()  {
        var b = object : B() {
            override fun funB() {
                funA() // A.funA()

                // Two attempts to fail
                funB() // b.funB(), not my expect
                A::funB() // compile error
            }
        }
    }
}

val x = {
  ... do some complex computations ..
  42
}

val x = {
  ... do some complex computations ..
  42
}()

run {}
run {}
{}()
import org.apache.commons.math3.distribution.TDistribution


// TDistribution  --&gt; It doesn't allow me to change to Double
fun calculo(a:Double): TDistribution {

    val distf = TDistribution(28.0,a)
    return distf
}

fun main(args: Array&lt;String&gt;){

    val ko = calculo(0.95)
    println(ko)
}

org.apache.commons.math3.distribution.TDistribution@404b9385

var foo: Double = 0.0
    get() { 
        update()
        return field
    }

var foo2: Double = 1.23
    get() { 
        update()
        return field
    }

interface Car&lt;T : Fuel?&gt; {
    fun run(fuel: T)
}

interface Fuel {
    ...
}

Fuel
Fuel
Fuel?
class PetrolCar : Car&lt;PetrolCar.Petrol&gt; {

    override fun run(fuel: Petrol) {
        println(&quot;\nRun the petrol car&quot;)
        fuel.burn()
    }

    class Petrol : Fuel {
        fun burn() = println(&quot;Burn some petrol&quot;)
    }
}

class ElectricCar : Car&lt;ElectricCar.Electricity&gt; {

    override fun run(fuel: Electricity) {
        println(&quot;\nRun the electric car&quot;)
        fuel.use()
    }

    class Electricity : Fuel {
        fun use() = println(&quot;Use some electricity&quot;)
    }
}

class PerpetuumMobile : Car&lt;Nothing?&gt; {

    override fun run(fuel: Nothing?) {
        println(&quot;\nRun the perpetuum mobile&quot;)
    }

}

run
Run the petrol car
Burn some petrol

Run the electric car
Use some electricity

Run the perpetuum mobile

Nothing?
private val mActivityTaskMap = mutableMapOf&lt;String, List&lt;CustomAsyncTask&lt;*, *, *&gt;&gt;&gt;()

fun removeTask(task: CustomAsyncTask&lt;*, *, *&gt;) {
    for ((key, tasks) in mActivityTaskMap) {
        for (i in tasks.indices) {
            if (tasks[i] === task) {
                tasks.removeAt(i)  // &lt;==== ERROR
                break
            }
        }
        if (tasks.size == 0) {
            mActivityTaskMap.remove(key)
            return
        }
    }
}

private Map&lt;String, List&lt;CustomAsyncTask&lt;?,?,?&gt;&gt;&gt; mActivityTaskMap;

public void removeTask(CustomAsyncTask&lt;?,?,?&gt; task) {
    for (Map.Entry&lt;String, List&lt;CustomAsyncTask&lt;?,?,?&gt;&gt;&gt; entry : mActivityTaskMap.entrySet()) {
        List&lt;CustomAsyncTask&lt;?,?,?&gt;&gt; tasks = entry.getValue();
        for (int i = 0; i &lt; tasks.size(); i++) {
            if (tasks.get(i) == task) {
                tasks.remove(i);
                break;
            }
        }

        if (tasks.size() == 0) {
            mActivityTaskMap.remove(entry.getKey());
            return;
        }
    }
}

private val mActivityTaskMap = mutableMapOf&lt;String, MutableList&lt;CustomAsyncTask&lt;*, *, *&gt;&gt;&gt;()

sortedBy()
val sortedList = if (sortingOrder == WordSortingOrder.BY_ALPHA) {
                    list.sortedBy { it.word.value }
                } else {
                    list.sortedBy { it.createdAt }
                }

sortedBy()
fun main()
{
    println(A() == B())
}

open class A
open class B

Operator '==' cannot be applied to 'A' and 'B'
TypeDescriptor
import org.springframework.core.convert.TypeDescriptor

fun foo(a: TypeDescriptor, b: TypeDescriptor) = a == b

No method 'equals(Any?): Boolean' available
TypeDescriptor
equals
==
a.equals(b)
Error: Could not find or load main class minimalkotlincommandline.MinimalkotlincommandlinePackage

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'org.jetbrains.kotlin:kotlin-gradle-plugin:1.0.0-beta-4584'
    }
}

apply plugin: "kotlin"
apply plugin: 'application'

mainClassName = "minimalkotlincommandline.MinimalkotlincommandlinePackage"

repositories {
    mavenCentral()
}

dependencies {
    compile 'org.jetbrains.kotlin:kotlin-stdlib:1.0.0-beta-4584'
}

fun main(args: Array&lt;String&gt;) {
    println("Hello world ")
}

Sequence&lt;T&gt;.all
inline fun &lt;T&gt; Sequence&lt;T&gt;.all(
    predicate: (T) -&gt; Boolean
): Boolean

listOf&lt;Int&gt;(1, 2, 3).fold(0) { x, y -&gt; x + y }

val list: List&lt;Int&gt; = (1, 2, 3, 4, 5).toList()
val rangeFromTheList: IntRange = ??? // 1..5

List&lt;Pair&lt;Int, Int&gt;&gt;

sortedWith(compareBy({ it.first }, { it.second }))

Cannot choose among the following candidates without completing type inference.
public fun &lt;T&gt; compareBy(vararg selectors: (???) -&gt; Comparable&lt;*&gt;?): kotlin.Comparator&lt;???&gt; defined in kotlin.comparisons
public fun &lt;T&gt; compareBy(vararg selectors: (Pair&lt;Int, Int&gt;) -&gt; Comparable&lt;*&gt;?): kotlin.Comparator&lt;Pair&lt;Int, Int&gt;&gt; defined in kotlin.comparisons

edges
  .map {
      it.either.run {
          val p = this
          val q = it.other(this)
          val min = min(p, q)
          if (min == p) p to q else q to p
      }
  }
  .sortedWith(compareBy({ it.first }, { it.second }))
  .toList()

edges
Iterable&lt;Edge&gt;
class Edge(private val v: Int, private val w: Int, val weight: Double) : Comparable&lt;Edge&gt; {
    val either: Int
        get() = v

    fun other(vertex: Int): Int {
        return if (v == vertex) w else v
    }

    override fun compareTo(other: Edge): Int {
        return weight.compareTo(other.weight)
    }

    override fun toString(): String {
        return "Edge(v=$v, w=$w, weight=$weight)"
    }
}

....
public @interface NotEmpty {
    ....
    public @interface List {
        NotEmpty[] value();
    }
}

annotation class
var prevResult = "abcde"
var tmp = prevResult[0]

for (i in 0..prevResult.length - 2) {
    prevResult[i] = prevResult[i+1]  // Error on preveResult[i]
}

prevResult[prevResult.length-1] = tmp // Error on preveResult[prevResult.lengt-1]

when
!!
fun main(args: Array&lt;String&gt;) {
    val string = "abc"
    val map1 = mapOf('a' to 5)
    val map2 = mapOf('b' to 4)
    when (val char = string.firstOrNull()) {
        null -&gt; println("Nothing to find")
        in map1 -&gt; println("Found in map1: ${map1[char]!!+1}")
        in map2 -&gt; println("Found in map2: ${map2[char]!!-1}")
        else -&gt; println("Unrecognised character $char")
    }
}

fun main(args: Array&lt;String&gt;) {
    maybeWriteMessage()
}

fun maybeWriteMessage(message: String? = null) {
    writeMessage(message!!)
}

fun writeMessage(message: String) {
    println("Hello World")
}

message!!
KotlinNullPointerException
var array = kotlin.arrayOfNulls&lt;Int&gt;(10)

for( i in array.indices ){
    array[i] = ( Math.random().toInt() )
}

Math.random()
var writer = PrintWriter("abc.txt")
writer.println("John")
writer.println("Emmy")
writer.println("Char")
writer.close()

var reader = File("abc.txt")
reader.forEachLine { println(it) }

package io.igx.iot.model

import com.fasterxml.jackson.annotation.JsonProperty
import java.time.LocalDate
import java.util.*


/**
 * @author Vinicius Carvalho
 */
data class SensorData(val type: String, val name: String, @JsonProperty("@timestamp") val timestamp: Date, val value: Double, val thermostatId: String)
data class Column(val type: String, val position: Int)
data class Report(val device: String, val id: String, val start: LocalDate, val end: LocalDate)


inline fun String.safeFloat() : Float {
    return try {
        this.toFloat()
    } catch (e: NumberFormatException){
        0.0f
    }
}

inline fun String.safeDouble() : Double {
    return try {
        this.toDouble()
    } catch (e: NumberFormatException){
        0.0
    }
}

inline fun String.safeInt() : Int {
    return try {
        this.toInt()
    } catch (e: NumberFormatException){
        0
    }
}

inline fun String.safeLong() : Long{
    return try {
        this.toLong()
    } catch (e: NumberFormatException){
        0L
    }
}

sensors.add(SensorData(column.type, entry.key, date, read, report.id))

EcobeeParser
EcoBeeParser parser = new EcoBeeParser(new FileInputStream(new File("")), 19);
val parser = EcobeeParser(FileInputStream(File)), 19)
volatile public var tmpEndedAt: Long? = null
struct data {
    char *time;
    char *name;
    char *message;
};

char *string = &quot;01:12 Joseph We will have a meeting at 6 PM.&quot;
struct data notification;
notification.time = strtok(string, &quot; &quot;);
notification.name = strtok(NULL, &quot; &quot;);
notification.message = strtok(NULL, &quot; &quot;);
puts(notification.time); // prints the time it was sent
puts(notification.name); // prints the name of the sender
puts(notification.message); // prints the message content

import java.lang.Exception

class TestAlreadyAddedException : Exception {
    constructor(details: String) {
       this.message = "Test already added: {details}" 
    }
}

val peopleAtParty = listOf(&quot;girlfriend&quot;,&quot;bestFriend&quot;,&quot;murderer&quot;,&quot;funnyPete&quot;)

val goingToParty = when(peopleAtParty.contains) {
    &quot;girlfriend&quot;,&quot;bestFriend&quot; -&gt; true
    &quot;murderer&quot; -&gt; false
    &quot;funnyPete&quot; -&gt; true
    else -&gt; false
}

fun getX(): Y {
    if (X == null) {
        X = ...
    }

    return X!!
}

fun getX(): Y {
    X = X ?: ...
    return X!!
}

!!
X
val array = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
val arraylist = arrayListOf&lt;Int&gt;() 
for(i in 0..array.size - 1) {
    if(array[i] % 2 != 0) 
        arraylist.add(array[i])
}
val oddarray = arraylist.toArray()

MutableList&lt;Card&gt;
cards
sortedWith
private var cards: MutableList&lt;Card&gt; = ArrayList()
...
cards = cards.sortedWith(compareBy{it.face}) as ArrayList&lt;Card&gt;



java.lang.ClassCastException: java.util.Arrays$ArrayList cannot be cast to java.util.ArrayList

MutableList&lt;Card&gt;
2 + 2.001
2 + 2.0
&gt;4.0

2 + 2.01
&gt;4.01

2 + 2.001
&gt;4.0009999999999994      &lt;-------------Super strange         

2 + 2.0001
&gt;4.0001 

fun main(args: Array&lt;String&gt;) {
    val total = (0..10).reduce { total, next -&gt; total + next }
}

Exception in thread "main" java.lang.NoClassDefFoundError: kotlin/IntIterator
    at TestReduceKt.main(TestReduce.kt:6)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:497)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)
Caused by: java.lang.ClassNotFoundException: kotlin.IntIterator
    at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
    ... 6 more

open class VecN&lt;Derived: VecN&lt;Derived&gt;&gt;(val buffer: FloatArray) {
    operator fun minus(other: Derived) = Derived(buffer.zip(other.buffer, { a, b -&gt; a - b }).toFloatArray())
    operator fun plus(other: Derived) = Derived(buffer.zip(other.buffer, { a, b -&gt; a + b }).toFloatArray())
    ... many more operators...
}

class Vec2(x: Float, y: Float) : VecN&lt;Vec2&gt;(floatArrayOf(x, y))
class Vec3(x: Float, y: Float, z: Float) : VecN&lt;Vec3&gt;(floatArrayOf(x, y, z))
class Vec4(x: Float, y: Float, z: Float, w: Float) : VecN&lt;Vec4&gt;(floatArrayOf(x, y, z, w))

(ShellInput) -&gt; ShellOutput
mutableMapOf&lt;String, (ShellInput) -&gt; ShellOutput&gt;("trim" to ::trim)

mutableMapOf&lt;String, (Any) -&gt; ShellOutput&gt;("trim" to ::trim)

mSingleAccountApp?.signIn(this@MainActivity, null!!, getScopes(), getAuthInteractiveCallback())

void signIn(@NonNull final Activity activity,
                @NonNull final String loginHint,
                @NonNull final String[] scopes,
                @NonNull final AuthenticationCallback callback);

1532358895
2018-07-23T15:14:55Z
fun main() = runBlocking { // this: CoroutineScope
    launch { 
        delay(200L)
        println("Task from runBlocking")
    }

    coroutineScope { // Creates a coroutine scope
        launch {
            delay(500L) 
            println("Task from nested launch")
        }

        delay(100L)
        println("Task from coroutine scope") // This line will be printed before the nested launch
    }

    println("Coroutine scope is over") // This line is not printed until the nested launch completes
}

Task from coroutine scope
Task from runBlocking
Task from nested launch
Coroutine scope is over

println("Coroutine scope is over")

Coroutine scope is over
Task from runBlocking
Task from coroutine scope
Task from nested launch

GPUImageSaturationFilter
public var filters: GPUImageFilterGroup

//filterClass:the specified gpuimage filter type extend GPUImageFilter
public fun getFilter(filterClass:the specified gpuimage filter type):GPUImageFilter {
        //filters.filters is a List&lt;GPUImageFilter&gt;
        filters.filters.forEach {
            if (it is filterClass) {
                 return it
            }
        }
}

filterClass:the specified gpuimage filter type

var something: Something? = null
val notNull: Something = ...

...

fun getSomething() {
    something = something ?: notNull
    return something
}

something = something ?: notNull; return something
if (myObject?.name !=null)
first.text = myObject.name.bigThing

if (myObject?.age !=null)
second.text = myObject.age.bigThing

if (myObject?.surname !=null)
third.text = myObject.surname.bigThing

age/surname/name
Big
id: Int
bigThing: String
fun &lt;T : Event&gt; addEventListener(eventClass: Class&lt;T&gt;, eventHandler: EventHandler&lt;T&gt;) {
    eventListeners.put(eventClass, eventHandler)        
}

eventListeners
private val eventListeners = HashMap&lt;Class&lt;T&gt;, EventHandler&lt;T&gt;&gt;()

T
eventListeners
T
class MyClass&lt;T: Event&gt; {...}
operator
operator
operator fun &lt;K, V&gt; Map&lt;K, V&gt;.iterator(): Iterator&lt;Map.Entry&lt;K, V&gt;&gt; = entrySet().iterator()
operator fun &lt;K, V&gt; Map.Entry&lt;K, V&gt;.component1() = getKey()
operator fun &lt;K, V&gt; Map.Entry&lt;K, V&gt;.component2() = getValue()

for ((key, value) in map) {
    // ...
}

interface ReadOnlyProperty&lt;in R, out T&gt; {
    operator fun getValue(thisRef: R, property: KProperty&lt;*&gt;): T
}

interface ReadWriteProperty&lt;in R, T&gt; {
    operator fun getValue(thisRef: R, property: KProperty&lt;*&gt;): T
    operator fun setValue(thisRef: R, property: KProperty&lt;*&gt;, value: T)
}

List&lt;User&gt;
List&lt;Movies&gt;
var isBlue = 1

if isBlue==1 then ...

var startTime: Int
    get() = {
        // read value from database
    }
    set(value) {
        // save value to database
    }

private A typeA;
private B typeB;

public Test(){
  typeA = createType();
  typeB = createType();
}

private &lt;T extends A &amp; B&gt; T createType(){
    return null;
}

IntArray
Int
Array&lt;Int&gt;

    package com.example.test

    import androidx.appcompat.app.AppCompatActivity
    import android.os.Bundle
    import android.widget.Button
    import android.widget.EditText
    import android.widget.TextView

    class MainActivity : AppCompatActivity() {

        override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContentView(R.layout.activity_main)
            val btnChangeText = findViewById(R.id.btn_change_text) as Button
            val tvBMI = findViewById(R.id.output_BMI) as TextView
            val weight = findViewById(R.id.input_weight) as EditText
            val height = findViewById(R.id.input_height) as EditText

            btnChangeText.setOnClickListener {
               val bmiWeight = weight.text.toString().toInt()
               val bmiHeight = height.text.toString().toInt()
               val bmiCalc =  bmiWeight /  bmiHeight /  bmiHeight * 10000
                tvBMI.text = bmiCalc.toString()
            }

        }

    }


fun drawerImageLoader(actions: DrawerImageLoaderKt.() -&gt; Unit): DrawerImageLoader.IDrawerImageLoader {
    val loaderImpl = DrawerImageLoaderKt().apply(actions).build()
    DrawerImageLoader.init(loaderImpl)
    return loaderImpl
}

class DrawerImageLoaderKt {
    ...
}

drawerImageLoader
companion object
.()
DrawerImageLoaderKt.()
duration
open class Timeline(
    open var props: MutableList&lt;Prop&gt; = mutableListOf()) {

    val duration: Long
        get() {
            var best: Prop? = null
            props.forEach {
                if (best == null || it.interval.end &gt; best?.interval!!.end) {
                    best = it
                }
            }
            return best?.interval?.end ?: 0L
        }
}

props
List
    if (networker.name != worker.name &amp;&amp; networker.name != null) {
        worker.name = networker.name
    }
    if (networker.lastName != worker.lastName &amp;&amp; networker.lastName != null) {
        worker.lastName = networker.lastName
    }
    if (networker.phone != worker.phone &amp;&amp; networker.phone != null) {
        worker.phone = networker.phone
    }
    if (networker.email != worker.email &amp;&amp; networker.email != null) {
        worker.email = networker.email
    }

class JSONSite : JSONObject() {
    val name : String = this.getString(&quot;Site&quot;)
    
    init { 
        // A lot of leg work  
    }
    
    fun doComplicatedStuff(){}
    fun doDifficultThings(){}
}

fun JSONObject.getJSONSite(key: String) : JSONSite {
    return this.getJSONObject(key) as JSONSite
}

for (key in masterSitesJSON.keys()) {
    val site: JSONSite = masterSitesJSON.getJSONSite(key)
    site.doTheThings()
}

producer
accessing non-final property in constructor
class KafkaService {

  val producer: KafkaProducer&lt;String, String&gt;

  init {
    val props = Properties()
    props[ProducerConfig.BOOTSTRAP_SERVERS_CONFIG] = "127.0.0.1:9092"
    props[ProducerConfig.CLIENT_ID_CONFIG] = "DemoProducer"
    props[ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG] = StringSerializer::class.java.name
    props[ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG] = StringSerializer::class.java.name

    producer = KafkaProducer(props)
  }

  fun sendToKafka(topic: String, message: String) {
    val producerRecord: ProducerRecord&lt;String?, String&gt; = ProducerRecord(topic, null, message)
    producer.send(producerRecord)
  }
}

public T GetValue&lt;T&gt;() where T : new() {
    return new T();
}

val unitNumber = findViewById&lt;EditText&gt;(R.id.unitNumber)
val code = arrayOf(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;,&quot;I&quot;,&quot;J&quot;)
val button3 = findViewById&lt;Button&gt;(R.id.button3)
val codeName = findViewById&lt;TextView&gt;(R.id.codeName)
val digit = unitNumber.text

    button3.setOnClickListener {

    val AOne = Random.nextInt(0,5)
    codeName.text = &quot;Your Code is:&quot;+ code[AOne] + code[digit[0].toString().toInt()] + code[digit[1].toString().toInt()] + code[digit[2].toString().toInt()];
        }

import java.io.*
import java.util.concurrent.TimeUnit.MINUTES
import java.util.concurrent.TimeUnit


val proc = ProcessBuilder("C:\\tools\\build\\maven\\3.6.1\\bin\\mvn.cmd")
    .directory(null)
    .redirectOutput(ProcessBuilder.Redirect.PIPE)
    .redirectError(ProcessBuilder.Redirect.PIPE)
    .start()
println("Started")
proc.waitFor(60, TimeUnit.MINUTES)
println("Ended")
val output : String = proc.inputStream.bufferedReader().readText()
println("Output : " + output)
var log : File = File("cmd.log")
log.writeText(output)

val output : String = proc.inputStream.bufferedReader().readText()

sealed class DownloadWallpaper : Result() {
    data class Progress(val hd: Boolean = false, ...) : DownloadWallpaper() 
    data class Success(val hd: Boolean = false, ...) : DownloadWallpaper()
    data class Error(val hd: Boolean = false, ...) : DownloadWallpaper()
}

//obs is of type Observable&lt;Detail.Result.DownloadWallpaper&gt; 
obs.map{ it.copy(hd = true) }

DownloadWallpaper
.copy()
data classes
DownloadWallpaper
when (it) {
           is Detail.Result.DownloadWallpaper.Success -&gt; it.copy(hd = true)
           is Detail.Result.DownloadWallpaper.Progress -&gt; it.copy(hd = true)
           is Detail.Result.DownloadWallpaper.Error -&gt; it.copy(hd = true)
 }

var answers: IntArray = intArrayOf(1,4,2,3,2)

var apple: IntArray = intArrayOf(1,2,3,4,5)
var banana: IntArray = intArrayOf(2,5,3,1,3)

val squares = listOf(diffApple,diffBanana)
val hobbies = listOf(&quot;apple&quot;, &quot;banana&quot;)

HashMap.getOrDefault(Object Key, V defaultValue)
fun main(args: Array&lt;String&gt;) {
    val numbersMap = mapOf(
        &quot;one&quot; to 1, 
        &quot;two&quot; to 2, 
        &quot;three&quot; to 3,
        &quot;four&quot; to 4,
        &quot;five&quot; to 5
    )
    println(numbersMap.get(&quot;one&quot;))
    println(numbersMap[&quot;one&quot;])
    println(numbersMap.getOrDefault(&quot;four&quot;, 10))
    println(numbersMap[&quot;five&quot;])
}

C:\Users\forestfh\Documents\KotlinProjects&gt;kotlinc GetOrDefault.kt
GetOrDefault.kt:11:24: error: unresolved reference. None of the following candid
ates is applicable because of receiver type mismatch:
public inline fun &lt;R, T : String&gt; Result&lt;String&gt;.getOrDefault(defaultValue: Stri
ng): String defined in kotlin
    println(numbersMap.getOrDefault(&quot;four&quot;, 10))

Null cannot be a value of a non-null type
override fun call(jso: JSONObject): JSONObject {
    ...
    ...
    return null
}

?
?
implicit def SeqExtensions[X](first: Seq[X]) = new {
 def join[Y](second: Y) = new {
   def on(predicate: (X, Y) =&gt; Boolean) = {
     for (ff &lt;- first; if predicate(ff, second)) yield (ff, second)
   }
 }
}

val joinSeq = unitComponents.flatMap(w =&gt; myOtherUnitComponents join w on { (u, w) =&gt;
  w.cell equals u.cell
})

protected var table = HashMap&lt;Class&lt;*&gt;, Double&gt;()

if (table.containsKey(object)) {
    value = table.get(object)
} 

if (table.containsKey(object as Any?)

.get(object)
val c = someObject.javaClass // pre j2k code: final Class&lt;? extends SomeClass&gt; c = someObject.getClass();
weight = weightingTable[c] &lt;-- error here

null
Paths.get(".")
imgui.ini
fileLoadToLines(iniFilename)
fun fileLoadToLines(filename: String) = ClassLoader.getSystemResourceAsStream(filename)?.use { it.bufferedReader().readLines() }
Thread.currentThread().contextClassLoader
out
I_have_a_string
I_have_a
string
val words = myString.split("_")
val first = words.dropLast(1).joinToString("_")
val second = words.last()

import kotlinx.coroutines.*
import kotlin.system.*

fun main() = runBlocking&lt;Unit&gt; {
    val time = measureTimeMillis {
        val one = async { doSomethingUsefulOne() }
        val two = async { doSomethingUsefulTwo() }
        println("The answer is ${one.await() + two.await()}")
    }
    println("Completed in $time ms")    
}

suspend fun doSomethingUsefulOne(): Int {

    delay(3000L) // pretend we are doing something useful here
    println("first")
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {

    delay(1000L) // pretend we are doing something useful here, too
    println("second")
    return 29
}

data class NameCreated(
    val index: Float,
    val name: String
) : ESEventPayload

&lt;Event&lt;out Any&gt;&gt;
ESEventPayload
fun isItUsing(message: AcknowledgeableMessage&lt;Event&lt;out Any&gt;&gt;): Boolean =

if (ESEventPayload::class.java.isAssignableFrom(message.body.payloadType::class.java)) {
   println("It's using the interface")
} else {
   println("It isn't using")
}

suspend fun concurrentSum(): Int = coroutineScope {
    val one = async { doSomethingUsefulOne() }
    val two = async { doSomethingUsefulTwo() }
    one.await() + two.await()
}

suspend fun fasterUseful(): Int = coroutineScope {
        val one = async { doSomethingUsefulOne() }
        val two = async { doSomethingUsefulTwo() }
        // ????? one.await() || two.await() whichever faster
    }

import kotlinx.coroutines.*
import kotlin.system.*

fun main() = runBlocking&lt;Unit&gt; {
    val time = measureTimeMillis {
        val one = async { doSomethingUsefulOne() }
        val two = async { doSomethingUsefulTwo() }
        two.await()
        one.await()
        println("Finished")
    }   
}

suspend fun doSomethingUsefulOne(): Int {
    delay(3000L)
    println("first")
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L)
    println("second")
    return 29
}

await
val evenNumbers = (1..10)
            .filter { it % 2 == 0 }
            .onFallThrough { println("dropped $it") }  // wishful Kotlin
            .toList()

dropped 1
dropped 3
dropped 5
dropped 7
dropped 9

evenNumbers
invoke
oldFunction
interface SomeInterface {

  operator fun invoke(param: A)

  @Deprecated("Old stuff", ReplaceWith("invoke(param)"))
  fun oldFunction(param: A)

}

oldFunction
invoke
invoke
()
public class myClass {

    private String department;

    private employee[] data;

}

data class Users(
        @field:[Expose SerializedName(&quot;id&quot;)]
        val id: Int)

@field:
data class Users(
        @Expose
        @SerializedName(&quot;id&quot;)
        val id: Int)

@field:[]
@
data class A(val commonParam1: String, val commonParam2: String, val specialParam: Int)
data class B(val commonParam1: String, val commonParam2: String, val specialParam: String)
data class C(val commonParam1: String, val commonParam2: String, val specialParam: Boolean)
data class D(val commonParam1: String, val commonParam2: String, val specialParam: Float)

data class G&lt;T&gt;(val commonParam1: String, val commonParam2: String, val specialParam: T)

MutationInputs
fun &lt;T&gt; Foo&lt;T&gt;.myFunction(func: () -&gt; Unit): Foo&lt;T&gt;

fun &lt;T&gt; Foo&lt;T&gt;.myFunction(func: () -&gt; Foo&lt;T&gt;): Foo&lt;T&gt;

if (list != null) {
    myData = list[0]
}

if (translation.equals(TRANSLATION_X) || 
    translation.equals(TRANSLATION_Y) || 
    translation.equals(TRANSLATION_Z)
) {
    return
} else {
    translation = TRANSLATION_X
}

    {
       &quot;steps&quot;: [
            &quot;This is normal text.&quot;,
            &quot;This is a list item.&quot;   
       ]
    }

This is normal text.
This is a list item.

This is normal text., This is a list item.

@JvmName("myFunction1")
fun &lt;T&gt; Foo&lt;T&gt;.myFunction(func: () -&gt; Foo&lt;Any&gt;): Foo&lt;T&gt;

@JvmName("myFunction2")
fun &lt;T&gt; Foo&lt;T&gt;.myFunction(func: () -&gt; Unit): Foo&lt;T&gt;

Cannot choose among the following candidates without completing type inference:
@JvmName public fun &lt;T&gt; Foo&lt;Any&gt;.myFunction(func: () → Foo&lt;Any&gt;): Foo&lt;Any&gt; defined in common.result
@JvmName public fun &lt;T&gt; Foo&lt;Any&gt;.myFunction(func: () → Unit): Foo&lt;Any&gt; defined in common.result

myFoo.myFunction{ methodReturningUnit() }
myFoo.myFunction{ methodReturningFooOfAny() }

+
class Demo{
  operator fun plus(i:Int):Demo {
    ...
  }
}

fun getApple(): Apple = {...}

fun setOrange(orange: Orange) {...}

val funMap = hashMapOf("getApple" to this::getApple, "setOrange" to this::setOrange)

funMap["getApple"]()

fun bytecoderepr(arg: String):String {
    var bcr:String = ""
    arg.toByteArray().forEach {
        bcr += it.toString()
    }
    return bcr
}

fun bytecoderepr(arg: String):String =
    arg.toByteArray().forEach().toString()

fun bytecoderepr(arg: String):String =
    arg.toByteArray().toString()

open class SuperClass&lt;T&gt;{
    protected open inner class InnerClass{
        fun someLogic(){
            println("some logic happened")
        }

        open fun someOverridableLogic(){
            println("some logic happened")
        }
    }
}

class ChildClass&lt;T&gt; : SuperClass&lt;T&gt;(){
    protected inner class ChildInnerClass:InnerClass{
        override fun someOverridableLogic(){
            super.someOverridableLogic()
            println("some OTHER logic happened")
        }
    }
}

protected inner class ChildInnerClass:InnerClass&lt;T&gt;

public class SuperClass&lt;T&gt; {
    protected class InnerClass{
        public void someLogic(){
            System.out.println("some logic happened");
        }

        public void someOverridableLogic(){
            System.out.println("some logic happened");
        }
    }
}


public class ChildClass&lt;T&gt; extends SuperClass&lt;T&gt;{
    protected class ChildInnerClass extends InnerClass{
        @Override
        public void someOverridableLogic() {
            super.someOverridableLogic();
            System.out.println("some OTHER logic happened");
        }
    }
}

import Y.*

abstract class File&lt;T&gt;

open class Y private constructor() {
  open class localhost_ {
    @JvmName("usr") operator fun div(a: usr.Companion) = usr&lt;localhost_&gt;()
    @JvmName("bin") operator fun div(a: bin.Companion) = bin&lt;localhost_&gt;()
    @JvmName("etc") operator fun div(a: etc.Companion) = etc&lt;localhost_&gt;()

    companion object: localhost_()
  }

  open class bin&lt;T&gt;: File&lt;T&gt;() { companion object }
  open class sh&lt;T&gt;: File&lt;T&gt;() { companion object }
  open class etc&lt;T&gt;: File&lt;T&gt;() { companion object }
  open class vim&lt;T&gt;: File&lt;T&gt;() { companion object }
  open class usr&lt;T&gt;: File&lt;T&gt;() { companion object }
  open class local&lt;T&gt;: File&lt;T&gt;() { companion object }

  companion object { fun uri(path: Any) = println(path) }
}

operator fun bin&lt;localhost_&gt;.div(a: sh.Companion) = sh&lt;bin&lt;localhost_&gt;&gt;()
operator fun bin&lt;usr&lt;localhost_&gt;&gt;.div(a: vim.Companion) = vim&lt;bin&lt;usr&lt;localhost_&gt;&gt;&gt;()
operator fun etc&lt;localhost_&gt;.div(a: vim.Companion) = vim&lt;etc&lt;localhost_&gt;&gt;()
operator fun usr&lt;localhost_&gt;.div(a: bin.Companion) = bin&lt;usr&lt;localhost_&gt;&gt;()
operator fun usr&lt;localhost_&gt;.div(a: local.Companion) = local&lt;usr&lt;localhost_&gt;&gt;()
operator fun local&lt;usr&lt;localhost_&gt;&gt;.div(a: bin.Companion) = bin&lt;local&lt;usr&lt;localhost_&gt;&gt;&gt;()

/**
 * localhost_/
 * ├── bin/
 * │   └── sh
 * ├── etc/
 * │   └── vim
 * └── usr/
 *     ├── bin/
 *     │   └── vim
 *     └── local/
 *         └── bin/
 */

fun main(a: Array&lt;String&gt;) {
  //Compiles!
  Y.uri(localhost_)
  Y.uri(localhost_/bin)
  Y.uri(localhost_/bin/sh)
  Y.uri(localhost_/etc)
  Y.uri(localhost_/etc/vim)
  Y.uri(localhost_/usr)
  Y.uri(localhost_/usr/bin/vim)
  Y.uri(localhost_/usr/local)
  Y.uri(localhost_/usr/local/bin)


  //Does not compile!
  Y.uri(localhost_/local)
  Y.uri(localhost_/bin/vim)
  Y.uri(localhost_/sh)
  Y.uri(localhost_/bin/local)
  Y.uri(localhost_/etc/local)
  Y.uri(localhost_/etc/sh)
  Y.uri(localhost_/usr/local/usr)
}

open class usr&lt;T&gt;: File&lt;T&gt;() {
    operator fun &lt;T: usr&lt;localhost_&gt;&gt; div(a: local.Companion) = local&lt;T&gt;()
    operator fun &lt;T: usr&lt;localhost_&gt;&gt; div(a: bin.Companion) = bin&lt;T&gt;()

    companion object
}

fun Example() : String{

 var value : String

     client.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                print("Getting Data Failed")
            }

            override fun onResponse(call: Call, response: Response) {
                value = "aaa"
            }  
     }

 return value
}


fun main(args: Array&lt;String&gt;) {

var names = arrayListOf(
        "Nathan",
        "Gerald",
        "Winchester",
        "Razi",
        "Tetsuo",
        "Bob",
        "Ryandick",
        "Jacafar",
        "Palamov",
        "Zaxon")

    print("Enter search query: ")
    val terms:String? = readLine()!!.toString()
    val output = names.filter{it == terms}
    println(output)

class Presenter {
    private var view : View? = null

    fun attachView(view: View) = this.view = view // error: Assignment is not a statement

    fun detachView() = view = null // error: Assignment is not a statement
}

class Presenter {
    var view : View? = null
}

presenter.view = View()
presenter.view = null
attachView
detachView
Unit
// lambda
val toUpper = { value: String -&gt; 
   if (value.isEmpty()) &quot;empty value&quot;
   else value.toUpperCase()
}

// anonymous func
val toUpper = fun(value: String): String {
  if (value.isEmpty()) return &quot;empty value&quot;
  else return value.toUpperCase()
}

var chart = new google.visualization.AreaChart(document.getElementById('chart_div'));

external class Google {
    val visualization: Visualization
    class Visualization {
        class AreaChart(element: Element?) {
            fun draw(chartDataTable: dynamic, options: dynamic)
        }
    }
}

external val google: Google

val chart = Google.Visualization.AreaChart(document.getElementById('chart_div'))


var chart = new google.visualization.AreaChart(document.getElementById('chart_div'));

  var Google$Visualization$AreaChart = Google.Visualization.AreaChart;
  var chart = new Google$Visualization$AreaChart(document.getElementById('chart_div'));


bla
blubb

blubber
testcode

Files.newBufferedReader("myfile").use { f -&gt;
    f.readText().splitToSequence("\n\n").forEach {
        // do my stuff
    }
}

\n\n
class Person(firstName: String) {
....
}

fun double(x: Int) {
...
}

var response: Response = client.newCall(request).execute()
&lt;uses-permission android:name="android.permission.INTERNET" /&gt;
    fun createCountry() {
    val client = OkHttpClient()

    val request: Request = Request.Builder()
        .url("https://restcountries-v1.p.rapidapi.com/all")
        .get()
       .addHeader("x-rapidapi-host", "restcountries-v1.p.rapidapi.com/all")
        .addHeader("x-rapidapi-key", "37fc618cmshase132cd36e0e395p149bbajsnab29a62e1016")
        .build()

    try {
        val country = Country("", "", "")

        val response: Response = client.newCall(request).execute()
        val jsonData: String = response.toString()
        val json = JSONObject(jsonData)

        country.name = json.getString("name")
        country.capital = json.getString("capital")
        country.region = json.getString("region")
        countries.add(country)
    }
    catch (e: Exception) {

    } catch (e: IOException) {

    }
}

Lazy.kt
UNINITIALIZED_VALUE
UNINITIALIZED_VALUE
_value
UNINITIALIZED_VALUE
_value
UNINITALIZED_VALUE
UNITIALIZED_VALUE
_value
UNINITIALIZED_VALUE
Boolean
UNINITIALIZED_VALUE
val myObj = SomeObj()
myObj?.property = SomeClass.someFunc() // What does ?. do in this context?

class Person(f_name : String, l_name : String){
    private var name = f_name + l_name
    get() = field
    set(value) {
        field = value
    }
    private var age : Int? = null
        get() {
            println("Age getter")
            return field
        }
        set(value) {
            println("Age setter")
            field = value
        }
    constructor(f_name: String, l_name: String, age : Int):this(f_name, l_name){
        name = "Mr./Msr./Ms. $f_name $l_name"
        this.age = age
    }

}

fun main() {
    var p = Person("M", "M")
    var m = Person("P", "P", 20)

    println("p : Person(${p.name})") // Shows error here

}

data structure
day stamp
data class transaction (var date: LocalDate, var quantity: Double) {

    private var calendar: Calendar =
            GregorianCalendar(date.year, (date.monthValue + 1), date.dayOfMonth)

    var day_stamp: Long = calendar.timeInMillis
}

var salesOrders = ArrayList&lt;transaction&gt;()
var demand = ArrayList&lt;transaction&gt;()

sales Orders
val formatter: DateTimeFormatter
    get() = DateTimeFormatter.ofPattern("dd.mm.yyyy", Locale.ENGLISH)

salesOrders.add(transaction(LocalDate.parse("01.02.2018", formatter), 100.0))
salesOrders.add(transaction(LocalDate.parse("01.02.2018", formatter), 80.0))
salesOrders.add(transaction(LocalDate.parse("02.02.2018", formatter), 120.0))
salesOrders.add(transaction(LocalDate.parse("02.02.2018", formatter), 90.0))

demand
day stamp
Considering a day is of: 24 hrs * 60 min/hour * 60,000 millisecond/min = 86,400,000 millisecond
for (i in 1519862400000..1519862400000 step 86400000){

    var calendar: Calendar = Calendar.getInstance()

    calendar.setTimeInMillis(i);

    val mYear: Int = calendar.get(Calendar.YEAR)

    val mMonth: Int = calendar.get(Calendar.MONTH)

    val mDay: Int = calendar.get(Calendar.DAY_OF_MONTH)

    val acc = salesOrders.filter { it.day_stamp == i }.
            fold (0.0) {s, els -&gt; s.plus(els.quantity) }

    demand.add(transaction(LocalDate.of(mDay, mMonth, mYear),acc))
}

"="
"="
myPairStr.asSequence()
        .filter { it.contains("=") }
        .map { it.split("=") }

        .filter { it.contains("=") }
        .map { it.split("=") }

getT()
() -&gt; T
interface Food
{
    var isHeated:Boolean;
    var name:String;
}

abstract class Cooker&lt;T:Food&gt;
{
    abstract fun getT():T;
    abstract fun enhance(t:T);
    fun cook(): T
    {
        var food = getT();
        food.isHeated = true;
        food.name = "heated " + food.name;
        enhance(food);
        return food;
    }
}

class PotatoChip:Food
{
    override var isHeated = false;
    override var name = "potato chip";
}

class PotatoChipCooker:Cooker&lt;PotatoChip&gt;()
{
    override fun getT(): PotatoChip {
        return PotatoChip();
    }
    override fun enhance(t:PotatoChip)
    {
        t.name = "salted " + t.name;
    }
}

class Pancake:Food
{
    override var isHeated = false;
    override var name = "pancake";
}

class PancakeCooker:Cooker&lt;Pancake&gt;()
{
    override fun getT(): Pancake {
        return Pancake();
    }
    override fun enhance(t:Pancake)
    {
        t.name = t.name + " coated with maple syrup";
    }
}

fun main(args: Array&lt;String&gt;)
{
    val result = PotatoChipCooker().cook();
    println(result.name);
    val result2 = PancakeCooker().cook();
    println(result2.name);
}

    class TestOne {
     def one(){
       print('function one');
     }
    }

    class TestTwo {
     def two() {
       print('function two');
     }
    }

workItOut("TestOne").one() // prints "function one"
workItOut("TestTwo").two() // prints "function two"

workItOut
fun workItOut(name: String) {
        if(name.equals("TestOne"))
            return TestOne()
        else if(name.equals("TestTwo"))
            return TestTwo()

        return ""
    }

val m = mapOf&lt;String, Int&gt;()
m.contains("Foo")
m.containsKey("Bar")

Map
contains
containsKey
key in m
init
object MyClass {
    var editor: Editor = getDefaultEditor()
        set(value) {
            field = value

            //Todo: figure out how to avoid duplicating init block
            project = editor.project!!
            document = editor.document.charsSequence.toString().toLowerCase()
            findModel = FindManager.getInstance(project).findInFileModel.clone()
            findManager = FindManager.getInstance(project)
        }

    var project: Project
    var document: String
    var findModel: FindModel
    var findManager: FindManager

    init {
        project = editor.project!!
        document = editor.document.charsSequence.toString().toLowerCase()
        findModel = FindManager.getInstance(project).findInFileModel.clone()
        findManager = FindManager.getInstance(project)
    }
}

init
init
setEditor(getDefaultEditor())
init
_
for _ in 0...10 {
  //loop logic here
}

val? context Context? = null
...
...
...
context = this
...
...
...
context = this.applicationContext //would be an error since context   
                                  //is val 

private fun getViewModel(): SubRedditViewModel {
    return ViewModelProviders.of(this, object : ViewModelProvider.Factory {
        override fun &lt;T : ViewModel?&gt; create(modelClass: Class&lt;T&gt;): T {
            val repoTypeParam = intent.getIntExtra(KEY_REPOSITORY_TYPE, 0)
            val repoType = RedditPostRepository.Type.values()[repoTypeParam]
            val repo = ServiceLocator.instance(this@RedditActivity)
                    .getRepository(repoType)
            @Suppress("UNCHECKED_CAST")
            return SubRedditViewModel(repo) as T
        }
    })[SubRedditViewModel::class.java]
}

get
fun main(args: Array&lt;String&gt;) {
    for (i in 1...10) {
        println(1)
    }
}

class Barrel&lt;out T&gt;(val item:T)
open class Loot(val value: Int)
class Fedora(val name:String, value:Int) : Loot(value)

public fun main(){
    var fedoraBarrel: Barrel&lt;Fedora&gt; = Barrel(Fedora("a generic-looking fedora", 15))
    var lootBarrel: Barrel&lt;Loot&gt; = fedoraBarrel
    lootBarrel = fedoraBarrel
    val myFedora: Fedora = lootBarrel.item
}

lootBarrel = fedoraBarrel

Error:(27, 28) Kotlin: Type mismatch: inferred type is Loot but Fedora was expected

lootBarrel = fedoraBarrel 

Ranges
String
val alpha = "A".."Z"

for (item in alpha) println(item)

foo as? Foo
foo as Foo?
fun main(args: Array&lt;String&gt;) {
    var ary = Array(5, {x -&gt; x + 2})
    println(ary[2])
}

$ kotlinc -version
info: kotlinc-jvm 1.2.70 (JRE 1.8.0_144-jdk_2017_08_24_20_46-b00)

$ kotlinc example.kt -include-runtime -d example.jar
$ java -jar example.jar 
Exception in thread "main" java.lang.NullPointerException
    at ExampleKt.main(example.kt:2)

myPairs: List&lt;Pair&lt;String, Double&gt;&gt;
val myAverages = myPairs.groupingBy { it.first }.fold(0.0) { sum, element -&gt; sum + element.second }.toMutableMap()
val myCounts = myPairs.groupingBy { it.first }.eachCount()

for ((myStr, count) in myCounts) {
        myAverages[myStr] = myAverages[myStr]!!.div(count)
    }

return myAverages

var a : Int;// I want this to be val, not var
var b: Int;// I want this to be val, not var too

if(condition) {
 a = 1
 b = 2
} else {
 a = 3
 b = 4
}

val a = if(condition) 1 else 2
val b = if(condition) 3 else 4

getCallData(ServiceCallBase::class.java)

fun getCallData(msg: Message, t: KClass&lt;Any&gt;): String {
   return gson.fromJson((msg.obj as Bundle).getString(SERVICE_BUNDLE_KEY_DATA_TO_SERVICE), t)
}

private inline fun &lt;reified T&gt; getCallData(msg: Message): String {
    return gson.fromJson((msg.obj as Bundle).getString(SERVICE_BUNDLE_KEY_DATA_TO_SERVICE), T)
}

  fun readFiles(directory: String): List&lt;File&gt; {
    val result = ArrayList&lt;File&gt;()

    File(directory).walkTopDown().forEach {
      result.addAll(getFiles(it))
    }

    return result
  }

  fun getFiles(file: File): List&lt;File&gt; { ... }

result
ArrayList
return File(directory).walkTopDown().???
mapOf("a" to listOf(1,2),
      "b" to listOf(3,4)
)

listOf("a", 1, 2, "b", 3, 4)

enum class WithGraphicKind(val innerClass: Class&lt;*&gt;) {
    CONTACT(Contact::class.java), SALE(Sale::class.java);
}

Contact
Sale
WithGraphics
innerClass: Class&lt;WithGraphics&gt;
Class&lt;* : WithGraphics&gt;
mutableListOf
isSaved
sealed class MasterList(val type: Type) {

    data class FavoriteList(
        val list: List&lt;Info&gt;
    ): MasterList(Type.FAVORITE)

    data class Child1List(
        val title: String,
        val list: List&lt;Info1&gt;
    ) : MasterList(Type.CHILD_1)

    data class Child2List(
        val title: String,
        val list: List&lt;Info2&gt;
    ) : MasterList(Type.CHILD_2)
}
data class Info(
    val fname: String,
    val lname: String,
    val age: String,
    val address: String
)
data class Info1(
    val fname: String,
    val lname: String,
    val isSaved: Boolean
)
data class Info2(
    val age: String,
    val address: String,
    val isSaved: Boolean
)
enum class Type {
    FAVORITE,
    CHILD_1,
    CHILD_2
}
fun loadInfo(): List&lt;MasterList&gt;? {
    val resultList = mutableListOf&lt;MasterList&gt;()
    val savedResult = MasterList.FavoriteList(localStroage.getAllFavorite())
    val feedResult = api.fetchAllInfo()
    return if (feedResult == null)
        null
    else {
        resultList.add(0, savedResult)
        resultList.addAll(feedResult)
        markSavedInfo(feedResult,savedResult.list)
        // I need to compare my savedResult with feedResult to put isSaved to true if it exist
        return resultList
    }
}
private fun markSavedInfo(feedResult: List&lt;MasterList&gt;, favoriteList: List&lt;Info&gt;) {
    feedResult.forEach {
        when (it.type) {
            Type.CHILD_1 -&gt; {
                (it as MasterList.Child1List).list.forEach {
                    val name = it.fname
                    for (saved in favoriteList) {
                        if (name == saved.fname)
                            println("Result $name")
                    }
                }
            }
            Type.CHILD_2 -&gt; {
                (it as MasterList.Child2List).list.forEach {
                    val age = it.age
                    for (saved in favoriteList) {
                        if (age == saved.age)
                            println("xxx: Result $age")
                    }
                }
            }
        }
    }
}

markSavedInfo
map
myList.map {
      if(resources.getBoolean(R.bool.is_tablet) &amp;&amp; it.itemList.size&lt;6 &amp;&amp; it.layerType == DOUBLE_LIST) {
        it.layerType = SINGLE_LIST_AUTO
        it.itemList.forEach {sectionItem-&gt;
          sectionItem.layerType = SINGLE_LIST_AUTO
        }
        it
      }else{
        it
      }
    }

var StringBuilder.lastChar: Char
    get() = get(length - 1)
    set(value: Char) {
        this.setCharAt(length - 1, value)
    }


val sb = StringBuilder("Kotlin?")
sb.lastChar = '!'
println(sb)

kotlinc -script
extensions.kts:3:14: error: unexpected type specification
    set(value: Char) {

adapter
setupWithViewPager
unresolved reference adapter
unresolved reference setupWithViewPager
package com.iraqairoirt.iraqairports

import android.os.Bundle
import android.support.design.widget.Snackbar
import android.support.design.widget.NavigationView
import android.support.v4.view.GravityCompat
import android.support.v7.app.ActionBarDrawerToggle
import android.support.v7.app.AppCompatActivity
import android.view.Menu
import android.view.MenuItem
import com.iraqairoirt.iraqairports.R.id.tabs_main
import com.iraqairoirt.iraqairports.R.id.viewpager_main
import kotlinx.android.synthetic.main.activity_main.*
import kotlinx.android.synthetic.main.app_bar_main.*

class MainActivity : AppCompatActivity(), NavigationView.OnNavigationItemSelectedListener {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        setSupportActionBar(toolbar)
        val fragmentAdapter = MyPagerAdapter(supportFragmentManager)

        viewpager_main.adapter = fragmentAdapter
        tabs_main.setupWithViewPager(viewpager_main)

        val toggle = ActionBarDrawerToggle(
            this, drawer_layout, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close
        )
        drawer_layout.addDrawerListener(toggle)
        toggle.syncState()

        nav_view.setNavigationItemSelectedListener(this)
    }

    override fun onBackPressed() {
        if (drawer_layout.isDrawerOpen(GravityCompat.START)) {
            drawer_layout.closeDrawer(GravityCompat.START)
        } else {
            super.onBackPressed()
        }
    }

    override fun onCreateOptionsMenu(menu: Menu): Boolean {
        // Inflate the menu; this adds items to the action bar if it is present.
        menuInflater.inflate(R.menu.main, menu)
        return true
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        when (item.itemId) {
            R.id.action_settings -&gt; return true
            else -&gt; return super.onOptionsItemSelected(item)
        }
    }

    override fun onNavigationItemSelected(item: MenuItem): Boolean {
        // Handle navigation view item clicks here.
        when (item.itemId) {
            R.id.nav_camera -&gt; {
                // Handle the camera action
            }
            R.id.nav_gallery -&gt; {

            }
            R.id.nav_slideshow -&gt; {

            }
            R.id.nav_manage -&gt; {

            }
            R.id.nav_share -&gt; {

            }
            R.id.nav_send -&gt; {

            }
        }

        drawer_layout.closeDrawer(GravityCompat.START)
        return true
    }
}

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;android.support.v4.widget.DrawerLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        xmlns:tools="http://schemas.android.com/tools"
        android:id="@+id/drawer_layout"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:fitsSystemWindows="true"
        tools:openDrawer="start"&gt;

    &lt;include
            layout="@layout/app_bar_main"
            android:layout_width="match_parent"
            android:layout_height="match_parent"/&gt;
    &lt;include
            layout="@layout/tabs"
            android:layout_width="match_parent"
            android:layout_height="match_parent"/&gt;
    &lt;android.support.design.widget.NavigationView
            android:id="@+id/nav_view"
            android:layout_width="wrap_content"
            android:layout_height="match_parent"
            android:layout_gravity="start"
            android:fitsSystemWindows="true"
            app:headerLayout="@layout/nav_header_main"
            app:menu="@menu/activity_main_drawer"/&gt;

&lt;/android.support.v4.widget.DrawerLayout&gt;

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
                                             xmlns:app="http://schemas.android.com/apk/res-auto"
                                             xmlns:tools="http://schemas.android.com/tools"
                                             android:layout_width="match_parent"
                                             android:layout_height="match_parent"
                                             tools:context="MainActivity"&gt;

    &lt;android.support.design.widget.TabLayout
            android:id="@+id/tabs_main"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            app:tabMode="fixed" /&gt;

    &lt;android.support.v4.view.ViewPager
            android:id="@+id/viewpager_main"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            app:layout_constraintTop_toBottomOf="@+id/tabs_main"/&gt;

&lt;/android.support.constraint.ConstraintLayout&gt;

fun say(val msg: String = "Hello World") {
    msg = "Hello To Me" // would give an error here since msg is val    
                        //or final
    ...
    ...
    ...
}

interface MyInterface {
    fun doSomething()
}

interface MyInterface {
    fun doSomething()
    companion object {
        val CONSTANT = object: MyInterface {
            override fun doSomething() { ... }
        }
    }
}

MyInterface.Companion.getCONSTANT()
@JvmField
interface MyInterface {
    fun doSomething()
    object CONSTANT: MyInterface {
            override fun doSomething() { ... }
        }
    }
}

MyInterface.CONSTANT
MyInterface.CONSTANT.INSTANCE
MyInterface.CONSTANT
static final
Object
public Object test() {
    return "Bla";
}

fun test(): Object {
    return "Bla"
}

return "Bla" as Object
Object
java.utils
A00.setOnCheckedChangeListener { _, isChecked -&gt;
    if (isChecked) {
        sendCommand("1050000")
        A00.setBackgroundColor(Color.rgb(248, 250, 237))
        A00.setTextColor(Color.rgb(96, 96, 96))
    } else {
        sendCommand("0050000")
        A00.setBackgroundColor(Color.rgb(96, 96, 96))
        A00.setTextColor(Color.rgb(248, 250, 237)) }
}

SC19.onItemSelectedListener = object : AdapterView.OnItemSelectedListener{
    override fun onNothingSelected(parent: AdapterView&lt;*&gt;?) {}
    override fun onItemSelected(parent: AdapterView&lt;*&gt;?, view: View?, position: Int, id: Long) {

        val selectedItem = view as TextView
        if (position == 0) { sendCommand("0000219") }
        if (position == 1) { sendCommand("1000219")
            selectedItem.setTextColor(Color.parseColor("#f8faed"))
            selectedItem.setBackgroundColor(Color.parseColor("#ff4500"))
        }
        if (position == 2) { sendCommand("1060219")
            selectedItem.setTextColor(Color.parseColor("#454545"))
            selectedItem.setBackgroundColor(Color.parseColor("#32cd32"))
        }
        if (position == 3) { sendCommand("1100219")
            selectedItem.setTextColor(Color.parseColor("#f8faed"))
            selectedItem.setBackgroundColor(Color.parseColor("#1e90ff"))
        }
        if (position == 4) { sendCommand("1040219")
            selectedItem.setTextColor(Color.parseColor("#454545"))
            selectedItem.setBackgroundColor(Color.parseColor("#ffff00"))
        }
    }
}

// allocate one mesh
pScene.mNumMeshes = 1
pScene.mMeshes = mutableListOf(AiMesh())
val pMesh = pScene.mMeshes[0]

mMeshes
var mMeshes: MutableList&lt;AiMesh&gt;? = null,
pMesh
MutableList&lt;AiMesh&gt;
pScene.mMeshes
val storedValue = sharedPreferences.getString(identifier, NOT_SET)
if (storedValue != NOT_SET) {
    super.setValue(storedValue)
}

storedValue
when (val storedValue = sharedPreferences.getString(identifier, NOT_SET)) {
    NOT_SET -&gt; {}
    else -&gt; super.setValue(storedValue)
}

NOT_SET
storedValue
when (val storedValue = sharedPreferences.getString(identifier, NOT_SET)) {
    !NOT_SET -&gt; super.setValue(storedValue)
}

if (sharedPreferences.contains(identifier)) {
    super.setValue(sharedPreferences.getString(identifier, null))
}

 fun getNameAlias(str: String): String {

        var nameLetter = ""
        if (!TextUtils.isEmpty(str)) {
            nameLetter = str!![0].toString()
        }
        if (!TextUtils.isEmpty(str.split("\\s ")[0])) {
            var index: Int = str.indexOf(" ")
            if (index &gt; 0) {

                nameLetter += if (index == -1) "" else str.substring(index + 1)[0]
            }
        }
        return nameLetter
    }

if (index &gt; 0) { }
"Test    me"
"Test me"
string?.replace("\\s+", " ")

\\s
val foo: kotlin.collections.List&lt;String&gt; = java.util.ArrayList()

ArrayList
List
        fun findExceptionType(currentException : Throwable?, exceptionToFind: KClass&lt;Throwable&gt;): Throwable? {
            var _currentException = currentException
            while((_currentException!!.cause == null)!!) {
                if (_currentException is exceptionToFind) {
                    return _currentException.cause
                }
                _currentException = _currentException.cause
            }
            return null
        }

exception.cause
exception.cause
exception.cause
if (s is String)
if (s is X)
X
X
KClass
is
class TestDuplicates {
    fun doSomething() {
        print("doSomething()")
    }
    fun doSomething(optional: String = "") {        
        print("doSomething($optional)")
    }
}

fun main() {    
    // Which is called? Why not at least warning?
    TestDuplicates().doSomething()
}

$ kotlinc
Welcome to Kotlin version 1.2.71 (JRE 10.0.2+13-Ubuntu-1ubuntu0.18.04.2)
Type :help for help, :quit for quit
&gt;&gt;&gt; var test: String = "This is a test of the user system."
&gt;&gt;&gt; var testarray2: Array&lt;String&gt; = test.split(" ").toTypedArray()
&gt;&gt;&gt; testarray2.sort()
&gt;&gt;&gt; testarray2.forEach { println("${it} ") }
This 
a 
is 
of 
system. 
test 
the 
user 
&gt;&gt;&gt; 

editText.text = "Mars"

editText.setText("Mars")

setText()
view.setOnClickListener { do() }

view.setOnClickListener(object : View.OnClickListener {
  override fun onClick(v: View?) {
    do()
  }
})

private var listener: OnCopyPasteClickListener? = null

interface OnCopyPasteClickListener {
  fun onPasteClick(text: String)
}

fun setOnCopyPasteClickListener(onCopyPasteClickListener: OnCopyPasteClickListener) {
  listener = onCopyPasteClickListener
}

copypaste.setOnCopyPasteClickListener(object : CopyPasteMenu.OnCopyPasteClickListener {
  override fun onPasteClick(text: String) {
    do(text)
  }
})

copypaste.setOnCopyPasteClickListener {
  do(it)
}

val doubleVal = (findViewId&lt;EditText&gt;(R.id.)).text.toString()
val doubleS = Double.parseDouble(doubleVal)

if(???)
{
    println("Number is double")
}
else
{
    editDouble.error = "Type double number!!"
}

import java.util.*

fun main(args: Array&lt;String&gt;) {
    val scanner = Scanner(System.`in`)

    val line: String = scanner.next()
    val number: Int = scanner.nextInt()

    var result: Char = (line)[number]

    println("Symbol # $number of the string $line is $result")
}

Symbol # 1 of the string "hello world" is 'h'

Enum.values()
sealed class State

object StateA: State()
object StateB: State()
object StateC: State()
....// 42 more

val VALUES = setOf(StateA, StateB, StateC, StateC, StateD, StateE,
    StateF, StateG, StateH, StateI, StateJ, StateK, StateL, ......

if ((i / 3) is Int ) {
print("Whole Number")
}

 if((i.toFloat()/3) == (i / 3).toFloat()){
        println("Whole Number")

val arr1 = arrayOf&lt;Char&gt;('a', 'b', 'c', 'd', 'e', 'b')
val arr2 = arrayOf&lt;Char&gt;('z', 'y', 'x', 'w', 'v', 'u')

fun filter(predicate: (T?) -&gt; Boolean): Collection&lt;Char&gt; { ... }

val res = obj.filter { it == 'b' }

val newList = arr1.flatten().mapIndexed{idx, it -&gt; predicate}

Option
@optics
data class TestClass(val opt: String) { companion object }

val tc = TestClass("Hello")
val tc2 = TestClass.opt.set(tc, "def")

@optics
data class TestClass(val opt: Option&lt;String&gt;) { companion object }

val tc = TestClass(Some("Hello"))
val tc2 = TestClass.opt.set(tc, None)

set
String
Option&lt;String&gt;
Optional
copy()
open val
var
open class Foo {
    open var str = "Hello"
}


class Bar : Foo() {
    override var str = "world" 

    init {
        println(str)
        println(super.str) // Shows that Bar actually contains "hello" and "world"
    }
} 

str
open class Foo(var str = "Hello") // Maybe make a secondary constructor

class Bar : Foo("world") // Bar has only 1 string

val
var
super
    override val foo = super.foo * 2

inline fun&lt;T&gt; with(t: T, body: T.() -&gt; Unit) { t.body() }

inline fun Activity.coordinatorLayout(init: CoordinatorLayout.() -&gt; Unit) = ankoView({ CoordinatorLayout(it) },init)

azimuth = Math.round(azimuth.toFloat())
    compass_image.rotation = (-azimuth).toFloat()

    val where = when(azimuth){
        in 281...348 -&gt; "NW"
        in 281...348 -&gt; "NW"
        in 281...348 -&gt; "NW"
        in 281...348 -&gt; "NW"
        in 281...348 -&gt; "NW"
        in 281...348 -&gt; "NW"
        in 281...348 -&gt; "NW"
        else -&gt; "N"
    }

    view_degree.text = "$azimuth° $where"

abstract class SuperClass(val someVal: String = "defaultValue") : SomeSuperClass 

someVal
"defaultValue"
someVal
val sc = SubClass()
val sc2 = SubClass("anotherVal")
class SubClass() : SuperClass() {
    constructor(someVal: String) : this(someVal)

Error:(5, 37) Kotlin: There's a cycle in the delegation calls chain

someVal
abstract class SuperClass(var someVal: String = "defaultValue") : SomeSuperClass 


class SubClass() : SuperClass() {
    constructor(someVal: String) : this() {
        super.someVal = someVal
    }
}

fun compose(a: (Int, Int) -&gt; Int, b: (Int, Int) -&gt; Int): Int {
    return a.invoke() + b.invoke()
}

val a : Int? = 1
val b : Int = 1
a?.compareTo(b)

val a : Int? = 1
val b : Int? = 2
a?.compareTo(b)

val a : Int? = 1
val b : Int? = 2
val x : Int = b ?: 0;
o1?.compareTo(x)

Map&lt;Pair&lt;Int, Int&gt;), String&gt;

Pair&lt;Int, Int&gt;) // zero based star index, inclusive end index
to
displayString

var index = 0
for (data in dataList) {
   /*
   if the current index is within one of the pair&lt;int, int&gt; 
   then use the mapped displayString
   */
   index++
}

val x: List&lt;Int&gt; = listOf(1,2,3,4,5,6)
val y: List&lt;Int&gt; = listOf(2,3,4,5,6,7)

val z: List&lt;Int&gt; = 3,5,7,9,11,13

importerResponse.applications
        val isDeployed = importerResponse.applications
                .flatMap(Application::instances)
                .map(Instance::state)
                .all { state -&gt; DEPLOYED == state }

isDeployed
applications
kotlin.CharSequence.split()
val delimiter = '\t'
val line = "example\tline"
val parts = line.split(delimiter)

parts
List&lt;String&gt;
split
String[]
String::split(String)
toInt()
var input = "8569 2478 0383 3437"

val regex = "[^0-9]".toRegex()
var value = regex.replace(input, "")

val iterator = value.iterator()

var sum : Int = 0
var v : Int
for((index, value) in iterator.withIndex()){
    if(index % 2 == 0){
        var v = value.toInt() * 2 
        if(v &gt; 9) v -= 9

        print("$v:$value ")
        sum += v
    }else{
        print("$value ")
        sum += value.toInt()
    }
}

103:8 5 99:6 9 91:2 4 101:7 8 87:0 3 103:8 3 93:3 4 93:3 7

8:8 5 6:6 9 2:2 4 7:7 8 0:0 3 8:8 3 3:3 4 3:3 7

class ExchangeRatesServiceImpl : ExchangeRatesService {

    private var container: ExchangeRatesContainer? = null

    /**
     * {@inheritDoc}
     */
    override val currentRates: Map&lt;Currency, BigDecimal&gt;
        get() {
            if (container == null || container.date != LocalDate.now()) {
                container = client.getRates(Currency.getBase())
                        log.info("exchange rates has been updated: {}", container)
            }
            return ImmutableMap.of&lt;Currency, BigDecimal&gt;(
                    Currency.EUR, container.rates[Currency.EUR.name],
                    Currency.RUB, container.rates[Currency.RUB.name],
                    Currency.USD, BigDecimal.ONE
            )
        }
}

"$foo"
'$foo'

[]
val testObject = MyCustumObject()
println(testObject["hi"])  // i.e. implement this accessor.

__getitem__
__setitem__
takeWhile
generateSequence(obj::class.java, Class&lt;*&gt;::getSuperclass)
        .takeWhile { interestedType !in it.interfaces }
        .joinToString(" &gt; ")
        .run(::println)

obj=arrayListOf(1)
interestedType=Collection::class.java
class java.util.ArrayList &gt; class java.util.AbstractList &gt; class java.util.AbstractCollection

generateSequence(obj::class.java, Class&lt;*&gt;::getSuperclass)
        .takeWhileInclusive { interestedType !in it.interfaces }
        .joinToString(" &gt; ")
        .run(::println)

Iterator
takeWhileInclusive
var
fun search(query: String): ArrayList&lt;String&gt; {
    val found = ArrayList&lt;String&gt;()
    for (i in terms.indices) {
        if (terms[i].contains(query)) {
            found.add(terms[i])
        }
        if (found.size == 10) {
            break
        }
    }
    return found
}

fun search2(query: String): List&lt;String&gt; {
    return terms.filter { it.contains(query) }.take(10)
}

fold
fun operation(acc: Int, next: Int): Int {
    return acc * next
}
val items = listOf(1, 2, 3, 4, 5)
println(items.fold(1, ::operation))

fold
operation
fold
fold
_Collections.kt
public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.fold(
        initial: R, 
        operation: (acc: R, T) -&gt; R
): R {
    var accumulator = initial
    for (element in this) accumulator = operation(accumulator, element)
    return accumulator
}

fold
Int::times
val items = listOf(1, 2, 3, 4, 5)
println(items.fold(1, Int::times))

Int::times
/** Multiplies this value by the other value. */
public operator fun times(other: Int): Int

operator
choseNavigation(childPos, {Toast.makeText(ctx, "hello1", Toast.LENGTH_SHORT).show()},
                                {Toast.makeText(ctx, "hello2", Toast.LENGTH_SHORT).show()})

private fun choseNavigation(pos: Int, action1: () -&gt; Unit, action2: () -&gt; Unit) {
    when(pos) {
        0-&gt; {
            action1
            Toast.makeText(ctx, "hello-again1", Toast.LENGTH_SHORT).show()
        }
        1-&gt;{
            action2
            Toast.makeText(ctx, "hello-again2", Toast.LENGTH_SHORT).show()
        }
    }
}

hello1
hello-again1
hello2
hello-again2
hello-again1
hello-again2
fun sum(x: Number, y: Number) = x + y
println(sum(2.2, 2))

return
fun main(args: Array&lt;String&gt;) {
    val nums = arrayOf(1, 2, 3)
    val numsPlusOne = nums.map { it -&gt; 
        val r = it + 1
        r
    }
    // numsPlusOne = [2, 3, 4]
}

import java.util.Scanner

fun main(args: Array&lt;String&gt;) {
    val reader = Scanner(System.`in`)
    print("Enter a number: ")
    var integer:Int = reader.nextInt()
    println("You entered: $integer")
}

infix fun &lt;T&gt; T.isNullOr(other: T): Boolean {
    if (this == null) return true
    return this == other
}

val thisShouldWork = true isNullOr true // this is true
val thisShouldNotWork = true isNullOr 0 // No compilation errors?

Boolean
isNullOr
static bool IsNullOr&lt;T&gt;(this T t, T other) {
    if (t == null) return true;
    return Equals(t, other);
}

bool howAboutThis = 0.IsNullOr(0);
bool andThis = 0.IsNullOr(false); // error - cannot detect type parameter for this

val list = listOf(1,2,3,4,5,6)
val listRepeated = listOf(2,2,3,4,5,5,6)
println(list.merge(listRepeated) { it1, it2  -&gt; it1 + it2 })

Error:(33, 18) Kotlin: Unresolved reference: merge
Error:(33, 40) Kotlin: Cannot infer a type for this parameter. Please specify it explicitly.
Error:(33, 45) Kotlin: Cannot infer a type for this parameter. Please specify it explicitly.

fun T GetContent(call: ApplicationCall) : T

fun GetContent&lt;T&gt;(call: ApplicationCall) : T

object
Type parameters are not allowed for objects
object RestApiParser&lt;T&gt; // ERROR(mark under T): Type parameters are not allowed for objects
: Callback&lt;T&gt; {

    override fun onFailure(call: Call&lt;T&gt;?, t: Throwable?) {
        // bla-bla-blaa codes ...
    }

    override fun onResponse(call: Call&lt;T&gt;?, response: Response&lt;T&gt;?) {
        // bla-bla-blaa codes ...
    }

    fun getResponse(context: Context, call: Call&lt;T&gt;, callback: RestApiCallback&lt;T&gt;) {
       // bla-bla-blaa codes ...
    }

    fun getList(context: Context, call: Call&lt;ArrayList&lt;T&gt;&gt;, callback: RestApiCallback&lt;T&gt;) {
       // bla-bla-blaa codes ...
    }

    // there are more codes like the above ...
}

companion object
class
RestApiParser
companion object {
    private var instance: RestApiParser&lt;*&gt;? = null
    fun &lt;T&gt; getParser(): RestApiParser&lt;T&gt; {
        if (instance == null)
            instance = RestApiParser&lt;T&gt;()
        return instance as RestApiParser&lt;T&gt;
    }
}

apply
SomeOfTheObjects().apply {
  someProperty = SomeOtherComplexObject().apply {
    someOtherProperty = "..."
  }
}

someProperty
SomeOtherComplexObject
@DslMarker
also
SomeOfTheObjects().also {
  it.someProperty = SomeOtherComplexObject().also {
    it.someOtherProperty = "..."
    //it.someProperty will not work if SomeOtherComplexObject has no such property
  }
}

it.
@DslMarker
@DslMarker
annotation class DemoMarker

@DemoMarker
inline fun &lt;T&gt; T.build(@DemoMarker builder : T.() -&gt; Unit) = this.apply(builder)

also


class MarketplaceGetEffectiveRateQuery(private val handle: Handle) {


    fun run(resourceUUID: UUID,subscriptionUuid: UUID): BigDecimal {
       return handle.createQuery(GET_EFFECTIVE_RATE_QUERY)
            .bind("resourceUUID", resourceUUID)
                .bind("ms_subscription_id", subscriptionUuid)
            .map(EffectiveRateMapper())
                .findOnly()
    }
}

   override fun map(rs: ResultSet, ctx: StatementContext): BigDecimal {
       return rs.getBigDecimal("effective_rate")
    }
}

onCreate
val cm = baseContext.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
val networkInfo = cm.activeNetworkInfo
if (networkInfo != null &amp;&amp; networkInfo.isConnected){

    if (networkInfo.type == ConnectivityManager.TYPE_WIFI){

        Toast.makeText(baseContext,"wifi",Toast.LENGTH_SHORT).show()
    }
    if (networkInfo.type == ConnectivityManager.TYPE_MOBILE){

        Toast.makeText(baseContext,"MOBILE",Toast.LENGTH_SHORT).show()
    }

}else {
    Toast.makeText(baseContext,"MOBILE",Toast.LENGTH_SHORT).show()
    this.finish()
}

E/AndroidRuntime: FATAL EXCEPTION: AsyncTask #1
    Process: com.iraqairoirt.iraqairports, PID: 10868

package com.iraqairoirt.iraqairports

import android.annotation.SuppressLint
import android.content.Context
import android.content.DialogInterface
import android.os.AsyncTask
import android.os.Bundle
import android.support.design.widget.NavigationView
import android.support.v4.view.GravityCompat
import android.support.v7.app.ActionBarDrawerToggle
import android.support.v7.app.AlertDialog
import android.support.v7.app.AppCompatActivity
import android.view.Menu
import android.view.MenuItem
import android.widget.TextView
import com.iraqairoirt.iraqairports.BaghdadAirport.ListAdapteArr
import com.iraqairoirt.iraqairports.BaghdadAirport.ListAdapteDep
import kotlinx.android.synthetic.main.activity_main.*
import kotlinx.android.synthetic.main.content_main.*
import kotlinx.android.synthetic.main.fragment_baghdada_arrivel.*
import kotlinx.android.synthetic.main.fragment_baghdada_dep.*

import org.json.JSONArray
import org.json.JSONObject
import java.net.HttpURLConnection
import java.net.URL
import android.widget.Toast
import android.content.Intent
import android.content.IntentFilter
import android.net.ConnectivityManager
import android.net.NetworkInfo
import android.support.design.widget.Snackbar
import com.iraqairoirt.iraqairports.BaghdadAirport.FlightsArrivelBeforBGW
import com.iraqairoirt.iraqairports.BaghdadAirport.FlightsDepBeforBGW


class MainActivity : AppCompatActivity(), NavigationView.OnNavigationItemSelectedListener {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)


        val url = "airport.json"
        Arr().execute(url)


        setSupportActionBar(toolbar)
        val fragmentAdapter = MyPagerAdapter(supportFragmentManager)

        viewpager_main.adapter = fragmentAdapter
        sliding_tabs.setupWithViewPager(viewpager_main)

        val toggle = ActionBarDrawerToggle(
            this, drawer_layout, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close
        )
        drawer_layout.addDrawerListener(toggle)
        toggle.syncState()

        nav_view.setNavigationItemSelectedListener(this)


        val cm = baseContext.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        val networkInfo = cm.activeNetworkInfo
        if (networkInfo != null &amp;&amp; networkInfo.isConnected){

            if (networkInfo.type == ConnectivityManager.TYPE_WIFI){

                Toast.makeText(baseContext,"wifi",Toast.LENGTH_SHORT).show()
            }
            if (networkInfo.type == ConnectivityManager.TYPE_MOBILE){

                Toast.makeText(baseContext,"MOBILE",Toast.LENGTH_SHORT).show()
            }

        }else {
            Toast.makeText(baseContext,"MOBILE",Toast.LENGTH_SHORT).show()
            this.finish()
        }

    }


    //    full class for json api
    inner class Arr : AsyncTask&lt;String, String, String&gt;() {

        val progressDialog = AlertDialog.Builder(this@MainActivity)
        val dialogView = layoutInflater.inflate(R.layout.progress_dialog, null)
        val message = dialogView.findViewById&lt;TextView&gt;(R.id.message_id)
        val dialog = progressDialog.create()

        override fun onPreExecute() {
            super.onPreExecute()

            dialog.setMessage("يرجى الانتظار")
            dialog.setCancelable(false)
            dialog.show()


        }

        //        for build connection
        override fun doInBackground(vararg url: String?): String {

            var text: String
            val connection = URL(url[0]).openConnection() as HttpURLConnection

            try {
                connection.connect()
                text = connection.inputStream.use { it.reader().use { reader -&gt; reader.readText() } }


            } finally {

                connection.disconnect()

            }
            return text
        }

        override fun onPostExecute(result: String?) {

            super.onPostExecute(result)
            handleJson(result)

            dialog.dismiss();

        }

        override fun onProgressUpdate(vararg text: String?) {


        }

        @SuppressLint("WrongViewCast")
        private fun handleJson(jsonString: String?) {

            val jsonObj = JSONObject(jsonString)
            val result = jsonObj.getJSONObject("result")
            val response = result.getJSONObject("response")
            val airport = response.getJSONObject("airport")
            val pluginData = airport.getJSONObject("pluginData")
            val schedule = pluginData.getJSONObject("schedule")
            val arrivals = schedule.getJSONObject("arrivals")

//            weather data
            val weather = pluginData.getJSONObject("weather")
            val mater = weather.getString("metar")

//            MaterText.text=mater
//        val data = arrivals.getJSONObject("data")
            val jsonArray = JSONArray(arrivals.get("data").toString())

            val list = ArrayList&lt;FlightShdu&gt;()
            var x = 0
            while (x &lt; jsonArray.length()) {

                val jsonObject = jsonArray.getJSONObject(x)



                list.add(
                    FlightShdu(
                        jsonObject.getJSONObject("flight").getJSONObject("identification").getJSONObject("number").getString(
                            "default"
                        ),
                        jsonObject.getJSONObject("flight").getJSONObject("airline").getString("short"),
                        jsonObject.getJSONObject("flight").getJSONObject("status").getJSONObject("generic").getJSONObject(
                            "status"
                        ).getString("text"),
                        jsonObject.getJSONObject("flight").getJSONObject("airline").getJSONObject("code").getString("icao"),
                        jsonObject.getJSONObject("flight").getJSONObject("time").getJSONObject("scheduled").getString("arrival"),
                        jsonObject.getJSONObject("flight").getJSONObject("airport").getJSONObject("origin").getJSONObject(
                            "code"
                        ).getString("iata"),
                        jsonObject.getJSONObject("flight").getJSONObject("aircraft").getJSONObject("model").getString("code"),
//                    for more information
                        jsonObject.getJSONObject("flight").getJSONObject("time").getJSONObject("real").getString("departure"),
                        jsonObject.getJSONObject("flight").getJSONObject("time").getJSONObject("estimated").getString("arrival"),
//                    jsonObject.getJSONObject("flight").getJSONObject("time").getJSONObject("estimated").getString("arrival"),
                        jsonObject.getJSONObject("flight").getJSONObject("aircraft").getString("registration"),
                        jsonObject.getJSONObject("flight").getJSONObject("status").getJSONObject("generic").getJSONObject(
                            "status"
                        ).getString("diverted"),
                        arrivals.getString("timestamp"),
                        jsonObject.getJSONObject("flight").getJSONObject("status").getString("icon")


                    )
                )


                x++
            }
            list.forEach(::println)

            var adapter = ListAdapteArr(this@MainActivity, list)
            flight_arrivel_list.adapter = adapter


        }

    }

    override fun onBackPressed() {
        if (drawer_layout.isDrawerOpen(GravityCompat.START)) {
            drawer_layout.closeDrawer(GravityCompat.START)
        } else {
            super.onBackPressed()
        }
    }

    override fun onCreateOptionsMenu(menu: Menu): Boolean {
        // Inflate the menu; this adds items to the action bar if it is present.
        menuInflater.inflate(R.menu.main, menu)
        return true
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {

        val id = item.itemId

        //noinspection SimplifiableIfStatement

        if (id == R.id.flightarrbeforbgw) {

            val intent = Intent(this, FlightsArrivelBeforBGW::class.java)
            this.startActivity(intent)
            return true
        }

        if (id == R.id.flightdepbefrobgw) {
            val intent = Intent(this, FlightsDepBeforBGW::class.java)
            this.startActivity(intent)
            return true
        }
//
//        if (id == R.id.searchflights) {
//            Toast.makeText(this, "Android Menu is Clicked", Toast.LENGTH_LONG).show()
//            return true
//        }

        return super.onOptionsItemSelected(item)

    }

    override fun onNavigationItemSelected(item: MenuItem): Boolean {
        // Handle navigation view item clicks here.
        when (item.itemId) {
            R.id.nav_camera -&gt; {
                // Handle the camera action
            }
            R.id.nav_gallery -&gt; {

            }
            R.id.nav_slideshow -&gt; {

            }
            R.id.nav_manage -&gt; {

            }
            R.id.nav_share -&gt; {

            }
            R.id.nav_send -&gt; {

            }
        }

        drawer_layout.closeDrawer(GravityCompat.START)
        return true
    }



}

{
    “PersonId”: 123,
    “PersonType”: [
        {
            “Age”: “10”,
            “Pid”: “ABC”
            “Ptype”: “abc”
        },
         {
            “Age”: “10”,
            “Pid”: “PQR”,
            “Ptype”: “per”
        }
    ]
}



List&lt;&lt;FamilyType&gt;&gt;
fun add(a: Int , b: Int): Int{
   return a+b 
}

val add  = {
        a:Int,b:Int-&gt;
        println("I am calculating the sale =&gt; no body you guy [$x+$y]");
  //works

  }


val add = { a:Int ,b : Int -&gt;
   //How do i return from this function
}

class Example {
    val name: String

    val lazyVar: String by lazy {
        name + " something else"
    }

    init {
        name = "StackOverflow"
    }
}

name
lazyVar
name
init
class Example {
    val name: String

    val lazyVar: String by lazy {
        initLazyVar()
    }

    init {
        name = "StackOverflow"
    }

    private fun initLazyVar(): String {
        return name + " something else"
    }
}

for (i in array.indices)
  print(array[i])

fun main(args: Array&lt;String&gt;) {
    val arr = arrayOf(1, 2, 3)
    for (i in arr.indices) {
        println(arr[i])
    }
}

      41: aload_1
      42: checkcast     #23                 // class &quot;[Ljava/lang/Object;&quot;
      45: invokestatic  #31                 // Method kotlin/collections/ArraysKt.getIndices:([Ljava/lang/Object;)Lkotlin/ranges/IntRange;
      48: dup
      49: invokevirtual #37                 // Method kotlin/ranges/IntRange.getFirst:()I
      52: istore_2
      53: invokevirtual #40                 // Method kotlin/ranges/IntRange.getLast:()I
      56: istore_3
      57: iload_2
      58: iload_3
      59: if_icmpgt     93

getIndices
IntRange
for (i in array.indices)
for (i in 0..array.size)
for (el in array)
array.forEach
for (i in coll.indices)
for (i in 0..coll.size)
for (el in coll)
coll.forEach
crossinline
    val edit = findViewById&lt;EditText&gt;(R.id.editBroj)
    val webView = findViewById&lt;WebView&gt;(R.id.web)
    val click=findViewById&lt;Button&gt;(R.id.pokreniB)
    val textView=findViewById&lt;TextView&gt;(R.id.textView)

    val si=edit.text.toString()

    textView.text= Editable.Factory.getInstance().newEditable(si)
    if (si!="") {
        click.setOnClickListener() {

            edit.text= Editable.Factory.getInstance().newEditable(null)
            val po: Int = Integer.parseInt(edit.getText().toString())

            for (i in 1..po) {
                val s:String=i.toString()
                Thread.sleep(1_000)
            }
        }
    }

person {
    name = "John Doe" // this field needs to be set always, or compile error
    age = 25
}

person(name = "John Doe") {
    age = 25
}

int first = 1, second = 2, third = 3;
var first: Int = 1
var second: Int = 2
var third: Int = 3

var first = 1, second = 2, third = 3: Int //Error
var first: Integer = 1; var second: Integer = 2; var third: Integer = 3
var first = 1; var second = 2; var third = 3
NestedStaticClass
package javapackage;

class HiddenClass {
    public static class NestedStaticClass {}
}

HiddenClass
package javapackage;

public class VisibleClass extends HiddenClass{}

VisibleClass
NestedStaticClass
package otherpackage;

import javapackage.VisibleClass;

public class JavaClass extends VisibleClass {

    public static class C4 extends NestedStaticClass {}

    public JavaClass() {
        new NestedStaticClass();
    }
}

package otherpackage

import javapackage.VisibleClass

class KotlinClass() : VisibleClass() {
    class C1() : NestedStaticClass()

    init {
        val v = NestedStaticClass()
    }
}

f1
fun f1(n: Int, map: MutableMap&lt;Int, Int&gt; = mutableMapOf(Pair(0, 0), Pair(1, 1))): Int =
        map.getOrPut(n) {
            val a = map.getOrPut(n - 1) { f1(n - 1, map) }
            val b = map.getOrPut(n - 2) { f1(n - 2, map) }
            a + b
        }

f2
fun f2(n: Int, map: MutableMap&lt;Int, Int&gt; = mutableMapOf(Pair(0, 0), Pair(1, 1))): Int =
        map.getOrPut(n) {
                    map.getOrPut(n - 1) { f2(n - 1, map) }
                    +
                    map.getOrPut(n - 2) { f2(n - 2, map) }

        }

f2
map.getOrPut(n - 1) { f2(n - 1, map) }
f2
fun f2(n: Int, map: MutableMap&lt;Int, Int&gt; = mutableMapOf(Pair(0, 0), Pair(1, 1))): Int =
        map.getOrPut(n) {
            (
                    map.getOrPut(n - 1) { f2(n - 1, map) }
                    +
                    map.getOrPut(n - 2) { f2(n - 2, map) }
            )
        }

(..)
fun f2(n: Int, map: MutableMap&lt;Int, Int&gt; = mutableMapOf(Pair(0, 0), Pair(1, 1))): Int =
        map.getOrPut(n) {
                    map.getOrPut(n - 1) { f2(n - 1, map) } +
                    map.getOrPut(n - 2) { f2(n - 2, map) }
        }

append
StringBuilder
fun append(c: Char) {
    println("TEST")
}

fun sbTest() = with(StringBuilder()) {
    for(c in 'A'..'Z') {
        append(c) // how do I refer to the append function declared above?
    }
    toString()
}

val f = ::append
f
append
var a: Int = 10000
var b: Int = 10000
print(b === a) // Prints 'true'

mySpinner.setSelection(myObj?.spinIdx)

var spinIdx: Int = 0

mySpinner.setSelection(myObj?.spinIdx as Int)

@InlineOnly
inline
inline
declare type Status = 'GOOD' | 'MEDIUM' | 'POOR';

status
interface Foo {
  status: Status;
}

List&lt;Policies&gt; -&gt; (key: String, value: String)
class Policy {
    val key: String,
    val value: String
}

data class Request (
  id: Long =  12,
  firstName: String = "test",
  surname: String = "test",
  address: String = "somewhere"
  ...// more fields
)

List&lt;Policy&gt; =&gt; [
    {
       key: "surname",
       value: "test"
    },
        {
       key: "firstName",
       value: "test"
    }
]

+=
i = i+1
i
+=
musicSource.forEach { mediaItem -&gt;
            val albumMediaId = mediaItem.album.urlEncoded
            val albumChildren = mediaIdToChildren[albumMediaId] ?: buildAlbumRoot(mediaItem)
            albumChildren += mediaItem
        }

,
fun main(args: Array&lt;String&gt;) {
    val regex = ","
    val lines = "30,21,29, 31, 40, 48, 53, 47, 37, 39, 31, 29, 17, 9, 20, 24, 27, 35, 41, 38, 27, 31, 27, 26, 21, 13, 21, 18, 33, 35, 40, 36, 22, 24, 21, 20, 17, 14, 17, 19, 26, 29, 40, 31, 20, 24, 18, 26, 17, 9, 17, 21, 28, 32, 46, 33, 23, 28, 22, 27, 18, 8, 17, 21, 31, 34, 44, 38, 31, 30, 26, 32"

    val series = lines.split(regex).toList().map{ it.toInt() }.toList&lt;Int&gt;()

    println(series)
}

typealias MyHandler = (Int, String) -&gt; Unit

var myHandler = MyHandler(1, "2")

class Bottle(bottleShape: String, capacity: Int, color: String): Container( bottleShape, capacity) {

private var closed: Boolean = true
    val bottleColor: String

 constructor(bottleShape: String, capacity: Int): this (bottleShape, capacity, "Transparent")

    init{

        closeAble = true
        bottleColor = color
        println(bottleColor)

    }
}

kotlinc -script myscript.kts

java.lang.OutOfMemoryError: GC overhead limit exceeded
java.lang.OutOfMemoryError: Java heap space
kotlinc -Xmx8g -script myscript.kts

warning: flag is not supported by this version of the compiler: -Xmx8g

fun main() {
    println(hasDuplicates(listOf(
        listOf("1", "2", "3"),
        listOf("4", "5"),
        listOf("1", "2")
    )))
}

fun hasDuplicates(input: List&lt;List&lt;String&gt;&gt;): Boolean {
    val seen = mutableSetOf&lt;String&gt;()
    input.forEach { inner -&gt;
        inner.forEach { element -&gt;
            if (!seen.add(element)) {
                return true
            }
        }
    }
    return false
}

fun hasDuplicates(input: List&lt;List&lt;String&gt;&gt;): Boolean {
    val flat = input.flatten()
    return flat.size != flat.toSet().size
}

fun hasDuplicates(input: List&lt;List&lt;String&gt;&gt;): Boolean {
    return input.asSequence().flatten()
//        .onEach {
//            println("getting $it")
//        }
        .groupingBy { it }
        .eachCount()
        .any { (_, count) -&gt; count &gt; 1 }
}

onEach
// (element, seenCount)
("1", 0)
("2", 0)
("1", 1)

seenCount &gt; 0
fun hasDuplicates(input: List&lt;List&lt;String&gt;&gt;): Boolean {
    input.asSequence().flatten()
        .onEach {
            println("getting $it")
        }
        .fold(mutableSetOf&lt;String&gt;()) { seen, element -&gt;
            if (!seen.add(element)) {
                return true
            }
            seen
        }
    return false
}

List&lt;Content&gt; getContent(List&lt;Node&gt; nodes, Map&lt;String, Content&gt; content) {
  List&lt;Content&gt; result = new ArrayList&lt;&gt;(nodes.size());
  for (Node node : nodes) {
    Content content = content.get(node.getId());
    if (content == null) {
      logger.atSevere().log("Content %s was not found", node.getId());
      continue;
    }
    result.add(content);
  }
  return result;
}

fun getContent(items: List&lt;Node&gt;, content: Map&lt;String, Content): List&lt;Content&gt; {
  val contentIds = items.mapNotNull { it.id }
  return contentIds.mapNotNull { contentMap[it] }
}

contentIds
contentIds
contentMap
Content
fun checkLengthA(str : String?): Int = if (str.isNullOrBlank()) 0 else str.length

fun checkLengthB(str : String?): Int = if (str == null) 0 else str.length

fun checkLengthC(str : String?): Int = str?.length ?: 0

fun checkLengthA(str : String): Int = if (str.isNullOrBlank()) 0 else str.length

infix fun xor(other: Boolean): Boolean
fun getTypes(@size(250) data: ByteArray): Types {

}

data
@RunWith(AndroidJUnit4::class)
class TradersActivityTest {

    private lateinit var mockServer: MockWebServer
    private const val ONE_TR = "no_wallets.json" // error here

Const 'val' are only allowed on top level or in objects

package foo

class Person() {
var name: String = "defaultValue"
   private set

}

fun countClicks(window: JComponent) {
   var clickCount = 0
   var enterCount = 0
   window.addMouseListener(object : MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) {
        clickCount++
    }

    override fun mouseEntered(e: MouseEvent) {
        enterCount++
    }
   })
}

enterCount
clickCount
Thread.sleep
class MatrixActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContentView(R.layout.loading_activity_matrix)

        Thread.sleep(3000)

        setContentView(R.layout.activity_matrix)

        A00.setOnClickListener { sendCommand("00000")}
        B00.setOnClickListener { sendCommand("00100")}
        C00.setOnClickListener { sendCommand("00200")}
        D00.setOnClickListener { sendCommand("00300")}
        E00.setOnClickListener { sendCommand("00400")}
        F00.setOnClickListener { sendCommand("00500")}
        G00.setOnClickListener { sendCommand("00600")}
        H00.setOnClickListener { sendCommand("00700")}

Integer
for (i in 15 downTo 10){
  print(i + " "); //error: None of the following function can be called with the argument supplied:
  print(i); //It's Working but I need some space after the integer value.
}

open class A {}
open class B : A() {}
open class C : B() {}

fun main(args: Array&lt;String&gt;) {
    var currentClass = C::class
    while(currentClass != Any::class) {
        println(currentClass)
        currentClass = currentClass.superclass
    }
}

KClass
superclass
superclass
 currentClass = currentClass.java.superclass.kotlin

Error:(9, 52) Type inference failed: 'T' cannot capture 'in ('C'..'C?')'. 
Type parameter has an upper bound 'kotlin.Any' that cannot be satisfied 
capturing 'in' projection

// testNullCheck.kt
fun isNullOrEmpty(list: List&lt;Int&gt;?): Boolean {
  if (list.isEmpty() || list == null ) {
    return true
  }else {
    return false
  } 
}

fun main(args: Array&lt;String&gt;) {
  val test: Boolean = isNullOrEmpty(
    listOf&lt;Int&gt;()
  )
  println(test)
}

leetcode/kotlin [master●] » kotlinr testNullCheck.kt
Compiling, please wait...
testNullCheck.kt:2:11: error: only safe (?.) or non-null asserted (fg.) calls are allowed on a nullable receiver of type List&lt;Int&gt;?
  if (list.isEmpty() || list == null ) {
          ^
1
2

MyEvent
data class MyEvent(val name: String, val version: Int, val content: Map&lt;String, String&gt;)

val OrderCreated = MyEvent("OrderCreated", 1, mapOf("orderId" to "UUID", "nameOfProduct" to "String(1, 256)", "quantity" to "Integer"))
val OrderCancelled = MyEvent("OrderCancelled", 2, mapOf("orderId" to "UUID", "reason" to "String(100, 1000)"))
val OrderQuestioned = MyEvent("OrderQuestioned", 3, mapOf("orderId" to "UUID", "question" to "String(10, 1000)"))

String
fun scanForAllMyEventsInstances(): Set&lt;MyEvent&gt; {
    return hashSetOf(OrderCreated, OrderCancelled, OrderQuestioned)
}

scanForAllMyEventsInstances
MyEvent
SpringBoot
game
Game
this
var game: Game

init {
    game = Game(this)
}

var game: Game = Game(this)

NullPointer
org.bukkit.plugin.InvalidPluginException: java.lang.NullPointerException
at org.bukkit.plugin.java.JavaPluginLoader.loadPlugin(JavaPluginLoader.java:135) ~[server.jar:git-Spigot-21fe707-e1ebe52]
at org.bukkit.plugin.SimplePluginManager.loadPlugin(SimplePluginManager.java:329) ~[server.jar:git-Spigot-21fe707-e1ebe52]
at org.bukkit.plugin.SimplePluginManager.loadPlugins(SimplePluginManager.java:251) [server.jar:git-Spigot-21fe707-e1ebe52]
at org.bukkit.craftbukkit.v1_8_R3.CraftServer.loadPlugins(CraftServer.java:292) [server.jar:git-Spigot-21fe707-e1ebe52]
at net.minecraft.server.v1_8_R3.DedicatedServer.init(DedicatedServer.java:198) [server.jar:git-Spigot-21fe707-e1ebe52]
at net.minecraft.server.v1_8_R3.MinecraftServer.run(MinecraftServer.java:525) [server.jar:git-Spigot-21fe707-e1ebe52]
at java.lang.Thread.run(Thread.java:745) [?:1.8.0_121]
Caused by: java.lang.NullPointerException
at org.bukkit.plugin.SimplePluginManager.registerEvents(SimplePluginManager.java:523) ~[server.jar:git-Spigot-21fe707-e1ebe52]
at me.darkpaladin.uhc.game.gameSettings.GameSettingsManager.addGameSettings(GameSettingsManager.kt:43) ~[?:?]
at me.darkpaladin.uhc.game.gameSettings.GameSettingsManager.&lt;init&gt;(GameSettingsManager.kt:20) ~[?:?]
at me.darkpaladin.uhc.game.Game.&lt;init&gt;(Game.kt:49) ~[?:?]
at me.darkpaladin.uhc.UHC.&lt;init&gt;(UHC.kt:20) ~[?:?]
at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[?:1.8.0_121]
at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) ~[?:1.8.0_121]
at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[?:1.8.0_121]
at java.lang.reflect.Constructor.newInstance(Constructor.java:423) ~[?:1.8.0_121]
at java.lang.Class.newInstance(Class.java:442) ~[?:1.8.0_121]
at org.bukkit.plugin.java.PluginClassLoader.&lt;init&gt;(PluginClassLoader.java:76) ~[server.jar:git-Spigot-21fe707-e1ebe52]
at org.bukkit.plugin.java.JavaPluginLoader.loadPlugin(JavaPluginLoader.java:131) ~[server.jar:git-Spigot-21fe707-e1ebe52]
... 6 more

var game: Game

init {
    game = Game(this)
}

override fun onReady() {
    //        new Lobby(Bukkit.getWorld("world"), this, false);
    TeamManager()
    registerCommands()
}

fun registerCommands() {
    val c = commandHandler
    c.addCommand(
            TeamCommand(),
            SetGameTypeCommand(game),
            ClaimHostCommand(game),
            StartGameCommand(game),
            ScenarioManagerCommand(game),
            KillTopCommand(game),
            ConfigCommand(game),
            ScatterCommand(game)
    )
}

fun registerListeners() {
    val p = Bukkit.getPluginManager()
    p.registerEvents(GamePlayerListener(game), this)
}

package me.darkpaladin.uhc.game

import me.darkpaladin.core.Core
import me.darkpaladin.core.utils.CoreUtils
import me.darkpaladin.core.utils.PacketUtils
import me.darkpaladin.uhc.UHC
import me.darkpaladin.uhc.events.GameStartEvent
import me.darkpaladin.uhc.events.GameStopEvent
import me.darkpaladin.uhc.game.gameEvents.GameEvent
import me.darkpaladin.uhc.game.gameEvents.GameEventRunnable
import me.darkpaladin.uhc.game.gamePlayers.GamePlayer
import me.darkpaladin.uhc.game.gamePlayers.GamePlayerManager
import me.darkpaladin.uhc.game.gameSettings.GameSettingsManager
import me.darkpaladin.uhc.scenarios.ScenarioManager
import org.apache.commons.lang.WordUtils
import org.bukkit.*
import org.bukkit.entity.Item
import org.bukkit.entity.Monster
import org.bukkit.entity.Player
import org.bukkit.scheduler.BukkitRunnable

import java.util.*

/**
 * Created by Caleb on 4/28/2017.
 */
class Game(private val plugin: UHC) {

    var gameType = GameType.NORMAL
    var gameState = GameState.SETTING_UP
    var gameStartTicks = (CoreUtils.ticksPerSecond * 10).toLong()
    var finalHealTime = (CoreUtils.ticksPerSecond * 15).toLong()
    var pvpTicks = (CoreUtils.ticksPerSecond * 20).toLong()
    var meetupTicks = (CoreUtils.ticksPerSecond * 25).toLong()
    var isBorderShrink = true
    var episodeLength = (CoreUtils.ticksPerMinute * 20).toLong()
    private var episode = 1

    private val worlds = ArrayList&lt;World&gt;()

    private val gameEvents = ArrayList&lt;GameEvent&gt;()

    var gameTicks: Long = 0L

    var hostUuid: UUID? = null

    val scenarioManager: ScenarioManager = ScenarioManager(this)
    val gamePlayerManager: GamePlayerManager = GamePlayerManager()
    val gameSettingsManager: GameSettingsManager = GameSettingsManager(this)

    private val instance: Game

    init {
        worlds.add(Bukkit.getWorld("world")) //TODO: remove
        instance = this
    }

    val overworld: World?
        get() = getWorldWithEnvironment(World.Environment.NORMAL)

    val nether: World?
        get() = getWorldWithEnvironment(World.Environment.NETHER)

    val end: World?
        get() = getWorldWithEnvironment(World.Environment.THE_END)

    fun getWorldWithEnvironment(environment: World.Environment): World? {
        return worlds.firstOrNull { it.environment == environment }
    }

    fun addGameEvent(vararg events: GameEvent) {
        gameEvents.addAll(Arrays.asList(*events))
    }

    val host: Player
        get() = Bukkit.getPlayer(hostUuid)

    fun start() {
        gameState = GameState.STARTING

        val finalHeal = GameEvent("Final Heal", finalHealTime, object : GameEventRunnable(this) {
            override fun run() {
                Bukkit.getOnlinePlayers().forEach { player -&gt; player.health = player.maxHealth }
                CoreUtils.broadcast(Core.PREFIX + "Final Heal has been given. This is the FINAL heal. Do not ask for more.")
            }
        })

        val pvp = GameEvent("PvP", pvpTicks, object : GameEventRunnable(this) {
            override fun run() {
                for (world in worlds) {
                    world.pvp = true
                    world.setGameRuleValue("doMobSpawning", "true")
                }
            }
        })

        val starting = GameEvent("Starting in", gameStartTicks, object : GameEventRunnable(this) {
            override fun run() {
                gameTicks = 0L
                addGameEvent(finalHeal, pvp)
                if (isBorderShrink)
                    addGameEvent(BorderShrinkGameEvent(meetupTicks, instance))

                for (player in Bukkit.getOnlinePlayers()) {
                    player.health = player.maxHealth
                    player.foodLevel = 20
                    player.saturation = 20f
                    player.level = 0
                    player.exp = 0f
                    player.totalExperience = 0
                    player.closeInventory()
                    player.inventory.clear()
                    player.inventory.armorContents = null
                    player.gameMode = GameMode.SURVIVAL
                    player.activePotionEffects.forEach { potionEffect -&gt; player.removePotionEffect(potionEffect.type) }
                }

                for (world in worlds) {
                    for (entity in world.entities) {
                        if (entity is Item || entity is Monster) {
                            entity.remove()
                        }
                    }
                    world.pvp = false
                    world.difficulty = Difficulty.HARD
                    world.time = 20
                    world.setSpawnFlags(false, false)
                }

                Bukkit.getOnlinePlayers().forEach { player -&gt; gamePlayerManager.addGamePlayers(GamePlayer(player.uniqueId)) }

                val players = ArrayList&lt;Player&gt;()
                gamePlayerManager.aliveGamePlayers
                        .filter { gamePlayer -&gt; gamePlayer.player != null }
                        .forEach { gamePlayer -&gt; players.add(gamePlayer.player) }

                scenarioManager.giveStartingItems(players)

                gameState = GameState.RUNNING
                Bukkit.getPluginManager().callEvent(GameStartEvent(instance))

            }
        })

        addGameEvent(starting)

        GameTimer().runTaskTimer(plugin, 0, 1)
        if (gameType === GameType.RECORDED)
            EpisodeTimerTask()
    }

    val nextEvent: GameEvent?
        get() {
            val events = gameEvents

            val times = HashMap&lt;GameEvent, Long&gt;()

            events.forEach { gameEvent -&gt; times.put(gameEvent, gameEvent.time) }

            var nextEvent: GameEvent? = null
            var nextEventTime: Long = 999999999999999999L
            for (event in times.keys) {
                if (event.time &lt; nextEventTime) {
                    nextEvent = event
                    nextEventTime = event.time
                }
            }
            return nextEvent
        }

    fun getNextBorderRadius(world: World): Int {
        return Math.round(world.worldBorder.size / 2 * .75).toInt()
    }

    private inner class GameTimer : BukkitRunnable() {
        override fun run() {

            val nextEvent = nextEvent

            if (nextEvent != null) {
                if (gameTicks!! % 20 == 0L) {
                    PacketUtils.sendAction(Core.HIGHLIGHTED_COLOR.toString() + ChatColor.BOLD.toString() + WordUtils.capitalizeFully(nextEvent.name) + Core.EXTRA_COLOR + " » " + Core.HIGHLIGHTED_COLOR + CoreUtils.formatTicks(nextEvent.time - gameTicks!!))
                }

                if (gameTicks &gt;= nextEvent.time) {
                    nextEvent.runnable!!.run()
                    gameEvents.remove(nextEvent)
                }
            }

            gameTicks++

        }
    }

    private inner class BorderShrinkGameEvent(time: Long, game: Game) : GameEvent("Border Shrink", time, object : GameEventRunnable(game) {
        override fun run() {
            for (world in worlds) {
                val wb = world.worldBorder

                val radius = Math.round(wb.size / 2).toInt()
                val newRadius = Math.round(wb.size / 2 * .75).toInt()

                if (newRadius &lt; 50)
                    wb.size = 100.0
                else
                    wb.size = (newRadius * 2).toDouble()

                CoreUtils.broadcast(Core.PREFIX + "The border has shrunk from " + radius + " to " + Math.round(wb.size / 2).toInt() + "!")

                if (wb.size &gt; 100) {
                    game.addGameEvent(BorderShrinkGameEvent(CoreUtils.ticksPerSecond * 5 + game.gameTicks!!, game))
                }

            }
        }
    })

    private inner class EpisodeTimerTask : BukkitRunnable() {

        private var ticks: Long = 0

        init {
            ticks = episodeLength
        }

        override fun run() {

            if (ticks &lt;= 0) {
                cancel()

                CoreUtils.broadcast(Core.PREFIX + "End of episode " + episode + ". Start episode " + episode + 1)
                episode++
                return
            }

            ticks--
        }
    }

    fun stop() {
        scenarioManager.disableAll()
        Bukkit.getPluginManager().callEvent(GameStopEvent(this))

        plugin.game = Game(plugin)
    }

}

package me.darkpaladin.uhc.game.gameSettings

import me.darkpaladin.core.Core
import me.darkpaladin.uhc.game.Game
import org.bukkit.Bukkit
import org.bukkit.event.Listener

import java.util.ArrayList
import java.util.Arrays
import java.util.stream.Collectors

/**
 * Created by caleb on 5/6/17.
 */
class GameSettingsManager(game: Game) {

    private val gameSettings = ArrayList&lt;GameSetting&gt;()

    init {
        addGameSettings(
                FriendlyFireGameSetting(game),
                NotchApplesGameSetting(),
                DoubleArrowsGameSetting()
        )
    }

    fun getGameSettings(): List&lt;GameSetting&gt; {
        return gameSettings
    }

    val toggleableGameSettings: List&lt;ToggleableGameSetting&gt;
        get() {
            val settings = ArrayList&lt;ToggleableGameSetting&gt;()
            for (setting in getGameSettings())
                if (setting is ToggleableGameSetting)
                    settings.add(setting)
            return settings
        }

    fun addGameSettings(vararg gameSettings: GameSetting) {
        this.gameSettings.addAll(Arrays.asList(*gameSettings))
        for(setting in gameSettings)
            Bukkit.getPluginManager().registerEvents(setting as Listener, Core.instance)
    }

    fun getGameSetting(name: String): GameSetting {
        return gameSettings.stream()
                .filter { gameSetting -&gt; gameSetting.name.equals(name, ignoreCase = true) }
                .collect(Collectors.toList&lt;GameSetting&gt;())[0]
    }

}

data class Test(var attribute: String) {

    // attribute can be mutated inside this class

    // but outside only readable ?
}

val a = File("/myfile.txt")
val b = File("/myfile.txt")
val sameRef = a === b

  val a = File("/myfile.txt")
    val b = File("/myfile.txt")
    val both= a == b

string.forEach(writer::append);
@Entity
@Table(name = "t_payment")
data class PaymentEntity(
        @ManyToOne(cascade = CascadeType.DETACH)
        @JoinColumn(name = "user_id", nullable = false)
        var user: User? = null) : Serializable {
}

"Type mismatch"
class A
equals()
javaClass
override fun equals(other: Any?): Boolean {
   if (this === other) return true
   if (javaClass != other?.javaClass) return false
   other as A
   ...
}

javaClass
if (other !is A) ...

open class Parent {
    fun some():Parent {
        return this;
    }
}

class A : Parent(){
    val name:String? = null;
}

val a = A().some().some()
a.name // ERROR

a.name
@JvmName
class Test() {
    fun &lt;T&gt; apply(calc: (String, List&lt;Double&gt;, Double, Double) -&gt; T): T {
        return calc("a", listOf(), 1.2, 3.4)
    }

    fun &lt;T&gt; apply(calc: (String, Double, Double, Double) -&gt; T): T {
        return calc("a", 1.2, 3.4, 5.6)
    }
}

Error:(375, 9) Kotlin: Platform declaration clash: The following declarations have the same JVM signature (apply(Lkotlin/jvm/functions/Function4;)Ljava/lang/Object;):
fun &lt;T&gt; apply(calc: (String, Double, Double, Double) -&gt; T): T defined in Sample.Test
fun &lt;T&gt; apply(calc: (String, List&lt;Double&gt;, Double, Double) -&gt; T): T defined in Sample.Test

try { 

} catch (ex: MyException1, MyException2 ) {
    logger.warn("", ex)
}

try { 

} catch (ex: MyException1 | MyException2 ) {
    logger.warn("", ex)
}

Unresolved reference: MyException2
kotlin.UninitializedPropertyAccessException: lateinit property textInput has not been initialized
        at org.ligi.survivalmanual.ui.MainActivity.access$getTextInput$p(MainActivity.kt:50)


class MainActivity : BaseActivity() {


    private val drawerToggle by lazy { ActionBarDrawerToggle(this, drawer_layout, drawer_open, drawer_close) }

    private val survivalContent by lazy { SurvivalContent(assets) }

    private lateinit var currentUrl: String
    private lateinit var currentTopicName: String


    private var lastFontSize = State.getFontSize()
    private var lastNightMode = State.nightModeString()
    private var lastAllowSelect = State.allowSelect()
    private lateinit var textInput: MutableList&lt;String&gt;

    private val linearLayoutManager by lazy { LinearLayoutManager(this) }

class Sokoban(Playground: Array&lt;CharArray&gt;)  
{    
    private var playground = Playground    
    private val _Playground = Playground    
    fun move(d: String) {    
        ...//"playground" got modified.         
    }    
    fun restart() {
        playground = _Playground
    }
}

fun main(args: Array&lt;String&gt;) {    
    val Playground: Array&lt;CharArray&gt; = arrayOf(    
            "###########".toCharArray(),    
            "#$...*....#".toCharArray(),    
            "#..@......#".toCharArray(),    
            "###########".toCharArray()    
    )    
    val sokoban = Sokoban(Playground.clone()) 
    sokoban.move("Left")
    sokoban.restart()   
    }

public Retention(RetentionPolicy.RUNTIME) annotation class foo(val text : String)

if (javaClass&lt;Bar&gt;().isAnnotationPresent(javaClass&lt;foo&gt;())) {
    // do something here.
}

foo
infix fun Int.isGreater(value: Int): Boolean = this &gt; value

when (value) {
    isGreater 2 -&gt; doSomething()
    isGreater 1 -&gt; doSomethingElse()
    else -&gt; doNothing()
}

val
var
import java.util.Scanner

fun main(args: Array&lt; String&gt;){
  println("Enter the no")
  val scanner = Scanner(System.`in`)
  var nos = Array&lt;Int&gt;(5){0}

  var i : Int = 1
  for (i in 1..3){
    nos[i] = scanner.nextInt()
     i = i+1
  }

  println("Given values $nos")
}

Map&lt;String, Any&gt;
a = rawData["A"] as? String ?: ""

b = rawData["B"] as? Array&lt;String&gt; ?: arrayOf&lt;String&gt;()

data class Person(val name: String, val age: Int)

fun task6(): List&lt;Person&gt; {
    return listOf(Person("Alice", 29), Person("Bob", 31))
}

[Person(name=Alice, age=29), Person(name=Bob, age=31)]

class Person(val name: String, val age: Int)

fun task6(): List&lt;Person&gt; {
    return listOf(Person("Alice", 29), Person("Bob", 31))
}

[i_introduction._6_Data_Classes.Person@4f47d241, i_introduction._6_Data_Classes.Person@4c3e4790]

class Person(val name: String, val age: Int) {
    override fun toString(): String {
        return "Person(name=$name, age=$age)"
    }
}

fun task6(): List&lt;Person&gt; {
    return listOf(Person("Alice", 29), Person("Bob", 31))
}

Stream.of("1", "2", "3").map(x -&gt; new AbstractMap.SimpleEntry&lt;&gt;(x, x)).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))

Stream.of("1", "2", "3").map{ x -&gt; x to x } 

  object Helper{
    fun getValuesForBlah1(constParam1 : Boolean, constParam2 : String, constParam3 : Float, varParam : Int)

    fun getValuesForBlah2(constParam1 : Boolean, constParam2 : String, constParam3 : Float, varParam : SomeClass)

    fun getValuesForBlah3(constParam1 : Boolean, constParam2 : String, constParam3 : Float, varParam : SomeOtherClass)
...
....
    }

!!
?
!!
mCurrentDataset
?
if(!mCurrentDataset!!.load(mDataSetString.get(mCurrentDataSelectionIndex), STORAGE_TYPE.STORAGE_APPRESOURCE))
{
    Log.d("MyActivity","Failed to load data.")
    return false
}

if(!mCurrentDataset?.load(mDataSetString.get(mCurrentDataSelectionIndex), STORAGE_TYPE.STORAGE_APPRESOURCE)!!)
{
    Log.d("MyActivity","Failed to load data.")
    return false
}

var filters: MutableMap&lt;String, Any?&gt;

var b = Bundle()
b.putSerializable("myFilter",filters) //- this gives a compile error that filters is not serializable. 

fun main(args: Array&lt;String&gt;) {
  /* Enter your code here. Read input from STDIN. Print output to STDOUT */
  val myarr=intArrayOf(1,2,3,4)

  for(element in myarr){
      println(element)
  }

fun main(args: Array&lt;String&gt;) {
  /* Enter your code here. Read input from STDIN. Print output to STDOUT */
  val myarr=intArrayOf(1,2,3,4)

  while(element in myarr){
      println(element)
  }

object Foo {
  object Moo {
    fun boo = 4
  }
}

import Foo._
moo.boo

fun foo(a: () -&gt; A) { }
fun foo(b: () -&gt; B) { }

Function0
Unit
sealed class User {

}

data class ActiveUser(val name: String, val lastName: String, val email: String) : User () {

fun &lt;T&gt; doSomething(name: String.() -&gt; T?) =
        name(this.email) ?:  throw RuntimeException("Error")

}

String.() -&gt; T?

fun main() {
    val activeUser: ActiveUser
    activeUser= ActiveUser("John", "Doe", "john@doe.com")
    activeUser.doSomething {"some name" }
}

The month of &lt;month&gt; has &lt;number&gt; of days
fun getDate(month:String, number:Int){
    
    var January =  31
    var February = 28  
    var March =  31
    var April =  30
    var May = 31
    var June = 30
    var July = 31
    var August = 31
    var September = 30
    var October = 31
    var November = 30
    var December = 31

    println(&quot;The month of $month has $number of days&quot;)
}

fun main(args: Array&lt;String&gt;) {
    getDate(&quot;January&quot;)
}

Int
Long
Int.MIN_VALUE       // -2147483648
Int.MAX_VALUE       //  2147483647

Long.MIN_VALUE      // -9223372036854775808
Long.MAX_VALUE      //  9223372036854775807

Float
Double
min
max
Float.MIN_VALUE     //  1.4E-45
Float.MAX_VALUE     //  3.4028235E38

Double.MIN_VALUE    //  4.9E-324
Double.MAX_VALUE    //  1.7976931348623157E308

Float
Double
with
apply
Person
val andre = Person().apply {
    name = "Andre"
    company = "Viacom"
    hobby = "losing in ping pong"
}

with
val andre = Person()
with(andre){
    name = "Andre"
    company = "Viacom"
    hobby = "losing in ping pong"
}

with
apply
enum
enum class
sealed class
sealed class
enum class
data class DisjointSetNode&lt;T&gt;(var parent: DisjointSetNode&lt;T&gt;, var data: T, var rank: Int) {
constructor(data: T): this(parent = this, data = data, rank = 0)

str.split(' ').maxBy{ it.sumBy{ it - 'a' + 1 } }!!

sumBy
trim()
IntArray
Array&lt;Int&gt;
IntArray
int[]
JVM
Array&lt;Int&gt;
String[]
YourObject[]
{primitive}Array
4 3
3 2 3

fun main(args: Array&lt;String&gt;)
{
    val n = readLine()!!.toInt()
    val m = readLine()!!.toInt()
    var a:Int
    for(i in 1..m) {
         a= readLine()!!.toInt()
        //Some additional manipulation involving all three variables
     }
}

java.lang.NumberFormatException: For input string: "4 3"
    at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
    at java.lang.Integer.parseInt(Integer.java:580)
    at java.lang.Integer.parseInt(Integer.java:615)
    at ProgramKt.main(program.kt:2)

fun addition(n:Int?,n1:Int?):Int{
        return (n?: 0)+ n1!!
    }

LinkedHashSet
fun process(minutes: Int) = 0

fun test() {
    process(System.currentTimeMillis() / 1000 / 60) // error: Int expected
}

process((System.currentTimeMillis() / 1000 / 60) as Int)
ClassCastException
fun fetchToDosFromServer(fullQueryString: String?)
        : Flowable&lt;GitResult&gt;? 
{
    if(fullQueryString.length&gt;0)
    { //call webservice- which return observable&lt;GitResult&gt;
       var returnedResult = myWebServiceCall()
        return returnedData.toFlowable(BackpressureStrategy.BUFFER)
       }

    else 
        return null

}

 fun getReposFromServer()
 {
    val resultFromApiCall_flowable : Flowable&lt;GitResult&gt;? =  mainRepository.fetchToDosFromServer("q=2")

    val source: LiveData&lt;GitResult&gt; = LiveDataReactiveStreams.fromPublisher(resultFromApiCall_flowable)
 }

apply()
main
apply
apply
apply(Event)
apply(EventOne)
apply(EventTwo)
apply
applyFromHistory
fold
fun main(args: Array&lt;String&gt;) {
    val subject = SomeAggregate()

    subject.applyFromHistory(listOf(
        EventOne(123),
        EventTwo("foobar")
    ))
}

sealed class Event
data class EventOne(val id: Int) : Event()
data class EventTwo(val content: String) : Event()

abstract class AggregateRoot(
    private val events : MutableList&lt;Event&gt; = mutableListOf()
) {

    fun applyFromHistory(history: List&lt;Event&gt;) {
        history.forEach { apply(it) }
    }

    fun apply(event: Event) { /* does nothing */ }
}

class SomeAggregate(var id: Int = 0, var content: String = "") : AggregateRoot() {
    fun apply(event: EventOne) {
        id = event.id
    }

    fun apply(event: EventTwo) {
        content = event.content
    }
}

abstract class AggregateRoot(... {

   ...

   abstract fun apply(event: Event)
}

class SomeAggregate(... : AggregateRoot() {

   ...

   override fun apply(event: Event) {
       when(event) {
           is EventOne -&gt; apply(event)
           is EventTwo -&gt; apply(event)
       }
   }

   ...
}

ArrayList
ArrayList
ArrayList
&lt;string-array name="object_types"&gt;

private var issues: ArrayList&lt;Issue&gt; = ArrayList()

  private fun getIssues() {
       val stream = resources.openRawResource(R.raw.markers)
        val inputString = stream.bufferedReader().use {
            it.readText()
        }
        val klaxon = Klaxon()
        JsonReader(StringReader(inputString)).use { reader -&gt; // requires kotlin &gt; 1.2 !!
         reader.beginArray {
              while (reader.hasNext()) { // requires "[]" array and not {"something": []}
                    val issue = klaxon.parse&lt;Issue&gt;(reader)
                   this.issues!!.add(issue!!)
               }          }
        }
        this.issues = Utils.markers
    }

class GalleryFragment : Fragment(), IssueItemOnClickListener {

    private var productsRecyclerView: RecyclerView? = null
    private var recyclerAdapter: IssueRecyclerViewAdapter? = null
    private var recyclerLayoutManager: RecyclerView.LayoutManager? = null
    private var issues: ArrayList&lt;Issue&gt; = ArrayList()

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.fragment_gallery, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        getIssues()

        this.productsRecyclerView = view.findViewById(R.id.issue_list_recycler_view) as RecyclerView
        this.productsRecyclerView!!.setHasFixedSize(true)

        // use a grid layout manager -&gt; 2 columns
        this.recyclerLayoutManager = GridLayoutManager(context, 2) as RecyclerView.LayoutManager?
        this.productsRecyclerView!!.layoutManager = this.recyclerLayoutManager

        this.recyclerAdapter = IssueRecyclerViewAdapter(this.issues, this)
        this.productsRecyclerView!!.adapter = recyclerAdapter
    }
    override fun onIssueItemClick(pos: Int, issue: Issue) {
        val args = Bundle()
        val detailsFragment = IssueDetailsFragment()
        args.putDouble("lat", issue.lat)
        args.putDouble("lng", issue.lng)
        args.putString("description", issue.description)
        args.putString("name", issue.name)
        args.putString("type", issue.type)
        args.putString("imgUrl", issue.imgUrl)
        detailsFragment.arguments = args

        val ft = activity!!.supportFragmentManager.beginTransaction()
        ft.replace(R.id.main_fragment_content, detailsFragment)
                .setTransition(android.app.FragmentTransaction.TRANSIT_FRAGMENT_FADE)
                .addToBackStack(null).commit()
    }
    private fun getIssues() {
        val stream = resources.openRawResource(R.raw.markers)
        val inputString = stream.bufferedReader().use {
            it.readText()
       }
       val klaxon = Klaxon()
       JsonReader(StringReader(inputString)).use { reader -&gt; // requires kotlin &gt; 1.2 !!
            reader.beginArray {
                while (reader.hasNext()) { // requires "[]" array and not {"something": []}
                   val issue = klaxon.parse&lt;Issue&gt;(reader)
                    this.issues!!.add(issue!!)
                }
            }
        }
        this.issues = Utils.markers
    }
}

var a : Int = 1
var c : Int? = 3

a + if (c != null) {c} else {0}
ERROR: None of the following functions can be called with supplied argument (followed by the various implementations of kotlin.int.plus())

!!
a + if (c != null) {c!!} else {0}
4  

!!
a + (c ?: 0)
4

!!
a + if (c != null) {c} else {0}
fun androidPermissionsByCategory(): Map&lt;String, List&lt;String&gt;&gt; {
    val result = hashMapOf&lt;String, MutableList&lt;String&gt;&gt;()
    enumValues&lt;AndroidPermission&gt;().onEach {
        result.getOrPut(it.permissionGroup, { mutableListOf() }).add(it.value())
    }
    return result
}

Allocator
public void setAllocMethod(@NotNull AllocMethod allocMethod) {
    this.allocMethod = allocMethod;
}

public void setAllocMethod(@Nullable AllocMethod allocMethod) {
    this.allocMethod= allocMethod;
}

allocator.allocMethod = DefaultAllocMethod() // kotlin code
public @NotNull AllocMethod getAllocMethod() {
        if (allocMethod == null) allocMethod = DefaultAllocMethod.newDefault();
        return allocMethod;
}

DefaultAllocMethod
AllocMethod
allocator
Allocator
val cls = javaClass&lt;T&gt;().kotlin

for(property in cls.properties) {
    if(property.accessible) {
        //Is it nullable?

    }
}

val sets = listOf(setOf(1, 2, 3), setOf(2, 3, 4), setOf(3, 4, 5))

val unionOfSets = sets.reduce(Set&lt;Int&gt;::union)  // == setOf(1, 2, 3, 4, 5)

val unionOfSets = sets.reduce { acc, set -&gt; acc.union(set) }

fun &lt;T: Any&gt; foo(o: T) {
    o::class
}

o::class
KClass&lt;out T&gt;
KClass&lt;out Any&gt;
T
Any
Object::getClass
Class
KClass
fun &lt;T: Any&gt; create(jClass: Class&lt;T&gt;): KClass&lt;T&gt;
o::class
KClass&lt;Any&gt;
jClass
Class&lt;Object&gt;
T
Any
Object
@Deprecated(
    message = "moved to def()",
    replaceWith = ReplaceWith(expression = "def()"),
    level = DeprecationLevel.ERROR)
fun abc() = def()

abc()
@Test
@Suppress("something")
fun deprecatedAbc() {
  abc()
}

@Suppress("DEPRECATION")
private val TAG = "Configuration Activity"

internal val COMPLICATION_CONFIG_REQUEST_CODE = 1001 // internal val COMPLICATION_CONFIG_REQUEST_CODE = 1001


enum class ComplicationLocation {
    LEFT,
    RIGHT,
    TOP,
    BOTTOM
}//---

private var mLeftComplicationId: Int = 0
private var mRightComplicationId: Int = 0
//---
private var mTopComplicationId: Int = 0
private var mBottomComplicationId: Int = 0
//---



override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_complication_config)

    setContentView(R.layout.activity_complication_config)
    mDefaultAddComplicationDrawable = getDrawable(R.drawable.add_complication)

    mSelectedComplicationId = -1

    mLeftComplicationId = MyWatchFace.getComplicationId(ComplicationLocation.LEFT) // unresolved reference
    mRightComplicationId = MyWatchFace.getComplicationId(ComplicationLocation.RIGHT) // getComplicationId
    mTopComplicationId = MyWatchFace.getComplicationId(ComplicationLocation.TOP)
    mBottomComplicationId = MyWatchFace.getComplicationId(ComplicationLocation.BOTTOM)

private val TAG = "ComplicationConfigActivity"
// TODO: Step 2, intro 1
private val LEFT_COMPLICATION_ID = 0
private val RIGHT_COMPLICATION_ID = 1
private val TOP_COMPLICATION_ID = 2
private val BOTTOM_COMPLICATION_ID = 3

private val COMPLICATION_IDS =
    intArrayOf(LEFT_COMPLICATION_ID, RIGHT_COMPLICATION_ID, TOP_COMPLICATION_ID, BOTTOM_COMPLICATION_ID)

// Left and right dial supported types.
private val COMPLICATION_SUPPORTED_TYPES = arrayOf(
    intArrayOf(
        ComplicationData.TYPE_RANGED_VALUE, ComplicationData.TYPE_ICON, ComplicationData.TYPE_SHORT_TEXT,
        //ComplicationData.IMAGE_STYLE_PHOTO,//
        ComplicationData.TYPE_SMALL_IMAGE
    ), intArrayOf(
        ComplicationData.TYPE_RANGED_VALUE, ComplicationData.TYPE_ICON, ComplicationData.TYPE_SHORT_TEXT,
        //ComplicationData.IMAGE_STYLE_PHOTO,//
        ComplicationData.TYPE_SMALL_IMAGE
    ), intArrayOf(
        ComplicationData.TYPE_RANGED_VALUE, ComplicationData.TYPE_ICON, ComplicationData.TYPE_SHORT_TEXT,
        //ComplicationData.IMAGE_STYLE_PHOTO,//
        ComplicationData.TYPE_SMALL_IMAGE
    ), intArrayOf(
        ComplicationData.TYPE_RANGED_VALUE, ComplicationData.TYPE_ICON, ComplicationData.TYPE_SHORT_TEXT,
        //ComplicationData.IMAGE_STYLE_PHOTO, //
        ComplicationData.TYPE_SMALL_IMAGE
    )
)

// Used by {@link ComplicationConfigActivity} to retrieve id for complication locations and
// to check if complication location is supported.
// TODO: Step 3, expose complication information, part 1
//---
internal fun getComplicationId( // CAN´T ACCESS THIS FUNCTION
    complicationLocation: ComplicationLocation
): Int {
    when (complicationLocation) {
        LEFT -&gt; return LEFT_COMPLICATION_ID
        RIGHT -&gt; return RIGHT_COMPLICATION_ID
        TOP -&gt; return TOP_COMPLICATION_ID
        BOTTOM -&gt; return BOTTOM_COMPLICATION_ID
        else -&gt; return -1
    }
}
//----
// Used by {@link ComplicationConfigActivity} to retrieve all complication ids.
// TODO: Step 3, expose complication information, part 2
//---
internal fun getComplicationIds(): IntArray { // CAN´T ACCESS THIS FUNCTION

    return COMPLICATION_IDS
}
//---

// Used by {@link ComplicationConfigActivity} to retrieve complication types supported by
// location.
// TODO: Step 3, expose complication information, part 3
//---
internal fun getSupportedComplicationTypes( // CAN´T ACCESS THIS FUNCTION
    complicationLocation: ComplicationLocation
): IntArray {
    when (complicationLocation) {
        LEFT -&gt; return COMPLICATION_SUPPORTED_TYPES[0]
        RIGHT -&gt; return COMPLICATION_SUPPORTED_TYPES[1]
        TOP -&gt; return COMPLICATION_SUPPORTED_TYPES[2]
        BOTTOM -&gt; return COMPLICATION_SUPPORTED_TYPES[3]
        else -&gt; return intArrayOf()
    }
}
//---

/*
 * Update rate in milliseconds for interactive mode. We update once a second to advance the
 * second hand.
 */
private val INTERACTIVE_UPDATE_RATE_MS = TimeUnit.SECONDS.toMillis(1)


override fun onCreateEngine(): Engine {
    return Engine()
}

private class EngineHandler(reference: Engine) : Handler() { // 
    private val mWeakReference: WeakReference&lt;Engine&gt; = WeakReference(reference)

    override fun handleMessage(msg: Message) {
        val engine = mWeakReference.get()
        if (engine != null) {
            when (msg.what) {
                MSG_UPDATE_TIME -&gt; engine.handleUpdateTimeMessage()
            }
        }
    }
}

inner class Engine : CanvasWatchFaceService.Engine() {}

when(subject) { ... }
val num: Any = 2
when(num) {
    // uses implicit subject in addition to an unrelated condition
    is Number &amp;&amp; true -&gt; println("TRUE")
    else -&gt; println("FALSE")
}

FALSE
val num: Any = 2
when(num) {
    num is Number &amp;&amp; true -&gt; println("TRUE")
    else -&gt; println("FALSE")
}

if-else
when
1
2
1
val x = if (1 &lt; 2) {println("something"); 1} else {println("something else"); 2}

y
1
val y = {println("something"); 1}

fun z() : Int {
    println("something")
    1
}

if-else
when
{.0, .1, .. .9, 1.0}
setOf(.0, .1, .2, .3, .4, .5, .6, .7, .8, .9, 1.0)

when
in 2..4
&gt;= 2
&lt;= 4
&gt;= 2
in 2..
&gt;= 2
::String.toSomething
fun String.toSomething() = length + 1
val some = listOf("lala", "bebebe").map(::String.toSomething)

fun sort(name: String, array: Array&lt;Int&gt;, sortingAlgorithm: (Array&lt;Int&gt;) -&gt; Array&lt;Int&gt;) {
    println(name)
    sortingAlgorithm(array).forEach { print(" $it ") }
    println()
}

sort("Selection Sort - Θ(n^2)", arrayOf(2, 3, 1), ::selectionSort)

selectionSort
fun selectionSort(array: Array&lt;Int&gt;): Array&lt;Int&gt; {
fun quickSort(array: Array&lt;Int&gt;,
              start: Int = 0,
              end: Int = array.size - 1): Array&lt;Int&gt; {

quickSort
selectionSort
(Array&lt;Int&gt;) -&gt; Array&lt;Int&gt;
sort("Quick Sort", arrayOf(2, 3, 1), ::quickSort)
sort
No set method providing array access
memberProperties
setter
data class EmailMessageStats(
    var bounce: Int = 0,
    var click: Int = 0,
    var deferred: Int = 0,
    var delivered: Int = 0,
    var dropped: Int = 0,
    var open: Int = 0,
    var processed: Int = 0,
    var spamreport: Int = 0
)

val sampleResponseFromDatabase = listOf(
    mapOf("type" to "bounce", "value" to 148),
    mapOf("type" to "click", "value" to 142),
    mapOf("type" to "deferred", "value" to 286),
    mapOf("type" to "delivered", "value" to 700),
    mapOf("type" to "dropped", "value" to 152),
    mapOf("type" to "open", "value" to 550),
    mapOf("type" to "processed", "value" to 1000),
    mapOf("type" to "spamreport", "value" to 140)
)

var summary = EmailMessageStats()
for (row in sampleResponseFromDatabase) {
    val type = row["type"] // e.g. bounce
    val value = row["value"] //e.g. 148
    summary[type] = value
}

println(summary)


package com.hadihariri.kotlincourse
fun main(args: Array&lt;String&gt;)
{
    println("Hello World!")
}

java -cp .:&lt;path to kotlin runtime&gt;/kotlin-runtime.jar com.hadihariri.kotlincourse.MainKt

java -cp .:~/.sdkman/candidates/kotlin/current/lib/kotlin-runtime.jar com.hadihariri.kotlincourse.MainKt

ls -al ~/.sdkman/candidates/kotlin/current/lib/kotlin-runtime.jar
-rw-r--r-- 1 user user 879182 Jun  8 18:23 /home/user/.sdkman/candidates/kotlin/current/lib/kotlin-runtime.jar

java -cp .:~/.sdkman/candidates/kotlin/current/lib/kotlin-runtime.jar com.hadihariri.kotlincourse.MainKt
Exception in thread "main" 
java.lang.NoClassDefFoundError: kotlin/jvm/internal/Intrinsics
    at com.hadihariri.kotlincourse.MainKt.main(Main.kt)
Caused by: java.lang.ClassNotFoundException: kotlin.jvm.internal.Intrinsics
    at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
    ... 1 more

[ 0.0, 0.1 .. 9.9 ]

val numbers: List&lt;BigDecimal&gt; = generateNumbers()

fun generateNumbers(): List&lt;BigDecimal&gt; {
    val list = ArrayList&lt;BigDecimal&gt;()
    for (i in 0..9)
        (0..9).mapTo(list) { BigDecimal("$i.$it") }

    return list
}

class MyClass{
    val myObservable: Observable&lt;Unit&gt; = PublishSubject.create&lt;Unit&gt;()

    fun foo(){
        myObservable.onNext(Unit) // smart casting doesn't work
    }
}


class MyClass{
    private val myPublisher = PublishSubject.create&lt;Unit&gt;()
    val myObservable: Observable&lt;Unit&gt; = myPublisher

    fun foo(){
        myPublisher.onNext(Unit)
    }
}


abstract class AbstractBook {
    abstract val type: String
    abstract val privateData: Any
    abstract val publicData: Any
}

data class FantasyBook (
    override val type: String = "FANTASY",
    override val privateData: FantasyBookPrivateData,
    override val publicData: FantasyBookPublicData
) : AbstractBook()

data class BookState(
        val owner: String,
        val bookData: AbstractBook,
        val status: String
)

BookState
type
FantasyBookPrivateData
FantasyBookPublicData
 fun &lt;T&gt; cloneWhenGreater(list: List&lt;T&gt;, threshold: T): List&lt;T&gt; 
 where T : Comparable, T : Cloneable {
 return list.filter { it &gt; threshold }.map { it.clone() }
 }

 fun &lt;T&gt; cloneWhenGreater(list: List&lt;T&gt;, threshold: T): List&lt;Any&gt;
        where T : Comparable&lt;in T&gt;, T : Cloneable {
    return list.filter { it &gt; threshold }.map { it.clone() }
}

val dis1: Float? = 10.0f
val dis2: Float? = 5.0f

val value = dis1 - dis2

operator fun Float?.minus(dis2: Float?): Float {
  return this - dis2
}

val imageBytes = Base64.decode(string, 0)
val image = BitmapFactory.decodeByteArray(imageBytes, 0, imageBytes.size)

this(a,b)
class Object (a: double, b:double)
{
  val a = a
  val b = b
  constructor(str: String) //Parsing constructor
  {
    //Do parsing
    a = parsed_a
    b = parsed_b
  }
}

&gt;&gt;&gt; a = [1,2,3]
&gt;&gt;&gt; b = [*a,4,5,6]
&gt;&gt;&gt; b
[1, 2, 3, 4, 5, 6]

&gt;&gt;&gt; listOf(1, 2, 3, *listOf(4,5,6).toTypedArray())
[1, 2, 3, 4, 5, 6]

Java8
StringUtils.join(java.lang.Iterable,char)
Kotlin
joinToString
joinToString
Kotlin
list.forEachIndexed { index, item -&gt;
   if (item.isGreen) {
       ...        
   }
}

class ParameterizedConsumer&lt;in T&gt; {
    fun toString(value: T): String {
        return value.toString()
    }
}

 val parameterizedConsumer = ParameterizedConsumer&lt;Number&gt;()

val ref: ParameterizedConsumer&lt;Double&gt; = parameterizedConsumer

assertTrue(ref is ParameterizedConsumer&lt;Double&gt;)

// Java
void demo(Source&lt;String&gt; strs) {
  Source&lt;Object&gt; objects = strs; // !!! Not allowed in Java
  // ...
}

   fun sPesquisa(){

            if (!galleryFragment.isAdded()){
                var mFragmentTransaction: FragmentTransaction = getSupportFragmentManager().beginTransaction()
                mFragmentTransaction.add(R.id.main_fragment_content,galleryFragment,"Fragment_One");
                mFragmentTransaction.commit();
            }
        }

         val sPesquisa = findViewById&lt;ImageButton&gt;(R.id.sPesquisa)
        sPesquisa.setOnClickListener {
            sPesquisa()
        }

E/MessageQueue-JNI: java.lang.IllegalStateException: Fragment already added: GalleryFragment{ef2fd8d #6 id=0x7f090081 Fragment_One}
        at android.support.v4.app.FragmentManagerImpl.addFragment(FragmentManager.java:1893)

String
text.split("\\s+".toRegex(), 2)
"abc".split("\\s+".toRegex(), 2).size == 1
String
Pair&lt;String, String&gt;
"123 456 789 0"
("123", "456 789 0")
listOf("123", "456 789 0")
"123"
("123", "")
listOf("123", "")
fun parse(string: String): LibObject {
  return SomeJavaLibrary.parse(string)
}

fun parseNullable(string: String?): LibObject? {
    if (string != null) {
        return parse(string)
    } else {
        return null;
    }
}

responseObject
class Controller(private val url: String) {
  fun &lt;T&gt; call(endpoint: String): T {
    return "$url/$endpoint".httpGet().responseObject&lt;T&gt;()
  }
}
class App(private val controller: Controller) {
  fun getModel() { 
    val model = controller.call&lt;AppModel&gt;("model")
    // use model
  }
}

Controller.call
AppModel
fuel-jackson:1.12.0
call
private val url
setReadOnly()
    override fun update(entity: GameEntity&lt;out EntityType&gt;, context: GameContext): Boolean {
    val (_, _, uiEvent, player) = context

if (currentForecastJava.getCurrentObservation().getTempF() &gt;= 60) {
    mCurrentWeatherBox.setBackgroundColor(getResources().getColor(R.color.weather_warm));
    mToolbar.setBackgroundColor(getResources().getColor(R.color.weather_warm));
} else {
    mCurrentWeatherBox.setBackgroundColor(getResources().getColor(R.color.weather_cool));
    mToolbar.setBackgroundColor(getResources().getColor(R.color.weather_cool));
}

if (currentObservationKotlin.tempF.compareTo() &gt;=)

    currentWeatherBox.setBackgroundColor(resources.getColor(R.color.weather_warm))
    toolbar.setBackgroundColor(resources.getColor(R.color.weather_warm))

else currentWeatherBox.setBackgroundColor(resources.getColor(R.color.weather_cool))
     toolbar.setBackgroundColor(resources.getColor(R.color.weather_cool))

override fun onDataChange(dataSnapshot: DataSnapshot) {
    if (null == dataSnapshot.value) {
        aThing.putAll(defaultConfig)
        dbRef.setValue(botState) { _, _ -&gt; startSync() }
    } else {
        startSync()
    }
}

Promise.resolve().then...
fun &lt;T&gt; isCurrentActivity( t: Class&lt;T&gt;): Boolean {
    return (currentActivity != null) &amp;&amp;  (currentActivity is t)
}

if (isCurrentActivity(MainActivity::class.java)) {

}

// Initializing webview
    val webView: WebView = findViewById(R.id.webview)
        // URL to be loaded
        webView.loadUrl("https://andela.com/alc/")
        //enabling javascript
        webView.settings.javaScriptEnabled = true

import kotlin.random.Random
var rnd = {Random.nextInt(0,100)}
print(rnd)

if(object.isArrayOf&lt;String&gt;())

/**
 * Checks if array can contain element of type [T].
 */
@Suppress("REIFIED_TYPE_PARAMETER_NO_INLINE")
public fun &lt;reified T : Any&gt; Array&lt;*&gt;.isArrayOf(): Boolean =
    T::class.java.isAssignableFrom(this::class.java.componentType)

@Suppress("REIFIED_TYPE_PARAMETER_NO_INLINE")
public fun &lt;reified T : Any&gt; ArrayList&lt;*&gt;.isArrayListOf(): Boolean =
    T::class.java.isAssignableFrom(this::class.java.componentType)

class ABC

class MyClass {
    private lateinit var abc: ABC

    fun abc() {
        if(!::abc.isInitialized){
            println("Hello")
        }
    }
}

MutableList
List
interface DeviceDef
data class BluetoothDef(val Status: Boolean = false) : DeviceDef
data class WiFiDef(val Name: String, val Status: Boolean = false) : DeviceDef
data class ScreenDef(val Name: String, val size: Long) : DeviceDef 


class MDetail(val _id: Long, val devices: List&lt;DeviceDef&gt;) {

    inline fun &lt;reified T&gt; getDevice(): T {
        return devices.filterIsInstance(T::class.java).first()
    }
}

mutableListOf&lt;DeviceDef&gt;
ListOf&lt;DeviceDef&gt;
aMutableList.add()
mutableListOf&lt;DeviceDef&gt;
ListOf&lt;DeviceDef&gt;
listOf(mBluetoothDef1, mWiFiDef1, //mOther)
var aMutableList= mutableListOf&lt;DeviceDef&gt;()

var mBluetoothDef1= BluetoothDef(true)
var mWiFiDef1= WiFiHelper(this).getWiFiDefFromSystem()

aMutableList.add(mBluetoothDef1)
aMutableList.add(mWiFiDef1)

// aMutableList.add(mOther)  //This is extension

var aMDetail1= MDetail(myID, aMutableList)

val idlist = arrayOf(imageView1, imageView2, imageView3, imageView4, imageView5, imageView6, imageView7, imageView8, imageView9)
        var a = 0

fun charp1(){

       val id = idlist[a]
        d("id", "${id}")
        if (cp1 == 1) {
            id.setImageResource(R.drawable.luuk2)
        }
        else if (cp1 == 2){
            id.setImageResource(R.drawable.alex)
        }
        else if (cp1 == 3){
            id.setImageResource(R.drawable.wouter)
        }
        else if (cp1 == 4){
            id.setImageResource(R.drawable.jesse)
        }
    }

    imageView1.setOnClickListener {
        a = 0
        if (count % 2 == 0){
            count += 1
            d("count", "uneven, $count, ${a}, ${idlist[a]}")
            message()
            charp1()
        }
        else{
            count+=1
            d("count", "even, $count, ${a}, ${idlist[a]}")
            message()
            charp2()
        }
    }

"http://img.omdbapi.com/?apikey=[apikey]&amp;i=${movieTrack.movie?.movieId?.imdb!!}"

movieTrack.movie?.movieId?.imdb!!

return Movie(
        name = movieTrack.movie?.name!!,
        year = movieTrack.movie?.year!!,
        movieId = movieTrack.movie?.movieId!!,
        watchers = movieTrack.watchersNumber,
        iconUrl = "http://img.omdbapi.com/?apikey=[apikey]&amp;i=${movieTrack.movie?.movieId?.imdb!!}"
)

class MainActivity : AppCompatActivity() {

    private val printers = Printers()

    private val strongObject = object: Item {
        override fun print(): Int {
            return Log.e("MainActivity", "strongObject")
        }
    }

    private val strongSAM = {
        Log.e("MainActivity", "strongSAM")
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        val localObject = object: Item {
            override fun print(): Int {
                return Log.e("MainActivity", "localObject")
            }
        }
        val localSAM = {
            Log.e("MainActivity", "localSAM")
        }
        printers.add(strongObject)
        printers.add(strongSAM)
        printers.add(localObject)
        printers.add(localSAM)
        findViewById&lt;TextView&gt;(R.id.content).setOnClickListener {
            printers.dump()
        }
    }

}

public interface Item {
    int print();
}

public class Printers {
    List&lt;WeakReference&lt;Item&gt;&gt; list = new ArrayList&lt;&gt;();

    public void add(final Item item) {
        list.add(new WeakReference&lt;&gt;(item));
    }

    public void dump() {
        Log.e("Printers", "Size: " + list.size());
        for (final WeakReference&lt;Item&gt; item: list) {
            if (item.get() != null) {
                item.get().print();
            }
        }
    }
}

Size: 4
strongObject

fun &lt;T&gt; computeMyThing(): List&lt;T&gt; {
    val array: Array&lt;T?&gt; = computeArray()
    return array.toList()
}

collectionOrSequence.sortedby{it.value}.take(n)
sortedby
var foo: [String] = [String]() {
    didSet {
        someFunction()
    }
}

var foo: ArrayList&lt;String&gt; by Delegates.observable(ArrayList&lt;String&gt;()){
    d, old, new -&gt;
    someFunction()
}

foo.add("Ally")

val (a, b) = Pair(1,2)

a, b = (1, 2)

def f(a, b): pass
pair = (1,2)
f(*pair)

f(pair.component1(), pair.component2())

abstract
isNotNull
abstract class Validator&lt;V&gt;(protected val value: V?) {
    fun isNotNull(): Validator&lt;V&gt; {
        if(value == null) {
            // ... some validation handling here ...
        }

        return this
    }
}

class IntValidator(value: Int?) : Validator&lt;Int&gt;(value) {
    fun isNotZero(): IntValidator {
        if(value == 0) {
            // ... some validation handling here ...
        }

        return this
    }
}

val validator = IntValidator(myNullableInteger)

validator
    .isNotNull()
    .isNotZero()

.isNotNull()
Validator&lt;V&gt;
IntValidator
.isNotZero()
IntValidator
Validator&lt;T&gt;
val expensiveProperty: A
constructor(expensiveProperty: A) {
    this.expensiveProperty = expensiveProperty
}
constructor(value: B) {
    // this doesn't work
    this.expensiveProperty = lazy { calculateExpensiveProperty(value) }
}

println()
System.err
val i = 3
println("my number is $i")

println()
@LocalServerPort
private lateinit var serverPort: Integer

java.lang.Integer
kotlin.Int
kotlin.Int
lateinit
-Werror
@Suppress("PLATFORM_CLASS_MAPPED_TO_KOTLIN")
mutableListOf
val
mutableListOf
val jobList = mutableListOf&lt;JobActivity&gt;()
jobList.addAll(job.activities)

mutableListOf
val jobList = mutableListOf&lt;JobActivity&gt;()
newJobList.filterScanType(retrieveJobType(JobContext.NEW)).forEach {
    jobList.add(it)
}

mutableListOf
var
mutableListOf
val
val
var
class MyClass {
    val A: String
    val B: String
    val C: String

    constructor(A: String, B: String, C: String) {
        this.A = A
        this.B = B
        this.C = C
    }

    constructor(A: String) {
        this.A = A
        val (_B, _C) = Calculator.calculate(A)
        this.B = _B
        this.C = _C
    }
}

interface Triggerable&lt;This: Triggerable&lt;This&gt;&gt; {
    var trigger: (This) -&gt; Unit
    fun triggerNow() = trigger(this as This)
}
class Test : Triggerable&lt;Test&gt;{
    override var trigger: (Test) -&gt; Unit = { /*...*/ }
}

interface TriggerInterface&lt;T&gt; {
    val trigger: (T) -&gt; Unit
    fun triggerNow()
}
interface Triggerable&lt;T: Triggerable&lt;T&gt;&gt;: TriggerInterface&lt;T&gt; {
    override fun triggerNow() = trigger(this as T)
}
interface Signalable&lt;T&gt;: TriggerInterface&lt;T&gt; {
    var value: T
    override fun triggerNow() = trigger(value)
}
class Test : Triggerable&lt;Test&gt;{
    override val trigger: (Test) -&gt; Unit = { /*...*/ }
}

fun interval
fun interval(reservas: List&lt;Reservas&gt;, dayInferior: Int, daySuperior: Int) {
    val map = mapReservas(reservas)
    for(day in dayInferior..daySuperior) {
        map.forEach {
            val reservasNum = it.key.first
            val reservasDay = it.key.second
            val reservasCount = it.value.count()
            if (reservasDay == day) {
                 println("$reservasNum has $reservasCount passengers on day $day")
            }
        }
    }
    println()
    println("Press Enter")                                                              
    readLine()
}

fun mapReservas(reservas: List&lt;Reservas&gt;): Map&lt;Pair&lt;String, Int&gt;, List&lt;Reservas&gt;&gt; {
    val map = mutableMapOf&lt;Pair&lt;String, Int&gt;, MutableList&lt;Reservas&gt;&gt;()
    for (reserva in reservas) {
        val key = reserva.numFlight to reserva.day
        val list = map[key] ?: mutableListOf()
        list.add(reserva)
        map[key] = list
    }
    return map
}

fun compare1(x: Int) = x == 1

fun compare2(x: String) = x == 1

fun &lt;T&gt; compare3(x: T) = x == 1

stringToEvent
(String) -&gt; Event
BigInteger
Kotlin
For-loop range must have an 'iterator()' method
BigInteger
Kotlin
private fun pow(base: BigInteger, power: BigInteger): String {
        for(i in BigInteger.ZERO..power){ //Giving error

        }
    }

public var funct : (vararg x : View?) -&gt; Unit by Delegates.notNull();

funct
funct(v1, v2)
Bundle
onSaveInstanceState
java.lang.RuntimeException: Parcelable encountered IOException writing serializable object (name = MyActivity$showFragmentA$1)
                                                                  at android.os.Parcel.writeSerializable(Parcel.java:1447)
                                                                  at android.os.Parcel.writeValue(Parcel.java:1395)
                                                                  at android.os.Parcel.writeArrayMapInternal(Parcel.java:665)
                                                                  at android.os.BaseBundle.writeToParcelInner(BaseBundle.java:1330)
                                                                  at android.os.Bundle.writeToParcel(Bundle.java:1079)
                                                                  at android.os.Parcel.writeBundle(Parcel.java:690)
                                                                  at android.app.ActivityManagerProxy.activityStopped(ActivityManagerNative.java:3269)
                                                                  at android.app.ActivityThread$StopInfo.run(ActivityThread.java:3632)
                                                                  at android.os.Handler.handleCallback(Handler.java:815)
                                                                  at android.os.Handler.dispatchMessage(Handler.java:104)
                                                                  at android.os.Looper.loop(Looper.java:207)
                                                                  at android.app.ActivityThread.main(ActivityThread.java:5728)
                                                                  at java.lang.reflect.Method.invoke(Native Method)
                                                                  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:789)
                                                                  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:679)
                                                               Caused by: java.io.NotSerializableException: MyActivity
                                                                  at java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1344)
                                                                  at java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1651)
                                                                  at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1497)
                                                                  at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1461)
                                                                  at java.io.ObjectOutputStream.writeFieldValues(ObjectOutputStream.java:959)
                                                                  at java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:360)
                                                                  at java.io.ObjectOutputStream.writeHierarchy(ObjectOutputStream.java:1054)
                                                                  at java.io.ObjectOutputStream.writeNewObject(ObjectOutputStream.java:1384)
                                                                  at java.io.ObjectOutputStream.writeObjectInternal(ObjectOutputStream.java:1651)
                                                                  at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1497)
                                                                  at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1461)
                                                                  at android.os.Parcel.writeSerializable(Parcel.java:1442)
                                                                  at android.os.Parcel.writeValue(Parcel.java:1395) 
                                                                  at android.os.Parcel.writeArrayMapInternal(Parcel.java:665) 
                                                                  at android.os.BaseBundle.writeToParcelInner(BaseBundle.java:1330) 
                                                                  at android.os.Bundle.writeToParcel(Bundle.java:1079) 
                                                                  at android.os.Parcel.writeBundle(Parcel.java:690) 
                                                                  at android.app.ActivityManagerProxy.activityStopped(ActivityManagerNative.java:3269) 
                                                                  at android.app.ActivityThread$StopInfo.run(ActivityThread.java:3632) 
                                                                  at android.os.Handler.handleCallback(Handler.java:815) 
                                                                  at android.os.Handler.dispatchMessage(Handler.java:104) 
                                                                  at android.os.Looper.loop(Looper.java:207) 
                                                                  at android.app.ActivityThread.main(ActivityThread.java:5728) 
                                                                  at java.lang.reflect.Method.invoke(Native Method) 
                                                                  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:789) 
                                                                  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:679)

class MyActivity : Activity {
    private var lastFragment: (() -&gt; Fragment)? = null

    override fun onSaveInstanceState(outState: Bundle?) {
        super.onSaveInstanceState(outState)
         outState?.putSerializable("lastFragment", lastFragment as Serializable)
    }

    fun showFragmentA() {
        lastFragment = { FragmentA() }
        // show fragment lastFragment()
    }

    fun showFragmentB() {
        ...
    }
}

package io.robusta.nikotor.core

import java.util.*
import java.util.concurrent.CompletableFuture

interface PersistedEvent&lt;E, P&gt; where E : Event&lt;P&gt; {
    val event: E
    val sequenceId: Long
    val technicalDate: Long
}


typealias Persisted = PersistedEvent&lt;*,*&gt;
typealias Events = List&lt;Event&lt;*&gt;&gt;
typealias PersistedEvents = List&lt;PersistedEvent&lt;*,*&gt;&gt;
​
abstract class AbstractPersistedEvent&lt;E, P&gt;(override val event: E)
    : PersistedEvent&lt;E, P&gt; where E : Event&lt;P&gt; {
    ​
    override val technicalDate = Date().time
}
​
object LocalSequence{
    private var localSequenceId = 0L
    fun next(): Long {
        localSequenceId++
        return localSequenceId
    }
}


class SequencePersisted&lt;E, P&gt;(event: E) : AbstractPersistedEvent&lt;E, P&gt;(event) where E : Event&lt;P&gt; {
    override val sequenceId = LocalSequence.next()
}


interface EventStore {
    fun &lt;P&gt; persist(event: Event&lt;P&gt;): CompletableFuture&lt;PersistedEvent&lt;*,*&gt;&gt;

    fun persistAll(events: Events): CompletableFuture&lt;PersistedEvents&gt;

    fun loadInitialEvents(): CompletableFuture&lt;PersistedEvents&gt;

    fun resetWith(events: Events): CompletableFuture&lt;PersistedEvents&gt;
}

class MySingleton {
    companion object {
        val instance = MySingleton
    }
}

val mySingleton = MySingleton()

val instance = MySingleton.instance

&gt;&gt;&gt; null.takeIf({1==2})
res4: kotlin.Nothing? = null

value
Boolean
Float
Int
Long
String
value
Any
when()
fun putValue(key: String, value: Any) {
        when (value) {
            is Boolean -&gt; putBoolean(key, value)
            is Float -&gt; putFloat(key, value)
            is Int -&gt; putInt(key, value)
            is Long -&gt; putLong(key, value)
            is String -&gt; putString(key, value)
            null -&gt; return
        }
    }

class Wolf {
    var hunger = 10
    val food = "meat"

    fun eat() {
        println("The Wolf is eating $food")
    }
}

class MyWolf {
    var wolf: Wolf? = Wolf()

    fun myFunction() {
        wolf?.eat()
    }
}

fun getAlphaWolf(): Wolf? {
    return Wolf()
}

fun main(args: Array&lt;String&gt;) {
    var w: Wolf? = Wolf()

    if (w != null) {
        w.eat()
    }

    var x = w?.hunger
    println("The value of x is $x")

    var y = w?.hunger ?: -1
    println("The value of y is $y")

    var myWolf = MyWolf()
    myWolf?.wolf?.hunger = 8
    println("The value of myWolf?.wolf?.hunger is ${myWolf?.wolf?.hunger}")

    var myArray = arrayOf("Hi", "Hello", null)
    for (item in myArray) {
        item?.let { println(it) }
    }

    getAlphaWolf()?.let { it.eat() }

    w = null
    var z = w!!.hunger
}

fun getAlphaWolf(): Wolf? {
     return Wolf()
}

package com.example.hello_app.demo

import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
class Hello {
        @RequestMapping("/")
        fun index() : String {
                return "Hello World"
        }
}

gradle compileKotlin
Unresolved reference: web
Unresolved reference: web
Unresolved reference: RestController
Unresolved reference: RequestMapping

var previousState = state.previousState
while (previousState != null &amp;&amp; previousState::class != searchClass) {
    previousState = previousState.previousState
}

while
var
np.linspace(start = 0, stop = 100, num = 5)


-------------------------
|0 | 25 | 50 | 75 | 100 |
-------------------------

fun convertToCharacter() {
    val number = 0

    val character = number.toChar()
    println(character)
}

fun convertToCharacter() {
    val number = 0

    val character = number.toChar() + '0'
    println(character)
}

data class Person(val name: String, val age: Int)
val people = listOf(Person("Alice", 29), Person("Bob", 31))
people.filter {it.age == people.maxBy(Person::age)}

  inner class Arr : AsyncTask&lt;String, String, String&gt;(){

        val progressDialog = AlertDialog.Builder(this@MainActivity)
        val dialogView = layoutInflater.inflate(R.layout.progress_dialog,null)
        val message = dialogView.findViewById&lt;TextView&gt;(R.id.message_id)
        val dialog = progressDialog.create()


        override fun onPreExecute() {
            super.onPreExecute()

            progressDialog.setMessage("loading")
            progressDialog.setCancelable(false)
            progressDialog.show()


        }

        //        for build connection
        override fun doInBackground(vararg url: String?): String{

            var text : String
            val connection = URL(url[0]).openConnection() as HttpURLConnection

            try {
                connection.connect()
                text = connection.inputStream.use { it.reader().use{reader -&gt; reader.readText()} }


            } finally{

                connection.disconnect()

            }
            return text
        }

        override fun onPostExecute(result: String?) {

            super.onPostExecute(result)
            handleJson(result)

                dialog.dismiss()


        }

        override fun onProgressUpdate(vararg text: String?) {
                dialog.dismiss()

        }
        private fun handleJson (jsonString: String?){
            dialog.dismiss()

            val jsonObj = JSONObject(jsonString)
            val result = jsonObj.getJSONObject("result")
            val response = result.getJSONObject("response")
            val airport = response.getJSONObject("airport")
            val pluginData = airport.getJSONObject("pluginData")
            val schedule = pluginData.getJSONObject("schedule")
            val arrivals = schedule.getJSONObject("arrivals")
//        val data = arrivals.getJSONObject("data")
            val jsonArray = JSONArray(arrivals.get("data").toString())

            val list =  ArrayList&lt;FlightShdu&gt;()
            var x = 0
            while (x &lt; jsonArray.length()){

                val jsonObject = jsonArray.getJSONObject(x)



                list.add(FlightShdu(

                    jsonObject.getJSONObject("flight").getJSONObject("identification").getJSONObject("number").getString("default"),
                    jsonObject.getJSONObject("flight").getJSONObject("airline").getString("name"),
                    jsonObject.getJSONObject("flight").getJSONObject("status").getString("text"),
                    jsonObject.getJSONObject("flight").getJSONObject("airline").getJSONObject("code").getString("icao"),
                   jsonObject.getJSONObject("flight").getJSONObject("time").getJSONObject("scheduled").getString("arrival")


                ))


                x++
            }
            list.forEach(::println)

            val adapter = ListAdapte(this@MainActivity,list)
            flight_arrivel_list.adapter = adapter

        }




    } // 

open class Base(
    val first: String,
    val second: String
)

class Child(
    first: String,
    second: String,
    val third: List&lt;String&gt;
) : Base(first, second)

open class Base(
    open val first: String,
    open val second: String
)

data class Child(
    override val first: String,
    override val second: String,
    val third: List&lt;String&gt;
) : Base(first, second)

class Foo{
    var name = "Foooo"
}

class Liii{
    var name = "Liii"
}

fun genericFunc(objects: Any, objectType: KClass&lt;*&gt;) {
    print((objects as objectType).name) //This is not exist how to do this?
}

val foo = Foo()
genericFun(foo, Foo::class)

val liii = Liii()
genericFun(liii, Liii::class)

func genericFunc(objects: Any, objectType: Object.type) {
    print((objects as objectType).name)
}

let foo = Foo()
genericFun(foo, Foo.self)

private val elements: ArrayList&lt;ISomeElement&gt; = ArrayList()

override fun curElements(): Collection&lt;GenericElement&gt; {  
  ...
  return elements as Collection&lt;GenericElement&gt; // squigly underline here, unchecked cast warning

}

ISomeElement
GenericElement
ISomeElement
class Item {
    private String text = "";

    public String getText() {
        return text;
    }

    public void setText(String str) {
        if(str == null){
            text = "";
        } else {
            text = str;
        }
    }

}

"BOOKING - PAID (price.amount=70, price.currency=EUR)"

70 EUR
removeAll("", "", ...)
price.amount
price.currency
fun main(args: Array&lt;String&gt;) {
    var s: String = "G:\My Web Sites\"
    println(s)
}

fun main(args: Array&lt;String&gt;) {
    var s: String = "G:\\My Web Sites\\"
    println(s)
}

import java.io.File
fun main(args: Array&lt;String&gt;) {
    var s: String = "G:\My Web Sites\"
    val replace = s.replace('/', File.separatorChar);
    println(replace)
}

import java.io.File

fun main(args: Array&lt;String&gt;) {
    var s = """"G:\My Web Sites\"""
    println(s)
    s= s.replace("\\", "\\\\")
    println(s)
    File(s).walk().forEach  { println(it) }
}


private fun String.replace(regex: Regex, notMatched: (String) -&gt; String, matched: (MatchResult) -&gt; String): String {
//    its from https://github.com/http4k/http4k/blob/master/http4k-core/src/main/kotlin/org/http4k/core/UriTemplate.kt
    val matches = regex.findAll(this)
    val builder = StringBuilder()
    var position = 0
    for (matchResult in matches) {
        val before = substring(position, matchResult.range.start)
        if (before.isNotEmpty()) builder.append(notMatched(before))
        builder.append(matched(matchResult))
        position = matchResult.range.endInclusive + 1
    }
    val after = substring(position, length)
    if (after.isNotEmpty()) builder.append(notMatched(after))
    return builder.toString()
}

translations
translations.map { it.key to it.value }.toMap()
  public static void main(String[] args) {
    checkVarargs(null);
  }

  public static void checkVarargs(String... o) {
    System.out.println(o);
  }

    @JvmStatic
    fun main(args: Array&lt;String&gt;) {
      checkVarargs(null)
    }

null
[Ljava.lang.String;@548c4f57
    package com.example.maxs.kotlinnearbyv2

import android.support.v7.app.AppCompatActivity
import android.os.Bundle
import android.util.Log
import android.widget.Toast
import com.example.maxs.kotlinnearbyv2.Common.Common
import com.example.maxs.kotlinnearbyv2.Model.MyPlaces
import com.example.maxs.kotlinnearbyv2.Remote.IGoogleAPIService
import com.google.android.gms.maps.*
import com.google.android.gms.maps.model.BitmapDescriptorFactory

import com.google.android.gms.maps.model.LatLng
import com.google.android.gms.maps.model.MarkerOptions
import kotlinx.android.synthetic.main.activity_maps.*
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response

class MapsActivity : AppCompatActivity(), OnMapReadyCallback {

private lateinit var mMap: GoogleMap

private var latitude:Double=0.toDouble()
private var longitude:Double=0.toDouble()

lateinit var mService:IGoogleAPIService

internal var currentPlace: MyPlaces?=null

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_maps)
    // Obtain the SupportMapFragment and get notified when the map is ready to be used.
    val mapFragment = supportFragmentManager
        .findFragmentById(R.id.map) as SupportMapFragment
    mapFragment.getMapAsync(this)

    //Init Service
    mService = Common.googleApiService

    bottom_navigation_view.setOnNavigationItemReselectedListener {item -&gt;
        when(item.itemId)
        {
            R.id.action_hospital -&gt; nearByPlace("hospital")
            R.id.action_restaurant -&gt; nearByPlace("restaurant")
            R.id.action_market -&gt; nearByPlace("market")
            R.id.action_school -&gt; nearByPlace("school")
        }
    }
}

private fun nearByPlace(typePlace: String) {

    //Clear all marker on Map
    mMap.clear()
    //build URL request base on location
    val url = getUrl(latitude,longitude, typePlace)

    mService.getNearByPlaces(url)
        .enqueue(object : Callback&lt;MyPlaces&gt;{
            override fun onResponse(call: Call&lt;MyPlaces&gt;, response: Response&lt;MyPlaces&gt;) {

                currentPlace = response.body()

                if(response!!.isSuccessful)
                {
                    for(i in 0 until response!!.body()!!.results!!.size)
                    {
                        val markerOptions=MarkerOptions()
                        val googlePlace = response.body().results!!(i)
                        val lat = googlePlace.geometry!!.location!!.lat
                        val lng = googlePlace.geometry!!.location!!.lng
                        val placeName = googlePlace.name
                        val latLng = LatLng(lat, lng)

                        markerOptions.position(latLng)
                        markerOptions.title(placeName)
                        if (typePlace.equals("hospital"))
                            markerOptions.icon(BitmapDescriptorFactory.fromResource(R.drawable.ic_local_hospital_black_24dp))
                        else if (typePlace.equals("market"))
                            markerOptions.icon(BitmapDescriptorFactory.fromResource(R.drawable.ic_shopping_cart_black_24dp))
                        else if (typePlace.equals("restaurant"))
                            markerOptions.icon(BitmapDescriptorFactory.fromResource(R.drawable.ic_restaurant_black_24dp))
                        else if (typePlace.equals("school"))
                            markerOptions.icon(BitmapDescriptorFactory.fromResource(R.drawable.ic_school_black_24dp))
                        else
                            markerOptions.icon(BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_BLUE))

                        markerOptions.snippet(i.toString())

                        //add marker to map
                        mMap!!.addMarker(markerOptions)


                    }
                    //move camera
                    mMap!!.moveCamera(CameraUpdateFactory.newLatLng(LatLng(latitude, longitude)))
                    mMap!!.animateCamera(CameraUpdateFactory.zoomTo(15.0f))
                }
            }

            override fun onFailure(call: Call&lt;MyPlaces&gt;, t: Throwable) {
                Toast.makeText(baseContext, ""+t!!.message,Toast.LENGTH_SHORT).show()
            }

        })
}

private fun getUrl(latitude: Double, longitude: Double, typePlace: String): String {

    val googlePlaceUrl = StringBuilder("https://maps.googleapis.com/maps/api/place/nearbysearch/json")
    googlePlaceUrl.append("?location=$latitude,$longitude")
    googlePlaceUrl.append("&amp;radius=10000") //10 km
    googlePlaceUrl.append("&amp;type=$typePlace")
    googlePlaceUrl.append("&amp;key=")

    Log.d("URL_DEBUG", googlePlaceUrl.toString())
    return googlePlaceUrl.toString()
}

/**
 * Manipulates the map once available.
 * This callback is triggered when the map is ready to be used.
 * This is where we can add markers or lines, add listeners or move the camera. In this case,
 * we just add a marker near Sydney, Australia.
 * If Google Play services is not installed on the device, the user will be prompted to install
 * it inside the SupportMapFragment. This method will only be triggered once the user has
 * installed Google Play services and returned to the app.
 */
override fun onMapReady(googleMap: GoogleMap) {
    mMap = googleMap

    // Add a marker in Sydney and move the camera
    val barbier = LatLng(52.391274, 6.449712)
    mMap.addMarker(MarkerOptions().position(barbier).title("Marker in Barbier"))
    mMap.moveCamera(CameraUpdateFactory.newLatLng(barbier))
    mMap.moveCamera(CameraUpdateFactory.newLatLngZoom(barbier, 15.0f))
}
}

val googlePlace = response.body().results!!(i)

val x = if (isOdd) 1 else 2

val x: Int
val y: Int
val z: Int

if (isOdd) {
    x = 1
    y = 3
    z = 5
} else {
    x = 2
    y = 4
    z = 6
}

val x = if (isOdd) 1 else 2
val y = if (isOdd) 3 else 4
val z = if (isOdd) 5 else 6

val map = mutableMapOf&lt;Int, Int&gt;()
ar.forEach{
    if(!map.containsKey(it)) {
        map[it] = 1
    } else {
        map[it] = map[it] + 1
    }
}

mutableMap
 else map[it] = map[it]!! + 1

javaClass
open class TestClass {
    companion object {
        init {
            val clazz = Class.forName(this::class.java.canonicalName.removeSuffix(".Companion"))
        }
    }    
}

class InheritingClass : TestClass()
this::class.companionClass
for (item in myList) item.someMethod()
myList.all().someMethod()
class MyClass {
 val someName = "want this value"
 val someOther = SomeOther().apply{ someName = someName }
 // other stuff below
}

SomeOther
someName
someName
someName
apply
this.someName=someName
fun main(args: Array&lt;String&gt;) {
    class SomeOther {
        var someName: String? = null
    }
    val someName = "want this value"
    print(SomeOther().apply { this.someName = someName }.someName) // works!

}

class SomeOther {
    var someName: String? = null
}

class MyClass {
    val someName = "want this value"
    val someOther = SomeOther().apply { this.someName = someName }
    fun go() = print(someOther.someName)
}

fun main(args: Array&lt;String&gt;) = MyClass().go() // prints null

MutableList
(0..10).toMutableList().map { 1 }

List
(0..10).toMutableList().map { 1 }.toMutableList() //ok

mapMutable
@OneToOne(mappedBy = "testOrder", cascade = [ CascadeType.ALL ], orphanRemoval = true)
    var or: OData? = null,

@OneToMany(mappedBy = "testOrder", cascade = [ CascadeType.ALL ], orphanRemoval = true)
    var ur: MutableList&lt;UData&gt;? = ArrayList(),

@OneToMany(mappedBy = "usr", cascade = [CascadeType.ALL], orphanRemoval = true)
    var sCriteria: MutableSet&lt;SCriteria&gt;? = LinkedHashSet()

@OneToMany(mappedBy = "owr", cascade = [CascadeType.ALL], orphanRemoval = true)
    var sCriteria: MutableSet&lt;SCriteria&gt;? = LinkedHashSet()

val sCriterias = testOrder.owr?.sCriteria;

fun main(args: Array&lt;String&gt;) {
    val args = Any()
}

a = [1, 1, 1] b = [1, 0, 0]
[2, 0]
fun compareArrays(a: Array&lt;Int&gt;, b: Array&lt;Int&gt;): Array&lt;Int&gt; {

    var aRetVal:Int = 0
    var bRetVal:Int = 0

    for(i in 0..2){
        when {
            a[i] &gt; b[i] -&gt; aRetVal + 1 // This does not add 1 to the variable
            b[i] &gt; a[i] -&gt; bRetVal++ // This does...
        }
    }
    return arrayOf(aRetVal, bRetVal)

}

val
class A {
  fun B.foo()
}

with (myA) { myB.foo() }
A
with (java.math.RoundingMode.CEILING) { 1 / 2 }

1
operator fun Int.div(Int)
RoundingMode
class A { }
class B {
    fun A.newFunction() { ... }
}

class B {
    var A.someCounter: Int = 0
}

fun theItemDTO.toDomainModel(
    domainOrderId: String,
    pIds: List&lt;Long&gt; = emptyList()
): theItem = let { dto -&gt;
    OrderProtoBuilders.theItem {
        this.id = dto.id.toString()
        skuId = dto.catalogEntryId.toString()
        orderId = domainOrderId
        quantity = dto.quantity
        unitPrice = dto.unitPrice
        totalPrice = dto.totalPrice
        price = null
        for (pId in pIds)
            addpId(pId.toString())

        dto.someMap[MAP_A]
            ?.let(::setAId)

        dto.someMap[MAP_B]
            ?.let(::setBId)
    }
}

dto.someMap[MAP_A]
            ?.let(::setAId)
someMap[MAP_A]
let
{
return
-&gt;
...: theItem
OrderProtoBuilders.theItem {...
let { dto -&gt;
    OrderProtoBuilders.theItem {...

class ItemObject(var itemNumber: String = "",
             var itemQty: Int = 0)

class ItemObject(var itemNumber: String = "",
             itemQty: Int = 0) {

var itemQty: Int = 0
    set(value: Int) =
        if (value &gt;= 0) {
            itemQty = value // Don't want to go negative
        } else {
        }

/**
 * Allows modifying the value in a synchronized way so that the get() and set() are atomic.
 *
 * Note: anything synchronized cannot be `inline`.
 */
@Synchronized fun safeSet(calculateNewValue: (T) -&gt; T) {
    set(calculateNewValue(get()))
}

inlined
inlined
@Test
fun `safeSet - is synchronized`() {
    val insideSet = AtomicInteger()
    val threadsRun = CountDownLatch(2)
    val t1 = Thread({
        threadsRun.countDown()
        sut.safeSet { currentValue: Int -&gt;
            insideSet.incrementAndGet()
            try {
                Thread.sleep(100000)
            } catch (interrupted: InterruptedException) {
                BoseLog.debug(interrupted)
            }
            currentValue + 1
        }
    })
    t1.start()

    val t2 = Thread({
        threadsRun.countDown()
        sut.safeSet { currentValue: Int -&gt;
            insideSet.incrementAndGet()
            try {
                Thread.sleep(100000)
            } catch (interrupted: InterruptedException) {
                BoseLog.debug(interrupted)
            }
            currentValue + 2
        }
    })
    t2.start()

    threadsRun.await()
    Thread.sleep(100)
    assertEquals(1, insideSet.get())
    t1.interrupt()
    t2.interrupt()
    Thread.sleep(100)
    assertEquals(2, insideSet.get())
}

val input = "2+2"
input.toInt()

setOnClickListener
interface I {
    fun ha()
}

class C() {
    fun set(i: I) { i.ha() }
}

fun main(args: Array&lt;String&gt;) {
    val c = C()
    c.set { println("Hi") }
}

error: type mismatch: inferred type is () -&gt; Unit but I was expected
    fun read(key: Key, defaultValue: String): String? {
        return prefs.getString(key.name, defaultValue)
    }

    fun read(key: Key, defaultValue: Boolean): Boolean? {
        return prefs.getBoolean(key.name, defaultValue)
    }

    fun read(key: Key, defaultValue: Int): Int {
        return prefs.getInt(key.name, defaultValue)
    }

read
fun&lt;T&gt; read(key: Key, defaultValue: T): T? {
    return when(defaultValue){
        is String -&gt; prefs.getString(key.name, defaultValue)
        is Boolean -&gt; prefs.getBoolean(key.name, defaultValue)
        else -&gt; throw IllegalArgumentException()
    }
}

fun &lt;T&gt;
class Adult: Resident {
    constructor(name: String, id:String): super(name, id)
    var email: String? = null
    var address: MutableList&lt;String&gt;? = null

    fun setAddress(s: String){
        address = s.split("\\n".toRegex()).toMutableList()
    }

}

b.address = a.address
b.address?.add("Universe"
a
fun test6() {
    val a = Adult("Roger Widdoff","604119274")
    val b = Adult("Kathleen Craig","647022192")
    a.setAddress("123 Main Street\nAnytown, Country")
    assertEquals(2,a.address?.size)

    b.address = a.address

    b.address?.add("Universe")

    assertEquals(3,b.address?.size)

    assertEquals(2,a.address?.size)
}

fun main(args: Array&lt;String&gt;) {
    println("Number: ")
    val num = readLine()!!.toInt()
    var sum = 0
    for (digit in num) {
        if (digit % 2 != 0) {
            sum += digit
        }
    }
    println("$sum")
}

val allInts = (1..).asSequence()

allInts.take(5)

when
fun
processFirstWhen
when (val result = callback.invoke()) {
            is DataCompletable.Success -&gt; DomainCompletable.Success
            is DataCompletable.Error -&gt;
                when (result.error) {
                    is DataError.Unauthorized -&gt;
                        when (tokenMixIn.refresh()) {
                            is DomainCompletable.Success -&gt; execute(
                                currentNumberOfRetries + 1,
                                callback
                            )
                            is DomainCompletable.Error -&gt; DomainCompletable.Error(DomainError.RefreshFailed)
                        }
                    else -&gt; DomainCompletable.Error(result.error.mapToDomain())
                }

fun main()  {
    var beverage:String? = readLine()
    if(beverage !=null){
        beverage =beverage .capitalize()
    }else{
        println("variable beverage equal null")
    }
    val beverageServed: String = beverage ?: "Buttered Ale"
    println(beverageServed)
}

override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_view)

        if (intent != null) {
            val viewType: String = intent.getStringExtra("ViewType")
            if (viewType != null &amp;&amp; !TextUtils.isEmpty(viewType)) {
                if (viewType.equals("localFile")) {
                    if (intent.getType().equals("application/pdf")) {
                        val selectedPdf: Uri = Uri.parse(intent.getStringExtra("FileUri"))
                        pdfView.fromUri(selectedPdf)
                            .password(null)
                            .defaultPage(0)
                            .enableSwipe(true)
                            .enableDoubletap(true)
                            .swipeHorizontal(true)
                            .pageSnap(true)
                            .autoSpacing(true)
                            .pageFling(true)
                            .onDraw { canvas, pageWidth, pageHeight, displayedPage -&gt;

                            }.onDrawAll { canvas, pageWidth, pageHeight, displayedPage -&gt;

                            }.onPageChange { page, pageCount -&gt;

                            }.onPageError { page, t -&gt;
                                Toast.makeText(
                                    this@ViewActivity,
                                    "Error while opening page " + page,
                                    Toast.LENGTH_SHORT
                                )
                                Log.d("ERROR", "" + t.localizedMessage)
                            }.onTap { false }
                            .onRender {
                                fun onRenderListener(pages, pageWidth, pageHeight) {
                                    fun onInitiallyRendered(pages, pageWidth, pageHeight) {
                                        pdfView.fitToWidth(pages)
                                    }
                                }
                            }.enableAnnotationRendering(true)
                            .load()
                    }
                }
            }
        }
    }

filter
var brandname = ""
var brandtofind = "tide"
var result = brandtofind.contains(brandname) //results in true

var candidates = this.filter{ product -&gt; 
                  text.contains(product.name) ||
                  text.contains(product.brandname) //brandname often empty

val result = 50 in 1..100

public final class Test14Kt {
   private static final boolean result = true;

   public static final boolean getResult() {
      return result;
   }
}

fun ambigousTypeEval(sport: String) = when (sport) {
  "cricket" -&gt; -1
  else -&gt; "I like $sport"
}

Int
String
Any
Any
&gt;&gt;&gt; examples.ambigousTypeEval("cricket")::class
examples.ambigousTypeEval("cricket")class kotlin.Int

&gt;&gt;&gt; examples.ambigousTypeEval("football")::class
examples.ambigousTypeEval("football")class kotlin.String

(String) -&gt; Any
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock


fun main()
{
    runBlocking {

      var counter = 0
      val lock = Mutex()  

      val coroutines = List(3) {
        launch {
          repeat(1_000) {
            lock.withLock {
              counter++
            }
          }
        }
      }

      coroutines.forEach { it.join() }

      println("Final counter: $counter")
    }
}

class SiteListEventBus : EventBus&lt;SiteListEventBus.SiteListChangeEvent, String, NotificationHandler&lt;SiteListEventBus.SiteListChangeEvent&gt;&gt;() {

    data class SiteListChangeEvent(val entityId: String, val routingKey: String)

    override fun getSubscriptionKey(event: SiteListChangeEvent?): String {
        return event!!.routingKey
    }
}

var weightInKilos = 100.0

//should multiply the above var
fun doSomething(multiplier: Double, weightInKilos: Double) {
    weightInKilos = weightInKilos * multiplier
}

print(doSomething(4.2, weightInKilos))

arr.forEach {
   val forEachIt = it //I need to get rid of this extra value
   val product = productList.firstOrNull { forEachIt.productId == it.productID }
}

// factory function, valid
val myInstance = myClassOf()

// class instantiation, invalid
val myInstance = MyClass()

intArrayOf()
// works
val myIntArray = intArrayOf()

// not possible as IntArray has a private constructor
val myIntArray = IntArray()

class myPanel : JPanel {
    myPanel() : super() {

    }
}

class myPanel() : JPanel() {
    {
        ...
    }
}

Long
    private fun &lt;T&gt; castLong(value: Long, clazz: Class&lt;out T&gt;): T {
        // map lookup removed for simplicity
        return when (clazz) {
            String::class.java -&gt; { value.toString() }
            else -&gt; { throw IllegalArgumentException("Unsupported Cast") }
        }
    }

T
String
castLong(aLongValue, String::class.java)
String
reified
kotlin-experiment/Play.kts
import experiment.*

println(sum(2, 2))

kotlin-experiment/Play.kts
package experiment

fun sum(x: Int, y: Int) = x + y

kotlinc -script Play.kts

Play.kts:3:9: error: unresolved reference. None of the following candidates is applicable because of receiver type mismatch:
...
println(sum(2, 2))
        ^

IntStream.iterate(0, i -&gt; i + 2)
     .limit(100)
     .forEach(System.out::println);

/**
 * Given an [iterator] function constructs a [Sequence] that returns values through the [Iterator]
 * provided by that function.
 * The values are evaluated lazily, and the sequence is potentially infinite.
 */

Sequence { iterator(arrayOf&lt;Int&gt;()) }
        .forEach { print(it) }

.iterate
.limit
.reduce
.reduce
.toList
plus100(Int):Int
Mul2.plus100(Int):Int
Mul2.plus100
class Mul2 {
    fun plus100(v: Int): Int = plus100(2 * v)
}

fun plus100(v: Int): Int = v + 100

fun main(args: Array&lt;String&gt;) {
    val v = Mul2()
    println(v.plus100(10)) // expected: "120", actual: StackOverflowError
}

plus100
Mul2.plus100
{
  "root": [
    {
      "id": 2,
      "val": 1231.12,
      "fruit": [
        {
          "id": 2,
          "name": "apple"
        }
      ]
    },
    {
      "id": 3,
      "val": 1231.12,
      "fruit": [
        {
          "id": 2,
          "name": "apple"
        },
        {
          "id": 3,
          "name": "orange"
        }
      ]
    }
  ],
  "fruits": [
    {
      "id": 1,
      "name": "apple"
    },
    {
      "id": 2,
      "name": "guava"
    },
    {
      "id": 3,
      "name": "banana"
    }
  ]
}

val tempList = arrayListOf&lt;RootItem&gt;()

root?.forEach { item -&gt; 
    item.fruit.filter {
        // filter condition
        it.id != null &amp;&amp; it.name == "apple"
    }
    testList.add(item)
}

fun test(temp: Int) {
    temp = 5
}

fun showProgressView() = ultraRecyclerView?.showProgressBar()

Unit?
Unit
fun showProgressView() = ultraRecyclerView?.showProgressBar() ?: Unit

fun showProgressView() { ultraRecyclerView?.showProgressBar() }

@Value("\${app.email-config-file: D:\\email\\src\\main\\resources\\email.config}")
private lateinit var emailDir: String 

init {
    log.info("====================================================================================================")
    log.info("Email Config File Dir: ${this.emailDir}")
    log.info("====================================================================================================")
}

private val creators: ArrayMap&lt;Class&lt;*&gt;,() -&gt;ViewModel&gt; = ArrayMap()

class A { // implicit label @A
    inner class B { // implicit label @B
        fun Int.foo() { // implicit label @foo
            val a = this@A // A's this
            val b = this@B // B's this

            val c = this // foo()'s receiver, an Int
            val c1 = this@foo // foo()'s receiver, an Int

            val funLit = lambda@ fun String.() {
                val d = this // funLit's receiver
            }


            val funLit2 = { s: String -&gt;
                // foo()'s receiver, since enclosing lambda expression
                // doesn't have any receiver
                val d1 = this
            }
        }
    }
}

var a = A()
a.Int.foo() // This is not allowed.

@GET
@Path("getParticipants")
@Produces(MediaType.APPLICATION_JSON)
fun getParticipants(): Map&lt;String, List&lt;String&gt;&gt; {
    val (nodeInfo, nodeUpdates) = rpcOps.networkMapFeed()
    nodeUpdates.notUsed()
    return mapOf("getParticipants" to nodeInfo
            .map { it.legalIdentities.first().toString() }
            .filter { it != myLegalName &amp;&amp; it !in NOTARY_NAMES })
}

0   "C=GB,L=London,O=UserA"
1   "C=GB,L=London,O=Controller"
2   "C=US,L=New York,O=UserB"

@Parcelize
data class MemberCard(
        val PartnerMembershipId: Int,
        override var MembershipNumber: String? = null,
        override var Name: String? = null,
        var MemberImgUrl: String? = null,
        val TextColorHex: String? = null,
        override var ExpirationDate: Date? = null,
        override var Issuer: String,
        var Notifications: kotlin.Int? = null,
        override var BarcodeType: kotlin.String? = null,
        override var Barcode: kotlin.String? = null,
        val IsPartnerCard: Boolean,
        val Status : String
) : BaseCard {
    val isPending = true//Status=="Pending"
}

final class Utils {
    public static boolean foo() {
        return false;
    }
}

object
object Utils {
    fun foo(): Boolean {
        return false
    }
}

INSTANCE
Utils.INSTANCE.foo()
class
object
@file:JvmName("Utils")
@file:JvmMultifileClass

fun foo(): Boolean {
    return true
}

Utils.foo()
Unresolved reference
foo()
Utils
var mRetrievingConnections: Boolean?

var retrievingConnections: Boolean?
    get() = mRetrievingConnections
    set(value) {
      mRetrievingConnections = value
    }

var retrievingConnections: Boolean?
    get() = field
    set(value) {
    }

fun foo(input: List&lt;String&gt;, modifier1: Function&lt;List&lt;String&gt;&gt;? = null){

}

modifier1.apply(input)
fun foo(input:String,  modifier2: (List&lt;String&gt;) -&gt; (List&lt;String&gt;){
}

modifier2(input)
service.foo(input, ::myModifierFunction)

fun myModifierFunction(input:List&lt;String&gt;):List&lt;String&gt;{
   //do something
   return input
}

data class Person(val name: String, val age: Int)

fun main(args: Array&lt;String&gt;) {
    var muchos = "muchos"

    fun dada(){
        println("dada")}
    var someRun = Runnable { println(muchos) }

    with(someRun){
        fun dada(){
            println("dodo")}
        run()
        muchos = "holas"
        //*********************//DOES'T COMPILE *******************
        this@OuterClass.dada() //DOES'T COMPILE *******************
        run()

    }
}

Property must be initialized or be abstract
a
class Foo {
    private val a: Int

    init {
        a = 42
        throw Exception()
    }
}

fun main() {
    Foo()
}

fun bar() {
    throw Exception()
}

class Foo {
    private val a: Int

    init {
        a = 42
        bar()
    }
}

fun main() {
    Foo()
}

class Foo {
    private val a: Int = throw Exception()
}

fun main() {
    Foo()
}

public class Test {
    private static class Foo {
        private final int a;

        public Foo() throws Exception {
            a = 42;
            throw new Exception();
        }
    }

     public static void main(String []args) throws Exception {
         new Foo();
     }
}


fun sum(number: Int) : Int {

    var sum = 0
    var i = 0
    while (i &lt;= number) {
        sum += i
        i++
    }
    return sum

}

fun main(args: Array&lt;String&gt;) {
    println(sum(10))  // 55

MutableList
kotlin
class Foo() {
    fun one() {
        //do something
    }

    fun two() {
        // do something
    }

    fun three() {
        // do something
    }
}

class Foo() {
    fun one() {
        log.call()
        //do something
    }

    fun two() {
        log.call()
        // do something
    }

    fun three() {
        log.call()
        // do something
    }
}

                   map[key]?.let{ value-&gt;

fun majorityElement(nums: IntArray): Int {
        HashMap&lt;Int,Int&gt;().let{ map -&gt;
                nums.forEach{ key-&gt;        
                   map[key]?.let{ value-&gt;
                        map[key]=value+1
                    }?:map[key]=1

                }
                map.forEach{entry-&gt;
                    if(entry.value&gt;nums.size/2){
                        return entry.key
                    }
                }
        }
        return -1
    }

fun notInPlaceRevers(array : IntArray): IntArray{
  val arrayB = IntArray(5)

  for (i in 0 until array.size)
      array[i] =  array[(array.size -1)  - i]

  return arrayB
}



fun main(args: Array&lt;String&gt;) {
  val initialArray = intArrayOf(2,3,4,5,6)

  print("${notInPlaceRevers(initialArray)}")
}

for(element in initialArray)
  print("$element")

    fun process(string: String?): Int {
        if (string != null) {
            return string.filter { it.equals("a") }.length
        }
        return 0
    }

it.equals("a")
Call replaceable with binary operator
Alt-Enter
    fun process(string: String?): Int {
        if (string != null) {
            return string.filter { it == "a" }.length
        }
        return 0
    }

Operator '==' cannot be applied to Char and String
var a:String? = null
var b:String? = null
a, b = "Text"

this
with
inline fun A.foo(bar: B, crossinline block: B.() -&gt; Unit) {
    with (bar) {
        this@A.doSomething() // compile error, "unresolved reference @A"
        block()
    }
}

inline fun A.foo(bar: B, crossinline block: B.() -&gt; Unit) {
    val self = this
    with (bar) {
        self.doSomething() // okay, but ugly
        block()
    }
}

fun receiveDogs(vararg dog: Dog){
    processDogs(dog)
    ... //more cool stuff
}

fun processDogs(vararg dog: Dog){
  .....//cool stuff
}

processDogs(dog)
&lt;out Dog&gt;
abstract class FooTable&lt;M, D&gt; where M : IModel, D : IDto {

    ///...

    fun getTableData(models: ArrayList&lt;M&gt;): ArrayList&lt;D&gt; {
        // ...
    }

}

abstract class FooPage&lt;M, F&gt; where M : IModel, F : IFilter {
    abstract val table: FooTable&lt;M, out IDto&gt;

page.table.getTableData(arrayListOf(m1, m2)).first()

FooTable&lt;out IModel, out IDto&gt;
public final fun getTableData(models: kotlin.collections.ArrayList&lt;M&gt; /* = java.util.ArrayList&lt;M&gt; */): kotlin.collections.ArrayList&lt;D&gt; /* = java.util.ArrayList&lt;D&gt; */
com.menighin.example.models.FooTable
interface IModel

interface IDto

interface IFilter

class Model : IModel

class Dto : IDto

class Filter : IFilter

class FooTable&lt;M, D&gt; where M : IModel, D : IDto {
    fun getTableData(models: List&lt;M&gt;): ArrayList&lt;D&gt; {
        return ArrayList()
    }

    fun testPage(masterModel: IModel, thisPage: FooPage&lt;out IModel, out IFilter&gt;) {
        thisPage.table.getTableData(arrayListOf(masterModel)) // Error here
    }

    fun testTable(masterModel: IModel, masterTable: FooTable&lt;out IModel, out IDto&gt;) {
        masterTable.getTableData(arrayListOf(masterModel)) // And error here
    }
}

class FooPage&lt;M, F&gt; where M : IModel, F : IFilter {
    val table: FooTable&lt;M, out IDto&gt; = FooTable()
}


fun main() {

    val page = FooPage&lt;Model, Filter&gt;()

    val a = page.table.getTableData(arrayListOf())

    println("Hello, world!!!")
}

FooTable
abstract val table: FooTable&lt;M, out IDto&gt;
abstract val table: FooTable&lt;M, Any&gt;
FooTable
IDto
fun main(args: Array&lt;String&gt;) {
    println("Hello, World!")
}

$kotlinc hello.kt -include-runtime -d hello.jar

$java -jar hello.jar

$no main manifest attribute, in hello.jar

Platform declaration clash: The following declarations have the same JVM signature (getName()Ljava/lang/String;):
  • public open fun getName(): kotlin.String?
  • internal final fun &lt;get-name&gt;(): kotlin.String?

JavaInterface.java
public interface JavaInterface {
  public String getName();
}

KotlinClass.kt
public class KotlinClass(val name: String?) : JavaInterface

override fun getName(): String? = name
public class KotlinClass(val namePrivate: String?) : JavaInterface {
  override fun getName(): String? = namePrivate
}

fun main(args:Array&lt;String&gt;)
{
    var input = Scanner(System.'in')

    println("Enter input : ")

    var userInput = input.nextInt()

    println("You entered : $userInput")
}

Kotlin: Expecting an element

val sc = Scanner(System.in)
val num1 = sc.nextInt()
val num2 = sc.nextInt()
val sum = sum(num1, num2)

 class User{
            /*private*/ var userName: String = "Emily"

            fun getUserName(): String{
                return userName
            }
        }

        fun main(args: Array&lt;String&gt;){
            val User = User()
            print(User.getUserName())
        }

MutableMap
val myMap = mutableMapOf&lt;String, Set&lt;String&gt;&gt;().withDefault { mutableSetOf() }

getOrImplicitDefault
withDefault
MutableMap&lt;String, Set&lt;String&gt;&gt;
MutableMapWithDefault
get
MutableMap
defaultValue
withDefault
return parsers.map { it.parse(content) }.firstOrNull { it != null }

return parsers.firstOrNull { it.parse(content) != null }?.parse(content)

parse()
for (parser in parsers) {
    val result = parser.parse(content)
    if (result != null) {
        return result
    }
}
return null

parsers.forEach { it.parse(content)?.run { return this } }
return null

groupBy
ByteArray
IntArray
inline fun &lt;T, K&gt; Array&lt;out T&gt;.groupBy(
    keySelector: (T) -&gt; K
): Map&lt;K, List&lt;T&gt;&gt;

inline fun &lt;T, K&gt; Array&lt;out T&gt;.groupBy(
    keySelector: (T) -&gt; K
): Map&lt;K, List&lt;T&gt;&gt;
inline fun &lt;K&gt; ByteArray.groupBy(
    keySelector: (Byte) -&gt; K
): Map&lt;K, List&lt;Byte&gt;&gt;
inline fun &lt;K&gt; ShortArray.groupBy(
    keySelector: (Short) -&gt; K
): Map&lt;K, List&lt;Short&gt;&gt;
inline fun &lt;K&gt; IntArray.groupBy(
    keySelector: (Int) -&gt; K
): Map&lt;K, List&lt;Int&gt;&gt;

...

IntArray
Array
verySpecialGroupBy
Array
double
65555
byte
19
class UserInfo (val username:String, val age:String)

data class UserInfo (val username:String, val age:String)

Class&lt;T&gt;
Class&lt;T&gt; where T : Enum&lt;T&gt;
fun &lt;T : Any&gt; handleAny(classOfT: Class&lt;T&gt;) {
    if (classOfT.isEnum) {
        handleEnum(classOfT)
    }
}

fun &lt;T : Enum&lt;T&gt;&gt; handleEnum(classOfT: Class&lt;T&gt;) { /*...*/ }

inferred type T is not a subtype of kotlin.Enum&lt;T&gt;
val list = generateSequence(1) { it + 1 }
    .take(50_000_000)
    .toList()

measure {
    list
        .filter { it % 3 == 0 }
        .average()
}
// 8644 ms

val sequence = generateSequence(1) { it + 1 }
    .take(50_000_000)

measure {
    sequence
        .filter { it % 3 == 0 }
        .average()
}
// 822 ms

val result = sequenceOf("a", "b", "c")
    .map {
        println("map: $it")
        it.toUpperCase()
    }
    .any {
        println("any: $it")
        it.startsWith("B")
    }

String
.length
Collections
.size
val dm = DisplayMetrics()
getWindowManager().getDefaultDisplay().getMetrics(dm)

var screenAdjust:Float = (dm.densityDpi / 160f)

var x:Int = (116f * screenAdjust).toInt()
debugText.text=x.toString()
window.showAtLocation(changeTextSize, Gravity.CENTER_HORIZONTAL or Gravity.BOTTOM, 0, x)

public inline fun &lt;S, T : S&gt; Iterable&lt;T&gt;.reduce(operation: (acc: S, T) -&gt; S): S 

refresh()
var viewAlpha= 255
        set(value) {
            field = value
            refresh()
        }

fun refresh() {
    viewAlpha = 255
    invalidate()
}

    package &lt;package name&gt;

    import kotlin.reflect.KProperty


    fun main(){

        val test = Test()

        test.hour = 25

        print(test.hour)    

        // this works:      print(test.hour as Number)   ("No cast needed")

    }

    // just a class which uses the delegate
    class Test {
        var hour by CyclicVariable(24)
    }

    // the delegate class
    class CyclicVariable(val max: Number, var value: Number = 0){

        operator fun getValue(reference: Any?, property: KProperty&lt;*&gt;): Number = value.toDouble()

        operator fun setValue(reference: Any?, property: KProperty&lt;*&gt;, value: Number) {
            val result = value.toDouble() % max.toDouble()
            this.value = if (result &gt;= 0) result else max.toDouble() + result
        }

    }


1.0
Error:(12, 11) Kotlin: Smart cast to 'Int' is impossible, because 'test.hour' is a mutable property that could have been changed by this time
ArrayList
var dynamicarray =ArrayList&lt;Int&gt;(4,{ArrayList&lt;Int&gt;(3)}) //error

ArrayList
var staticarray = Array(4,{IntArray(3)}) // no error

val list: List&lt;Int&gt; = listOf(1, 2, 3)
val newList = mutableListOf&lt;Int&gt;()
    val sum: List&lt;Int&gt; = list.fold(newList) { (acc: List&lt;Int&gt;, i: Int) -&gt; {
        acc.add(i + 10)
        acc
    }}

list.reduce((acc, item) =&gt; {
   acc.push(item + 10)
   return acc;
}, [])

data class Person(var name: String, var hobbies: List&lt;String&gt;)

val people = mutableListOf(
        Person("joe", asList("biking", "baking")),
        Person("jane", asList("baking")),
        Person("jack", asList("painting"))
)
val map = mutableMapOf&lt;String, List&lt;String&gt;&gt;()

for ((name, hobbies) in people) {

    for (hobby in hobbies) {

        var peopleWithThisHobby = map.getOrElse(hobby, { mutableListOf() })
        peopleWithThisHobby.plus(name)
        map[hobby] = peopleWithThisHobby
    }
}

println(map)

peopleWithThisHobby.plus(name)
add()
var peopleWithThisHobby = map.getOrElse(hobby, { mutableListOf() })
peopleWithThisHobby = peopleWithThisHobby.plus(name)
map[hobby] = peopleWithThisHobby

mutableList()
getOrElse
by
interface Foo&lt;T&gt; {

    fun foo(t: T)
}

inline fun &lt;reified T&gt; createFoo() = object : Foo&lt;T&gt; {

    override fun foo(t: T) {
        // do stuff
    }
}


// This is an error
class StringIntFoo : Foo&lt;String&gt; by createFoo(), Foo&lt;Int&gt; by createFoo()

fun main(){
    val foo = StringIntFoo()
    foo.foo("")
    foo.foo(2)
}


// Doing it manually obviously isn't an issue
class ManualStringIntFoo {

    fun foo(t: String){

    }

    fun foo(t: Int){

    }
}


data class Person(val id: String, val name: String)

@EqualsAndHashCode(includes = 'id')

@EqualsAndHashCode(of = &quot;id&quot;)

data class Person(val id: String) {
   // at least we can guarantee it is present at access time
   var name: String by Delegates.notNull()

   constructor(id: String, name: String): this(id) {
      this.name = name
   }
}

name
expr
  fun eval(expr: Expr): Int =
    when (expr) {
        is Num -&gt;  expr.value
        is Sum -&gt; eval(expr.left)+eval(expr.right)
        else -&gt; throw IllegalArgumentException("Unknown expression")
    }

interface Expr
class Num(val value: Int) : Expr

class Sum(val left: Expr, val right: Expr) : Exp

HashMap
var listOfMaps: List&lt;Map&lt;String, String&gt;&gt; = listOf(mapOf("test" to "test1"), mapOf("test2" to "test3"), mapOf("test4" to "test5"))

get:Map&lt;String,String&gt;
inline
generic
reified
fun log(note: String, block: () -&gt; Unit): () -&gt; Unit {
    print(note)
    return block
}

note
override fun onClick(clicked: View) = log("Green Button") {
    // here the regular onClick functionality goes
}

fun test() = log("foo") { ... }
fun otherTest(a: String, b: Int) = log("bar") { ... }

GlobalScope.launch
fun  &lt;K, V&gt; find(map : Map&lt;K, V?&gt;, predicate: (V?) -&gt; Boolean): K? {
    var key : K? = null
    map.forEach { it -&gt;
        if(predicate(it.value)) {
            key = it.key
            return@forEach
        }
    }
    return key
}

public class GsonRequest&lt;T&gt;(url: String, val clazz: Class&lt;T&gt;) : 
    Request&lt;T&gt;(Request.Method.GET, url, this), ErrorListener

public enum AvroCompatibilityLevel {
   NONE("NONE", AvroCompatibilityChecker.NO_OP_CHECKER),
   // ...

   public final String name;
   public final AvroCompatibilityChecker compatibilityChecker;

   // ...

AvroCompatibilityLevel.NONE.name
Overload resolution ambiguity. All these functions match:

public final val name: String? // coming from the field name

public final val name: String // coming from enum

last
fun foo() {
    val range = 1..3
    range.endInclusive
}

endInclusive
last
endInclusive
apply
roles
UserService
roles
User
data class User(
    var userId: String? = "",
    var roles: List&lt;String&gt; = emptyList()
)

class UserService {

    fun getUser() = User("test_user").apply { roles = roles.asList() }

    var roles: Array&lt;String&gt; = listOf("role1","role2").toTypedArray()

}

roles
UserService
fun foo(bar: String = "ABC", baz: Int = 42) {}

fun foo2(bar: String = "ABC", baz: Int = 42) {
    // do stuff
    foo(bar, baz)
}

fun foo3(bar: String = "ABC", baz: Int = 42) {
    // do other stuff
    foo(bar, baz)
}

foo
import android.os.Bundle
import android.os.CountDownTimer
import android.widget.Button
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import kotlinx.android.synthetic.main.activity_main5.*

class Main5Activity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main5)
        val timer = MyCounter(10000, 1000)
        start.setOnClickListener { timer.start() }
        stop.setOnClickListener { timer.cancel() }
    }
}

class MyCounter(millisInFuture: Long, countDownInterval: Long) : 
CountDownTimer(millisInFuture, countDownInterval) {

    override fun onFinish() {
        println("Timer Completed.")
        qq.text = "Timer Completed."

    }

    override fun onTick(millisUntilFinished: Long) {
        qq.textSize = 50f

        qq.text = (millisUntilFinished / 1000).toString() + ""
        println("Timer  : " + millisUntilFinished / 1000)
    }
}

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".Main5Activity"&gt;

&lt;TextView
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="@string/pomodoro_timer"
        android:textAlignment="center"
        android:textSize="40sp"
        tools:ignore="MissingConstraints"/&gt;

&lt;Button
        android:id="@+id/start"
        android:layout_width="150dp"
        android:layout_height="wrap_content"
        android:layout_marginBottom="8dp"
        android:layout_marginStart="8dp"
        android:background="#55ff00"
        android:text="@string/start_timer"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent" 
android:layout_marginLeft="8dp"&gt;

&lt;/Button&gt;

&lt;Button
        android:id="@+id/stop"
        android:layout_width="150dp"
        android:layout_height="wrap_content"
        android:layout_marginBottom="8dp"
        android:layout_marginEnd="8dp"
        android:background="#ff0000"
        android:text="@string/stop_timer"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent" 
android:layout_marginRight="8dp"&gt;

&lt;/Button&gt;

&lt;TextView
        android:id="@+id/qq"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:layout_marginBottom="332dp"
        android:text=""
        android:textAlignment="center"
        android:textColor="#ff4000"
        android:textSize="50sp"
        app:layout_constraintBottom_toBottomOf="parent"
        tools:layout_editor_absoluteX="0dp" 
tools:ignore="MissingConstraints"/&gt;


&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;

public val Activity.qq: TextView! defined in 
kotlinx.android.synthetic.main.activity_main5 in file activity_main5.xml
public val Dialog.qq: TextView! defined in 
kotlinx.android.synthetic.main.activity_main5 in file 
activity_main5.xml``
public val android.app.Fragment.qq: TextView! defined in 
kotlinx.android.synthetic.main.activity_main5 in file activity_main5.xml
public val androidx.fragment.app.Fragment.qq: TextView! defined in 
kotlinx.android.synthetic.main.activity_main5 in file activity_main5.xml

if(::db.isinitialized) condition
class MainActivity : AppCompatActivity() {

    lateinit var db: DatabaseCommon;

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)


        if(::db.isInitialized) {
            val dbVersion = DatabaseCommon.myInstance.dbVersion;
            val dbName = DatabaseCommon.myInstance.dbName;
            val tableName = DatabaseCommon.myInstance.tableName;
            val name: String = DatabaseCommon.myInstance.name;
            val age: String = DatabaseCommon.myInstance.age;

            try{
                val db = this.openOrCreateDatabase(dbName, Context.MODE_PRIVATE, null)
                var query = "CREATE TABLE IF NOT EXISTS  ${tableName} (${name} VARCHAR, ${age} INT(2))";
                db.execSQL(query)

                query = "INSERT INTO ${tableName} (${name}, ${age}) VALUES ('James', 20)";
                db.execSQL(query);

                Toast.makeText(applicationContext, "CREATED", Toast.LENGTH_LONG);
            }catch(e: Exception) {
                e.printStackTrace();
            }
        }
    }
}

class DatabaseCommon {

    val dbVersion: Int = 1;
    val dbName: String = "db_munsicians";

    val tableName: String = "musicians"
    val name: String = "name";
    var age: String = "age";

    private constructor() {}

    companion object {
        private lateinit var instance: DatabaseCommon;

        val myInstance: DatabaseCommon
            get() {
                if (instance == null) {
                    instance = DatabaseCommon();
                }
                return instance;
            }
    }

    fun returnDbClass() {
        println("I was called");
    }
}

if(::db.isinitialized)
newmatrix = MutableList&lt;MutableList&lt;Int&gt;&gt;
matrix = MutableList&lt;MutableList&lt;Boolean&gt;&gt;
newmatrix
var newmatrix = matrix
// tworzymy macierz równą zero
for (k in 0..matrix.indices.last) {
    for (l in 0..matrix[0].indices.last) {
        newmatrix[k][l] = 0
    }
}

newmatrix
Boolean
Int
fun main(args: Array&lt;String&gt;){
  println(maxOf(args[0], args[1]))
  println(maxOf2(args[0], args[1]))
}

fun maxOf(a: Int, b: Int): Int{
  return if (a&gt;b) a else b
}

fun maxOf2(a: Int, b: Int): Int = if (a&gt;b) a else b

kotlinc test1.kt -include-runtime -d test1.jar

test1.kt:3:18: error: type mismatch: inferred type is String but Int was expected
  println(maxOf2(args[0], args[1]))
                 ^
test1.kt:3:27: error: type mismatch: inferred type is String but Int was expected
  println(maxOf2(args[0], args[1]))
                          ^

println(maxOf2(args[0], args[1]))

println(maxOf2(args[0].toInt(), args[1].toInt()))

object C {
    @JvmStatic
    fun main(vararg args: String) {
        val s: String? = null
        check(s != null) {
            "The string is null"
        }
        require(s != null) {
            "The string is null"
        }
        assert(s != null) {
            "The string is null"
        }
        s.length
    }
}

check()
require()
contract {
    returns() implies value
}

?.
s?.length

!!
s!!.length

val view : View = LayoutInflater.from(context).inflate(R.layout.row_layout,parent,false)

context
Type mismatch: inferred type is fragment_Dep but Context! was expected
package com.iraqairoirt.iraqairports


import android.annotation.SuppressLint
import android.support.v7.widget.AppCompatTextView
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.BaseAdapter

class ListAdapte (val context: fragment_Dep, val list: ArrayList&lt;FlightShdu&gt;): BaseAdapter() {

    @SuppressLint("ViewHolder")
    override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {

        val view : View = LayoutInflater.from(context).inflate(R.layout.row_layout,parent,false)

        val CallsingID = view.findViewById(R.id.callsign_id) as AppCompatTextView
        val StatusID = view.findViewById(R.id.status_id) as AppCompatTextView

        CallsingID.text = list[position].Callsign.toString()
        StatusID.text = list[position].Status

        return view
    }

    override fun getItem(position: Int): Any {
        return list [position]
    }

    override fun getItemId(position: Int): Long {
        return position.toLong()
    }

    override fun getCount(): Int {
        return list.size
    }
}

package com.iraqairoirt.iraqairports

import android.os.AsyncTask
import android.os.Bundle
import android.support.v4.app.Fragment
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup

import com.iraqairoirt.iraqairports.flightsArr.ListAdapteArr
import kotlinx.android.synthetic.main.fragment_arrivel.*
import org.json.JSONArray
import org.json.JSONObject
import java.net.HttpURLConnection
import java.net.URL


@Suppress("UNREACHABLE_CODE")
class fragment_Arr :Fragment(), View.OnClickListener {
    override fun onClick(v: View?) {
//        val intent = Intent(context, FlightsArrbefor::class.java)
//        context!!.startActivity(intent)
    }


    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
        val view = inflater.inflate(R.layout.fragment_arrivel,container,false)


        val url = "xxxxxxxxxxxxxxx/airport.json?code=BGW"
        Dep().execute(url)

        return view
    }


    //    full class for json api
    inner class Dep : AsyncTask&lt;String, String, String&gt;(){


        override fun onPreExecute() {
            super.onPreExecute()


        }

        //        for build connection

        override fun onPostExecute(result: String?) {

            super.onPostExecute(result)
            handleJson(result)


        }

        override fun onProgressUpdate(vararg text: String?) {


        }
        //        for build connection
        override fun doInBackground(vararg url: String?): String{

            var text : String
            val connection = URL(url[0]).openConnection() as HttpURLConnection

            try {
                connection.connect()
                text = connection.inputStream.use { it.reader().use{reader -&gt; reader.readText()} }


            } finally{

                connection.disconnect()

            }
            return text
        }


        private fun handleJson (jsonString: String?){

            val jsonObj = JSONObject(jsonString)
            val result = jsonObj.getJSONObject("result")
            val response = result.getJSONObject("response")
            val airport = response.getJSONObject("airport")
            val pluginData = airport.getJSONObject("pluginData")
            val schedule = pluginData.getJSONObject("schedule")
            val departures = schedule.getJSONObject("departures")
//        val data = arrivals.getJSONObject("data")
            val jsonArray = JSONArray(departures.get("data").toString())

            val list =  ArrayList&lt;FlightShdu&gt;()
            var x = 0
            while (x &lt; jsonArray.length()){

                val jsonObject = jsonArray.getJSONObject(x)



                list.add(FlightShdu(
                    jsonObject.getJSONObject("flight").getJSONObject("identification").getJSONObject("number").getString("default"),
                    jsonObject.getJSONObject("flight").getJSONObject("airline").getString("short"),
                    jsonObject.getJSONObject("flight").getJSONObject("status").getJSONObject("generic").getJSONObject("status").getString("text"),
                    jsonObject.getJSONObject("flight").getJSONObject("airline").getJSONObject("code").getString("icao"),
                    jsonObject.getJSONObject("flight").getJSONObject("time").getJSONObject("scheduled").getString("departure"),
                    jsonObject.getJSONObject("flight").getJSONObject("airport").getJSONObject("destination").getJSONObject("code").getString("iata"),
                    jsonObject.getJSONObject("flight").getJSONObject("aircraft").getJSONObject("model").getString("code"),
//                    for more information
                    jsonObject.getJSONObject("flight").getJSONObject("time").getJSONObject("real").getString("departure"),
                    jsonObject.getJSONObject("flight").getJSONObject("time").getJSONObject("estimated").getString("departure"),
//                    jsonObject.getJSONObject("flight").getJSONObject("time").getJSONObject("estimated").getString("arrival"),
                    jsonObject.getJSONObject("flight").getJSONObject("aircraft").getString("registration"),
                    jsonObject.getJSONObject("flight").getJSONObject("status").getJSONObject("generic").getJSONObject("status").getString("diverted"),
                    departures.getString("timestamp"),
                    jsonObject.getJSONObject("flight").getJSONObject("status").getString("icon")



                ))


                x++
            }
            list.forEach(::println)

            val adapter = ListAdapteArr(list)
            flight_arrivel_list.adapter = adapter

        }




    }



}

data class User(val name: String = "", val age: Int = 0)

var user = User [] // this is not working

user[0].name // something like this!

fun toJSON(collection: Collection&lt;Int&gt;): String {
    val str = collection.reduce{ a:String, b:Int -&gt; ""}
    return str.toString()
}

Error:(2, 25) Type parameter bound for T in inline fun &lt;S, T : S&gt; Iterable&lt;T&gt;.reduce(operation: (S, T) -&gt; S): S
is not satisfied: inferred type Int is not a subtype of String
var emailText
    get() = presenter.emailText
    set(value) {
        presenter.emailText = value
    }

var emailText by PropertyDelegate(presenter.emailText)

data class
Date
KotlinJS
LocalDate
import java.time.LocalDate
import java.time.format.DateTimeFormatter
import java.util.*

data class transaction (var date: LocalDate, var quantity: Double)
val formatter: DateTimeFormatter
    get() = DateTimeFormatter.ofPattern("dd.mm.yyyy", Locale.ENGLISH)

fun main(args: Array&lt;String&gt;) {
    var salesOrders = ArrayList&lt;transaction&gt;()

    println("Hello, world! ")

    salesOrders.set(0, transaction(LocalDate.parse("01.02.2018", formatter), 0.0))


    println(salesOrders)

}

javap -cp target.jar -verbose fully.qualified.class.name | grep major

interface CrudRepo {
  fun save()
  fun saveAll()
}

interface CustomRepo : CrudRepo {
  fun validate()
  override fun save() {
    validate()
    saveAll() // can call saveAll, I need to call save on CrudRepo here
  }
}

CrudRepo
CrudRepo
save
save
CrudRepo
a()
var quackBehavior: QuackBehavior? = null

fun a(){
    quackBehavior?.let{
        it("I want print this message")
    }
}

fun printMessage(){
    quackBehavior = {
        println(it)
    }
}

fun main() {
    a()
}

typealias QuackBehavior = (String) -&gt; Unit
``

val aList = Array(5, {Array&lt;String&gt;(2){ " " }})
aList[0] = ArrayList(input.nextLine().split(" "))  // `split` returns a List

error: type inference failed. Expected type mismatch: inferred type is ArrayList&lt;String!&gt; but Array&lt;String&gt; was expected
T!
T or T?
ArrayList&lt;String!&gt;
Array&lt;String&gt;
id
id
data class Resource(val id: String?, val property: String)
sealed class Resource(val property: String) {
  class WithoutID(property: String): Resource(property)
  class WithID(val id: String, property: String): Resource(property)
}

Resource.WithID
Resource.WithoutID
id
property
Pair
List
Pair(a, b).toList()

Pair(list[0], list[1])

List
listOf(a, b).toPair()

class LockFragment extends  Fragment implements IOnBackPressed

class LockFragment : Fragment() : IOnBackPressed

data class Pet(val name: String)

data class Household (
   val pet: Pet,
   ... 
)

data class District(
   val allPets: Set&lt;Pet&gt;,
   val allHouseholds: List&lt;Household&gt;,
   ...)

fun Locality.findFeralPets(): Set&lt;Pet&gt; =

allPets.filter { pet -&gt; pet.name != "Bob" }

fun x() : Int { return 10 }
val y : () -&gt; Int = ::x
val z : () -&gt; Int = { 10 }

fun main(args: Array&lt;String&gt;) {
    println(::x) 
    println(y)   
    println(z)    
}

fun x(): kotlin.Int
fun x(): kotlin.Int
() -&gt; kotlin.Int

() -&gt; Int
fun x
y
::
val y = x
as
as?
(origin as? Implementor)?.someFunction()

(origin as Implementor?)?.someFunction()

var foo : String by Foo(init: {"bar"})

print(foo) // prints "bar"
foo = null // or foo.reset()
print(foo) // prints "bar"

apply
List(1, 2, 3)
List(1, 2, 3)
listOf(1, 2, 3)
List
List
public inline fun &lt;T&gt; List(size: Int, init: (index: Int) -&gt; T): List&lt;T&gt;
wait
notify
while (true) {
    val data = fetchData()
    processData(data)
    if (data.isEmpty()) {
        wait()
    }
}

fetchData
import java.util.*

fun main(args: Array&lt;String&gt;) {
    val (a, u) = readLine()!!.split(' ').map(String::toInt)

    println(add(a, u))
}

fun  add(a: Int, u: Int) = a + u

Exception in thread "main" java.lang.NumberFormatException: For input string: ""
    at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
    at java.lang.Integer.parseInt(Integer.java:592)
    at java.lang.Integer.parseInt(Integer.java:615)
    at Kotlin_learnKt.main(kotlin^learn.kt:6)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)

Process finished with exit code 1

fun main(args: Array&lt;String&gt;) {
     val PASSWORD_REGEX = """^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%!\-_?&amp;])(?=\\S+$).{8,}""".toRegex()
    val password:String = "Align@123"
    println(PASSWORD_REGEX.matches(password))
}

class Test {
  var stringRepresentation: String
    get() = field
    set(value) {
      setDataFromString(value) 
    }

  init {
    stringRepresentation = "test"
  }

  private fun setDataFromString(value: String) { }
}

init
class Test {
  // Compilation error: "Property must be initialized"
  var stringRepresentation: String
    set(value) {
      setDataFromString(value)
    }

  init {
    stringRepresentation = "test"
  }

  private fun setDataFromString(value: String) { }
}

class Test {
  var stringRepresentation: String
    get() = field 

  init {
    stringRepresentation = "test"
  }

  private fun setDataFromString(value: String) { }
}

init
init
class Test {
  var stringRepresentation: String = "" // Does not call custom setter
    set(value) {
      setDataFromString(value)
    }

  init {
    stringRepresentation = "test" // Calls custom setter
  }

  private fun setDataFromString(value: String) { }
}

List&lt;T&gt;
Pair&lt;T,T&gt;
for (index in 0 until list.size-1) {
        val current = list[index]
        val next = list[index + 1]
        //do calculations on current/next.
    }

list.forEachPaired { it: Pair&lt;String,String?&gt; -&gt;//do something }
class UserManager @Inject constructor(
        val prefs: SharedPreferences,
        val jsonAdapter: JsonAdapter&lt;User&gt;
    ) {

    companion object {
        val USER = "user"
    }

    var user: User = User()
        set(value) {
            field = value
            prefs.edit().putString(USER, jsonAdapter.toJson(user)).apply()
        }

    init {
        val userString = prefs.getString(USER, null)
        if (userString != null) {
            user = jsonAdapter.fromJson(userString)
        }
    }
}

fun myHigherOrderFun(functionArg: (Int)-&gt;String) = functionArg(5)
println ( myHigherOrderFun { "The Number is $it" })
prints "The Number is 5"

class Time(time: Int){
   var time: Int = time
     get()= if(field &gt; 127){
            127
          }else if(){
           -128
          }
          else{
            field
          }
}


class Time(time: Int){
   var time: Int = time
      get()= {
          if(field &gt; 127){
            127
          }else if(){
            -128
          }
          else{
            field
          }
        }
}

replicate(n:Int,x:T):List&lt;T&gt;
fun &lt;T&gt; mutableReplicate(n:Int, x:T) : MutableList&lt;T&gt;{
    val xs = mutableListOf&lt;T&gt;()
    for (i in 1..n){
        xs.add(x)
    }
    return xs
}

val myBoolean = false &amp; true

#!/usr/bin/env kscript
@file:DependsOn("com.domain.project:name:1.0-SNAPSHOT")

 #!/usr/bin/env kscript
 @file:DependsOn("com.github.username.project")

val globalList = listOf("a1" to "b1", "a2" to "b2")
object MatrixObject {
 var table: Array&lt;Array&lt;Int&gt;&gt;? = null

 fun randOf(n: Int) {
    table= Array(n, { Array(n, { Random().nextInt(100 - 0) + 0 }) })
 }

 var tableF: Array&lt;Array&lt;Int&gt;&gt;? = null
    get() {
        if (field==null)
          factorization()
        return field
    }

 fun factorization() {
        tableF = table!! 
        ...     //here I change elements of tableF
  }


}

 for(row in 0 until table!!.size)
   tableF!![row] = Arrays.copyOf(table!![row], table!![row].size)

 for(row in 0 until table!!.size)
   tableF!![row] = table!![row].clone() // and copyOf()

Item
ItemFood : Item
Item
registerItem(item: Item, name: String)
ItemKey : Item
ItemBerry : ItemFood
name: String
ItemKey
ItemBerry
NamedItem
fun registerNamedItem(namedItem: NamedItem) {
    registerItem(namedItem, namedItem.name)
}

class NamedItem(val name: String) : Item
ItemFood
Item
class NamedItem(val item: Item, val name: String)
Item
item
registerItem(namedItem.item, namedItem.name)
interface INamedItem { val name: String }
ItemKey
ItemBerry
fun registerNamedItem(item: Item, namedItem: INamedItem) {
    registerItem(item, namedItem.name)
}

registerNamedItem
registerItem(item: Item, name: String)
NamedItem
namedItem.name
object TimeCalc {
    private const val SECONDS: Int = 1000
    private const val MINUTES: Int = SECONDS * 60
    private const val HOURS: Int = MINUTES * 60
    private const val DAYS: Int = HOURS * 24

    fun timeDiff(sTime: Long, eTime: Long){
        Log.i("Test", "sec $SECONDS: min $MINUTES : hrs $HOURS : days $DAYS")
        var startTime = sTime
        var endTime = eTime
        var mDiff: Int
        var mHours: Int
        var mMinutes: Int
        var mSeconds:Int
        var mMilliS: Int

        Log.i("Test", "$startTime - $endTime")

        mDiff = (endTime - startTime).toInt()
        Log.i("Test", "Diff = $mDiff")
        **mHours = mDiff.rem(DAYS)**
        Log.i("Test", "Hours = $mHours")

        Log.i("Test", "${mHours}")
    }
}

I/Test: sec 1000: min 60000 : hrs 3600000 : days 86400000
I/Test: 1545062123189 - 1545062217296
I/Test: Diff = 94107
I/Test: Hours = 94107
I/Test: 94107

val myList: List&lt;Int&gt;? = listOf()
if(!myList.isNullOrEmpty()){
    // myList manipulations
}

if(!myList.orEmpty().isNotEmpty()){
    // Compiler thinks myList can be null here
    // But this is not what I want either, I want the extension fun below
}

if(myList.isNotEmptyExtension()){
    // Compiler thinks myList can be null here
}

private fun &lt;T&gt; Collection&lt;T&gt;?.isNotEmptyExtension() : Boolean {
    return !this.isNullOrEmpty()
}

public class Test {
    static class Builder&lt;B extends Builder&lt;B&gt;&gt;{
        B asBuilder() {
            return (B) this;
        }
    }

    public static &lt;B extends Builder&lt;B&gt;&gt; B newBuilder() {
        return new Builder&lt;B&gt;().asBuilder();
    }
}

Test.newBuilder()
Type expected
Test.newBuilder&lt;&gt;()
Test.newBuilder&lt;Test.Builder&gt;()
One type argument expected for class Builder&lt;B : Test.Builder&lt;B!&gt;!&gt;
org.apache.logging.log4j.core.layout.GelfLayout.newBuilder()

(String) -&gt; Int
{s: String -&gt; s.length }
String.() -&gt; Int
open class LibraryClass{
    var x: Int = 0

    fun setMyX(x_: Int){
        x = x_
    }
}

interface MyInterface{
    var y: Int
    var z: Int
    var abc: Int

    fun myMethod(y_: Int){
        y = y_
        z = y*y
    }
} 

class InheritanceTest: LibraryClass(), MyInterface{    
    fun print(){
    println("My values: $x, $y, $z")
    }
}

fun main(){
    var test = InheritanceTest()
    test.setMyX(1)
    test.myMethod(5)
    test.print()    
}

error: class 'InheritanceTest' is not abstract and does not implement abstract member public abstract var y: Int defined in MyInterface

class InheritanceTest(override var y: Int, override var z: Int, override var abc: Int)

var test = InheritanceTest(2,3,0)

var fgh: Int 
    get()  { return fgh }
    set(v) { fgh = v }

test.fgh = 100
main()
Exception in thread "main" java.lang.StackOverflowError
    at MyInterface$DefaultImpls.setFgh(

test.setFgh(100)
error: unresolved reference: setFgh

setFgh(v: Int) {fgh = v}
error: platform declaration clash: The following declarations have the same JVM signature (setFgh(I)V):
    fun &lt;set-fgh&gt;(v: Int): Unit defined in MyInterface
    fun setFgh(v: Int): Unit defined in MyInterface

myMethod()
fun myOtherMethod(v: Int){    
    fgh = v 
    z = fgh * fgh
}

myOtherMethod(10)
main()
Exception in thread "main" java.lang.StackOverflowError
    at MyInterface$DefaultImpls.setFgh

open class A (a: String, b: String, c: String)

class B(a: String, b: String, c: String, d: String) : A(a, b, c)

class B(super, d:String) : A(super)

List.get
get(-1)
operator fun &lt;T&gt; List&lt;T&gt;.get(index: Int): T {
    return this[if (index &lt; 0) size + index else index]
}

scratch.kts:3:26: warning: extension is shadowed by a member: public abstract operator fun get(index: Int): T
operator fun &lt;T&gt; List&lt;T&gt;.get(index: Int): T {
                         ^

fun accountInThreeYears(initial: Int, percent: Int): Double = initial + (initial * percent / 100.toDouble()) * 3

val jsonObj = json as JsonObject
as
open class WeatherDeserializer : JsonDeserializer&lt;WeatherObject&gt; {

    override fun deserialize(json: JsonElement?, typeOfT: Type?, context: JsonDeserializationContext?): WeatherObject? {
        val jsonObj = json as JsonObject

        val wheather = WeatherObject()
        val wind = WindObject()

        val jsonWeatherArray = jsonObj.getAsJsonArray("weather").get(0)
        val jsonMainObj = jsonObj.getAsJsonObject("main")
        val jsonWindObj = jsonObj.getAsJsonObject("wind")

        wheather.main = jsonWeatherArray.asJsonObject.get("main").asString
        wheather.description = jsonWeatherArray.asJsonObject.get("description").asString
        wheather.temp = jsonMainObj.get("temp").asFloat
        wheather.tempMax = jsonMainObj.get("temp_max").asFloat
        wheather.tempMin = jsonMainObj.get("temp_min").asFloat
        wheather.humidity = jsonMainObj.get("humidity").asInt
        wind.speed = jsonWindObj.get("speed").asFloat
        wind.deg = jsonWindObj.get("deg").asFloat
        wheather.wind = wind

        return wheather

    }
}

coverView.viewTreeObserver.addOnPreDrawListener {
    coverView.viewTreeObserver.removeOnPreDrawListener(this)
    true
}

this
isBackgroundWindow
PreferenceTool
private val prefs: SharedPreferences by lazy {  }
PreferenceTool&lt;T&gt;
PreferenceTool(this, getString(R.string.IsBackgroundName) , false),
private lateinit var isBackgroundWindow: Boolean by PreferenceTool(this, getString(R.string.IsBackgroundName) , false)
class UIHome : AppCompatActivity() {   

   //I think the object this is not initialized, it will cause null error.
    private var isBackgroundWindow: Boolean by PreferenceTool(this, getString(R.string.IsBackgroundName) , false) 

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.layout_home)

        isBackgroundWindow=false
     }

}

class PreferenceTool&lt;T&gt;(private val context: Context, private val name: String,  private val default: T) {

    private val prefs: SharedPreferences by lazy {     
        context.defaultSharedPreferences     
    }

    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T = findPreference(name, default)

    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) {
        putPreference(name, value)
    }

    @Suppress("UNCHECKED_CAST")
    private fun findPreference(name: String, default: T): T = with(prefs) {
        val res: Any = when (default) {
            is Long -&gt; getLong(name, default)
            is String -&gt; getString(name, default)
            is Int -&gt; getInt(name, default)
            is Boolean -&gt; getBoolean(name, default)
            is Float -&gt; getFloat(name, default)
            else -&gt; throw IllegalArgumentException("This type can be saved into Preferences")
        }

        res as T
    }

    @SuppressLint("CommitPrefEdits")
    private fun putPreference(name: String, value: T) = with(prefs.edit()) {
        when (value) {
            is Long -&gt; putLong(name, value)
            is String -&gt; putString(name, value)
            is Int -&gt; putInt(name, value)
            is Boolean -&gt; putBoolean(name, value)
            is Float -&gt; putFloat(name, value)
            else -&gt; throw IllegalArgumentException("This type can't be saved into Preferences")
        }.apply()
    }
}

sealed class Foo&lt;A&gt; {
  data class Bar&lt;A&gt;(val value: Int): Foo&lt;A&gt;()
}

Bar&lt;Int&gt;
::
Foo&lt;Int&gt;::Bar&lt;Int&gt;
::Foo.Bar&lt;Int&gt;
::(Foo.Bar&lt;Int&gt;)
import com.package.Foo.Bar

::Bar
Bar&lt;Int&gt;::value
::
Foo::Bar
mutableMap&lt;String, Int&gt;
0
0 + 3
Iterable.fold(...)
operation
val numbers = listOf(5, 2, 10, 4)

// operation function passed as the second param of fold
val sumDoubled1 = numbers.fold(0, { sum, n -&gt; sum + n * 2 })
println(sumDoubled1)

// operation function after the closing paren of fold
val sumDoubled2 = numbers.fold(0) { sum, n -&gt; sum + n * 2 }
println(sumDoubled2)


User
User
data class User (
@Id
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "sequenceGenerator")
@SequenceGenerator(name = "sequenceGenerator")
var id: Long? = null,
...
)

import static org.assertj.core.api.Assertions.assertThat;

public class TestUtil {
    public static void equalsVerifier(Class clazz) throws Exception {
        Object domainObject1 = clazz.getConstructor().newInstance();
        // Test with an instance of the same class
        Object domainObject2 = clazz.getConstructor().newInstance();
        assertThat(domainObject1).isNotEqualTo(domainObject2);
    }
}

assertThat(domainObject1).isNotEqualTo(domainObject2)
domainObject1
domainObject2
 val map = HashMap&lt;String, Set&lt;String&gt;&gt;()

?.let
?.let
block
?.apply
?.run
if
BufferedReader().use {}
close()
use
fun main() {
    sendGet()
}

fun sendGet() {
    val queryUrl = "http://www.google.com/search?q=kotlin&amp;ie=utf-8&amp;oe=utf-8"
    val url = URL(queryUrl)
    val conn = url.openConnection() as HttpURLConnection
    conn.requestMethod = "GET"
    conn.setRequestProperty("User-Agent", "Mozilla/5.0")

    val responseCode = conn.responseCode
    println("Response code: ${responseCode}")

    when (responseCode) {
        200 -&gt; {
            println("response: ${conn.getResponseText()}")
        }
        else -&gt; println("Bad response code: ${responseCode}")
    }

}

private fun HttpURLConnection.getResponseText(): String {
    BufferedReader(InputStreamReader(inputStream)).use {
        return it.readText()
    }
}

`this `fails with` "the state is propagated"`

kotlin
class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContentView(R.layout.activity_main)      
            main()  
        }
           private fun main(){
          val letter : Char
          val arrayNumber: IntArray = intArrayOf(1,2,3,4,5,6,7,8,9)        
          println("with : " +"${arrayNumber.size}")
          println("without : " +arrayNumber.size)        
      }
}

 I/System.out: with : 9
 I/System.out: without : 9

fun main(args: Array&lt;String&gt;) {
    val age1 = 42.toDouble()
    val age2 = 21.toDouble()

    println("Average = ${(age1 + age2)/2}")

println("Average = " + "%.3f".format((age1 + age2)/2))

    override fun setContentView(layoutResID: Int) {
    super.setContentView(layoutResID)
    val toolbar = findViewById(R.id.toolbar) as? Toolbar
   if(toolbar!=null){ setSupportActionBar(toolbar)
    supportActionBar!!.setDisplayHomeAsUpEnabled(true)}
}
fun setMaterialTheme(newTheme: Int) {
    setTheme(newTheme)
    setContentView(R.layout.settings_fragment)
    saveTheme(newTheme)
}

 &lt;androidx.appcompat.widget.Toolbar
                android:id="@+id/toolbar"
                android:layout_width="match_parent"
                android:layout_height="?attr/actionBarSize"
                android:background="?attr/colorPrimary"
                android:elevation="4dp"
                android:foregroundTint="#CDFFFFFF"
                android:outlineProvider="paddedBounds"
                app:layout_constraintBottom_toTopOf="@+id/textInputLayout"
                app:layout_constraintEnd_toEndOf="parent"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintTop_toTopOf="parent"
                app:subtitleTextColor="#CDFFFFFF"
                app:titleTextColor="#CDFFFFFF" /&gt;

 override fun onViewCreated(view: View, savedInstanceState: Bundle?)
{
    nightThemeSwitch = view?.findViewById(R.id.night_theme_switch)
    super.onViewCreated(view, savedInstanceState)
    readSettings()
    nightThemeSwitch?.setOnCheckedChangeListener{
            buttonView: CompoundButton, isChecked: Boolean -&gt;
        if (isChecked) {
            (activity as MainActivity).setMaterialTheme(R.style.AppTheme_Night)
        } else {
            (activity as MainActivity).setMaterialTheme(R.style.AppTheme)
        }
    }
}

arrayOfNulls()
stack = stack.stream()
    .map(e -&gt; // some code here)
    .collect(Collectors.toCollection(ArrayDeque::new));

stack = stack.withIndex()
    .map { (i, v) -&gt; {
        // some code here
    }}
    .toCollection(ArrayDeque::new)

var stack = ArrayDeque&lt;Long&gt;()

for (op in operations){
    val split = op.split(' ')
    when (split[0]) {
        "push" -&gt; {
            stack.push(split[1].toLong())
        }
        "pop" -&gt; {
            stack.pop()
        }
        else -&gt; {
            stack = stack.withIndex()
                .map { (i, v) -&gt; {
                    if (i &lt; split[1].toInt())
                        v + split[2].toLong()
                    else
                        v
                }}
                .toCollection(ArrayDeque())
        }
    }

    if (stack.isEmpty()){
        println("EMPTY")
    } else {
        println(stack.peekFirst()!!)
    }
}

error: type inference failed. Expected type mismatch: inferred type is ArrayDeque&lt;Long&gt; but ArrayDeque&lt;Long&gt; was expected
val totalById = list
                    .filter { it.status == StatusEnum.Active }
                    .groupBy { it.item.id }
                    .mapValues { it.value.sumBy { it.amount } }

Collectors.groupingBy(i-&gt; i.getItem().getId(), Collectors.mapping(Item::getAmount, Collectors.reducing(BigDecimal.ZERO, BigDecimal::add))))
"Happy Halloween!"
42
interface Type&lt;T&gt;
class StringType() : Type&lt;String&gt;
class IntType1() : Type&lt;Int&gt;
class IntType2(val a: Int, val b: Int) : Type&lt;Int&gt;

fun &lt;T&gt; something(type: Type&lt;T&gt;): T = when (type) {
    is StringType -&gt; "Happy Halloween!"
    is IntType1 -&gt; 42
    is IntType2 -&gt; type.a * type.a + type.b * type.b + type.a * type.b
    else -&gt; throw IllegalArgumentException()
}

val c: Int  // Type required when no initializer is provided
c = 3       // deferred assignment

kotlin.Array
operator fun &lt;T&gt; Array&lt;T&gt;.Companion.invoke() {
}

Array
Array
inline operator fun &lt;reified T&gt; Array&lt;T&gt;.Companion.invoke() {
}

class Foo(length: Int) {
    var length = length
        set(value) {
            if (value &lt; 0) throw IllegalArgumentException("Can't be negative.")
            field = value
        }
    }
}

Foo(-5)
class Foo(length: Int) {
    var length = length
        set(value) {
            if (value &lt; 0) throw IllegalArgumentException("Can't be negative.")
            field = value
        }
    }

    init {
        this.length = length
    }
}

class Foo(length: Int) {
    init {
        if (length &lt; 0) throw IllegalArgumentException("Can't be negative.")
    }

    var length = length
        set(value) {
            if (value &lt; 0) throw IllegalArgumentException("Can't be negative.")
            field = value
        }
    }
}

fun foo(bar: Int = 0, baz: Int) {
    /* ... */
}

public static final void foo(int bar, int baz) {
}

// $FF: synthetic method
// $FF: bridge method
public static void foo$default(int var0, int var1, int var2, Object var3) {
  if ((var2 &amp; 1) != 0) {
     var0 = 0;
  }

  foo(var0, var1);
}

Object var3
class Foo {
    fun foo(bar: Int = 0, baz: Int) {
        /* ... */
    }
}

public final class Foo {
   public final void foo(int bar, int baz) {
   }

   // $FF: synthetic method
   // $FF: bridge method
   public static void foo$default(Foo var0, int var1, int var2, int var3, Object var4) {
      if ((var3 &amp; 1) != 0) {
         var1 = 0;
      }

      var0.foo(var1, var2);
   }
}

Object
fun foo(bar: Int, baz: Int = 0) {}
fun main(args: Array&lt;String&gt;) {
    foo(baz = 2)
}

class Something {
    init {
        foo(baz = 2)
    }
}

public static final void main(@NotNull String[] args) {
      Intrinsics.checkParameterIsNotNull(args, "args");
      foo$default(0, 2, 1, (Object)null);
}

public final class Something {
   public Something() {
      FooKt.foo$default(0, 2, 1, (Object)null);
   }
}

Cars
val listA: ArrayList&lt;Cars&gt; = ArrayList()
listA.add(*API response objects*)

val listB: ArrayList&lt;Cars&gt; = ArrayList()
listB.addAll(listA)

if (imFeelingLucky) listB.removeAt(position)

listB
listA
listA
listB
List&lt;Cars&gt;:
 Car#1:
      *name_of_car
      *car_colors: List&lt;CarColors&gt; ...
 Car#2:
      *name_of_car
      *car_colors: List&lt;CarColors&gt; ...
 Car#3:
      *name_of_car
      *car_colors: List&lt;CarColors&gt; ...

for-loop
class testA {

    val listA: ArrayList&lt;Cars&gt; = ArrayList()

    init {
        getData()
        changeData()
    }

    private fun getData() {
        listA.add(..getting data and population listA)
    }

    private fun changeData(): List&lt;Cars&gt; {
        val listB: List&lt;Cars&gt; = ArrayList()
        listB.addAll(listA)

        for (carPosition in listC.size - 1 downTo 0) {
            for (carColorPosition in listC[carPosition].size - 1 downTo 0) {
                if (!listC[carPosition][carColorPosition]) {
                    listB[carPosition].options.removeAt(carColorPosition)
                }
            }
        }

        for (itemToRemovePosition in listB.size - 1 downTo 0) {
            if (listB[itemToRemovePosition] == 0) {
                listB.removeAt(itemToRemovePosition)
            }
        }

        return listB
    }

}

class Foo&lt;T&gt;: where Comparable&lt;T?&gt; {
    fun &lt;U&gt; bar(u: U) : where Comparable&lt;U?&gt; {
        if (u is T?) {
            // do something
        } else {
            // do something
        }
    }
}

val a = b ?: ({
    val temp = c.evaluate()
    store(temp)
    temp // returns temp to the lambda, which will set `a` to `temp` if `b` is null 
})()

({})
val a = b ?: {
    val temp = c.evaluate()
    store(temp)
    temp // returns temp to the lambda, which will set `a` to `temp` if `b` is null 
}

data class Response(val id: String, val name: String)
val list = mutableListOf&lt;Response&gt;()

val id : String? = "test_id"
val name : String? = "test_name"

if (!id.isNullOrBlank() and !name.isNullOrBlank()) {
    list.add(Response(id, name)) // Type mismatch. Required String, Found String?
}

Type mismatch. Required String, Found String?
public class OrderBookEntry {

  private String price;
  private String qty;

  public String getPrice() {
    return price;
  }

  public void setPrice(String price) {
    this.price = price;
  }

  public String getQty() {
    return qty;
  }

  public void setQty(String qty) {
    this.qty = qty;
  }
}

fun OrderBookEntry.equals(other: Any?): Boolean = 
  EqualsBuilder.reflectionEquals(this, other)

public open fun equals(other: Any?): Boolean
public class TargetTitleEntryController extends BaseController {

    public interface TargetTitleEntryControllerListener {
        void onTitlePicked(String option);
    }

    public &lt;T extends Controller &amp; TargetTitleEntryControllerListener&gt; TargetTitleEntryController(T targetController) {
        setTargetController(targetController);
    }

    public TargetTitleEntryController() { }
}

kotlin
Local declarations
Kotlin
fun bind(pair: Pair&lt;String, Boolean&gt;) {
   // Change pair value here
}

when
String
when (subtype.toLowerCase()) {
    MessagingClient.RTC_SUBTYPE.sdp.toString().toLowerCase() -&gt; onSDPMessageReceived(topic, sender, data!!)
    MessagingClient.RTC_SUBTYPE.bye.toString().toLowerCase() -&gt; onRTCBYEMessageReceived(topic, sender)
    MessagingClient.RTC_SUBTYPE.negotiationOffer.toString().toLowerCase() -&gt; onNegotiationOfferMessageReceived(sender, data!!)
}

MessagingClient.RTC_SUBTYPE
enum class
subtype
fun myFunction(mesg:String){
 mesg="hi" //local val variables that can’t be reused for other values
}

fun main(args: Array&lt;String&gt;) {
    val abc = arrayOf("A", "B", "C")
    updateArray(abc)

    println(abc[2])// print Z
}

fun updateArray(abcParam: Array&lt;String&gt;) {
    abcParam[2] = "Z" // 
}

Any
List
Unchecked cast: Any! to List
val x: List&lt;Apples&gt; = objectOfTypeAny as List&lt;Apples&gt;

listOf&lt;T&gt;
List&lt;T&gt;
val emptyList = listOf&lt;String&gt;()
val oneArgList = listOf("asd")
val varargsList = listOf("asd", "asd")

if (emptyList is MutableList) println("emptyList is mutable")
if (oneArgList is MutableList) println("oneArgList is mutable")
if (varargsList is MutableList) println("varargList is mutable")

oneArgList is mutable
varargList is mutable

String?
aNullableString.isNullOrBlank()
String
fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; {

}

val l = singletonList&lt;Int&gt;(1)

val binding = DataBindingUtil.inflate&lt;FragmentPlantDetailBinding&gt;(
        inflater, R.layout.fragment_plant_detail, container, false).apply {
    }
}

public static &lt;T extends ViewDataBinding&gt; T inflate(@NonNull LayoutInflater inflater,
        int layoutId, @Nullable ViewGroup parent, boolean attachToParent) {
    return inflate(inflater, layoutId, parent, attachToParent, sDefaultComponent);
}

&lt;T&gt;
fun &lt;T : View&gt; T.setVisible(visible: Boolean) {
    visibility = if (visible) View.VISIBLE else View.GONE
}

myTextView.setVisible(true)

myTextView.isVisible = true

@Deprecated("Use Android KTX isVisible", replaceWith = ReplaceWith("isVisible = visible", "androidx.core.view.isVisible"))
fun &lt;T : View&gt; T.setVisible(visible: Boolean) {
    visibility = if (visible) View.VISIBLE else View.GONE
}

for (item in list) {
  getNullableValue(item).? let {
    return it
  }
}

let
for (item in list) {
  val nullableValue = getNullableValue(item)
  if (nullableValue != null) {
    return nullableValue
  }
}

Vector2
Vector2
Vector2
fun main(args: Array&lt;String&gt;) {
    val vector = Vector2(2.0, 3.0) * 2.0
}

Vector2
operator fun times(d: Double) = Vector2(x * d, y * d)

fun main(args: Array&lt;String&gt;) {
    val vector = 2.0  * Vector2(2.0, 3.0)
}

times()
Double
// In 'Vector2.kt'
operator fun Double.times(vector: Vector2) = ...

        val discAnimator = ObjectAnimator.ofFloat(discView, "translationY", 723f)
        discAnimator.setDuration(animationDropSpeed)

        discAnimator.addListener(object : Animator.AnimatorListener{
            override fun onAnimationEnd(p0: Animator?) {
                Toast.makeText(mainActivity,"Animation Started",Toast.LENGTH_SHORT).show();
            }
        })
        discAnimator.start()

SOMETHING
fun whoAreYou() {}

fun thisFuntionsIs(): ()-&gt;Unit {
    var i = 0
    println("It's parent Function!")
    return { println("It's child Function! ${i++}") }
}

fun whoAreYou() = thisFuntionsIs() // Suppose used the override keyword

whoAreYou
class SOMETHING {
    var whoAreYou = ()-&gt;{} // If it was a property...
    // fun whoAreYou() {} // But the current situation is
}
SOMETHING.whoAreYou = thisFuntionsIs()
SOMETHING.whoAreYou() // Yea~ I wanted that

class Foo {
    lateinit var foo: String
}

class Bar {
    fun doSomething() {
        val foo = Foo().foo
        if (::foo.isInitialized) { // Unsupported [reference to variables aren't supported yet]
            Log.i("TAG", "do something")
        }
    }
}

&lt;integer-array name="main_menu_category_image"&gt;
    &lt;item&gt;@drawable/plane/item&gt;
    &lt;item&gt;@drawable/auto&lt;/item&gt;
    &lt;item&gt;@drawable/tools&lt;/item&gt;
    &lt;item&gt;@drawable/computer&lt;/item&gt;
&lt;/integer-array&gt;

inline class Meters(val v: Float) {
    operator fun plus(other: Meters) = Meters(v + other.v)
    operator fun times(amount: Float) = Meters(v * amount)
    operator fun compareTo(other: Meters) = v.compareTo(other.v)
    operator fun div(other: Meters): Float = v / other.v

    fun calcSpeed(time: Seconds) = MetersPerSecond(v * time.v)
    // operator fun times(time: Seconds) = MetersPerSecond(v / time.v) // clash (for now?)
}

inline class Seconds(val v: Float) {
    operator fun plus(other: Seconds) = Seconds(v + other.v)
    operator fun times(amount: Float) = Seconds(v * amount)
    operator fun compareTo(other: Seconds) = v.compareTo(other.v)
    operator fun div(other: Seconds): Float = v / other.v

    fun calcSpeed(distance: Meters) = MetersPerSecond(distance.v / v)
}

inline class MetersPerSecond(val v: Float) {
    operator fun plus(other: MetersPerSecond) = MetersPerSecond(v + other.v)
    operator fun times(amount: Float) = MetersPerSecond(v * amount)
    operator fun compareTo(other: MetersPerSecond) = v.compareTo(other.v)

    fun calcDistance(time: Seconds) = Meters(v * time.v)
    fun calcTime(distance: Meters) = Seconds(distance.v / v)
}

time * distance = speed
val distance = Meters(1f)
val time = Seconds(1f)
val speed: MetersPerSecond = (distance * 0.5f).calcSpeed(time)

interface UnitOfMeasurement { val v: Float }
operator fun &lt;T: UnitOfMeasurement&gt; T.plus(other: T) = T(v + other.v)

"Error:(13, 26) Unresolved reference: BaseAppComponent"
open interface BaseAppComponent {

    fun inject(defaultApplication: DefaultApplication)
    fun inject(activity: BaseActivity)

    fun plus(comicListModule: ComicListModule): ComicListSubComponent
    fun plus(comicDetailModule: ComicDetailModule): ComicDetailSubComponent
}

@Singleton
@Component(modules = arrayOf(AppModule::class, ServiceModule::class))
interface AppComponent : BaseAppComponent {}

inline
inline fun &lt;T&gt; myFun(getUserName: () -&gt; String, getUserMobile: () -&gt; String): T {
    // ...
}

getUserName()
getUserMobile()
myFun
onCreate
// unresolved reference: override
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    // MapFragment erstellen und anzeigen
    startMapFragment()
    mapFragment.getMapAsync(this)

    // OnClickListener für SpeicherDetailActivity
    btnDetailSpeichern.setOnClickListener {
        val detailIntent = Intent(this, SpeicherDetailActivity::class.java)
        startActivity(detailIntent)
    }
}

class SpeicherActivity : AppCompatActivity(), OnMapReadyCallback {

// Variablem für MapFragment erstellen
var mapFragment = MapFragment.newInstance()
var fragmentTransaction = fragmentManager.beginTransaction()
var muennerstand : Ort = Ort(20.0, 5.0, "Münnerstadt", "", 0.0f)
var standartMarker = MarkerOptions().position(LatLng(muennerstand.latitute, muennerstand.longitute)).title("standart")

// GPS TEST
val locManager = LocationManager.GPS_PROVIDER.


// unresolved reference: override
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    // MapFragment erstellen und anzeigen
    startMapFragment()
    mapFragment.getMapAsync(this)

    // OnClickListener für SpeicherDetailActivity
    btnDetailSpeichern.setOnClickListener {
        val detailIntent = Intent(this, SpeicherDetailActivity::class.java)
        startActivity(detailIntent)
    }
}



// MapFragment erstellen und anzeigen
fun startMapFragment() {
    fragmentTransaction.add(R.id.fragmentContainer, mapFragment)
    fragmentTransaction.commit()
}

override fun onMapReady(mMap : GoogleMap?) {
   mMap?.addMarker(standartMarker)
 }
}

var f: (Number) -&gt; Unit = { number: Number -&gt; println(number) }
f = {int: Int -&gt; println(number) } // &lt;-- this does not compile

var f: (in Number) -&gt; Unit = {number: Number -&gt;} // doesn't compile
var f: (out Number) -&gt; Unit = {number: Number -&gt;} // doesn't compile
var f: &lt;N: Number&gt; (N) -&gt; Unit = {number: Number -&gt;} // ridiculous

class EventHandler() {
  private val NO_OP = {event: Event -&gt; }
  private val handlerMap = 
      mutableMapOf&lt;KClass&lt;out Event&gt;, (Event) -&gt; Unit&gt;() // here is the problem declaration

  fun &lt;E: Event&gt; registerHandler(
    eventClass: KClass&lt;out E&gt;, 
    handler: (E) -&gt; Unit) {

    handlerMap[eventClass] = handler // this doesn't compile
  }

  fun handle(event: Event) = getHandler(event).invoke(event)

  fun getHandler(event: Event): (Event) -&gt; Unit = 
     handlerMap[event::class] ?: NO_OP
}

handlerMap[eventClass] = handler
handlerMap
(Event) -&gt; Unit
handler
(E) -&gt; Unit
E
&lt;E: Event&gt;
Events.kt:[18,9] Type inference failed: Cannot infer type parameter V in operator inline fun &lt;K, V&gt; MutableMap&lt;K, V&gt;.set(key: K, value: V): Unit

None of the following substitutions
    receiver: MutableMap&lt;KClass&lt;out Event&gt;, (Event) -&gt; Unit&gt;  arguments: (KClass&lt;out Event&gt;,(Event) -&gt; Unit)
    receiver: MutableMap&lt;KClass&lt;out Event&gt;, (E) -&gt; Unit&gt;  arguments: (KClass&lt;out Event&gt;,(E) -&gt; Unit)
can be applied to
    receiver: MutableMap&lt;KClass&lt;out Event&gt;, (Event) -&gt; Unit&gt;  arguments: (KClass&lt;out E&gt;,(E) -&gt; Unit)

class Foo {
    val obj = object {
        val field = 42
    }
}

fun foo() {
    Foo().obj.field // unresolved reference field
}

class Example {
    companion object {
        const val CONSTANT = "something"
}

const val CONSTANT = "something"

class Example {
}

import java.io.*
import java.util.*

fun main(args: Array&lt;String&gt;) {
    val sc = Scanner(System.`in`)
    var grid = Array(9, {IntArray(9)})
    for(i in 0..grid.size - 1) {
        var rowArray = IntArray(9)
        for(j in 0..rowArray.size - 1) {
            rowArray[j] = sc.nextInt()
        }
        grid[i] = rowArray
    }
    for(row in grid) {
        for(j in row) {
            print(j)
            print(" ")
        }
        println("")
    }

}

   val listOne = arrayListOf&lt;TicketDisplay&gt;()
                val listTwo = arrayListOf&lt;TicketDisplay&gt;()
                ticketDisplayList.forEach { ticket -&gt;
                    when (ticket.zoneId) {
                        1.toLong() -&gt; {
                            listOne.add(ticket)
                        }
                        3.toLong() -&gt; {
                            listTwo.add(ticket)

                        }
                    }
                }

fun main(){
  val str = "123"
  println(str.toInt()) // 123
  println(str[1].toInt()) // 50 ???
}

data class UserUpdateRequest(val map: Map&lt;String, Any?&gt;) {
    @get:Email
    val email: String? by map
    val firstName: String? by map
    val lastName: String? by map
}

instance.email
NoSuchElementException
null
   edittext_search.setOnFocusChangeListener { v, hasFocus -&gt;
        if(hasFocus){
            chipgroup.clearCheck()
        }
    }

(...)
{...}
class Foo(val name: String = "Yuchen") {
    val name2: String = "Zhong"
}

fun main(args: Array&lt;String&gt;) {
    val foo = Foo()
    println(foo.name)
    println(foo.name2)
}

null
        val entityAttributes = entity.optJSONObject("Attributes") ?: run {
            LOG.error("Could not find 'Attribute' entry in Entity object")
            return
        }

entity.optJSONObject("Attributes")
interface Delegate {
    fun didSelectWord(word: String)
}

delegate
val delegate: &lt;T&gt; where T : Delegate

delegate
val delegate: Any : Delegate

package util

class PersonA {
    fun greet() {
        println("...")
    }
}

import util.PersonA

fun main(args: Array&lt;String&gt;){
   val person = PersonA()
   val greet = person.greet() 
   println(greet)
}

val rand = Random().nextInt(seekBar.progress)

 package pro.bwac.randomizer

import android.support.v7.app.AppCompatActivity
import android.os.Bundle
import android.widget.Button
import android.widget.SeekBar
import android.widget.TextView
import java.util.*

class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        val rollButton = findViewById&lt;Button&gt;(R.id.RollButton)
        val seekBar = findViewById&lt;SeekBar&gt;(R.id.seekBar)
        val textView = findViewById&lt;TextView&gt;(R.id.preNumberView)
        val ResultsTextView = findViewById&lt;TextView&gt;(R.id.ResultsTextView)

        rollButton.setOnContextClickListener{
            val rand = Random().nextInt(seekBar.progress)
        }
    }

     Got unknown argument class: Object[]

     var data = [{"name":"Elim","startDate":"2019-09-09"}....]
     NativeModules.EmployeeProcessor.processData(data,err=&gt;{}, success =&gt;{});

        processData(data: Array&lt;kotlin.Any&gt;, cb: Callback) {
        for(k in data){
           Log.i(null, k['name'])
           }

        }

class classA {
fun doSomething(f: class){
when (f){
classB -&gt; print("class B")
classC -&gt; print("class C")
}
}

foo = bar ?: return

foo = bar ?: {
   Log.e(TAG, "Some error occurred.")
   return
}

foo = bar
if (foo == null) {
   Log.e(TAG, "Some error occurred.")
   return
}

val list = listOf(1,2,3,4,5,6)

val anotherlist = listOf(7,8,9,10,11,12)

assertEquals(listOf(8,10,12,14,16,18),list.merge(anotherlist){it1,it2 - &gt; it1+it2})

Mockito.mock(Function2&lt;Int, Int, Unit&gt;::class.java)

Mockito.mock(Function2::class.java) as (Int, Int) -&gt; Unit

compareTo
data class MyDate(val year: Int, val month: Int, val dayOfMonth: Int) {

    operator fun compareTo(other: MyDate)= when {
        year != other.year -&gt; year - other.year
        month != other.month -&gt; month - other.month
        else -&gt; dayOfMonth - other.dayOfMonth
    }

}

compareTo
data class MyDate(val year: Int, val month: Int, val dayOfMonth: Int) {


     operator fun compareTo(other: MyDate){

        when {
            year != other.year -&gt; return year - other.year
            month != other.month -&gt; return month - other.month
            else -&gt; return dayOfMonth - other.dayOfMonth
       }
     }


 }

Int
object Random {

    internal fun generatePositiveFloat(
        leftLimit: Float = Float.MIN_VALUE,
        rightLimit: Float = Float.MAX_VALUE
    ): Float {
        if (leftLimit &lt; 0) {
            throw InvalidAlgorithmParameterException("
                Left limit can't be negative"
            )
        } else if (rightLimit &lt;= leftLimit) {
            throw InvalidAlgorithmParameterException(
                "Right limit can't be less or equal than left limit"
            )
        }
        return Random().nextFloat()
     }

    internal fun generatePositiveShort(
        leftLimit: Short = 0,
        rightLimit:  Short = Short.MAX_VALUE
    ): Short {
        if (leftLimit &lt; 0) {
            throw InvalidAlgorithmParameterException(
                "Left limit can't be negative"
            )
        } else if (rightLimit &lt;= leftLimit) {
            throw InvalidAlgorithmParameterException(
                "Right limit can't be less or equal than left limit"
            )
        }
        return ThreadLocalRandom.current().nextInt(
            leftLimit.toInt(),
            rightLimit.toInt()
        ).toShort()
}

private fun validatePositiveLimits(
    leftLimit: Number,
    rightLimit: Comparable&lt;Number&gt;) {

    if (leftLimit as Comparable&lt;Number&gt; &lt; 0) {
        throw InvalidAlgorithmParameterException(
            "Left limit can't be negative"
        )
    } else if (rightLimit &lt;= leftLimit) {
        throw InvalidAlgorithmParameterException(
            "Right limit can't be less or equal than left limit"
        )
    }
}

class MyButton : AppCompatButton {
    @JvmOverloads
    constructor(
        context: Context,
        attrs: AttributeSet? = null,
    defStyleAttr: Int = 0)
    : super(context, attrs, defStyleAttr) {
        inflateView(attrs)
    }

    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    constructor(
        context: Context,
        attrs: AttributeSet?,
    defStyleAttr: Int,
    defStyleRes: Int)
    : super(context, attrs, defStyleAttr, defStyleRes) {
        inflateView(attrs)
    }

    fun inflateView(attrs: AttributeSet?) {
        LayoutInflater.from(context).inflate(R.layout.my_button, this, true)
    }
}

val ts: Long? = 1481710060773

val date: Date?
if (ts != null) {
    date = Date(ts)
}

let
val ts: Long? = 1481710060773

val date: Date?
ts?.let {
    date = Date(ts)
}

IntArray
fun minimalExample(nums: IntArray): Unit {
    for(num in nums.sliceArray(IntRange(1,nums.size-1))) println(num)
}

nums
for (num in nums[1:])

class Service(services: PluginServiceHub) {
    init {
        services.registerFlowInitiator(Landlord::class.java) { Landlord(it) }
    }
}

class Service(services: PluginServiceHub) {
    init {
        services.registerFlowInitiator(IssuanceRequester::class.java, ::Issuer)
    }
}

::Issuer
class ViewHolderBinder(val onBind: (ViewHolder) -&gt; Unit, val onClick: () -&gt; Unit)

val items: MutableList&lt;ViewHolderBinder&gt; = mutableListOf()

items.getOrNull(position)?.onClick()

items.getOrNull(position)?.let { it.onClick() }

val person = Person().apply {
    name = "Tony Stark"
    age = 52
    // More such stuff
}

val person = Person().also {
  it.name = "Tony Stark"
  it.age = 52
  // More such stuff
}

fun &lt;T&gt; someMethod(class : () -&gt; T) {
    val newInstance = class()
}

someMethod&lt;MyClass&gt;(::MyClass)

fun &lt;T : new&gt; someMethod() {
    val newInstance = T()
}

inline fun &lt;reified T&gt; verifyAndPerformRequest(myRequest: MyRequest, 
header: Map&lt;String, String&gt;, crossinline callback: (Any?, error: 
Error?) -&gt; Any?) {}

fun sumOfBigDecimals() : BigDecimal{
    var sum = BigDecimal.ZERO
    while(true){
        when(val num = readBigDecimal()){
            null -&gt; return sum
            else -&gt; sum += num
        }
    }
}

fun readBigDecimal() = readLine()?.let { if(it.isNotEmpty()) BigDecimal(it) else null }

open class Foo(open val img: Image) {
    val use = img.graphics
}
class Bar(override val img: BufferedImage) : Foo(img)

img.width
img
"Hello World"
Map&lt;Char, Int&gt;
{H=1, e=1, l=3, o=2,r=1, d=1}
createOp
interface UnarySymbolicOp&lt;InType : Any,
                          OutType : Any,
                          OpType : UnarySymbolicOp&lt;InType,OutType,OpType&gt;&gt; :
        Symbolic&lt;OutType&gt; {

    // Arg may be a complex expression
    val arg: Symbolic&lt;InType&gt;

    fun createOp(mesh: Symbolic&lt;InType&gt;) : OpType

    override val variables
        get() = arg.variables

    override fun &lt;V : Any&gt; substituteInside(find: Symbolic&lt;V&gt;, replace: Symbolic&lt;V&gt;): OpType {
        return createOp(arg.substitute(find, replace))
    }
}

data class GetX(override val arg: Symbolic&lt;Vector3d&gt;) : UnarySymbolicOp&lt;Vector3d, Double, GetX&gt; {
    override fun createOp(mesh: Symbolic&lt;Vector3d&gt;) = GetX(arg)

    override fun eval() = arg.eval().x
}

data class GetY(override val arg: Symbolic&lt;Vector3d&gt;) : UnarySymbolicOp&lt;Vector3d, Double, GetY&gt; {
    override fun createOp(mesh: Symbolic&lt;Vector3d&gt;) = GetY(arg)

    override fun eval() = arg.eval().y
}

data class GetZ(override val arg: Symbolic&lt;Vector3d&gt;) : UnarySymbolicOp&lt;Vector3d, Double, GetZ&gt; {
    override fun createOp(mesh: Symbolic&lt;Vector3d&gt;) = GetZ(arg)

    override fun eval() = arg.eval().z
}

class SomeWrappingClass {

    lateinit var data: SomeDataHolder

    // Want to 'forward' many properties to the data class

    var thing0: String? by data
    var thing1: String? by data
    var thing2: String? by data
}

var thing0: String? by data.thing0

SomeDataHolder {

    operator fun getValue(internationalTransferViewModel: SomeWrappingClass, property: KProperty&lt;*&gt;): String? {
    TODO("not implemented")
    }

    operator fun setValue(internationalTransferViewModel: SomeWrappingClass, property: KProperty&lt;*&gt;, s: String?) {
    TODO("not implemented")
    }

var thing: String?
    get() = data.thing
    set(value) {
        data.thing = value
    }

data
SomeWrappingClass
myWrap.data.thing = Thing()
extension String {
    @discardableResult public mutating func consumeWhile(test: (String) -&gt; Bool) -&gt; String {
        var chars = [Character](self.characters)
        var result = ""

        while chars.count &gt; 0 &amp;&amp; test(String(chars[0])) {
            result.append(chars.remove(at: 0))
        }

        self = String(chars)

        return result
    }
}

fun String.consumeWhile(test: (String) -&gt; Boolean): String {
    if (isEmpty()) return ""

    val chars = toCharArray().toMutableList()
    var result = ""
    var i = -1

    while (chars.isNotEmpty() &amp;&amp; test(chars.first().toString())) {
        result += chars.removeAt(0)
        ++i
    }

    removeRange(0..i)

    return result
}

val myString = "--Test" // IntelliJ suggests change var to val
val consumedString = myString.consumeWhile{ it != "-" }
println("result: $myString consumedString: $consumedString") 
// expected: "result: Test consumedString: --"
// but got: "result: --Test consumedString: --"

class Line(var string: String) {
    val length: Int
        get() = string.length

    fun consumeWhile(test: (String) -&gt; Boolean): String {
        if (string.isEmpty()) return ""

        val chars = string.toCharArray().toMutableList()
        var result = ""

        while (chars.isNotEmpty() &amp;&amp; test(chars.first().toString())) {
            result += chars.removeAt(0)
        }

        string = chars.joinToString("")

        return result
    }

    fun isNullOrEmpty(): Boolean {
        return string.isNullOrEmpty()
    }

    fun isNotEmpty(): Boolean {
        return string.isNotEmpty()
    }

    private fun removeRange(range: IntRange) {
        string = string.removeRange(range)
    }

    operator fun get(i: Int): Char {
        return string[i]
    }
}

val line = Line(string)

if (line.isNotEmpty() &amp;&amp; line[0].toString() == "(") {
    line.consumeWhile { it == "(" }
    while (line.isNotEmpty() &amp;&amp; line[0].toString() != ")") {
        line.consumeWhile { it == " " }
        val key = line.consumeWhile { it != "=" }
        line.consumeWhile { it == "\"" || it == "=" }
        val value = line.consumeWhile { it != "\"" }
        line.consumeWhile { it == "\"" }

        attributes[key] = value
    }

    line.consumeWhile { it == ")" }
}

data class Trip(
        val driver: Driver,
        val passengers: Set&lt;Passenger&gt;,
        ...
)

val trips: List&lt;Trip&gt;

[
    driver1 : passenger1
    driver1 : passenger2
    driver2 : passenger1
    driver2 : passenger3
...
]

trips.map {t -&gt; Pair (t.driver, t.passengers)} 

 trips.flatMap {t -&gt; Pair (t.driver, t.passengers)} 

 var str : CharArray


var t =0
for (k in i..i+3) {
    str[t++] = array[k][j]

var array: Array&lt;CharArray&gt; = arrayOf("India");

if (r1 == null &amp;&amp; r2 == null)
    throw IllegalArgumentException("All nulls!")
else if (r1 == null)
    return r2!!.reading // &lt;----- I am forced to !! here
else if (r2 == null)
    return r1.reading // &lt;----- The compiler does not complain in this line

when
else
sealed class SealedClass {
  class First : SealedClass()
  class Second : SealedClass()
}

fun test(sealedClass: SealedClass) : String =
    when (sealedClass) {
      is SealedClass.First -&gt; "First"
      is SealedClass.Second -&gt; "Second"
    }

Third
SealedClass
when
test()
Third
else
test()
fun test(sealedClass: SealedClass) {
    when (sealedClass) {
      is SealedClass.First -&gt; doSomething()
      is SealedClass.Second -&gt; doSomethingElse()
    }
}

Third
return
when
Unit
when
Array&lt;String?&gt;
fun doStuff(words: Array&lt;String?&gt;) {
    // ...
}

Array&lt;String&gt;
private val SOME_WORDS = arrayOf("I", "want", "to", "use", "these")

doStuff(SOME_WORDS) // throws a type-mismatch error

SOME_WORDS
arrayOf&lt;String?&gt;(...)
class clock (Hour: Int, Minute: Int)  {


}

val sc = Scanner(System.in)
var n:Int = sc.nextInt()
var t:Int = sc.nextInt()
var tm = IntArray(100000)
var i:Int = 0
while(i&lt;n){
    tm[i] = sc.nextInt()
    i++
}
tm.sort()
//var am = tm.sortedArray()
println("tm ${tm[0]}")
i = 0
while(i&lt;n){
    println("${tm[i]}")
    i++
}

return VAL_MAP.getOrDefault(push.type, listOf { _: Push, _: SystemState -&gt; false}.stream().allMatch ( { predicate -&gt; predicate.test(push, systemState)}))

fun &lt;T&gt; T?.test(): T = this ?: throw Exception()

val x: String? = "x"
x.test()
x.length // Only safe (?.) or non-null asserted (!!) calls are allowed on a nullable receiver of type String?

import java.time.LocalDate
import java.time.Period

fun main(args: Array&lt;String&gt;) {
  val p = Person("Boris",LocalDate.of(1987,1,1))
  println("Person's age is ${p.age()}")
}

class Person(val name: String, val dateOfBirth: LocalDate = LocalDate.of(1900,1,1)) {
  fun age() {
    Period.between(this.dateOfBirth,LocalDate.now()).getYears()
  }
}

Person's age is kotlin.Unit

val reds = IntArray(10)
val greens = IntArray(10)
val blues = IntArray(10)
val lums = IntArray(10)

myObj.reds[5] = 100 // Should update myObj.lums[5] = reds[5]+greens[5]+blues[5]

by Delegates.observable
import kotlin.test.assertEquals

fun foobalize(start: Int = 0, separator: String = "\t", convert: Boolean = false): Int {
    return 0 // implementation omitted
}

data class TestSpec(
        val start: Int? = null, // null should mean: Don't pass this argument to foobalize(), but use its default value
        val separator: String? = null, // dito
        val convert: Boolean? = null, // dito
        val expectedResult: Int
)

fun testFoobalize(testSpec: TestSpec) {
    // How to call foobalize here with values from TestSpec, but leave out parameters that are null,
    // so that the defaults from the fopobalize() function declaration are used???
    val actualResult = foobalize(start = testSpec.start)
    assertEquals(testSpec.expectedResult, actualResult)
}

["cat", "dog", "lion", "tiger",  "dog",  "rabbit"]
for
for(....){

val part = list.get(i).split(" ")
val year = parts[0]
val month = parts[1]
val spend = parts[2]

yearlist.add(year)
monthlist.add(month)
spendlist.add(spend)
}

var totalspend = 0
for(i in 0..yearlist.size-1){

if(yearlist[i]==yearlist[i+1]){//i get an error here 
    totalspend = totalspend + spendlift[i]
}
else if(yearlist[i]!=yearlist[i+1]){
    totalspend = totalspend + spendlift[i]
    spendforyear.add(totals(year[i], totalspend))
    totalspend = 0.0
}

}

private fun copyDatabase(context: Context): Boolean {
    try {

        val inputStream = context.assets.open(DatabaseHelper.DBNAME)
        val outFileName = DatabaseHelper.DBLOCATION + DatabaseHelper.DBNAME
        val outputStream = FileOutputStream(outFileName)
        val buff = ByteArray(1024)
        var length = 0

        while((length = inputStream.read(buff)) &gt; 0) {
            outputStream.write(buff , 0 , length)
        }

        outputStream.flush()
        outputStream.close()
        Log.w("MainActivity" , "DB copied")
        return true
    } catch (e: Exception) {
        e.printStackTrace()
        return false
    }

}

class Foo {
    fun bar(baz: (x: String) -&gt; Unit) {
        // ...
    }
}

baz: (String) -&gt; Unit
x:
baz
x
Server exception: java.security.AccessControlException: access denied ("java.net.SocketPermission" "127.0.0.1:1099" "connect,resolve")
java.security.AccessControlException: access denied ("java.net.SocketPermission" "127.0.0.1:1099" "connect,resolve")
    at java.security.AccessControlContext.checkPermission(AccessControlContext.java:472)
    at java.security.AccessController.checkPermission(AccessController.java:884)
    at java.lang.SecurityManager.checkPermission(SecurityManager.java:549)
    at java.lang.SecurityManager.checkConnect(SecurityManager.java:1051)
    at java.net.Socket.connect(Socket.java:584)
    at java.net.Socket.connect(Socket.java:538)
    at java.net.Socket.&lt;init&gt;(Socket.java:434)
    at java.net.Socket.&lt;init&gt;(Socket.java:211)
    at sun.rmi.transport.proxy.RMIDirectSocketFactory.createSocket(RMIDirectSocketFactory.java:40)
    at sun.rmi.transport.proxy.RMIMasterSocketFactory.createSocket(RMIMasterSocketFactory.java:148)
    at sun.rmi.transport.tcp.TCPEndpoint.newSocket(TCPEndpoint.java:613)
    at sun.rmi.transport.tcp.TCPChannel.createConnection(TCPChannel.java:216)
    at sun.rmi.transport.tcp.TCPChannel.newConnection(TCPChannel.java:202)
    at sun.rmi.server.UnicastRef.newCall(UnicastRef.java:342)
    at sun.rmi.registry.RegistryImpl_Stub.rebind(Unknown Source)
    at java.rmi.Naming.rebind(Naming.java:177)
    at Task2Server$Companion.main(Task2Server.kt:24)
    at Task2Server.main(Task2Server.kt)

class Task2Server {
    companion object {
    val name = "task2server"
    val url = "//localhost/$name"
    @JvmStatic
    fun main(args: Array&lt;String&gt;) {

        if (System.getSecurityManager() == null) {
            System.setSecurityManager(SecurityManager())
        }


        try {
            val graphSearcher: GraphSearcher = SearcherImpl()
            LocateRegistry.getRegistry(Registry.REGISTRY_PORT)
            Naming.rebind(url, graphSearcher)
            println("Server is ready")
        } catch (ex: Exception) {
            System.err.println("Server exception: " + ex.toString());
            ex.printStackTrace()
            System.exit(0)
        }
    }

    }
}

-Djava.rmi.server.codebase=file:.\graphSearcher.jar 
-Djava.rmi.server.hostname=localhost -Djava.security.manager 
-Djava.security.policy=server.policy

grant codeBase "file:*" {
    permission java.security.AllPermission;
};

class Entry1(var type:String, var kind:String, var index:Int)

var map1 = mutableMapOf&lt;String, Entry&gt;()

map1["ex1"] = Entry("ex2","ex3",4)

index
object Logger {
    private var instance: LogEntry? = null
}

A
abstract val predicate: (ModelClass) -&gt; Boolean
B
aInstance.predicate
B.predicate
open class CSRequest&lt;Data : Any&gt;(open val onSend: () -&gt; CSResponse&lt;Data&gt;) {
// some other code
}

class SpecialRequest(items: List&lt;String&gt;) : CSRequest&lt;CSServerData&gt;() {
    override val onSend: () -&gt; CSResponse&lt;CSServerData&gt; = {
        // Do send work
    }
}

 var greet: String.() -&gt; Unit = {
        println("Hello $this")
    }

  "my extintion  text".greet()  //--&gt; prints "Hello extintion  text"

greet("also my extintion  text") //--- prints "Hello also extintion text"

min
a555585887996669
val list = listOf&lt;String&gt;("a555585887996669","abtfcr6cr","abcde","abcd")
   println(list.min()) //a555585887996669

private fun List&lt;Int&gt;.padWithIndices(newLength: Int): List&lt;Int&gt;

fun List&lt;Int&gt;.padWithIndices(newLength: Int): List&lt;Int&gt; {
    var newList = this
    for (x in size until newLength) {
        newList += x
    }
    return newList
}

class Foo {
    fun CoroutineScope.foo() {

    }
}

class Bar {
    val f = Foo()

    fun CoroutineScope.bar() { // this could also be "suspend fun bar = coroutineScope {"
        f.foo() // unresolved reference

        with (f) { 
            foo() // OK
        }

        with (f) {
            with(this) {
                foo() // OK
            }
        }        
    }
}

f.foo()
CoroutineScope
bar()
import kotlinx.coroutines.*

class Foo {
    fun CoroutineScope.foo() { println("Foo.foo")}
    fun Baz.fed(){ println("Foo.fed") }
}

class Baz {
    fun CoroutineScope.foo() { println("Baz.foo") }
    fun Foo.fed(){ println("Baz.fed") }
}

fun CoroutineScope.foo() { println("CoroutineScope.foo") }

fun foo() { println("Global.foo") }

fun bar(scope: CoroutineScope) {
    val f = Foo()
    val b = Baz()

    println ("Test 1")
    foo() // foo() from Global
    scope.foo() // foo() from CoroutineScope
    //f.foo() // unresolved reference

    println ("\nTest 2")
    with(scope) {
        foo() // foo() from CoroutineScope
        //f.foo() // unresolved reference
    }

    println ("\nTest 3")
    with(f) {
        scope.foo() // foo() from Foo
        foo() // foo() from Global
    }

    println ("\nTest 4")
    with(scope) {
        with (f) {
            foo() // foo() from Foo
            scope.foo() // foo() from Foo
        }
    }

    println ("\nTest 5")
    with(f) {
        with (scope) {
            foo() // foo() from Foo
            scope.foo() // foo() from Foo
        }
    }

    println ("\nTest 6")
    with(b) {
        with(f) {
            with (scope) {
                foo() // foo() from Foo

                fed() // fed() from Baz     
            }
        }
    }

    println ("\nTest 7")
    with(f) {
        with(b) {
            with (scope) {
                foo() // foo() from Baz

                fed() // fed() from Foo
            }
        }
    }
}

fun main() = runBlocking {
    bar(this)
}

with
f.bar()
bar
Foo
Foo
x.y()
y()
x
c
x.y()
c
fun CoroutineScope.foo()
scope
Foo
Baz
foo()
y()
x.y()
fed()
x
y()
x
y()
y()
override val vm: MyViewModel by viewModel()

inline fun &lt;reified T : ViewModel&gt; LifecycleOwner.viewModel(
    key: String? = null,
    name: String? = null,
    noinline parameters: ParameterDefinition = emptyParameterDefinition()
) = viewModelByClass(T::class, key, name, null, parameters)

by viewModel
-e
normal
-t
flat
-s
test
-e
normal
-t
flat
-s
test
class Result(val code:Int)
{
}
fun getResult():Result?
{
    return null;
}
fun main(args: Array&lt;String&gt;)
{
    var result = getResult();
    var success:Boolean? = null;

    //if(result?.code &gt; 0)
    if(result?.code?:0 &gt; 0)
    {
        print("Good.");
    }

    //if(success)
    if(success == true)
    {
        print("Good.");
    }
}

 ... arrayListOf&lt;OrderSmallDTO&gt; to arrayListOf&lt;int&gt;?


        private var mentionedTasks = arrayListOf&lt;OrderSmallDTO&gt;()

        composite.add(repository.getOrders(params)
                .subscribe({orders -&gt;
                    orders.tasksList.forEach { order -&gt;
                        if (!mentionedTasks.contains(order.id)) {
                            mentionedTasks.add(order)
                        }
                    }
                    checkForDelay()
                }, {}))

onClick
val onClick: (() -&gt; Unit)? = null
if (onClick != null) {
    item.setOnClickListener { onClick.invoke() }
}

let
unresolved reference: invoke
onClick?.let {
    item.setOnClickListener { it.invoke() }
}

fun foo(m: String, bar: (m: String) -&gt; Unit) {
    bar(m)
}

foo("a message") { 
    println("message: $it")
}

fun foo(m: String, bar1: (m: String) -&gt; Unit, bar2: (m: String) -&gt; Unit) {
    bar1(m)
    bar2(m)
}

foo("a message", { println("message 1: $it") }, { println("message 2: $it") } )

fun fn1: Unit {           // using Unit is optional
    println("Hi there!")
}

fun fn2 {        
    println("Hi again!")
}

fun MainFun(x: int){
val map: HashMap&lt;Int, String&gt; = hashMapOf(1 to fn1, 2 to fn2)

for ((key, value) in map) {
     // if key = x then run/invoke the function mapped with x, for example if x = 1 then invoke fn1
}

}

inline fun &lt;K, V&gt; Map&lt;out K, V&gt;.filter(
    predicate: (Entry&lt;K, V&gt;) -&gt; Boolean
): Map&lt;K, V&gt; (source)

val russianNames = arrayOf("Maksim", "Artem", "Sophia", "Maria", "Maksim")
val selectedName = russianNames
      .filter { it.startsWith("m", ignoreCase = true) }
      .sortedBy { it.length }
      .firstOrNull()

UserBuilder
public class Person {
    private final String firstName; // required
    private final String lastName; // required
    private final int age; // optional
    private final String phone; // optional
    private final String address; // optional

    private Person(UserBuilder builder) {
        this.firstName = builder.firstName;
        this.lastName = builder.lastName;
        this.age = builder.age;
        this.phone = builder.phone;
        this.address = builder.address;
    }

    public String getFirstName() {
        return firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public int getAge() {
        return age;
    }

    public String getPhone() {
        return phone;
    }

    public String getAddress() {
        return address;
    }

    public static class UserBuilder {
        private final String firstName;
        private final String lastName;
        private int age;
        private String phone;
        private String address;

        public UserBuilder(String firstName, String lastName) {
            this.firstName = firstName;
            this.lastName = lastName;
        }

        public UserBuilder age(int age) {
            this.age = age;
            return this;
        }

        public UserBuilder phone(String phone) {
            this.phone = phone;
            return this;
        }

        public UserBuilder address(String address) {
            this.address = address;
            return this;
        }

        public Person build() {
            return new Person(this);
        }

    }
}

class Person private constructor(builder: UserBuilder) {
    val firstName: String // required
    val lastName: String // required
    val age: Int // optional
    val phone: String // optional
    val address: String // optional

    init {
        //cannot access the variables, they are private in UserBuilder
        this.firstName = builder.firstName  
        this.lastName = builder.lastName   
        this.age = builder.age
        this.phone = builder.phone
        this.address = builder.address
    }

    class UserBuilder(private val firstName: String, private val lastName: String) {
        private var age: Int = 0
        private var phone: String? = null
        private var address: String? = null

        fun age(age: Int): UserBuilder {
            this.age = age
            return this
        }

        fun phone(phone: String): UserBuilder {
            this.phone = phone
            return this
        }

        fun address(address: String): UserBuilder {
            this.address = address
            return this
        }

        fun build(): Person {
            return Person(this)
        }

    }
}

class Person private constructor(builder: UserBuilder) {
    val firstName: String // required
    val lastName: String // required
    val age: Int // optional
    val phone: String? // optional
    val address: String? // optional

    init {
        this.firstName = builder.firstName
        this.lastName = builder.lastName
        this.age = builder.age
        this.phone = builder.phone
        this.address = builder.address
    }

    class UserBuilder(internal val firstName: String, internal val lastName: String) {
        internal var age: Int = 0
        internal var phone: String? = null
        internal var address: String? = null

        fun age(age: Int): UserBuilder {
            this.age = age
            return this
        }

        fun phone(phone: String): UserBuilder {
            this.phone = phone
            return this
        }

        fun address(address: String): UserBuilder {
            this.address = address
            return this
        }

        fun build(): Person {
            return Person(this)
        }

    }
}

list1.zip(list2).zip(list3) { (a, b), c -&gt; listOf(a, b, c)}

Exception
val SOME_CONST = "value"
companion object {
    val SOME_CONST = "value"
}

@JvmStatic
data class MyData(var v: Int?)

fun myFunction(v: Int) {
    val myData = MyData(null).apply { 
        v = @myFunction.v   //does not work
    }

}

Expected 2 parameters of types android.widget.CompoundButton!, kotlin.Boolean

{
    alarmSwitch.setOnCheckedChangeListener(CompoundButton.OnCheckedChangeListener()
    { 
        fun onCheckedChanged(buttonView: CompoundButton, isChecked: Boolean)
        {

buttonView: !CompoundButton,
buttonView: CompoundButton!,
buttonView!: CompoundButton,
!buttonView: CompoundButton,
buttonView: CompoundButton?,
private void runInference(float[][][][] input, float[][][][] output){
  //body
}

Array&lt;Array&lt;Array&lt;FloatArray!&gt;!&gt;!&gt;

Array&lt;Array&lt;Array&lt;Array&lt;Float?&gt;&gt;&gt;&gt;.

Error:(12, 9) Type mismatch: inferred type is Child but Parent&lt;Any&gt; was expected
abstract class Parent&lt;T&gt; {
    abstract fun hi()
}
class Child: Parent&lt;String&gt;() {
    override fun hi() {
        println("Hi from child")
    }
}

fun main(args: Array&lt;String&gt;) {
    println("Hello, world!")
    test(Child())
}

fun test(parent: Parent&lt;Any&gt;) {
    parent.hi()
}

public class HelloWorld {

    public static void main(String[] args) {
        test(new Child());
    }

    public static void test(Parent object) {
        object.hi();
    }
}

abstract class Parent&lt;T&gt; {
    public abstract void hi();
}

class Child extends Parent&lt;String&gt; {

    public void hi() {
        System.out.println("Hi from child");
    }
}

class Robot (name: String,color :String) {

    var roboName= String
    var roboColor= String
    init {
        this.roboName=name
        this.roboColor=color
        }
    fun makeBed()
    {
        println("I will make your bed.")

    }

}
fun main(args: Array&lt;String&gt;){

     var robot1=Robot("Robot1","Black")
      println(robot1.roboName)
      println(robot1.roboColor)
      robot1.makeBed()
}

@RestControllerAdvice
class ExceptionHandlerAndValidate(): ResponseEntityExceptionHandler(){

    companion object {
        private val log = LoggerFactory.getLogger(ResponseEntityExceptionHandler::class.java)
        init {
        }
    }

     fun test(){
        println("Always Executed---------&gt;&gt;")
     }
}

mouseListener
// this is not working
val result = task10 {
    mouseListener  -&gt;
    {
        mouseListener.mouseClicked(mouseEvent)
        mouseListener.mouseClicked(mouseEvent)
        mouseListener.mouseClicked(mouseEvent)
        mouseListener.mouseClicked(mouseEvent)
    }
}

fun task10(handleMouse: (MouseListener) -&gt; Unit): Int {
    var mouseClicks = 0
    handleMouse(todoTask10())
    return mouseClicks
 }

var obj_str: Object = "NEW" as Object  

This class shouldn't be used in Kotlin. Use kotlin.Any instead
private var mOnTextWatcherCallback: ((m: String) -&gt; Unit)? = null

fun main(args: Array&lt;String&gt;) {
    val UserModel = UserModel()
    val app = Javalin.create().port(7000).start()

    with (app) {
        get("/users") {
            context -&gt; context.json(UserModel)
        }
    }
}

package org.apache.shiro.cache;

public interface CacheManager {
    &lt;K, V&gt; Cache&lt;K, V&gt; getCache(String var1) throws CacheException;
}

open class DefaultCacheManager : CacheManager {
    @Throws(CacheException::class)
    override fun getCache(name: String): Cache&lt;Any, Any&gt; {
        return InnerCache(name)
    }
} 
class InnerCache(var name: String) : Cache&lt;Any, Any&gt; {
//.... omitted ....
}

Conflicting overloads: 
@Throws public open fun getCache(name: String): Cache&lt;Any, Any&gt; defined in com.yootai.oms.permission.DefaultCacheManager, 
public abstract fun &lt;K : Any!, V : Any!&gt; getCache(p0: String!): Cache&lt;K!, V!&gt;! defined in org.apache.shiro.cache.CacheManager

override fun &lt;K : Any?, V : Any?&gt; getCache(name: String): Cache&lt;K, V&gt; {
        return InnerCache(name)
}

Type mismatch.
Required: Cache&lt;K,V&gt;
Found: InnerCache

interface I

class O : I

class A (val i: I) {
    constructor(): this(factory!!.create())
}

interface Factory {
    fun create(): I
}

class MyFactory: Factory {
    override fun create(): I {
        return O()
    }
}

var factory: Factory? = null

fun main(args: Array&lt;String&gt;) {
    factory = MyFactory()
    A()
}

ReferenceError:Can't find variable: tmp$0

val factory: Factory = MyFactory()

fun main(args: Array&lt;String&gt;) {
    A()
}

var KotlinTest = function (Kotlin) {
  'use strict';
  var _ = Kotlin.defineRootPackage(function () {
    this.factory = null;
  }, /** @lends _ */ {
    I: Kotlin.createTrait(null),
    O: Kotlin.createClass(function () {
      return [_.I];
    }, function O() {
    }),
    A: Kotlin.createClass(null, function A(i) {
      this.i = i;
    }),
    A_init: function ($this) {
      $this = $this || Object.create(_.A.prototype);
      _.A.call($this, ((tmp$0 = _.factory) != null ? tmp$0 : Kotlin.throwNPE()).create());
      return $this;
    },
    Factory: Kotlin.createTrait(null),
    MyFactory: Kotlin.createClass(function () {
      return [_.Factory];
    }, function MyFactory() {
    }, /** @lends _.MyFactory.prototype */ {
      create: function () {
        return new _.O();
      }
    }),
    main_kand9s$: function (args) {
      _.factory = new _.MyFactory();
      _.A_init();
    }
  });
  Kotlin.defineModule('KotlinTest', _);
  _.main_kand9s$([]);
  return _;
}(kotlin);

var myList: List&lt;Int&gt;

registerMonitorVar(myList)

fun onVariableChange(){
   if (myList.size&gt;=1){
      btnDelete.enabled=true
   }
}

private lateinit var allList: MutableList&lt;MSetting&gt; set(value) {
        field = value
        onVariableChange()
}

private  var allList=mutableListOf&lt;MSetting&gt;() set(value) {
        field = value
        onVariableChange()
}

fun onVariableChange(){
    if (allList.size&gt;=1){

     }
}

 private var allList: MutableList&lt;MSetting&gt;  by Delegates.vetoable(mutableListOf&lt;MSetting&gt;())
    { property, oldValue, newValue -&gt;
        {
            btnRestore.isEnabled=(newValue.size &gt;= 1)
            btnBackup.isEnabled=(newValue.size &gt;= 1)
        }

    }

 private var allList: MutableList&lt;MSetting&gt;  by Delegates.observable(mutableListOf&lt;MSetting&gt;())
    { property, oldValue, newValue -&gt;
        btnRestore.isEnabled = newValue.size &gt;= 1
    }

allList=SettingHandler().getListAllSetting().toMutableList() // Observable Work

allList.clear()
 allList.addAll(SettingHandler().getListAllSetting().toMutableList()) //Observable Doesn't Work

&gt; 10^3         // 1000
&gt; 2.71^2       // 7.3441
&gt; 3.14^(-3.14) // 0.027..

// Define extension to Int
infix fun Int.exp(exponent: Int): Int {
...
}

^
data class A(){
   fun c(){}
  }
    val result: MutableMap&lt;key, MutableList&lt;Int&gt;&gt; = mutableMapOf()

    someArray.onEach { (key, int) -&gt;
        result
            .computeIfAbsent(key.id) { mutableListOf() }
            .add(int)
    }

    return list

    return someArray
        .map { (key, int) -&gt;
            key.id to int
        }
        .groupBy { it.first }
        .map { (k, v) -&gt;
            k to v.filter { it.first == k }
                .map { it.second }
        }

protected abstract
abstract class BaseDialogFragment {
    protected abstract fun getButton1Text(): String
    protected abstract fun getButton2Text(): String
}

fun getComponent(clazz : KClass&lt;*&gt;) : Component? {
    for(component in components) {
        if(component is clazz) {
            return component
        }
    }
    return null
}

var _age: Int? = 0

public var isAdult: Boolean? = false
   get() = _age?.compareTo(18) &gt;= 0 

abstract class RootRepository&lt;out T&gt; : KodeinInjected {

    override val injector: KodeinInjector = KodeinInjector()

    @Suppress("UNCHECKED_CAST")
    fun init(kodein: Kodein): T {
        injector.inject(kodein)
        return this as T
    }

}

class NewRepo: RootRepository&lt;NewRepo&gt;() {

    private val mangaDao by injector.instance&lt;MangaDao&gt;()
    private val api by injector.instance&lt;Api&gt;()


    fun getMangaList() {
        //Some code here
    }

    fun fetchMangaList(){
        //Some code here
    }

}

val newRepo:NewRepo = NewRepo.init(appKodein())

high != null
!!
compareTo
private class Bot(val number: Int, var low: Int?, var high: Int?) {

  fun acceptValue(value: Int) {
    if (low == null &amp;&amp; high == null) {
      high = value
    } else {
      if (high != null) {
        if (high!! &gt; value) { //it doesn't compile, because appareantly, high is still not considered nonnull at this point
          low = value
        } else {
          low = high
          high = value
        }
      }
    }
  }
}

1.1.3-2
  public var oneTouchTimer: CountDownTimer = CountDownTimer(500, 100) {
    override fun onTick(l: Long) {

    }

    override fun onFinish() {

    }
}

Cannot create an instance of an abstract class.

    CountDownTimer oneTouchTimer = new CountDownTimer(500, 100) {
    @Override
    public void onTick(long l) {

    }

    @Override
    public void onFinish() {

    }
};

@Target({ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.TYPE, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@com.fasterxml.jackson.annotation.JacksonAnnotation
public @interface JsonDeserialize

@JsonSerialize(using = IDEncryptJsonSerializer::class)
@JsonDeserialize(using = IDDecryptJsonDeserializer::class)
@Column(name = "sku_id", nullable = false)
open var skuId: Long = 0L

@field:javax.persistence.Column public open var skuId: kotlin.Long

Builder
public class Example {
    private SneakyType doNotExposeThis;

    private Example(Builder builder) {
        // OK 'cause in Java you can access the private
        // members of a nested class
        doNotExposeThis = builder.doNotExposeThis;
    }

    private static class SneakyType {
        SneakyType(String x) {
            // stuff
        }
    }

    public static class Builder {
        private SneakyType doNotExposeThis;

        public void addFoo(String something) {
            doNotExposeThis = new SneakyType(something);
        }

        public Example build() { return new Example(this); }
    }
}

class Example(builder: Builder) {
    private lateinit var doNotExposeThis: SneakyType

    init {
        doNotExposeThis = builder.doNotExposeThis
    }

    class Builder {
        // If private or internal I can't access it in Example.init
        // and if public it gets exposed. 
        val doNotExposeThis: SneakyType


        fun addFoo(something: String) {
            // actual construction is quite a bit more complex
            doNotExposeThis = SneakyType(something)
        }
    }
}

init
Example
SneakyType
Example
Example
Sneaky
Sneaky
class Foo(
        val name: String,
        val things: List&lt;Thing&gt;
)

val foo = thirdPartyGetFoo()
val filteredFoo = Foo(foo.name, foo.things.filterNotNull())

class fragment_Arr :Fragment(), View.OnClickListener {
    override fun onClick(v: View?) {
        val intent = Intent(activity, FlightDeatilasDep::class.java)
        startActivity(intent)
    }


    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.fragment_arrivel,container,false)


        loadmorefilghtsbeforday.setOnClickListener{this}
    }



}

abstract class Bird&lt;T: Food&gt;

Fish
Food
class Falcon: Bird&lt;Fish&gt;()

Bird
fun getBird(type: Int): Bird&lt;Food&gt; {
   if (type == SOME_CONSTANT) {
       return Falcon()
   } else {
      // Another bird
   }
}

Type mismatch: Required Bird&lt;Food&gt;, found Falcon  

if (name == nameArray[0]) {
    // The statement
} else if(name == nameArray[1]) {
    // The statement
} else if(name == nameArray[2]) {
    // The statement
} else if(name == nameArray[3]) {
    // The statement
} else {
    // The statement
}

with
HomePage.class
val fooClass = foo.javaClass
Foo.class
Foo::class.java
val fooClass = Foo::class.java
HomePage::class.java
Unresolved reference: java
    var left: Node? = null

    fun show() {
         if (left != null) {
             queue.add(left) // ERROR HERE
         }
    }

left
left != null
left
Node
private String doit(Class&lt;?&gt; c) {
  //body
}

fun doit(clazz: Class&lt;Any&gt;) : String {
    //body
}

data class Module
(
        var id: String? = ObjectId().toHexString(),
        var name: String = "",
        var description: String = " ",
        var frames : MutableList&lt;Frame&gt; = mutableListOf&lt;Frame&gt;(),
        var functions : MutableList&lt;Function&gt; = mutableListOf&lt;Function&gt;(),
        var created_at: Date = Date(System.currentTimeMillis()),
        var updated_at: Date = Date(System.currentTimeMillis())
)

data class Frame (

        var id: String? = ObjectId().toHexString(),
        var name:String  = "",
        var level:String = "",
        var moduleID:String = "",
        var subFrames : MutableList&lt;Frame&gt; = mutableListOf()

    )

val hline_magf = SampleUtils.getDataFromOneFile("C:\\Users\\XXXX\\Desktop\\test\\hline.421.magf.csv")
val adj_ts = Preprocess.adjustTimestamps(hline_magf)
val abs = Preprocess.abs(adj_ts)
var lerp = Preprocess.lerp(abs)
val lh = Preprocess.hanning_window(lerp)

val lhl = Preprocess.pad_left(lh)           // these cause the problems somewhere
val lhr = Preprocess.pad_right(lh)
val lhm = Preprocess.pad_center(lh)

    fun pad_left(sample: Sample): Sample {
        var ret_val = sample
        println("#### pad left")

        while (ret_val.timestamp.size &lt; MAX_LEN) ret_val.timestamp = doubleArrayOf(0.0) + ret_val.timestamp
        while (ret_val.absoluteSquare_float.size &lt; MAX_LEN) ret_val.absoluteSquare_float = floatArrayOf(0.0f) + ret_val.absoluteSquare_float
        while (ret_val.x_float.size &lt; MAX_LEN) ret_val.x_float = floatArrayOf(0.0f) + ret_val.x_float
        while (ret_val.y_float.size &lt; MAX_LEN) ret_val.y_float = floatArrayOf(0.0f) + ret_val.y_float
        while (ret_val.z_float.size &lt; MAX_LEN) ret_val.z_float = floatArrayOf(0.0f) + ret_val.z_float

        return ret_val
    }

Float
f.ToString("P1")
setOfStrings
hashSetOfStrings
val setOfStrings = setOf("A", "B", "C")
val hashSetOfStrings = hashSetOf("A", "B", "C") 

input = listOf(a, b, c, a) 

val filtered = input.removeAllInstancesOf(a)

val output = input.filterNot { it == a }
val output = input.minus(listOf(a))
val output = input.minus(a)
val
x
const
fun main(args: Array&lt;String&gt;) {
    val x = 6
    val y = 9
    for (x in 1..y) {
        println("fits in range $x")
    }
}

fits in range 1
fits in range 2
fits in range 3
fits in range 4
fits in range 5
fits in range 6
fits in range 7
fits in range 8
fits in range 9

n
class Item(val level : Int)
(Item(1), Item(2), Item(5))
level &gt; 0 &amp;&amp; level &lt; 3
level &gt; 4
listOf(Item(1), Item(2))
listOf(Item(5))
groupBy
class Turtle : ActorBeta {
constructor() : super()

override fun act(dt: Float) {
    super.act(dt)

    if(Gdx.input.isKeyPressed(Input.Keys.LEFT))
        this.moveBy(-1f, 0f)
    if(Gdx.input.isKeyPressed(Input.Keys.RIGHT))
        this.moveBy(1f, 0f)
    if(Gdx.input.isKeyPressed(Input.Keys.UP))
        this.moveBy(0f, 1f)
    if(Gdx.input.isKeyPressed(Input.Keys.DOWN))
        this.moveBy(0f, -1f)
    }
}

sealed class User
sealed object User
private fun getTouchX(): Int {
    arguments ?: return centerX()

    return if (arguments.containsKey(KEY_DOWN_X)) {
        arguments.getInt(KEY_DOWN_X)
    } else {
        centerX()
    }
}

private fun centerX() = (views.rootView?.width ?: 0) / 2

 private fun getTouchX(): Int {
    if (arguments == null || !arguments.containsKey(KEY_DOWN_X)) {
        return centerX()
    }
    return arguments.getInt(KEY_DOWN_X)
}

class ViewHolder(itemView: View, val ui: ViewUI)

var setterVisibility: String = "abc"
    private set

abstract class ChannelCompanion&lt;T : BaseChannel&lt;T&gt;&gt;
Channel
Group
fromJson(JsonObject)
inline fun start(callback: () -&gt; Unit)
Channel
Channel.start { }
ChannelCompanion.start {  }
Channel.fromJson(JsonObject)
Channel.fromJson
Channel.fromJson
Channel.fromJson
val presenter by lazy { initializePresenter() }
abstract fun initializePresenter(): T

viewInterface
val presenter by lazy { initializePresenter(/*Error here: what should I put here?*/) }
abstract fun initializePresenter(viewInterface: V): T

$ ./gradlew ::copyKotlinLibs ; ./gradlew war

BUILD SUCCESSFUL in 1s
5 actionable tasks: 5 up-to-date

FAILURE: Build failed with an exception.

* What went wrong:
Could not resolve all files for configuration ':versions:1.3.31:library'.
&gt; Could not resolve com.github.komputing.kethereum:model:0.75.1.
  Required by:
      project :versions:1.3.31
   &gt; Could not resolve com.github.komputing.kethereum:model:0.75.1.
      &gt; Could not parse POM https://jitpack.io/com/github/komputing/kethereum/model/0.75.1/model-0.75.1.pom
         &gt; Unable to resolve version for dependency 'org.jetbrains.kotlin:kotlin-test:jar'
&gt; Could not resolve com.github.komputing.kethereum:erc55:0.75.1.
  Required by:
      project :versions:1.3.31
   &gt; Could not resolve com.github.komputing.kethereum:erc55:0.75.1.
      &gt; Could not parse POM https://jitpack.io/com/github/komputing/kethereum/erc55/0.75.1/erc55-0.75.1.pom
         &gt; Unable to resolve version for dependency 'org.jetbrains.kotlin:kotlin-test:jar'

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

* Get more help at https://help.gradle.org

BUILD FAILED in 5s
24 actionable tasks: 1 executed, 23 up-to-date

diff --git a/versions/1.3.31/build.gradle b/versions/1.3.31/build.gradle
index 1e0ab00e..721c12e0 100644
--- a/versions/1.3.31/build.gradle
+++ b/versions/1.3.31/build.gradle
@@ -40,6 +40,8 @@ repositories {
     maven {
         url  "https://dl.bintray.com/kotlin/kotlin-dev"
     }
+    jcenter()
+    maven { url 'https://jitpack.io' }
 }

 configurations {
@@ -106,7 +108,8 @@ dependencies {
      *      permission java.lang.RuntimePermission "accessDeclaredMembers";
      * };
      */
-
+    library "com.github.komputing.kethereum:model:0.75.1"
+    library "com.github.komputing.kethereum:erc55:0.75.1"
     compile fileTree(dir: projectDir.toString() + File.separator + "kotlin", include: '*.jar')
 }

emptyArray()
emptyArray
fun Activity.postDelay1s(run: () -&gt; Unit) {
Handler().postDelayed({ run() }, 1000)
}

fun CustomRefreshLayout.setUp(containerRecycleView: RecyclerView, onResfresh: () -&gt; Unit) {
with(this) {
    recyclerView = containerRecycleView
    setColorSchemeColors(Color.BLUE,
            Color.GREEN,
            Color.YELLOW,
            Color.RED)
    setDistanceToTriggerSync(300)
    setProgressBackgroundColorSchemeColor(Color.WHITE)
    setSize(SwipeRefreshLayout.LARGE)
    setOnRefreshListener { onResfresh() }
}

}

a
postDelay1s { initData() }
b
swipe.setUp(trade_list, this::initData)
initData()
this::initData
ArrayList
abstract class Data {
    abstract var data: ArrayList&lt;Entry&gt;
    abstract class Entry(open var name: String)
}

ArrayList
Entry
class Category : Data() {
    override var data = ArrayList&lt;CategoryItem&gt;()
    class CategoryItem(
        override var name: String
    ):Entry(name)
}

CategoryItem
Entry
override var data = ArrayList&lt;CategoryItem&gt;() 

CategoryItem
Entry
@Entity
class TestExecutionSummary {
    @EmbeddedId
    lateinit var id: TestExecutionId

    lateinit var timeStarted: OffsetDateTime
    lateinit var timeFinished: OffsetDateTime
    var totalFailureCount: Long by Delegates.notNull()
    var containersFoundCount: Long by Delegates.notNull()
    var containersStartedCount: Long by Delegates.notNull()
    var containersSkippedCount: Long by Delegates.notNull()
    var containersAbortedCount: Long by Delegates.notNull()
    var containersSucceededCount: Long by Delegates.notNull()
    var containersFailedCount: Long by Delegates.notNull()
    var testsFoundCount: Long by Delegates.notNull()
    var testsStartedCount: Long by Delegates.notNull()
    var testsSkippedCount: Long by Delegates.notNull()
    var testsAbortedCount: Long by Delegates.notNull()
    var testsSucceededCount: Long by Delegates.notNull()
    var testsFailedCount: Long by Delegates.notNull()
    @OneToMany(cascade = [CascadeType.ALL])
    var failures: List&lt;TestFailure&gt; = emptyList()

    @Embeddable
    class TestExecutionId {
        var id: Long by Delegates.notNull()
        var jobExecutionId: Long by Delegates.notNull()
    }
}

val list = mutableListOf("a","b","c") //1
list = mutableListOf("d", "e") //2 Error
list.remove("a") //3

package stackoverflow

fun main(args : Array&lt;String&gt;) {

  class Person
  class Group(val people:List&lt;Person&gt;)

  // x=22 and y=6 should produce following groups 6,6,5,5.

  // By using kotlin's Collections.chunked function I can put people into groups.
  val x = 22
  val y = 6
  val people = (1..x).map { Person() }
  val groups = people.chunked(y).map { peopleList -&gt; Group(peopleList) }

  // part a succeed
  assert(groups.size == 4)

  // part b fails
  groups.forEach { print(" "+it.people.size) } // 6 6 6 4
}

KClass.simpleName
interface Human { fun think(): String }

@Test fun `when finding the name of an anonymous object verify the name is null`() {
    fun start(man: Human) = println(man.think())

    start(object: Human {
        val name = this::class.simpleName
        override fun think() = "Thinking really hard! Name is: $name" // name == 2
    })
}

null
null
1.0.4
-version
-version 1.0.4
for(int i=0, j=0; i &lt; 6 &amp;&amp; j &lt; 6; i++, j+=2) {
    // code here
}

ApiResponse
sealed class ApiResponse&lt;T&gt; {
  class Success&lt;T&gt;(body: T)
}

fun getUsers(): ApiResponse&lt;List&lt;User&gt;&gt;

getUsers
ApiResponse.Success&lt;List&lt;User&gt;&gt;
T
ApiResponse&lt;T&gt;
Success&lt;T&gt;
sealed class ApiResponse&lt;NotUsed&gt; {
  class Success&lt;T&gt;(body: T)
}

ApiResponse
fun getUsers(): ApiResponse

Arrays
inline fun &lt;reified E&gt; getArray(key: String, defValue: Array&lt;E&gt;): Array&lt;E&gt;? {
    return when(defValue) {
        is Array&lt;Int&gt; -&gt; // ...
        is Array&lt;String?&gt; -&gt; // ...
        else // ...
    }
}

fun intArray(size: Int): Array&lt;Int&gt; = Array(size) {i -&gt; 0}
fun stringArray(size: Int): Array&lt;String?&gt; = Array(size) {i -&gt; null}

val strings: Array&lt;Int&gt; = getArray(KEY_INTS, intArray(0))
val strings: Array&lt;String&gt; = getArray(KEY_STRINGS, stringArray(0))

"Some String".map { SomeObject($0) } 

"Some String".map { SomeObject(it) } 

for(int i = 0; i &lt; array.length; i++) {
  for(int j = i; j &lt; array.length; j++) {
    // do something here.
  }
}

for((i, num1) in array.withIndex()) {
  for((j, num2) in array.withIndex()) {
    // do something here.
  }
}

for(i in 0..(array.size)) {
  for(j in i..array.size)) {
    // do something here, access array directly with indices.
  }
}

interface Watcher {
    fun funWithoutBody()

    fun startWatching() {
        //do some important stuff which must be called
    }
}

kotlin 1.2.50

params.bottomMargin
Smart cast to android.support.v7.widget.RecyclerView.LayoutParams
    val child = parent.getChildAt(i)
    val params = child.layoutParams
    if(params is RecyclerView.LayoutParams) {
        val dividerTop = child.bottom + params.bottomMargin
        val dividerBottom = dividerTop + drawable.intrinsicHeight

        drawable.setBounds(dividerLeft, dividerTop, dividerRight, dividerBottom)
        drawable.draw(c)
    }

params to RecyclerView.LayouParams
val exceptionHandler = CoroutineExceptionHandler { context, exception -&gt;
    println(exception.message)
}

val threadPool = Dispatchers.IO
val job = Job()

GlobalScope.launch(exceptionHandler + threadPool + job) {
    throw Exception("Bad robot")
}

fun search(latLng: LatLng?){
        dispose = weatherApiService
                .requestHourlyWeather(latLng!!.latitude, latLng!!.longitude, client_id, client_secret)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(
                        {result -&gt; Log.d("Search result:", result.response[0].periods[0].tempC.toString())},
                        { error -&gt; Log.d("Searching error", error.message)}
                )
    }


override fun onPlaceSelected(p0: Place?) {
    search(p0?.latLng) //is not executed, but if I place code directly here it is working

}

for(int j = 0; j &lt; 6 &amp;&amp; j &lt; ((int)abc[j] &amp; 0xff); j++) { 
  // ...
}

val repeatFunWithReceiver : String.(Int)-&gt; String = {
    times : Int -&gt;this.repeat(times)
}
println("repeatfun: " + repeatFunWithReceiver("B", 5))

"A".repeatFunWithReceiver(4)//&lt;-repeateFunWithReceiver is not list among the method "in the auto comlete"

someList.stream().map(x -&gt; {
    y = doSomeOperation(x);
    z = doSomeOtherOperation(y);
    return z;
}).collect(Collectors.toList());

x -&gt; x*x
x-&gt;doSomethingThenReturnValue(x)
someList.map{ x -&gt; {
    y = doSomeOperation(x);
    z = doSomeOtherOperation(y);
    return z;
}}

System.out.print(
    String("Carthorse".toCharArray().sortedArray())
   .equals(String("Orchestra".toCharArray().sortedArray()),true)
)

    val a = 10 * 20 +
            10 * 30

    val b = 10 * 20
          + 10 * 30

    val c = (
               (10 * 20)
             + (10 * 30)
            )

    val d = (10 * 20)
          + (10 * 30)

    println(a)
    println(b)
    println(c)
    println(d)

500
200
500
200

val obj = Obj()
with (obj) {
    objMethod1()
    objMethod2()
}

val obj = with(Obj()) {
    objMethod1()
    objMethod2()
}

list("A","B","C") to -&gt; list(Pair(A,B),Pair(A,C),Pair(B,C))

list("A","B","C","D") to -&gt; list(Pair(A,B),Pair(A,C),Pair(A,D),Pair(B,C),Pair(B,D),Pair(C,D))

zipWithNext
interface Options {
    fun load(conf: JsonObject)
}

object BasicOptions : Options { }
object PersonOptions : Options { }
object CarOptions : Options { }

Objects
interface
forEach
fun main(args: Array) {
    configFuture.whenComplete { config -&gt;
            options.forEach { it.load(config) }
    }
}

val obj1 = Obj(date = LocalDate.parse("2018-12-12"), amount = BigDecimal(100))
val obj2 = Obj(date = LocalDate.parse("2018-12-12"), amount = BigDecimal(200))
val obj3 = Obj(date = LocalDate.parse("2019-10-10"), amount = BigDecimal(500))

val arrayOfObj = arrayOf(obj1, obj2, obj3)

date=2018-12-12, amount=300, objs=[Obj(date=2018-12-12, amount=100), Obj(date=2018-12-12, amount=200)]
date=2019-10-10, amount=500, objs=[Obj(date=2019-10-10, amount=500)]

data class Result(val res1 :Int, val res2: Int)
class test{
        fun retresult():Result{
        return Result(2,2)
    }
}

fun main(args: Array&lt;String&gt;) {
    var var1:Int = 0
    var var2:Int = 0
    var des = test()
    //(var1, var2) = des.retresult() this doesn't work

    var1 = des.retresult().res1
    var2 = des.retresult().res2 // **works but calls function twice** 
}

 val (var1, var2) = des.retresult()

class Testing() {
    var var1 = 0
    var str1 = ""
    var b = false

    fun test(var1: Int, str1: String, lambda1: (Boolean)-&gt;Unit){
    this.var1 = var1 
    this.str1 = str1 
    // do something
    }
}

var t1 = Testing()
t1.test(1, "String"){
      // do something else
}

fun sum(first:Int, second:Int):Int
{
    return first + second
}

println("$sum(3,4)")

MutableList
MutableList
var pusta: List&lt;Kolory&gt; = emptyList()
var cos: MutableList&lt;Kolory&gt; = pusta.toArrayList()

WebServlet
404 Not Found
import javax.servlet.http.HttpServletRequest
import javax.servlet.http.HttpServletResponse
import javax.servlet.http.HttpServlet
import javax.servlet.annotation.WebServlet
import de.daimler.servlets.Deals


@WebServlet("/Check")
class KotlinFirst : HttpServlet() {


 override fun doGet(req: HttpServletRequest, res: HttpServletResponse) {        
    res.writer.write("flat 20% off on fashion, ");
    res.writer.write("upto 50% off on mobiles, ");

    res.writer.write(Deals.getDeals());
  }

}

&lt;Button
            android:id="@+id/apply_job"

            android:layout_width="match_parent"
            android:text="Apply"
            android:background="@color/colorPrimary"
            android:layout_height="wrap_content" /&gt;

if ((testingStartTime != null) &amp;&amp; (testingEndTime != null))
    summary.duration = testingEndTime!!.time - testingStartTime!!.time

!!
Map&lt;String, () -&gt; Unit&gt;

Map&lt;String, () -&gt; Unit&gt;
Map&lt;String, (T, X, Y, ...) -&gt; V&gt;

class One{
    fun delegate(operation: One.()-&gt; Unit){
        operation()
    }
    fun main(args: Array&lt;String&gt;){
    val one= One()
    fun One.doIt(){
        println("Test A")
    }
    one.delegate { doIt() } //prints Test A
    one.delegate {
        fun One.doItDifferently(){
            println("Test B")      //not printed
        }
    }
}

val x = someList.map(::SomeConstructor)

val x = someList.map{ ::SomeConstructor }

sealed class PaginationViewState&lt;T&gt; {
    object LoadingFirstPage: PaginationViewState&lt;T&gt;()//doesn't work
    object LoadingPage: PaginationViewState&lt;T&gt;()//doesn't work

    data class DataLoaded&lt;T&gt;(val data: List&lt;T&gt;): PaginationViewState&lt;T&gt;()
    data class DataLoadedFromCache&lt;T&gt;(val data: List&lt;T&gt;): PaginationViewState&lt;T&gt;()
    data class Failure&lt;T&gt;(val e: Throwable): PaginationViewState&lt;T&gt;()
}

package myapp

private val CONST1 = 1
private val CONST2 = 2

public fun function1() {}
public fun function2() {}


package hr.ferit.brunozoric.taskie.ui.fragments

import android.os.Bundle
import android.view.View
import androidx.fragment.app.Fragment
import hr.ferit.brunozoric.taskie.R
import hr.ferit.brunozoric.taskie.ui.adapters.ViewPagerAdapter
import hr.ferit.brunozoric.taskie.ui.fragments.base.BaseFragment
import kotlinx.android.synthetic.main.fragment_about.*



class AboutFragment: BaseFragment() {



    override fun getLayoutResourceId(): Int {
        return R.layout.fragment_about

    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setupPager()



    }

    private fun setupPager() {
        viewPager.adapter = ViewPagerAdapter(fragmentManager!!)
        tabLayout.setupWithViewPager(viewPager)  // I have error in this line :(

    }


    companion object{
        fun newIstance(): Fragment {
            return AboutFragment()
        }
    }

}



package hr.ferit.brunozoric.taskie.ui.adapters

import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentManager
import androidx.fragment.app.FragmentStatePagerAdapter
import hr.ferit.brunozoric.taskie.ui.fragments.AboutAplicationFragment

class ViewPagerAdapter(manager :FragmentManager) : FragmentStatePagerAdapter(manager) {


    companion object{
        const val NUM_OF_PAGES =2
        const val PAGE_ONE_TITLE = "About Application"
        const val PAGE_TWO_TITLE = "About Author"
    }

    private val frags = mutableListOf&lt;Fragment&gt;(AboutAplicationFragment(),AboutAplicationFragment())
    private val titles = mutableListOf(PAGE_ONE_TITLE, PAGE_TWO_TITLE)

    override fun getItem(position: Int): Fragment {
        return frags[position]
    }

    override fun getPageTitle(position :Int) : String{
        return titles[position]
    }

    override fun getCount(): Int {
        return NUM_OF_PAGES
    }
}



&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                xmlns:app="http://schemas.android.com/apk/res-auto"&gt;


  &lt;androidx.viewpager.widget.ViewPager
          android:id="@+id/viewPager"
          android:layout_width="match_parent"
          android:layout_height="match_parent"
          android:layout_below="@id/tabLayout"
          /&gt;

  &lt;TableLayout
          android:id="@+id/tabLayout"
          android:layout_width="match_parent"
          android:layout_height="wrap_content"
          android:layout_alignParentTop="true"
          /&gt;


&lt;/RelativeLayout&gt;


mListMy
onCreateViewHolder
class MydAdapter () : RecyclerView.Adapter&lt;MydAdapter.MyViewHolder&gt;() {

   private lateinit var mListMy: List&lt;MRecord&gt;

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MydAdapter.MyViewHolder {
        initListMy()

        val v = LayoutInflater.from(parent.context).inflate(R.layout.item_recyclerview_my, parent, false)
        return MyViewHolder(v)
    }

    fun initListMy(){
        mListMy=RecordHandler().listAllRecord(ESortBy.NameAsc,ECategory.My)
    }

    override fun onBindViewHolder(holder: MydAdapter.MyViewHolder, position: Int) {
        holder.bindItems(mListMy[position])
    }

}

[Flags]
enum BeerProperty
{
    Bold = 1,
    Refreshing = 2
}

static void Taste(BeerProperty beer)
{
    if (beer == (BeerProperty.Bold | BeerProperty.Refreshing))
    {
        Debug.WriteLine("I can't qutie put my finger on...");
    }
}

static void Main(string[] args)
{
    var tickBeer = BeerProperty.Bold | BeerProperty.Refreshing;
    Taste(tickBeer);
}

enum class BeerProperty(value:Int)
{
    Bold(1),
    Refreshing(2)
}

fun taste(beer:BeerProperty)
{
    if(beer == (BeerProperty.Bold | BeerProperty.Refreshing))
    {
        print("I can't qutie put my finger on...");
    }
}

fun main(args: Array&lt;String&gt;)
{
    val tickBeer = BeerProperty.Bold | BeerProperty.Refreshing;
    taste(tickBeer);
}

fun taste(beer: EnumSet&lt;BeerProperty&gt;)
{
    if(beer.contains(BeerProperty.Bold) &amp;&amp; beer.contains(BeerProperty.Refreshing))
    {
        print("I can't qutie put my finger on...");
    }
}

fun main(args: Array&lt;String&gt;)
{
    val tickBeer = EnumSet.of(BeerProperty.Bold, BeerProperty.Refreshing);
    taste(tickBeer);
}

class LoginResponseDomainMapperImp : LoginResponseDomainMapper {
    override fun map(entity: LoginResponseEntity): LoginResponse {
        return LoginResponse(
            entity.token ?: "",
            mapUsers(entity.user),
            mapEnterprises(entity.enterprises ?: emptyList()),
            mapVendors(entity.vendors ?: emptyList()))
    }

    private fun mapUsers(userEntity: UserEntity?): User {
        return User(
            userEntity?.id,
            userEntity?.email,
            userEntity?.firstName,
            userEntity?.lastName,
            userEntity?.phone,
            userEntity?.address,
            userEntity?.dob,
            userEntity?.customer,
            userEntity?.enterpriseIds ?: emptyList(),
            userEntity?.vendorIds ?: emptyList())
    }

    private fun mapEnterprises(enterprisesEntity: List&lt;EnterprisesEntity&gt;): List&lt;Enterprises&gt; {
        val enterpriseList = mutableListOf&lt;Enterprises&gt;()

        enterprisesEntity.forEach {
            val enterprise = Enterprises(
                it.id,
                it.enterpriseName,
                it.typeLabel,
                it.country,
                it.imageId,
                it.managers,
                it.members,
                it.stripe,
                it.locations)

            enterpriseList.add(enterprise)
        }

        return enterpriseList.toList()
    }

    private fun mapVendors(vendorsEntity: List&lt;VendorsEntity&gt;): List&lt;Vendors&gt; {
        val vendorList = mutableListOf&lt;Vendors&gt;()

        vendorsEntity.forEach {
            val vendor = Vendors(
                it.id,
                it.vendorName,
                it.typeLabel,
                it.userRole,
                it.latitude,
                it.longitude,
                it.partner,
                it.country,
                it.imageId,
                it.stripe)

            vendorList.add(vendor)
        }

        return vendorList.toList()
    }
}

data class LoginResponseEntity(
    @SerializedName("token") val token: String?,
    @SerializedName("user") val user: UserEntity?,
    @SerializedName("enterprises") val enterprises: List&lt;EnterprisesEntity&gt;?,
    @SerializedName("vendors") val vendors: List&lt;VendorsEntity&gt;?)

data class UserEntity(
    @SerializedName("id") val id: String?,
    @SerializedName("email") val email: String?,
    @SerializedName("first_name") val firstName: String?,
    @SerializedName("last_name") val lastName: String?,
    @SerializedName("phone") val phone: String?,
    @SerializedName("address") val address: String?,
    @SerializedName("dob") val dob: String?,
    @SerializedName("customer") val customer: String?,
    @SerializedName("enterprise_ids") val enterpriseIds: List&lt;String&gt;?,
    @SerializedName("vendor_ids") val vendorIds: List&lt;String&gt;?)

data class EnterprisesEntity(
    @SerializedName("id") val id: String?,
    @SerializedName("enterprise_name") val enterpriseName: String?,
    @SerializedName("type_label") val typeLabel: String?,
    @SerializedName("referral_code") val referralCode: String?,
    @SerializedName("country") val country: String?,
    @SerializedName("image_id") val imageId: String?,
    @SerializedName("managers") val managers: List&lt;String&gt;?,
    @SerializedName("members") val members: List&lt;String&gt;?,
    @SerializedName("stripe") val stripe: Boolean,
    @SerializedName("locations") val locations: List&lt;String&gt;?)

data class VendorsEntity(
    @SerializedName("id") val id: String?,
    @SerializedName("vendor_name") val vendorName: String?,
    @SerializedName("type_label") val typeLabel: String?,
    @SerializedName("user_role") val userRole: String?,
    @SerializedName("latitude") val latitude: Float,
    @SerializedName("longitude") val longitude: Float,
    @SerializedName("partner") val partner: Boolean,
    @SerializedName("country") val country: String?,
    @SerializedName("image_id") val imageId: String?,
    @SerializedName("stripe") val stripe: Boolean)

data class LoginResponse(
    val token: String,
    val user: User?,
    val enterprises: List&lt;Enterprises&gt;,
    val vendors: List&lt;Vendors&gt;)

data class User(
    val id: String?,
    val email: String?,
    val firstName: String?,
    val lastName: String?,
    val phone: String?,
    val address: String?,
    val dob: String?,
    val customer: String?,
    val enterpriseIds: List&lt;String&gt;,
    val vendorIds: List&lt;String&gt;)

data class Enterprises(
    val id: String,
    val enterpriseName: String,
    val typeLabel: String,
    val country: String,
    val imageId: String,
    val managers: List&lt;String&gt;,
    val members: List&lt;String&gt;,
    val stripe: Boolean,
    val locations: List&lt;String&gt;)

data class Vendors(
    val id: String,
    val vendorName: String,
    val typeLabel: String?,
    val userRole: String,
    val latitude: Float,
    val longitude: Float,
    val partner: Boolean,
    val country: String?,
    val imageId: String,
    val stripe: Boolean)

enum class State {
    STATE_1, STATE_2, STATE_4, READY, UNKNOWN
}

val list = listOf(READY, STATE_2, STATE_1)

STATE_2
val list = listOf(READY, STATE_1)

STATE_1
val list = listOf(STATE_2, STATE_1)

STATE_2
val list = listOf(UNKNOWN, STATE_2)

STATE_2
find
private fun filter(states: List&lt;State&gt;): State {
    val currentStates = states.filter {
        it != State.UNKNOWN || it != State.READY
    }

    currentStates.find { it == State.STATE_4 }?.let {
        return it
    } ?: currentStates.find { it == State.STATE_2 }?.let {
        return it
    } ?: currentStates.find { it == State.STATE_1 }?.let {
        return it
    }
}

sealed class Node {
    abstract val parent: Parent?
}

class Child(
    override val parent: Parent,
) : Node()

class Parent(
    override val parent: Parent?,
    val children: List&lt;Node&gt;
) : Node()

interface MyInterface {
}

class MyFirstClass : MyInterface {
}

class MySecondClass : MyInterface {
}

MyInterface
fun someMethod(param: MyInterface) {
}

somethod(MySecondClass())

MyInterface
java.lang.reflect.Method
org.springframework.expression.spel.support.StandardEvaluationContext#registerFunction
companion object {
    @JvmStatic
    fun foo(): Boolean = true
}

Companion::foo.javaMethod!!

Companion.javaClass.getMethod("foo").modifiers

Modifier.isStatic
false
org.springframework.expression.spel.SpelEvaluationException:
EL1039E: Only static methods can be called via function references.
The method '…$Companion.foo' referred to by name 'foo' is not static.

data class LineStyle(val thickness: Float) {
    override fun toString() =
            if (thickness == 0f) {
                "NO_LINE"
            } else {
                "LineStyle(${thickness}f)"
            }

    companion object {
        @JvmField
        val NO_LINE = LineStyle(0f)
    }
}

(key, value)
hashmap
kotlin
hashmap
val tips = hashMapOf("Having a balanced diet is the key" to "Have nutritious foods like vegetables and fruits along with legumes, whole wheat, cereals etc."
            , "Fluids will help you manage" to "Drink sufficient water and fluids to maintain the retention of water in your body."
            , "Do not miss prenatal supplements" to "Doctors prescribe prenatal vitamin and mineral supplements for the normal growth and development."
            , "Folic acid is essential" to "During pregnancy, have folic acid (supplement) or folate (natural source of folic acid) to avoid various health problems.")

(key, value)
hashmap
   private val REQUEST_CAMERA = 1002
   var foto: Uri? = null

   @RequiresApi(Build.VERSION_CODES.O)
   override fun onCreate(savedInstanceState: Bundle?) {
       super.onCreate(savedInstanceState)
       setContentView(R.layout.activity_main)
       abreCamara_click()}

   private fun abreCamara_click() {
       btnCamara.setOnClickListener() {
           if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {
               if (checkSelfPermission(Manifest.permission.CAMERA) == PackageManager.PERMISSION_DENIED
                   || checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_DENIED
               ) {
                   val permisosCamara = arrayOf(
                       Manifest.permission.CAMERA,
                       Manifest.permission.WRITE_EXTERNAL_STORAGE
                   )
                   requestPermissions(permisosCamara, REQUEST_CAMERA)
               } else
                   abreCamara()
           } else
               abreCamara()
       }
   }

   override fun onRequestPermissionsResult(
       requestCode: Int,
       permissions: Array&lt;out String&gt;,
       grantResults: IntArray
   ) {
       super.onRequestPermissionsResult(requestCode, permissions, grantResults)
       when(requestCode){
           REQUEST_CAMERA -&gt; {
               if(grantResults[0] == PackageManager.PERMISSION_GRANTED)
                   abreCamara()
               else
                   Toast.makeText(applicationContext,"No se puede acceder a la cámara", Toast.LENGTH_SHORT).show()
           }
       }
   }

   private fun abreCamara(){
       val value = ContentValues()
       value.put(MediaStore.Images.Media.TITLE,"Nueva imagen")
       foto = contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, value)
       val camaraIntent = Intent(MediaStore.ACTION_IMAGE_CAPTURE)
       camaraIntent.putExtra(MediaStore. EXTRA_OUTPUT,foto)
       startActivityForResult(camaraIntent,REQUEST_CAMERA)
   }

   override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
       super.onActivityResult(requestCode, resultCode, data)
       if(resultCode==Activity.RESULT_OK &amp;&amp; requestCode == REQUEST_CAMERA){
           imgFoto.setImageURI(foto)
       }
   }


Object from = ...
Class&lt;T&gt; toClass = ...

T result = toClass.cast(from);

Any? from = ...
KClass&lt;T&gt; toClass = ...

T result = // toClass.cast(from) - how to convert this line to Kotlin?

// ...my logic to create a stream of identical class type instances 
// that all have a vanilla blocking .calculate():Double method...
// which I now want to (maybe?) map to Jobs

listOf(MyClass(1), MyClass(2), MyClass(1000))
.map {
  launch(CommonPool) {
    val errorRate: Double? = it?.calculate()
    println("${it?.javaClass?.simpleName}  $errorRate") // desired output
    errorRate
  }
}
.collect(Collectors.toList&lt;Job&gt;())

jobs.forEach {
    println(it.join())
}

fun MyClass.calculateTimeLimited(): Double = runBlocking {
  withTimeout(TIMEOUT) {
    this.calculate() // &lt;-- doesn't compile! "this" is "CoroutineScope"

New -&gt; Module
Java Library
forEach
HashMap
items[0]
single(name = walletOkHttpTag) {
        createOkHttpClient {
            addHeaders(
                *mutableListOf&lt;Pair&lt;String, String&gt;&gt;().apply {
                    add(HeaderKey.ACCEPT to APPLICATION_JSON_HEADER)
                    if (isDebug || isBeta) {
                        add(HeaderKey.AUTHORIZATION to BASIC_AUTH_WALLET_STAGE_HEADER)
                    }
                }.toTypedArray()
            )
        }
    }

"Extrace string resource"
strings.xml
import packetId.R.string
getString(string.xxx)
string.xml
var validPushes: MutableList&lt;Push&gt; = IntStream.range(0, pushQuantity).mapToObj { inx -&gt; readPush()}
              .filter { push  -&gt; processor.validatePush(push, state)}
              .collect(Collectors.toList());

var test = listOf&lt;String&gt;("Blah blah " + list1.shuffled().take(1)[0] + " blah blah")
biglist
test
biglist
    var list3 = listOf&lt;String&gt;("Something something1","Something something2")
    var list2 = listOf&lt;String&gt;("item1", "item2", "item3", "item4")
    var list = listOf&lt;String&gt;("Blah " + list2.shuffled().take(1)[0] + " blah")
    var sb = StringBuilder ()
    var biglist = listOf&lt;String&gt;()
    if (...) biglist += list
    if (...) biglist += list3.get(0)
    if (...) biglist += list3.get(1)
    for (i in 0 until 4) {
        sb.append(biglist.shuffled().take(1)[0] + "\n")
        i + 1
    }

    println(sb)

Something something1
Blah item2 blah
Something something2
Blah item4 blah

Something something1
Blah item2 blah
Something something2
Blah item2 blah

sb
test
list1
biglist
for
private var data: Any? // fixed, can't change data type as it's in a compiled library to accept all kinds of data.

fun users() : ArrayList&lt;User&gt; {
    return (data as Array&lt;*&gt;).filterIsInstance&lt;User&gt;() as ArrayList&lt;User&gt;
}

fun users() : ArrayList&lt;User&gt; {
    return (data as ArrayList&lt;*&gt;).filterIsInstance&lt;User&gt;() as ArrayList&lt;User&gt;
}

fun addItem(userVO: User) {
    users().add(user)
}

val users: ArrayList&lt;User&gt; get() = ((data as? ArrayList&lt;Any&gt;)?.filterIsInstance&lt;User&gt;() ?: emptyList()) as ArrayList&lt;User&gt;

fun addItem(user: User) {
    users.add(user)
}

btnApplyPayment.setOnClickListener {
    if (isFloat(strAmount))            
       //exit here

fun main(args: Array&lt;String&gt;) {
    val language = if (args.size == 0) "EN" else args[0]
    println(when (language) {
        "EN" -&gt; "Hello!"
        "FR" -&gt; "Salut!"
        "IT" -&gt; "Ciao!"
        else -&gt; "Sorry, I can't greet you in $language yet"
    })
}

fun main(args: Array&lt;String&gt;) {
    println(when (if (args.size == 0) "EN" else args[0]) {
        "EN" -&gt; "Hello!"
        "FR" -&gt; "Salut!"
        "IT" -&gt; "Ciao!"
        else -&gt; "Sorry, I can't greet you in $language yet"
    })
}

when
if
error:
class A{
   int x;
   int y;
   A(int x, int y){
    this.x=x;
     this.y=y
   }
}

class B extends A{  
    int x,y;   
    B(int a, int b){
        super(x,getSum(x,y));
     }
   int getSum(int x, int y){
       return x+y;
    }
}

public interface TokenAuthenticationConfig {

    public fun apiKey() : String

}

@Component
@ConfigurationProperties(prefix = "service.api")
public open class TokenAuthenticationConfigImpl : TokenAuthenticationConfig
{
    public var apiKey : String

    constructor() {
        this.apiKey = ""
    }

    override fun apiKey(): String
    {
        return this.apiKey
    }
}

hashmap
Collections.shuffle()
list
hashmap
val tips = hashMapOf("Having a balanced diet is the key" to "Have nutritious foods like vegetables and fruits along with legumes, whole wheat, cereals etc., at regular intervals. Avoid oily and spicy food to ease your pregnancy symptoms. Plan your food intake and have it as 4-5 light meals every day."
            , "Fluids will help you manage" to "Drink sufficient water and fluids to maintain the retention of water in your body. This will help you control constipation, indigestion, dryness, fatigue, bloating and gas. Avoid alcohol and caffeine drinks which may have serious effects during pregnancy."
            , "Do not miss prenatal supplements" to "Doctors prescribe prenatal vitamin and mineral supplements for the normal growth and development. Do not skip these supplements as they can prevent preterm labour and many serious health concerns in the newborn."
            , "Folic acid is essential" to "During pregnancy, have folic acid (supplement) or folate (natural source of folic acid) to avoid various health problems. They are rich in green leafy vegetables, oranges, avocado etc.")

class myfragment : Fragment() {
private lateinit var myLayoutAdapter: MultiPurposeListAdapter&lt;*&gt;
private var myItems = mutableListOf&lt;AbstractFlexibleItem&lt;*&gt;&gt;()

override fun onActivityCreated(savedInstanceState: Bundle?) {
    super.onActivityCreated(savedInstanceState)

    myLayoutAdapter = MultiPurposeListAdapter(myItems, this, true)

    // Prepare the RecyclerView and attach the Adapter to it
    fragment_recycler_view.apply {
        layoutManager = createNewLinearLayoutManager()
        adapter = mIngredientsLayoutAdapter
        setHasFixedSize(false) //Size of RecyclerView will change
    }
}

/******
 * A function to add items
 ******
fun addNewItem(itemToAdd: MyItem) {
    //Note: itemToAdd is from MyItem that extends AbstractFlexibleItem

    // If I try to invoke the addOtem method from the FlexibleAdapter
    // I get a Type mismatch error
    // addItem is not overriden by MultiplePurposeListAdapter!

    myLayoutAdapter.addItem(itemToAdd)  // &lt;- Here I get a Type mismatch error
                                        // Required: Nothing
                                        // Found: MyItem
    }
}

open class MultiPurposeListAdapter&lt;T: AbstractFlexibleItem&lt;*&gt;&gt;
@JvmOverloads constructor(items: List&lt;T&gt;?, listeners: Any? = null, stableIds: Boolean = true)
: FlexibleAdapter&lt;T&gt;(items, listeners, stableIds) {

    // Here we extend the FlexibleAdapter with custom filters
    }

public class FlexibleAdapter&lt;T extends IFlexible&gt; extends AnimatorAdapter {

private List&lt;T&gt; mItems // The main container for ALL items

/**
 * Simply append the provided item to the end of the list.
 * &lt;p&gt;Convenience method of {@link #addItem(int, IFlexible)} with
 * {@code position = getMainItemCount()}.&lt;/p&gt;
 *
 * @param item the item to add
 * @return true if the internal list was successfully modified, false otherwise
 */
public boolean addItem(@NonNull T item) {
    return addItem(getItemCount(), item);
}

/**
 * Returns the total number of items in the data set held by the adapter.
 *
 * @return the total number of items (headers and footers INCLUDED) held by the adapter
 */
@Override
public int getItemCount() {
    return mItems.size();
}

/**
 * Inserts the given item at the specified position or Adds the item to the end of the list
 * (no matters if the new position is out of bounds!).
 *
 * @param position position inside the list, if negative, items will be added to the end
 * @param item     the item to add
 * @return true if the internal list was successfully modified, false otherwise
 */
public boolean addItem(@IntRange(from = 0) int position, @NonNull T item) {
    if (item == null) {
        log.e("addItem No item to add!");
        return false;
    }
    log.v("addItem delegates addition to addItems!");
    return addItems(position, Collections.singletonList(item));
}

/**
 * Inserts a set of items at specified position or Adds the items to the end of the list
 * (no matters if the new position is out of bounds!).
 *
 * @param position position inside the list, if negative, items will be added to the end
 * @param items    the set of items to add
 * @return true if the internal list was successfully modified, false otherwise
 */
public boolean addItems(@IntRange(from = 0) int position, @NonNull List&lt;T&gt; items) {
    if (items == null || items.isEmpty()) {
        log.e("addItems No items to add!");
        return false;
    }
    int initialCount = getMainItemCount(); // Count only main items!
    if (position &lt; 0) {
        log.w("addItems Position is negative! adding items to the end");
        position = initialCount + mScrollableHeaders.size();
    }
    // Insert the items properly
    performInsert(position, items, true);
    // Show the headers of new items
    showOrUpdateHeaders(items);
    // Call listener to update EmptyView
    if (!recursive &amp;&amp; mUpdateListener != null &amp;&amp; !multiRange &amp;&amp; initialCount == 0 &amp;&amp; getItemCount() &gt; 0) {
        mUpdateListener.onUpdateEmptyView(getMainItemCount());
    }
    return true;
}
}

fun &lt;P1, P2, R&gt; curry2(fn: (p1: P1, p2: P2) -&gt; R): (P1) -&gt; R {
    return { p: P1 -&gt; fn(p, p2) }
}

fn
    fun getMinimumAgeInMillis(): Long {
        val long: Long = 1000 * 60 * 60 * 24 * 365 * 14
        return (long)
    }

class Test&lt;T&gt; : (T) -&gt; Unit, () -&gt; T {
    ...
}

FunctionN
FunctionN
Function
FunctionN
Function
replace
takeIf{}
,
replace(",", "")
    .takeIf {
        println(it) //prints nothing
        println(it.length) //prints 0
        if (isNotEmpty()) { // docs says that it checks if length &gt; 0, which is not, so string is empty
            println("not empty") // still prints not empty
        } else {
            println("empty")
        }
        isNotEmpty()
    }?.toDouble()) // runs toDouble on empty string

System.out: 0
System.out: not empty

sealed class IntList
data class Cons(val head: Int, val tail: IntList): IntList()
data class Nil() : IntList()

sealed class Nil() : IntList()

hashCode()
equals()
data class
Nil
object Nil : IntList()

sealed class List&lt;A&gt;
data class Cons&lt;A&gt;(val head: A, val tail: List&lt;A&gt;): List&lt;A&gt;()

Nil
List&lt;A&gt;
A
A
A
Nil
List&lt;Nothing&gt;
sealed class List&lt;out A&gt;
data class Cons&lt;A&gt;(val head: A, val tail: List&lt;A&gt;): List&lt;A&gt;()
object Nil : List&lt;Nothing&gt;()

val xs: List&lt;Int&gt; = Cons(1, Cons(2, Nil))
val ys: List&lt;Char&gt; = Cons('a', Cons('b', Nil))

value -&gt;  println(value)
fun foo(): Flow&lt;Int&gt; = flow { 
    println("Flow started")
    for (i in 1..3) {
        delay(1000)
        emit(i)
    }
}

fun main() = runBlocking&lt;Unit&gt; {
    println("Calling foo...")
    val flow = foo()
    println("Calling collect...")
    flow.collect { value -&gt;  println(value)                                                            
                 } 
    println("Done")    
}

fun foo(): Flow&lt;Int&gt; = flow { 
    println("Flow started")
    for (i in 1..3) {
        delay(1000)
        emit(i)
    }
}

fun main() = runBlocking&lt;Unit&gt; {
    println("Calling foo...")
    val flow = foo()
    println("Calling collect...")
    flow.collect { value -&gt; (                            
                              println(value) 
                              delay(10) 
                            )
                 } 
    println("Done")    
}

fun &lt;T : Tag&gt; T.set(name: String, value: String?): T {
    if (value != null) {
        attributes.add(Attribute(name, value))
    }
    return this
}

fun Tag.set(name: String, value: String?): Tag {
    if (value != null) {
        attributes.add(Attribute(name, value))
    }
    return this
}

fun myFun(isAsync: Boolean) {
  ...
}

isAsync = true
isAsync = false
data class Product(val name: String,
                   val maker: List&lt;String&gt;)

[{"name":"Car", "maker":["Audi"]},
 {"name":"Car", "maker":["BMW"]},
 {"name":"Motorcycle", "maker":["Yamaha"]},
 {"name":"Motorcycle", "maker":["Kawasaki"]}
]

name
[{"name":"Car", "maker":["Audi", "BMW"]},
 {"name":"Motorcycle", "maker":["Yamaha","Kawasaki"]}
]

example3.field.method()
example2.field.method()
class Example3 {
    val field = object {
        fun method() {}
    }
}

fun showcase() {
    val example1 = object {
        fun method() {}
    }
    example1.method()
    println(example1::class.qualifiedName)

    class Example2 {
        val field = object {
            fun method() {}
        }
    }

    val example2 = Example2()
    example2.field.method()
    println(example2::class.qualifiedName)

    val example3 = Example3()
    // example3.field.method()  // won't compile
    println(example3::class.qualifiedName)
}

class Foo(val bar: String, val baz: Boolean = true) {
    constructor(bar: String) : this(bar, false)
}

Foo("")
baz
true
Foo("")
baz
false
kotlin-runtime.jar
kotlin-stdlib.jar
1.0.0-beta-1103
kotlin-stdlib.jar
kotlin-runtime.jar
Runnable
var condition: String? = null
Runnable {
    if (condition == null) return
    // do something
}

LocalDate
LocalDate
String
LocalDate
String
class SomeExampleClass(var _date: LocalDate) {
    var date = _date
        set(value) {
            when(value) {
                is LocalDate -&gt; value
                is String -&gt; LocalDate.parse(value)
            }
        }
}

Stream&lt;String&gt; lines =
  Files.list(Paths.get(dir_in))
  .flatMap((Files::lines));

// do something with my stream

lines.close();

when (x) {
    1 -&gt; print("x == 1")
    2 -&gt; print("x == 2")
     else -&gt; { // Note the block
        print("x is neither 1 nor 2")
   }
}

interface BlogService {
    suspend fun tag() : JsonObject
}

class C(val field: T): T by field

People
string
string
// Save data
val peopleString = myList.toString()

// String saved is
[People(name=john, age=23), People(name=mary, age=21), People(name=george, age=11)]

peopleString
val peopleList: List&lt;People&gt; = peopleString.?

private fun createVideo(path: Url = DEFAULT_PATH, width: Int = 0, height: Int = 0) {
    if (path is default value) {
        // it means caller didn't set path
        return AVideo()
    else {
        return BVideo()
    }
}

  private fun createMediaItemMock(mediaType: Int,
                                    width: Int = WIDTH_2K,
                                    height: Int = HEIGHT_2K,
                                    trimmingDataCan: Boolean) = mock&lt;PickerMediaItem&gt; {
        on { it.mediaType } doReturn mediaType
        it.width = width
        it.height = height
        it.trimmingData = mock {
            on { can() } doReturn trimmingDataCan
        }
    }

    private fun createMediaItemMock(mediaType: Int,
                                    width: Int = WIDTH_2K,
                                    height: Int = HEIGHT_2K) = mock&lt;PickerMediaItem&gt; {
        on { it.mediaType } doReturn mediaType
        it.width = width
        it.height = height
    }

abstract class Person constructor (var name :String ,var gender :String) {
}

class Employee() : Person() {
    constructor(age : Int ) : super (name , gender)
} 

class A{ public static Integer age = 30;}
print(A.age)
print(A.INSTANCE.age)
print(A.Companion.age)
import android.widget.RadioButton
import android.widget.RadioGroup
import androidx.appcompat.app.AppCompatActivity
import com.xwray.groupie.kotlinandroidextensions.Item
import com.xwray.groupie.kotlinandroidextensions.ViewHolder
import kotlinx.android.synthetic.main.activity_set_frequency.frequency_options
import kotlinx.android.synthetic.main.rx_section_frequency.*


class RxSectionFrequency: Item() {


    companion object comp : AppCompatActivity(){


    }

    lateinit var radioGroup : RadioGroup
    lateinit var radioButton: RadioButton

    override fun bind(viewHolder: ViewHolder, position: Int) {

        fun checkBtn(){
            val frequency_fragment = FrgFrequencyInterval()

            var radioId = radioGroup.checkedRadioButtonId
            radioButton = radioGroup.findViewById(radioId)

            var radio_name = radioButton.text

            var transaction = supportFragmentManager.beginTransaction().add(R.id.fragment_holder,frequency_fragment).commit()
            var removeFragment = supportFragmentManager.beginTransaction().remove(frequency_fragment)


        if(radio_name=="Interval"){ try {transaction} catch (e: Exception){
            println(e)}}

        }

        radioGroup = viewHolder.frequency_options
        radioGroup.setOnCheckedChangeListener{ radioGroup, i -&gt; checkBtn() }

    }

    override fun getLayout()=R.layout.rx_section_frequency
}```


On the radioGroup selection I expect to load a fragment called FrgFrequencyInterval() into a FrameLayout called fragment_holder within rx_section_frequency layout. As the code is throws the following exception and no further explanation as what is causing the error:
java.lang.IllegalStateException: Activity has been destroyed

var text: String?
text!!
text as String
text
null
Mockito.`when`(mockedSkillMaxCountRepository.getSkillMaxCount()).thenReturn(
     SkillMaxCount(count = 65),
     SkillMaxCount(count = 65)
)

mockSkillMaxCount(SkillMaxCount(count = 65), SkillMaxCount(count = 65),...)

private fun mockSkillMaxCount(SkillMaxCount(count = 65),SkillMaxCount(count = 65),...){       
     Mockito.`when`(mockedSkillMaxCountRepository.getSkillMaxCount()).thenReturn(params)
}

sealed class Attributes

data class Attributes1(
    val prop1: String
) : Attributes()

private data class IMyType&lt;A&gt;(
    val attributes: A
) where A: Attributes

typealias MyType1 = IMyType&lt;Attributes1&gt;

MyType1
IMyType
val outputs: NDArray = Nd4j.zeros((868 - 60))
outputs
fun main(args:Array&lt;String&gt;)
{
    println("Enter values of c and d")
    var c:String= readLine()!!
    var d:String= readLine()!!
    try 
   {
       division(c,d)
    } catch (e:Exception)
     {
       println("Exception Occured")
       e.printStackTrace()
     }
}

fun division(a:Int,b:Int){
    println(a/b)

}

data class AModel(var title: String, var body: String) 

data class AModel(var title: String, var body: String)
data class BModel(var title: String, var body: String)
data class CModel(var title: String, var body: String)
data class DModel(var title: String, var body: String)
data class EModel(var title: String, var body: String)

val
const val
const
const
removeAll()
data class Dog(var name: String)

val dog1 = Dog(name = "dodo")
val dog2 = Dog(name = "mimi")

val set = mutableSetOf&lt;Dog&gt;()
set.add(dog1)
set.add(dog2)

dog1.name = "dodo2"

val before_size = set.size // 2

set.removeAll { true }

val after_size = set.size  // why it is 1!?, I expect it should be 0

removeAll
class Num1Activity : AppcompatActivity() {


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_num1)


        nextNumBtn.setOnClickListener {
            val secondNum = Intent(this, Num2Activity::class.java)
            intent.putExtra("num1", uno.text.toString())
            startActivity(secondNum)
        }
    }
}

class Num2Activity : AppcompatActivity() {


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_num2)

        gotoAnsBtn.setOnClickListener {
            val answer = Intent(this, AnswerActivity::class.java)
            intent.putExtra("num2", dos.text.toString())
            startActivity(answer)
        }
    }
}

class AnswerActivity : AppCompatActivity() {



    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_answer)

    }
}

MutableSet
sealed class
MutableSet
sealed class LoginSavedCommand {
    class Login(val email: String, val password: String) : LoginSavedCommand()
    class SaveData(val email: String, val password: String) : LoginSavedCommand()
}

fun main(args: Array&lt;String&gt;) {

    val mSet: MutableSet&lt;LoginSavedCommand&gt; = hashSetOf()

    mSet.add(LoginSavedCommand.Login("oba", "pass"))
    mSet.add(LoginSavedCommand.Login("faiii", "blabla"))

    if (mSet.add(LoginSavedCommand.Login("oba", "pass"))) {
        println("don't")
    } else {
        println("do")
    }
}

LoginSavedCommand.Login
MutableSet
println
selaed class
var i = 0
integers = iterate{i++}

integers[3] // does not work
integers drop 3 // works

fun main() {

    val x = Example1()
    x.listOfInt = mutableListOf(3,4)
    x.listOfInt.add(455)
}

class Example1 {

  var listOfInt: MutableList&lt;Int&gt; = mutableListOf()
    set(value) { 
        println("setting it here to value =&gt; $value")
         field = value 
    }
}
// It only prints:
// setting it here to value =&gt; [3, 4]


import Foundation

class Example1 {
  var fieldProperty: Int = 0

  var listOfInt: [Int] = [] {
    didSet { 
        print("setting it here to value =&gt; \(listOfInt) vs oldValue: \(oldValue)")      
    }
  }
}

let x = Example1()
x.listOfInt = [3,4]
x.listOfInt.append(455)

// this prints:
// setting it here to value =&gt; [3, 4] vs oldValue: []
// setting it here to value =&gt; [3, 4, 455] vs oldValue: [3, 4]

"https://www.xxxx.com/static/images/data/operators/"+code+"_logo0.png"
override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {

    val view : View = LayoutInflater.from(context).inflate(R.layout.row_layout,parent,false)


    val code = view.findViewById(R.id.code_id) as AppCompatTextView
    val LogoAriline = view.findViewById(R.id.logo_image) as ImageView

    code.text = list[position].logo
    Picasso.get().load(Uri.parse("https://www.xxxx.com/static/images/data/operators/"+code+"_logo0.png")).into(LogoAriline)



    return view as View
}
}

package com.iraqairoirt.iraqairports

data class FlightShdu (val Callsign : String, val Airline : String , val logo : String)

class NonNullableBehaviourSubject&lt;T : Any&gt;(defaultValue: T) : Subject&lt;T&gt;() {
   private val behaviourSubject = BehaviorSubject.createDefault&lt;T&gt;(defaultValue)
}

val emailValidationSubject = NonNullableBehaviourSubject(Int)

emailValidationSubject.onNext(error?.errorResId)

Required: Companion.Int
Found: Int?

var mRef:DatabaseReference? = null
var mNoteList:ArrayList&lt;Note&gt;? = null

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)

    val database = FirebaseDatabase.getInstance()
    mRef = database.getReference("Notes")

    mNoteList = ArrayList()

    add_new_note_btn.setOnClickListener {
        showDialogAddNote() }

}

override fun onStart() {
    super.onStart()

    mRef?.addValueEventListener(object :ValueEventListener{
        override fun onCancelled(p0: DatabaseError) {
        }

        override fun onDataChange(p0: DataSnapshot) {

            for (n in p0.children){
                var note = n.getValue(Note::class.java)
                mNoteList!!.add(note!!)
            }

            var noteAdapter = NoteAdapter(applicationContext ,mNoteList!!)
            note_list_view.adapter = noteAdapter
        }
    })


}




fun showDialogAddNote(){
    val alertBuilder = AlertDialog.Builder(this)
    val view = layoutInflater.inflate(R.layout.add_note,null)

    alertBuilder.setView(view)
    val alertDialog= alertBuilder.create()
    alertDialog.show()


    view.btnSaveNote.setOnClickListener {
        val title = view.title_edit_text.text.toString()
        val note = view.note_edit_text.text.toString()


        if (title.isNotEmpty()&amp;&amp; note.isNotEmpty()){

            var id = mRef!!.push().key

            var myNote = Note(id!!,title,note,getCurrentDate())


            mRef!!.child(id!!).setValue(myNote)
            alertDialog.dismiss()

        }
        else{
            Toast.makeText(this,"Empty Note", Toast.LENGTH_LONG).show()
        }
    }
}

// method to get current Date

fun getCurrentDate():String{
    val calendar = Calendar.getInstance()
    val mdformat = SimpleDateFormat("EEEE hh:mm a")
    val strDate = mdformat.format(calendar.time)
    return strDate

}

var id:String? = null
var title:String? = null
var note:String? = null
var timestamp: String? = null

constructor(){

}



constructor(id:String, title:String, note:String, timestamp:String){

    this.id = id
    this.title = title
    this.note = note
    this.timestamp = timestamp
}

override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
    val view = LayoutInflater.from(context).inflate(R.layout.note_layout,parent,false)

    val note:Note? = getItem(position)
    view.titleTextView.text = note?.title
    view.timeTextView.text = note?.timestamp.toString()

    return view

}

class MyClass {
    companion object Factory {
        fun create(): MyClass = MyClass()
    }
}

val instance = MyClass.create()

create
MyClass()
create
if (x == y)
private fun findFixPoint(): Double {
    var x = 1.0
    while (true) {
        val y = Math.cos(x)
        if (x == y) return y
        x = y
    }
}

fun parametersOf(vararg pairs: Pair&lt;String, Any&gt;): Parameters {

    val p = Parameters(pairs.size)

    for ((key, value) in pairs)
        when (value) {
            is String  -&gt; p.put(key, value)
            is Int     -&gt; p.put(key, value)
            is Double  -&gt; p.put(key, value)
            is Boolean -&gt; p.put(key, value)
            else -&gt; throw BBIllegalOperationException("Unknown type for value:'$value' of key:'$key'")
        }

    return p
}

fun parametersOf(map: Map&lt;String, Any&gt;): Parameters {
    val p = Parameters(map.size)

    for ((key, value) in map)
        when (value) {
            is String  -&gt; p.put(key, value)
            is Int     -&gt; p.put(key, value)
            is Double  -&gt; p.put(key, value)
            is Boolean -&gt; p.put(key, value)
            else -&gt; throw BBIllegalOperationException("Unknown type for value:'$value' of key:'$key'")
        }

    return p
}

public class BadRequestAlertException extends AbstractThrowableProblem {

    private static final long serialVersionUID = 1L;

    private final String entityName;

    private final String errorKey;

    public BadRequestAlertException(String defaultMessage, String entityName, String errorKey) {
        this(ErrorConstants.DEFAULT_TYPE, defaultMessage, entityName, errorKey);
    }

    public BadRequestAlertException(URI type, String defaultMessage, String entityName, String errorKey) {
        super(type, defaultMessage, Status.BAD_REQUEST, null, null, null, getAlertParameters(entityName, errorKey));
        this.entityName = entityName;
        this.errorKey = errorKey;
    }

    public String getEntityName() {
        return entityName;
    }

    public String getErrorKey() {
        return errorKey;
    }

    private static Map&lt;String, Object&gt; getAlertParameters(String entityName, String errorKey) {
        Map&lt;String, Object&gt; parameters = new HashMap&lt;&gt;();
        parameters.put("message", "error." + errorKey);
        parameters.put("params", entityName);
        return parameters;
    }
}

class BadRequestAlertException(type: URI = ErrorConstants.DEFAULT_TYPE, defaultMessage: String, val entityName: String, val errorKey: String) : AbstractThrowableProblem(type, defaultMessage, Status.BAD_REQUEST, null, null, null, getAlertParameters(entityName, errorKey)) {

    companion object {
        private const val serialVersionUID = 1L

        private fun getAlertParameters(entityName: String, errorKey: String): Map&lt;String, Any&gt; {
            val parameters = HashMap&lt;String, Any&gt;()
            parameters["message"] = "error.$errorKey"
            parameters["params"] = entityName
            return parameters
        }
    }
}

Class 'BadRequestAlertException' is not abstract and does not implement abstract base class member public abstract fun getCause(): Exceptional! defined in org.zalando.problem.AbstractThrowableProblem
getClause()
this
Activity
view
view.setOnClickListener {
    val self: View.OnClickListener = this // Not compiling, "this" references outer context
}

this
view.setOnClickListener(object: View.OnClickListener {
    override fun onClick(v: View) {
        val self: View.OnClickListener = this // Ok
    }
})

DefaultServiceLocator
interface ServiceLocator
interface ServiceLocator {
    companion object {
        private val LOCK = Any()
        private var instance: ServiceLocator? = null


        fun instance(context: Context): ServiceLocator {
            synchronized(LOCK) {
                if (instance == null) {
                    instance = DefaultServiceLocator(
                            app = context.applicationContext as Application,
                            useInMemoryDb = false)
                }
                return instance!!
            }
        }

        /**
         * Allows tests to replace the default implementations.
         */
        @VisibleForTesting
        fun swap(locator: ServiceLocator) {
            instance = locator
        }
    }

    ...
}


open class DefaultServiceLocator(val app: Application, val useInMemoryDb: Boolean) : ServiceLocator {
  ...
}

ArrayList&lt;Int&gt;
ArrayList&lt;Int&gt;
ArrayList&lt;Int&gt;
&gt;&gt;&gt; reduce(lambda x, y: x*y, [1,2,3,4,5,6])
output: 720

var allGood: Boolean = false
val deviceId: String = "3550200583"
var isValidId: Boolean = false
allGood = isValidId = deviceId.length &gt; 0 &amp;&amp; deviceId.length &lt;= 16

fun foo() { //doSomething }
fun bar(function: () -&gt; Unit) { 
    //anotherThing! 
    function()
}

bar(foo()) 

bar(::foo)

bar( { foo() } )

bar {
foo()
}

@Volatile
public var loggedIn = false
    public set(value) {
        if (this.loggedIn != value) {
            this.loggedIn = value
            database.write(LOGGED_IN, value)
        }
    }

var counter = 0 // the initializer value is written directly to the backing field
  set(value) {
    if (value &gt;= 0)
      field = value
  }

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Hans {
    String[] value() default {};
}

@Hans(value = "test")

@Hans(name = arrayOf("test"))

    var a = "abcd"
    println(System.identityHashCode(a)) //495053715
    var b = a
    a = "1234"
    println(System.identityHashCode(a)) //1922154895
    println(System.identityHashCode(b)) // 495053715

a
a
495053715
b
a
a
1922154895
495053715
b
Mutable
ArrayList&lt;AbstractObject&gt;
abstract
AbstractObject
abstractList.add(Object1)
RecyclerView
ViewTypes
abstract class ListItem {

    abstract val type: Int

    companion object {
        const val TYPE_HEADER = 0
        const val TYPE_ITEM = 1
    }

}

class HeaderItem(val headerTitle: String) : ListItem() {

    val type: Int
        get() = TYPE_HEADER

}

class ObjectItem(val object: ParseObject) : ListItem() {


    val type: Int
        get() = TYPE_ITEM

}

var recyclerViewArray: ArrayList&lt;out ListItem&gt; = ArrayList()

var recyclerViewArray: ArrayList&lt;ListItem&gt; = ArrayList()

Type mismatch
as
as
This cast can never succeed.
open class Base {

    open fun v() {}

    fun nv() {}
}

class Derived() : Base() {

    override fun v() {}
}

object Foo : Any() { ... }

val Foo = object : Any() { ... }

class RegisterThingPostBody(inputBody: Map&lt;String, Any&gt;) {
  val device: Device by inputBody
  val thing: Thing by inputBody

  class Device(inputBody: Map&lt;String, Any&gt;) {
    val serialnumber: String by inputBody
    val securityCode : String by inputBody
  }

  class Thing(inputBody: Map&lt;String, Any&gt;) {
    val name: String by inputBody
    val location: Location by inputBody

    class Location(inputBody: Map&lt;String, Any&gt;) {
        val street: String by inputBody
        val city: String by inputBody
        val state: String by inputBody
        val lat: Double by inputBody
        val lon: Double by inputBody
    }
  }
}

ClassCastException
class RegisterThingPostBody(inputBody: Map&lt;String, Any&gt;) {
  val device = Device(inputBody["device"] as Map&lt;String, Any&gt;)
  val thing = Thing(inputBody["thing"] as Map&lt;String, Any&gt;)

  class Device(inputBody: Map&lt;String, Any&gt;) {
    val serialnumber: String by inputBody
    val securityCode : String by inputBody
  }

  class Thing(inputBody: Map&lt;String, Any&gt;) {
    val name: String by inputBody
    val location = Location(inputBody["location"] as Map&lt;String, Any&gt;)

    class Location(inputBody: Map&lt;String, Any&gt;) {
        val street: String by inputBody
        val city: String by inputBody
        val state: String by inputBody
        val lat: Double by inputBody
        val lon: Double by inputBody
    }
  }
}

val keys = arrayOf("butter", "milk", "apples")
val values = arrayOf(5, 10, 42)
val map: Map&lt;String, Int&gt; = ???

accountsLoopQuery                             - "$.contactPoints.contactPoints[?(@.contactAccount.id)]"
brokerPassword                                - *****
brokerURI                                     - tcp://localhost:61616
brokerUsername                                - admin
contactPointPriorityProperties                - "contactPointPriority.properties"
customerCollection                            - "customer"
customerHistoryCollection                     - "customer_history"
defaultSystemOwner                            - "TUIGROUP"

mutableList.forEach { cp -&gt;
    println(String.format("%-45s - %s", cp.name, cp.value))
}

as String
fun
String
 parametersOf("appKey" to "asdas3334", "token" to "433432")

/**
 * Returns a new [Parameters] with the specified contents, given as a list of pairs
 * where the first component is the key and the second is the value.
 */
fun &lt;K, V&gt; parametersOf(vararg pairs: Pair&lt;K, V&gt;): Parameters {

    val p = Parameters(pairs.size)

    for ((key, value) in pairs)
        p.put(key as String, value as String)

    return p
}

var userAttributes = mapOf&lt;Any?, Any?&gt;()

val responseEntity = restTemplate.exchange(userInfoEndpointUri, HttpMethod.GET, entity, Map::class.java)

userAttributes = responseEntity.body // compilation error

Type inference failed. Expected type mismatch:
required Map&lt;Any?, Any?&gt;
found    Map&lt;*,*&gt;!

lambTest2 : Int.(Int) -&gt; Int = { i: Int -&gt; i * 2 }
val intTest = 25
val Test = intTest.lambTest2(25)

print(Test)

error: unexpected tokens (use ';' to separate expressions on the same line) 
lambTest2 : Int.(Int) -&gt; Int = { i: Int -&gt; i * 2 

data class ValveSpan(val begin:Duration, val end:Duration, val key:String):Comparable&lt;ValveSpan&gt; {
    ...
}

constructor(doc:TSON):this(doc["begin"].duration!!, doc["end"].duration!!, doc["valves"].sequence!!.first()!!.string!!) {
    // do nothing here, because, uh, I had to do it all in the delegated primary????
}

constructor(doc:TSON) {
    var sanitizedBegin =  doc["begin"].duration ?: 0.minutes
    var sanitizedEnd = doc["end"].duration ?: 0.minutes
    var sanitizedKey = doc["valves"].sequence?.firstOrNull()?.string ?: ""
    primaryConstructor(sanitizedBegin, sanitizedEnd, sanitizedKey)
}

true -&gt; 1
false -&gt; 0

class Square(var width: Int, var height: Int) {
    var color : String = "red"
}

var color : String = "red"
get() = field
set(value) { field = value}

fun &lt;A, B&gt; foo(x: Any, y: A.() -&gt; B) = (x as A).y()

// at call site
foo&lt;String, Int&gt;("1", { toInt() })

B
Int
A
String
A
B
A
B
class &lt;A&gt; Foo() {
    fun &lt;B&gt; apply(x: Any, y: A.() -&gt; B) = ...
}

// at call site
Foo&lt;String&gt;().apply("1", { toInt() })

fab.setOnClickListener {
        val linearshell = LinearLayout(this, null, R.style.quickTest)
        linearshell.layoutParams = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        linearshell.orientation = LinearLayout.VERTICAL
        linearshell.textAlignment = LinearLayout.TEXT_ALIGNMENT_CENTER

        val Name = TextView(this)
        val CurrentPlace = TextView(this)
        val Date = TextView(this)

        Name.text = "WowwoW"
        CurrentPlace.text = "Here"
        Date.text = "11/04/2020"

        TableManners.addView(linearshell)
        linearshell.addView(Name)
        linearshell.addView(CurrentPlace)
        linearshell.addView(Date)

    }

&lt;resources&gt;
    &lt;!-- Base application theme. --&gt;
    &lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
        &lt;!-- Customize your theme here. --&gt;
        &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;
        &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;
        &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;
    &lt;/style&gt;

    &lt;style name="quickTest"&gt;
        &lt;item name="android:backgroundTint"&gt;@color/Redmen&lt;/item&gt;
        &lt;item name="android:background"&gt;@drawable/roundstyle&lt;/item&gt;
    &lt;/style&gt;
&lt;/resources&gt;

fun myDslFunction(builderFunction: MyReceiverObject.() -&gt; Unit) {
    val receiver = MyReceiverObject()
    builderFunction(receiver)
    // do something with receiver
}

class MyReceiverObject {
    infix fun myReceiversInfixFunc(someString: String) {
        // do something with someString
    }
}

fun test() {
    // desired syntax
    myDslFunction {
        myReceiversInfixFunc "some string" // doesn't compile
    }

    // not-desired syntax that compiles and works...
    myDslFunction { 
        this myReceiversInfixFunc "some string" // does compile
    }
}

this
class Rect(val width: Int, val height: Int, position: Position) : Positionable by DefaultPositionable(position) {

    override fun getPosition() {
        val parent = super.getPosition()
        return parent.copy(x = parent.x + 1)    
    }
}

interface GroupRepository&lt;T, F&gt; {
   fun save(): Kind&lt;T, Group&gt;
   fun findAll() Kind&lt;F, Group&gt;
}

class GroupRepositoryJpa(): GroupRepository&lt;ForIO, IO&lt;ForPage&gt;&gt; {

   override fun findAll(): IO&lt;PageK&lt;Group&gt;&gt; {
       val groups : Page&lt;Group&gt; = ...
       return IO { groups.k() }
   }
}

class ForPageK private constructor() { companion object }
typealias PageKOf&lt;A&gt; = Kind&lt;ForPageK, A&gt;

@Suppress("UNCHECKED_CAST", "NOTHING_TO_INLINE")
inline fun &lt;A&gt; PageKOf&lt;A&gt;.fix(): PageK&lt;A&gt; = this as PageK&lt;A&gt;

data class PageK&lt;A&gt;(val page: Page&lt;A&gt;) : PageKOf&lt;A&gt;, Page&lt;A&gt; by page

fun &lt;A&gt; Page&lt;A&gt;.k(): PageK&lt;A&gt; = PageK(this)



findAll
IO&lt;PageK&lt;Group&gt;&gt;
Return type is 'IO&lt;PageK&lt;Group&gt;&gt;', which is not a subtype of overridden
Kind&lt;F, Group&gt;
interface GroupRepository&lt;T, F, G&gt; {
   fun save(): Kind&lt;T, Group&gt;
   fun findAll() Kind&lt;F, Kind&lt;G Group&gt;&gt;
}

class GroupRepositoryJpa(): GroupRepository&lt;ForIO, ForIO, ForPageK&gt; {

   override fun findAll(): IO&lt;PageK&lt;Group&gt;&gt; {
       val groups : Page&lt;Group&gt; = ...
       return IO { groups.k() }
   }
}

data class Node(var prev: Node, var next: Node, val value: Int)

constructor(v1: Int, v2: Int) : this(Node(this, this, v1), v2)
this
contains
val contains: Boolean = 
    try {
        MyEnum.valueOf("some string")
        true
    } catch (e: IllegalArgumentException) {
        false
    }

===
val x = "A"
val y = "A"

println(x === y) // "true"
println("A" === "A") // "true"

val x = readLine()!! // "A"
val y = readLine()!! // "A"

println(x === y) // "false"

Any
Any
fun MainActivity.log(claz: Objects,any: Any){
    Log.d("Main", claz.name +  any.toString())
}

fun test(i: Int) {
    i += 5
}

val
var
run
val jar = ToolProvider.findFirst("jar").orElseThrow()
jar.run(null, null, "--create", "file=foo.jar", "--main-class=foo.bar", "-C", "baz", ".")

fun foo(): Boolean {
    println("foo")
    return true
}

fun bar() : Boolean {
    println("bar")
    return false
}

fun main() {
    if(foo() || bar()) { 
        // prints foo
    }
}

foo
bar
foo
[1, 2, 3, 4, 5, 6, 7] //Input
[(1, 2), (3, 4), (5, 6)] //Output

fun main(args: Array&lt;String&gt;) {
    mapFunctional()
    mapIterative()
}

fun mapFunctional() {
    val list: List&lt;Int&gt; = listOf(1, 2, 3, 4, 5, 6, 7)

    val output: List&lt;Pair&lt;Int, Int&gt;&gt; = list.filterIndexed { index, _ -&gt;
        index % 2 == 0
    }.zip(list.filterIndexed {
        index, _ -&gt; index % 2 == 1
    })

    println(output)
}

fun mapIterative() {
    val list: List&lt;Int&gt; = listOf(1, 2, 3, 4, 5, 6, 7)

    val output: MutableList&lt;Pair&lt;Int, Int&gt;&gt; = mutableListOf()
    var index = 0
    while (index &lt; list.size - 1) {
        output.add(list[index++] to list[index++])
    }

    println(output)
}

var
val
val foo
var counter = 0

val foo: String
  get(){
    counter++
    return "val$counter"
  }

fun main(): String {
    val a = foo
    val b = foo
    val c = foo
    return "we got: $a $b $c"
    // output: we got: val1 val2 val3
}

get()
foo
foo
var
var foo: String = "default value that will never be used"
  get(){
    counter++
    return "val$counter"
  }

sealed class BookingState {
    object ReasonOfTravel : BookingState()
}

 [a, a, b, a, b, b, b, c, c, c, c] -&gt; [[a, a], [b], [a], [b, b, b], [c, c, c, c]]

fun foo(chars: List&lt;Char&gt;): List&lt;List&lt;Char&gt;&gt; {
    val result = arrayListOf&lt;ArrayList&lt;Char&gt;&gt;()
    var part = arrayListOf(chars.first())
    var cur = chars.first()
    for (char in chars.drop(1)){
        if (cur == char) part.add(char)
        else {
            cur = char
            result.add(part)
            part = arrayListOf(char)
        }
    }
    if(part.isNotEmpty()) result.add(part)
    return result
}

file.foreachblock(){ -&gt;
  messageDigest.update(it.bytearray, 0, it.length);
}

abcd;abcd;abcd;
bcda;bcda;bcda;
dacb;dacb;dacb;

abcd;abcd;abcd;smth1
bcda;bcda;bcda;smth2
dacb;dacb;dacb;smth3

val pathToFile = "abc.txt"
val scan = Scanner(File(pathToFile))
while (scan.hasNextLine()) {
    val line = scan.nextLine()
    var lista = ArrayList&lt;String&gt;()
    lista = line.split(";") as ArrayList&lt;String&gt;
    println(lista.get(0) + " and " + lista.get(1) + " and " + lista.get(2))
}

mRecyclerView.adapter= CustomAdapter(allList)
private lateinit var mCustomAdapter CustomAdapter
class UIMain : AppCompatActivity() {


    private lateinit var mCustomAdapter CustomAdapter  //Error

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.layout_main)

        ...

        mRecyclerView.layoutManager = LinearLayoutManager(this, LinearLayout.VERTICAL, false)
        mRecyclerView.adapter= CustomAdapter(allList) //OK

    }

class CustomAdapter (val backupItemList: List&lt;MSetting&gt;) : RecyclerView.Adapter&lt;CustomAdapter.ViewHolder&gt;() {

    private var mSelectedItem = -1

    //this method is returning the view for each item in the list
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): CustomAdapter.ViewHolder {
        val v = LayoutInflater.from(parent.context).inflate(R.layout.item_recyclerview, parent, false)

        return ViewHolder(v)
    }


    fun getSelectedItem():Int{
        return  mSelectedItem
    }

    //this method is binding the data on the list
    override fun onBindViewHolder(holder: CustomAdapter.ViewHolder, position: Int) {
        holder.bindItems(backupItemList[position])
        holder.itemView.radioButton.setChecked(position == mSelectedItem);
    }

    //this method is giving the size of the list
    override fun getItemCount(): Int {
        return backupItemList.size
    }

    //the class is hodling the list view
    inner class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {

        fun bindItems(aMSetting: MSetting) {

            //itemView.radioButton.isChecked=false

            itemView.radioButton.tag=aMSetting._id
            itemView.textViewUsername.text=aMSetting.createdDate.toString()
            itemView.textViewAddress.text=aMSetting.description

            itemView.radioButton.setOnClickListener {
                mSelectedItem=getAdapterPosition()
                notifyDataSetChanged();
            }

        }

    }

}

reified
private fun &lt;T&gt;createFragmentX(fragmentClass: Class&lt;T&gt;, fragmentArgs: Bundle?): Fragment {
    try {
        val fragment = fragmentClass.newInstance() as Fragment
        fragment.arguments = fragmentArgs
        return fragment
    } catch (exception: Exception) {
        throw RuntimeException(exception.message)
    }
}

private inline fun &lt;reified T&gt;createFragmentZ(fragmentArgs: Bundle?): Fragment {
    try {
        val fragment = T::class.java.newInstance() as Fragment
        fragment.arguments = fragmentArgs
        return fragment
    } catch (exception: Exception) {
        throw RuntimeException(exception.message)
    }
}

reified
Class
KClass
Class
KClass
reified
subList
private fun bar(): Boolean = TODO()

fun works(): Int {
    while (true) {
        if (bar()) {
            return 5
        }
    }
}

fun openFile(): InputStream = TODO()

fun doesnt_work(): Int {
    openFile().use { input -&gt;
        while (true) {
            if (bar()) {
                return 5
            }
        }
    }
 } // line 42

fun works_but_awkward(): Int {
    openFile().use { input -&gt;
        val result: Int
        while (true) {
            if (bar()) {
                result = 5
                break
            }
        }
        return result
    }
}

fun workaround_with_named_function(): Int {
    fun loop(input: InputStream): Int {
        while (true) {
            if (bar()) {
                return 5
            }
        }
    }
    return openFile().use { loop(it) }
}

use
use
object DefaultValues {
    val FILES_TO_DOWNLOAD = 100
}

class DefaultValues {
    companion object {
        val FILES_TO_DOWNLOAD = 100
    }
}

const val DEFAULT_FILES_TO_DOWNLOAD = 100

val DEFAULT_FILES_TO_DOWNLOAD = 100

public static final int FILES_TO_DOWNLOAD = 100

class Dog
class DogHouse(dog: Dog)

inline fun &lt;T: Any, A: Any&gt; build(sth: String = "", call: (A) -&gt; T) {}

fun main(args: Array&lt;String&gt;) {
    build(call = ::DogHouse)
    build(::DogHouse)  // This line fails to compile
}

Error:(11, 5) Kotlin: Type inference failed: inline fun &lt;T : Any, A : Any&gt; build(sth: String = ..., call: (A) -&gt; T): Unit
cannot be applied to
(KFunction1&lt;@ParameterName Dog, DogHouse&gt;)

Error:(11, 11) Kotlin: Type mismatch: inferred type is KFunction1&lt;@ParameterName Dog, DogHouse&gt; but String was expected

Error:(11, 21) Kotlin: No value passed for parameter call

class Foo {
    fun a(x: Int) = ...
    fun b(x: Int) = ...
    fun c(x: Int, y: Int) = ...
}

class Foo {
    @WithTryCatch fun a(x: Int) = ...
    @WithTryCatch fun b(x: Int) = ...
    @WithTryCatch fun c(x: Int, y: Int) = ...

    fun executeOnCatch() {
        log.fatal(...)
    }
}

public class JavaClass implements ModelController.Callback {

    @Override
    public void onModelsLoaded(@NonNull List&lt;? extends Model&gt; models) {
        doSomething(models);
    }

    private void doSomething(List&lt;Model&gt; models) { }

}

class ModelController {
    var callback = WeakReference&lt;Callback&gt;(null)

    interface Callback {
        fun onModelsLoaded(models: List&lt;Model&gt;)
    }

    fun someFunction() {
        callback.get().onModelsLoaded(ArrayList&lt;Model&gt;())
    }
}

interface Model {

}

doSomething(&lt;java.util.List&lt;com.yada.Model&gt;) cannot be applied to (java.util.List&lt;capture&lt;? extends com.yada.Model&gt;&gt;)

?
readLine()
!!
var myvar=readLine()?.toIntOrNull() ?: 1

fun generateValue(param:KParameter):Any? {
    // do something here
}

param
KParameter
KParameter
public interface KParameter : KAnnotatedElement {
    public val index: Int
    public val name: String?
    public val type: KType
    public val kind: Kind
    public enum class Kind {
        INSTANCE,
        EXTENSION_RECEIVER,
        VALUE,
    }
    public val isOptional: Boolean

    @SinceKotlin("1.1")
    public val isVararg: Boolean
}

expression evaluation
1
param.A
KParameter
name
type
class MyData(val value: Double)

class MyClass(val values: List&lt;MyData&gt;)

values.sumByDouble { it.value }

var test = "&lt;html&gt;&lt;body&gt;&lt;p&gt; just some test text&lt;/p&gt; And i wanna use this text for texting and i ll show you this image https://www.instagram.com/p/B8I9_KiF45g/?utm_source=ig_web_copy_link also this is the instagram photo with just normal link id body https://www.instagram.com/p/B8I3r66pVpp/ &lt;h&gt; random title text &lt;/h&gt;&lt;/body&gt;&lt;/html&gt;"

"&lt;html&gt;&lt;body&gt;&lt;p&gt; just some test text&lt;/p&gt; And i wanna use this text for texting and i ll show you this image &lt;iframe src="https://www.instagram.com/p/B8I9_KiF45g/embed"&gt; &lt;/iframe&gt; also this is the instagram photo with just normal link id body &lt;iframe src="https://www.instagram.com/p/B8I3r66pVpp/embed" &lt;/iframe&gt; &lt;h&gt; random title text &lt;/h&gt;&lt;/body&gt;&lt;/html&gt;"

Int::class.java.isInstance(4)
String::class.java.isInstance("aa")
Int
fun &lt;T&gt; castValue(v: Any?, clazz: Class&lt;T&gt;): T? {
  if (v != null &amp;&amp; clazz.isInstance(v) return v as T
  return null
}

val result = castValue(4, Int::class.java)

fun&lt;T&gt; foo() {
    var myModel = T()
    myModel.id = 2
    myModel.name = ""
}

fun passes(address: String) = Collections.frequency(addresses, address) &lt;= CONNECTIONS_PER_IP

fun passes(remoteAddress: InetSocketAddress) = passes(remoteAddress.hostName)

passes("127.0.0.1")
None of the following functions can eb called with the arguments supplied.

passes(String) defined in abendigo.Firewall
passes(InetSocketAddress) defined in abendigo.Firewall

val url=taskSnapshot.getMetadata()?.getReference()?.getDownloadUrl()?.toString() 

override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {

        if (requestCode == PICK_PROFILE_FROM_ALBUM &amp;&amp; resultCode == Activity.RESULT_OK) {
            var imageUri = data?.data
            val uid = FirebaseAuth.getInstance().currentUser!!.uid 

            FirebaseStorage
                .getInstance()
                .reference
                .child("userProfileImages")
                .child(uid)
                .putFile(imageUri!!)
                .addOnSuccessListener { taskSnapshot -&gt;
                    val url = taskSnapshot.getMetadata()?.getReference()?.getDownloadUrl()?.toString()
                    val map = HashMap&lt;String, Any&gt;()
                    map["image"] = url
                    FirebaseFirestore.getInstance().collection("profileImages").document(uid).set(map)
                }
        }
    }
}

Type of 'exoPlayer' doesn't match the type of the overridden var-property 'public abstract var exoPlayer: ExoPlayer? defined in...
class LocalPlayback(context: Context, override var exoPlayer: SimpleExoPlayer?) : Playback {
    private val context: Context
    //... other stuff...
    }

interface Playback {
    var exoPlayer: ExoPlayer?
    //... other stuff...
    }

SimpleExoPlayer
ExoPlayer
i++
i++;
i++
#unresolved reference error

    //lampda
    val impl1 : (String,String) -&gt; Boolean =  {
        s1, s2 -&gt; s1.length &gt; s2.length
    }

    //lampda with a reciver object and scoping object
    val impl2 : String.(String) -&gt; Boolean =  {
        s -&gt; this.length &gt; s.length
    }

    print(max1("1234", "12", impl1))
    print(max2("1234", "12", impl2))
}

fun max1 (s1: String, s2: String, c: (String, String) -&gt; Boolean) : String {
    return "inside methods.....${ c(s1, s2) }" 
}

fun max2 (s1: String, s2: String, c: String.(String) -&gt; Boolean) : String {
    return "inside methods ${ s1.impl2.s2 } "// #unresolved reference error
    return "inside methods ${ s1.c.s2 } "// #unresolved reference error
}

data class ContactData(val name: String? = "", val online: Boolean = false)

public final class ContactData {

private String name = "";
private boolean online = false;


public final String getName() {
    return name;
}

public final boolean getOnline() {
    return online;
}

ContactData(String name, boolean online) {
    this.name = name;
    this.online = online;
}

public final String name() {
    return this.name;
}

public final boolean online() {
    return this.online;
}

}

val type = typeOf&lt;Int&gt;()
val list = arrayListOf&lt;**type**&gt;()

return if(mValue== null || mValue.asString.isNullOrEmpty()) "Home" else mValue.asString
return mValue?.asString ?: "Home"
mValue
mValue
when
if
bufferedReader.useLines { it }
            .take(10)
            .toList()

useLines
class SalutationConverter : EnumTypeConverter&lt;Salutation&gt;({ enumValueOf(it) })

open class EnumTypeConverter&lt;T : Enum&lt;T&gt;&gt;(private val enumValueOfParser: ((String) -&gt; T)) {

    @TypeConverter
    fun enumTypeToString(taxType: T?): String? = taxType?.name

    @TypeConverter
    fun stringToEnum(taxType: String?): T? = taxType?.let { enumValueOfParser(it) }
}

fun doSomeWork (range: IntProgression, j: Int): List&lt;Cell&gt;{

    println (range.first.toString() + " to " + range.last.toString() + ", step = " + range.step)

for (i in range) {
     println ("range: $i)"
}

for (i in range.first until range.last step range.step){
        println ("Loop de loop $i")
    }

 range.forEach { println ("range foreach") }

OuterClass.super.method()
class Outer {
    class Inner {
        void someMethod() {
            Outer.super.someOtherMethod();
        }
    }

    @Override
    public String someOtherMethod() {
        // This is not called...
    }
}

1.3.11
fun main(args: Array&lt;String&gt;) {
    val test = object {
        operator fun invoke() = println("test invocation")
    }

    test() // Prints: "test invocation"

    // I think this should fail to compile, but it works
    fun test() = println("test function")

    test() // Prints: "test function"
}

fun main(args: Array&lt;String&gt;) {
    fun test() = println("test function")

    val test = object {
        operator fun invoke() = println("test invocation")
    }

    test() // Prints: "test function"
}

fun test() = println("test function")

fun main(args: Array&lt;String&gt;) {
    val test = object {
        operator fun invoke() = println("test invocation")
    }

    test() // Prints "test invocation"
}

val test = object {
    operator fun invoke() = println("test invocation")
}

fun main(args: Array&lt;String&gt;) {
    fun test() = println("test function")
    test() // Prints: "test function"
}

val test = object {
    operator fun invoke() = println("test invocation")
}

fun test() = println("test function")

fun main(args: Array&lt;String&gt;) {
    test() // Prints: "test function"
}

test
class test {} // Does not compile

fun test() = println("test function")

val test = object {
    operator fun invoke() = println("test invocation")
}

Error:(1, 6) Conflicting overloads: public fun test(): Unit defined in root package in file Simplest version.kt, public constructor test() defined in test, public val test: Any defined in root package in file Simplest version.kt, public final class test defined in root package in file Simplest version.kt
Error:(1, 6) Conflicting declarations: public fun test(): Unit, public constructor test(), public val test: Any, public final class test
Error:(2, 0) Conflicting overloads: public fun test(): Unit defined in root package in file Simplest version.kt, public constructor test() defined in test, public val test: Any defined in root package in file Simplest version.kt, public final class test defined in root package in file Simplest version.kt
Error:(3, 4) Conflicting declarations: public fun test(): Unit, public constructor test(), public val test: Any, public final class test

class test {
    constructor() {
        println("test constructor")
    }
}

fun main(args: Array&lt;String&gt;) {
    fun test() = println("test function")

    val test = object {
        operator fun invoke() = println("test invocation")
    }

    test() // Prints: "test function"
}

class test {
    constructor() {
        println("test constructor")
    }

    companion object {
        operator fun invoke() = println("test companion invocation")
    }
}

fun main(args: Array&lt;String&gt;) {
    test() // Prints: "test constructor"
}

class test {
    constructor() {
        println("test constructor")
    }

    companion object {
        operator fun invoke() = println("test companion invocation")
    }
}

fun main(args: Array&lt;String&gt;) {
    test() // Prints: "test constructor"

    val test = object {
        operator fun invoke() = println("test invocation")
    }

    test() // Prints: "test invocation"

    fun test() = println("test function")

    test() // Prints: "test function"
}

class test {
    constructor() {
        println("test constructor")
    }

    companion object {
        operator fun invoke() = println("test companion invocation")
    }

    operator fun invoke() = println("test invocation overload")
}

fun main(args: Array&lt;String&gt;) {
    val test = test() // Prints: "test constructor"

    val test1 = test() // Prints: "test invocation overload"
}

alphanumerical
class Test private constructor(className: String) {
    companion object {
        // If I remove the internal it fails 
        internal inline operator fun &lt;reified T&gt; invoke(): Test {
            return Test(T::class.java.name) // why can I even call it? The constructor is private
        }
    }
}

public inline fun test() = Test&lt;Any&gt;() // Why can I call it, it is internal

test()
Test(Any::class.java.name)
internal inline fun
public inline fun
public inline fun
abstract class Greeter(val firstName: String, val lastName: String) {
  abstract fun greet()
}

class Formal(firstName: String, lastName: String): Greeter(firstName, lastName) {
  override fun greet() {
    println("Hello $firstName $lastName!")
  }
}

class Informal(firstName: String, lastName: String): Greeter(firstName, lastName) {
  override fun greet() {
    println("Hi $firstName!")
  }
}

class Informal(*): Greeter(*) {
  override fun greet() {
    println("Hi $firstName!")
  }
}

    BufferedReader br = Files.newBufferedReader(Paths.get("filename"));
    String line;
    while ((line = br.readLine()) != null)
        System.out.println(line);

    val br = Files.newBufferedReader(Paths.get("filename"))
    var line: String
    while ((line = br.readLine()) != null)
        println(line)

while ((line = br.nextLine()) != null)
val foo = someFooReturningFunction()
val foo get() = someFooReturningFunction()
someFooReturningFunction()
fun main(args: Array&lt;String&gt;) {
    val list = mutableListOf(1,2,3)
    //  here if use String template the property does not work, list itself is printed
     println("the last index is $list.lastIndex")
    // but this works - calling method
    println("the last element is ${list.last()}")
    // This way also works, so the extension property works correct
    println("the last index is " +list.lastIndex)
}

val &lt;T&gt; List&lt;T&gt;.lastIndex: Int
    get() = size - 1

the last index is [1, 2, 3].lastIndex
the last element is 3
the last index is 2

private var completed: BooleanArray = booleanArrayOf(false, false, false, false)

fun startProcess() {
    completed.all { it -&gt; callback.onFinished() }
}

            text2.setText("0s")
            text5.setText("Your Score:" + (Integer.toString(score)+ "/" + Integer.toString(noq)))
            playa.setVisibility(View.VISIBLE)

        }

        override fun onTick(millisUntilFinished: Long) {
            text2.setText(String.valueof(millisUntilFinished / 1000 + "s")
}

// foo.kt
fun bar() {
    val foo = object {
        fun zzz() {
            println()
        }
    }

    foo.zzz()
}

kotlinc foo.kt
import java.io.PrintStream;
import kotlin.Metadata;

@Metadata(mv={1, 1, 6}, bv={1, 0, 1}, k=2, d1={"\000\006\n\000\n\002\020\002\032\006\020\000\032\0020\001"}, d2={"bar", ""})
public final class MainKt
{
  public static final void bar()
  {
    Object foo = new Object()
    {
      public final void zzz()
      {
        System.out.println();
      }
    };
    foo.zzz();        // You can NOT do this in java world. But kotlin can do. Why?
  }
}

zzz unresolved
new Object()
data class1(val uniq1: Long, val uniq2:Long, val uniq3:Long, val shared:Long): Parcelable
data class2(val shared:Long):Parcelable

open class2(open val shared:Long): Parcelable
class1(val uniq1: Long, val uniq2:Long, val uniq3:Long, override val shared:Long):class2(shared), Parcelable

val class1obj = class1(1L, 2L, 3L, 4L)

Kotlin
interface User {
    var nickName : String
}

PrivateUser
nickName
class PrivateUser(override var nickName: String) : User

Idea
class Button: User {

override var nickName: String
    get() = TODO("not implemented")
    set(value) {}
}

+=
MutableCollection
MutableCollections.kt
...operator...plusAssign(t: T)
var videoBGGlobal:VideoView
var videoBGGlobal = VideoView(this)
var videoBGGlobal: VideoView = VideoView(this)
var videoBGGlobal: VideoView? = VideoView(this)
var videoBGGlobal: VideoView = null as VideoView
var videoBGGlobal = null //and then tried to assign videoBGGlobal = 
//videoBG within the onCreate but it says VideoView isn't type Nothing?

package ...
imports ...

class MainActivity {

//Global variables
var videoBGGlobal: VideoView = VideoView(this) //this just doesn't
var mMediaPlayer: MediaPlayer? = MediaPlayer() //this works
var mCurrentVideoPosition: Int? = 0 //this works

override fun onCreate() {
     var videoBG = findViewById&lt;VideoView&gt;(R.id.videoView) //here it //works
     }
 override fun onPause(){
    //need to access videoBGGlobal here
 }
}

import kotlin.collections.CollectionsKt; 
...
CollectionsKt.removeAll(x, y);

@Suppress("UNCHECKED_CAST")
var test = authentication.details as Pair&lt;String?,String?&gt;
@Suppress("UNCHECKED_CAST")
val (token,role) = authentication.details as Pair&lt;String?,String?&gt;

distinctBy
val uniqueObjects = myObjectList.distinctBy { it.myField, it.myOtherField }
distinctBy
data class State&lt;S, out A&gt;(val run: (S) -&gt; Pair&lt;A, S&gt;) {
    fun &lt;B&gt; flatMap(f: (A) -&gt; State&lt;S, B&gt;): State&lt;S, B&gt; = State { s -&gt;
        val (a, s1) = run(s)
        f(a).run(s1)
    }

    fun &lt;B&gt; map(f: (A) -&gt; B): State&lt;S, B&gt; =
            flatMap { a -&gt; unit(f(a)) }

    companion object {
        fun &lt;S, A&gt; unit(a: A): State&lt;S, A&gt; =
                State { s -&gt; a to s }
    }
}

Error:(8, 28) Kotlin: Type inference failed: Not enough information to infer parameter S in 
    fun &lt;S, A&gt; unit(a: A): State&lt;S, A&gt;
Please specify it explicitly.

fun main(args: Array&lt;String&gt;){

val unkownUser = "unkown User"
val name:String? = readLine()

println("Type the name\n")

if(name!!.isNotEmpty() &amp;&amp; name.isNotBlank()) // name?.isNotEmpty()  doesn't work. wonder why
{
    println("$name")
}else{
    println(unkownUser)
}

if (!reached)
        {
            if (!info)
            {
                d.sinfo = extractinfo()
            }
            else
            {
                parserMessage("print something")
                return d
            }
            info = true
        }
        else
        {
            if (d.media.isEmpty()){
                parserMessage("print something")
                return d
            }
            else{
                if (d.media.at(d.media.size() - 1).media_information.isEmpty())
                    {d.media[d.media.size() - 1].minfo = extractinfo()}
                else{
                    parserMessage("print something")
                    return d

            }
        }
    }

blah1 { em -&gt;
    // do some stuff here
}

blah2 { em -&gt;
    // do some stuff here
    listOf("1","2","3")
}

inline fun blah1(f: (em: EM) -&gt; Unit): Result {
    f(em)
    return Result()
}

inline fun blah2(f: (em: EM) -&gt; Any?): Result {
    val res = f(em)
    when (res) {
        is List&lt;*&gt; -&gt; res.forEach { item -&gt;
            // do something with item
        }
    }
    return Result()
}

blah1
blah2
blah { em -&gt;

}

val res = f(em)
blah { em -&gt;
   listOf("1","2","3")
}

val res = f(em)
inline fun blah(
    noinline f1: (em: EM) -&gt; Unit = f1fun,
    noinline f2: (em: EM) -&gt; Any? = f2fun
): Result {
    f1(em)
    f2(em)?.let { res -&gt;
        when (res) {
            is List&lt;*&gt; -&gt; res.forEach { item -&gt;
                // do something with item
            }
        }
    }
    return Result()
}

val f1fun: (em: EntityManager) -&gt; Unit = { Unit }
val f2fun: (em: EntityManager) -&gt; Any? = { null }

blah { em -&gt;
    // code here    
}

blah { em -&gt;
    // code here
    listOf("1", "2")
}

f2
blah { with or without statement }
Any?
Unit
inline fun blah2(f: (em: EM) -&gt; Any?): Result {
blah2 {
   k = k + 1
}

blah2 {

}

blah2 {
  k++
}

WHEN
&gt;
&lt;
val foo = 2

// doesn't compile
when (foo) {
    &gt; 0 -&gt; doSomethingWhenPositive()
    0   -&gt; doSomethingWhenZero()
    &lt; 0 -&gt; doSomethingWhenNegative()
}

// trying to get an unbounded range - doesn't compile
when (foo) {
    in 1.. -&gt; doSomethingWhenPositive()
    else -&gt; doSomethingElse()
}

when {
    foo &gt; 0 -&gt; doSomethingWhenPositive()
    foo &lt; 0 -&gt; doSomethingWhenNegative()
    else -&gt; doSomethingWhenZero()
}

if ( foo &gt; 0 ) {
    doSomethingWhenPositive()
}
else if (foo &lt; 0) {
    doSomethingWhenNegative()
}
else {
    doSomethingWhenZero()
}

WHEN
Foo
Foo&lt;Int&gt;.bar()
Foo&lt;String&gt;.bar()
class Foo&lt;T&gt;(t: T) {
  val a: String = "bar"
  val b: Int = 111
}

fun Foo&lt;Int&gt;.bar() = a
fun Foo&lt;String&gt;.bar() = b

fun main(args: Array&lt;String&gt;) {
  val stringBar: String = Foo(1).bar()
  val intBar: Int = Foo("").bar()
}

fun main(args: Array&lt;String&gt;) {
    var l: List&lt;String&gt; = mutableListOf("string")
    demo(l)
    println("======")
    for (s in l) {
        println(s)
    }
}

fun demo(strs: List&lt;String&gt;) {
    val objects: List&lt;Any&gt; = strs // This is OK, since T is an out-parameter
    if (objects is MutableList) {
        val obs: MutableList&lt;Any&gt; = objects as MutableList&lt;Any&gt;
        obs.add(TextView())
    }
}

Exception in thread "main" java.lang.ClassCastException: com.kotlin.demo.clzz.TextView cannot be cast to java.lang.String
    at com.kotlin.demo.clzz.Declaration_Site_VarianceKt.main(Declaration-Site-Variance.kt:14)
======
adn

val myList = listOf(3,4,2)

class DynamicInvocationHandler&lt;T&gt;(private val delegate: Map&lt;String, Any&gt;, clzz: Class&lt;T&gt;) : InvocationHandler {

    val introspector = Introspector.getBeanInfo(clzz)
    val getters = introspector.propertyDescriptors.map { it.readMethod }

    override fun invoke(proxy: Any, method: Method, args: Array&lt;Any&gt;?): Any? {
        if (method in getters) {
            // get the value from the map
            val representation = delegate[method.name.substring(3).toLowerCase()]
            // TODO need better than name
            when (method.returnType.kotlin.simpleName) {                
                LocalDate::class.simpleName -&gt; {
                    val result = representation as ArrayList&lt;Int&gt;
                    return LocalDate.of(result[0], result[1], result[2])
                }
                // TODO a few other basic types like LocalDateTime
                // primitives come as they are
                else -&gt; return representation
            }
        }
        return null
    }
}

this
it
class HomeActivity : DemoActivity() {    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        Display1(this)
        Utility.Display2(this)
    }
}

import android.content.Context
import android.widget.Toast

fun Display1(mContext: Context){
    Toast.makeText(mContext, "Hello, World 1", Toast.LENGTH_LONG).show();
}

import android.content.Context
import android.widget.Toast

object Utility {
    fun Display2(mContext: Context) {
        Toast.makeText(mContext, "Hello, World 2", Toast.LENGTH_LONG).show();
    }
}

// some java file
public interface FrameworkDevice {
    @Nullable
    open fun getName(): String?
}


interface Device {
    val name: String?
}

abstract class BluetoothDevice(private val device: FrameworkDevice):
    Device, FrameworkDevice by device 

con = urlGet.openConnection() as HttpURLConnection
con.readTimeout = 10000
con.connectTimeout = 2000 
con.requestMethod = "GET"
con.doInput = true
con.connect()
inst = con.inputStream

con = urlGet.openConnection() as HttpURLConnection
inputStream = con.run {
   readTimeout = 10000
   connectTimeout = 2000
   requestMethod = "GET"
   doInput = true
   // Start the query
   connect()
   inputStream
}

    con = urlGet.openConnection() as HttpURLConnection
    con.apply {
           readTimeout = 10000
           connectTimeout = 2000
           requestMethod = "GET"
           doInput = true
        }
    inputStream = con.run {
           // Start the query
           connect()
           inputStream
        }

Supplier&lt;Int&gt;
operator fun &lt;T&gt; Supplier&lt;T&gt;.invoke(): T = this.get()

val supplier: Supplier&lt;Int&gt;? = (Supplier&lt;Int&gt; { 5 })

if (supplier != null) {
    // Fails: Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type Supplier&lt;Int&gt;?
    supplier() 
    supplier.invoke() // fine, smart casts
    supplier.get() // fine, smart casts
}

private fun stringToWords(mnemonic: String): List&lt;String&gt; {
    val words = ArrayList&lt;String&gt;()
    for (word in mnemonic.trim { it &lt;= ' ' }.split(" ".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()) {
        if (word.isNotEmpty()) {
            words.add(word)
        }
    }
    return words
}

A
B
fromB(A a)
a.val = b.val...
a.with { val = b.val... }
instance.apply{}
with
A().apply {}
Expression is inaccessible from a nested class 'Companion', use 'inner' keyword to make the class inner
inner
fun main(args: Array&lt;String&gt;) {
    val b = B("Hello", "World")
    val a = A.fromB(b)

    print("$a.value1 $a.value2")
}


class A() {
    var value1: String? = null
    var value2: String? = null

    companion object {
        //This fails with "Expression is inaccessible from a nested class 'Companion', use 'inner' keyword to make the class inner"
        fun fromB(b: B): A {
            return A().apply {
                value1 = b.value3
                value2 = b.value4
            }
        }
    }
}

class B(val value3: String, val value4: String) {}

//This works
fun bToA(b: B): A {
    return A().apply {
                value1 = b.value3
                value2 = b.value4
            }
}

@Test
fun testReadCursorRequest() {
    val xml = fromFile()
    val parser: ReadCursorRequestParser = ReadCursorRequestParser(xml)
    assertEquals(0, parser.status)
    assertEquals(134, parser.contacts!!.size)
}

abstract class EnvelopeParser(val xml: String) {
    abstract fun parseResponse(response: Element)

    init {
        parseResponse(xmlFromString(xml))
    }

    // non-related stuff
}

class ReadCursorRequestParser(xml: String) : EnvelopeParser(xml) {

    var contacts: List&lt;AddressBookElementParser&gt; = mutableListOf()     

    override fun parseResponse(response: Element) {
        // here some parsing stuff, fills the contacts-list
        println("size is: ${contacts.size}")
    }
}

size is: 134
java.lang.AssertionError: Expected &lt;134&gt;, actual &lt;0&gt;
class Test {
    val classLevel = object {
        operator fun invoke() = println("test class level property invocaton")
    }

    fun foo() {
        val functionLevel = object {
            operator fun invoke() = println("test invocation")
        }
        functionLevel() // no problem
        classLevel() // Expression 'classLevel' of type 'Any' cannot be invoked as a function. The function 'invoke()' is not found
    }
}

List&lt;Map&lt;Branch,Pair&lt;String, Any&gt;&gt;&gt;
Map&lt;Branch,List&lt;Pair&lt;String, Any&gt;&gt;&gt;
1. branch1 -&gt; Pair(key1,value1)

   branch2 -&gt; Pair(key2,value2)


2. branch1 -&gt; Pair(key1a,value1a)

branch1 -&gt; Pair(key1,value1)

           Pair(key1a,value1a)

branch2 -&gt; Pair(key2,value2)

list.groupBy{it-&gt; it.keys.first()} 

Stealth
Skill
SoundlessMovement
Mastery
SoundlessMovement
Skill
Stealth
Mastery
Skill
interface Skill {
    val masteries: List&lt;Mastery&lt;Skill&gt;&gt; // Mastery linked to type Skill
}

interface Mastery&lt;Skill&gt; { // Every Mastery must be compatible with only one Skill
    val masteryName: String
}

class Stealth : Skill {
    override val masteries: ArrayList&lt;Mastery&lt;Stealth&gt;() // Any Mastery bound to Stealth
}

class SoundlessMovement : Mastery&lt;Stealth&gt; { // Is a Mastery compatible with Stealth
    override val masteryName = "Soundless Movement"
}

abstract class ParentRepository {}

class ChildRepository : ParentRepository {}

abstract class ParentClass {
    protected abstract var repository: ParentRepository
}

class ChildClass : ParentClass {
    override var repository: ChildRepository
}

override var repository: ChildRepository

Type of 'repository' doesn't match the type of the overridden var-property 'protected abstract var repository: ParentRepository

Map&lt;String, String?&gt;
Map&lt;String, String&gt;
null
!!
fun Map&lt;String, String?&gt;.filterNonNull() = this
            .filter { it.value != null }
            .map { it.key to it.value!! }
            .toMap()

Set
String
val myStr = "oop"

Set
Kotlin
Kotlin
package functions

fun sayHello(name: String): String {
    val personName = name
    return "hello $personName"
}
fun main(args: Array&lt;String&gt;) {
    println(sayHello("Netra"))
}

Scanner.skip()
string.skip("**")
**
string
"**hello stack".skip("**") --&gt; "hello stack"
open class Book(val title: String, val author: String) {
    companion object BookConstants {
        const val BASE_URL = "https://kbooks.co/"
    }
    open fun buildBookUrl(): String {
        return "$BASE_URL$title.html"
    }
}

fun main(args: Array&lt;String&gt;) {
    val allBooks = setOf&lt;Book&gt;(Book("Book Title 1", "Author 1"),
        Book("Book Title 2", "Author 2"),
        Book("Book Title 3", "Author 3"))

    //CODE HERE to access each book in `allBooks` set and call `buildBookUrl()` on it to get each custom url string


}

class Greeter() {

    fun greet(name: String) {
        val c = Greeter::class;
        for (m in c.memberFunctions) {
            if (m.name == "greet") {
                val p = m.parameters
                println(p.toString())
            }
        }
        println("Hello, ${name}");
    }
}

fun main(args: Array&lt;String&gt;) {
    Greeter().greet("UserName")
}

class Greeter() {

    fun greet(name: String) {
        val p = Greeter::greet.parameters
        println(p.toString())
        println("Hello, ${name}");
    }
}

fun main(args: Array&lt;String&gt;) {
    Greeter().greet("UserName")
}

fun main()
{

    arrayOfNulls&lt;String?&gt;(size = 11)
    var firstWord : String?

    print("Enter in the sentence ")
    var strAnagram : String = readLine()!!

    var arrUserInput = strAnagram.split(" ")
    var  arrFirstLetter = charArrayOf()

    for(x in 0..arrUserInput.size+1)
    {
        firstWord = arrUserInput.get(x)
        arrFirstLetter[x] = firstWord[0]

    }

    for (y in 0..11)
    {
    println(arrFirstLetter[y])
    }

}

interface MyInterface {
    val myValue: Int
}

object MySingleton: MyInterface {
    override val myValue: String = "My value"
}

class NotMySingleton: MyInterface {
    override val myValue: String = "My value"
}

MyInterface
print
println
printStackTrace()
init
init {
    creationDate = owner.network.currentDate
}

Exception in thread "main" java.lang.NullPointerException
    at Vault.&amp;amp;lt;init&amp;amp;gt;(Vault.kt:13)
    at NetworkProductionVault.&amp;amp;lt;init&amp;amp;gt;(Vault.kt:65)
    at Snc_tokenKt.main(snc-token.kt:13)

fun f1(a: A?): R? {
    if (a != null) {
        val b = getB(a)
        if (b != null &amp;&amp; b.f()) {
            val c = getC(b)
            if (c != null &amp;&amp; c.f()) {
                return c.f2()
            }
        }
    }
    return null
}

fun f2(a: A?): R? = a
        ?.let { getB(it) }
        ?.takeIf { it.f() }
        ?.let { getC(it) }
        ?.takeIf { it.f() }
        ?.let { it.f2() }

fun main(){
    val randomclassobject = RandomClass()
    println(randomclassobject is someRandomInterface)
}
open class RandomClass{
}
interface someRandomInterface{
    fun mustImplementThis()
}

fun main(){
    val randomclassobject = RandomClass()
    println(randomclassobject is someRandomInterface)
}
class RandomClass{
}
interface someRandomInterface{
    fun mustImplementThis()
}

    object singleton{
    ...
    }

    val x = singleton

    singleton.propertyName

    x.propertyName

    singleton.propertyName 

class OutA {

    var var1 = ""

    inner class A {
        init {
            print(var1)
        }
    }

    enum class A2 {
        ;

        init {
        print(var1)//unresolved reference:var1
        }
    }

    inner enum class A3 {//Modifier 'inner' is not applicable to 'enum class'
        ;

        init {
            print(var1)
        }
    }
}

unresolved reference:var1
Modifier 'inner' is not applicable to
fun String.getAllCorrectLetters(guess: String): Int{
    var count = 0
    val guessList = guess.toList()
    for((index1,ch1) in this.withIndex()){
        for (element in guessList) {
            if (ch1 == element){
                count++
                // Can I remove element from guessList here
            }
        }
    }
    return count;
}

 Appslist = ArrayList&lt;AppInfo&gt;()

    val i = Intent(Intent.ACTION_MAIN, null)
    i.addCategory(Intent.CATEGORY_LAUNCHER)
    val allApps = this.packageManager.queryIntentActivities(i, 0)

    for (ri in allApps) {
        val app = AppInfo()
        app.label = ri.loadLabel(this.packageManager)
        app.packageName = ri.activityInfo.packageName
        app.icon = ri.activityInfo.loadIcon(this.packageManager)
        if(app.label?.toString()!!.length &gt;= searchWord.length &amp;&amp; app.label?.toString()!!.substring(0, searchWord.length) == searchWord.toUpperCase() &amp;&amp; searchWord != "" ||
            app.label?.toString()!!.length &gt;= searchWord.length &amp;&amp; app.label?.toString()!!.substring(0, searchWord.length) == searchWord.toLowerCase() &amp;&amp; searchWord != "" ||
            app.label?.toString()!!.length &gt;= searchWord.length &amp;&amp; app.label?.toString()!!.substring(0, searchWord.length) == searchWord.capitalize() &amp;&amp; searchWord != "" ||
            app.label?.toString()!!.length &gt;= searchWord.length &amp;&amp; app.label?.toString()!!.substring(0, searchWord.length) == searchWord &amp;&amp; searchWord != ""){

            if(app.packageName != "com.david.launcher" ){
                Appslist.add(app)
            }

        }
        if(searchWord == ""){
            if(app.packageName != "com.david.launcher"){
                Appslist.add(app)
            }
        }

    }

public class AppInfo {
internal var label: CharSequence? = null
internal var packageName: CharSequence? = null
internal var icon: Drawable? = null
internal var isInFav: Boolean? = false

    private fun method1(a: A): A {
        return a.copy(v1 = null)
    }

    private fun method2(a: A): A {
        return a.copy(v2 = null)
    }

    private fun commonMethod(a: A, variableToChange: String): A {
        return a.copy($variableToChange = null)
    }

public &lt;T&gt; T proxy(KClass&lt;T&gt; kClass) { 
    // unfortunately nothing like getJavaClass() exists
    return (T) proxy(kClass.getJavaClass()); 
}

public &lt;T&gt; T proxy(Class&lt;T&gt; jClass) {
    return (T) context.getBean(jClass);
}

.java
 /root/.sdkman/candidates/kotlin/current/bin/kotlinc: line 80: 34 Killed "${JAVACMD:=java}" $JAVA_OPTS "${java_args[@]}" -cp "${kotlin_app[@]}" "${kotlin_args[@]}"

RUN apt-get install sudo -y
RUN curl -s https://get.sdkman.io | bash
RUN chmod u+x "$HOME/.sdkman/bin/sdkman-init.sh"
RUN /bin/bash -c "source $HOME/.sdkman/bin/sdkman-init.sh &amp;&amp; sdk install kotlin"
ENV PATH /root/.sdkman/candidates/kotlin/current/bin:$PATH

LocalDateTime
fun LocalDateTime.isNotBefore(other: ChronoLocalDateTime&lt;*&gt;) = !isBefore(other)

curTime
val
LocalDateTime?
isNotBefore(curTime)
!!
LocalDateTime
isBefore()
!!
E/AndroidRuntime: FATAL EXCEPTION: OkHttp Dispatcher
    Process: com.iraqairoirt.iraqairports, PID: 20692
    com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected BEGIN_OBJECT but was BEGIN_ARRAY at line 1 column 2 path $
        at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:226)
        at com.google.gson.Gson.fromJson(Gson.java:927)
        at com.google.gson.Gson.fromJson(Gson.java:892)
        at com.google.gson.Gson.fromJson(Gson.java:841)
        at com.google.gson.Gson.fromJson(Gson.java:813)
        at com.iraqairoirt.iraqairports.NotamOrbi$fetchjson$1.onResponse(NotamOrbi.kt:55)
        at okhttp3.RealCall$AsyncCall.execute(RealCall.java:206)
        at okhttp3.internal.NamedRunnable.run(NamedRunnable.java:32)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)
        at java.lang.Thread.run(Thread.java:762)
     Caused by: java.lang.IllegalStateException: Expected BEGIN_OBJECT but was BEGIN_ARRAY at line 1 column 2 path $
        at com.google.gson.stream.JsonReader.beginObject(JsonReader.java:385)
        at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter

class NotamOrbi : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.notam_orbi)

        val recyclerView = findViewById&lt;RecyclerView&gt;(R.id.recyclerDate)
        recyclerView.layoutManager = LinearLayoutManager(this)

        fetchjson()

    }

    fun fetchjson() {

        val url =
            "/&amp;locations=orbi"
        val request = Request.Builder().url(url).build()
        val client = OkHttpClient()
        client.newCall(request).enqueue(object : Callback {

            override fun onResponse(call: Call, response: Response) {
                val body = response?.body()?.string()
                println(body)

                val gson = GsonBuilder().create()

                val homedata = gson.fromJson(body, HomeDate::class.java)

                runOnUiThread{
                    recyclerDate.adapter=NotamOrbiAdapter(homedata)

                }

            }

            override fun onFailure(call: Call, e: IOException) {

            }


        })


    }

    class HomeDate( val datanotam:ArrayList&lt;NotamORBI&gt;)
    class NotamORBI(val id : String)

    class NotamOrbiAdapter (val datajson:HomeDate): RecyclerView.Adapter&lt;NotamOrbiAdapter.ViewHolder&gt;() {
        override fun onCreateViewHolder(p0: ViewGroup, p1: Int): ViewHolder {

            val v = LayoutInflater.from(p0.context).inflate(R.layout.notam_reclycer_card, p0, false)
            return ViewHolder(v)
        }

        override fun getItemCount(): Int {
            return datajson.datanotam.count()
        }

        override fun onBindViewHolder(p0: ViewHolder, p1: Int) {

           val data = datajson.datanotam.get(p1)
            p0?.itemView.id_notam.text=data.id

        }

        class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {

            val id_notam = itemView.findViewById&lt;TextView&gt;(R.id.id_notam)
        }
    }
}

val homedata = gson.fromJson(body, HomeDate::class.java)
 [
      {
        "_id": "5c0b4ed2ab233e849941925c",
        "id": "A0466/18",
        "entity": "MR",
        "status": "LC",
        "Qcode": "MRLC",
        "Area": "AGA",
        "SubArea": "Movement and landing area",
        "Condition": "Limitations",
        "Subject": "Runway",
        "Modifier": "Closed",
        "message": "RWY 15L/33R CLSD DUE TO MAINT DURING VMC ONLY.\nCREATED: 05 Dec 2018 06:59:00 \nSOURCE: ORBIYNYX",
        "startdate": "2018-12-07T11:00:00.000Z",
        "enddate": "2018-12-17T13:00:00.000Z",
        "all": "A0466/18 NOTAMN\nQ) ORBB/QMRLC/IV/NBO/A/000/999/3316N04414E005\nA) ORBI\nB) 1812071100\nC) 1812171300\nD) MON FRI 1100-1300\nE) RWY 15L/33R CLSD DUE TO MAINT DURING VMC ONLY.\nCREATED: 05 Dec 2018 06:59:00 \nSOURCE: ORBIYNYX",
        "location": "ORBI",
        "isICAO": true,
        "Created": "2018-12-05T06:59:00.000Z",
        "key": "A0466/18-ORBI",
        "type": "airport",
        "StateCode": "IRQ",
        "StateName": "Iraq"
      }
    ]

public @interface ThirdPartyAnnotation{
    String foo();
}

class MyApp{
    ThirdPartyAnnotation getInstanceOfAnnotation(final String foo)
        {
            ThirdPartyAnnotation annotation = new ThirdPartyAnnotation()
            {
                @Override
                public String foo()
                {
                    return foo;
                }

            }; 
            return annotation;
        }
}

class MyApp{
               fun getAnnotationInstance(fooString:String):ThirdPartyAnnotation{
                    return ThirdPartyAnnotation(){
                        override fun foo=fooString
                }
    }

var mutableMap: MutableMap&lt;Int, MutableSet&lt;Int&gt;&gt; = mutableMapOf(someList.map{ it to mutableSetOf&lt;Int&gt;() })

Type mismatch.
Required:
Pair&lt;TypeVariable(K), TypeVariable(V)&gt;
Found:
List&lt;Pair&lt;Int, MutableSet&lt;Int&gt;&gt;&gt;

varargs pairs
*
when
if-else
when
if-else
val someNumber = when (someObject) {
    null -&gt; 0
    else -&gt; someCalculation()
}

val someNumber = if (someObject == null) {
    0
} else {
    someCalculation()
}

class myClass private constructor() {

    constructor(
        weather: String, 
        day: Int?
    ) : this() {
        //I can put assignment here
    }
    constructor(
        day: Int?
    ) : this() {
        //and here, but can this be done more efficiently?
    }
    val dayString: String = when(day) { //kotlin doesn't recognize 'day' variable here outside of constructors...
        0 -&gt; "Sunday"
        1 -&gt; "Monday"
        2 -&gt; "Tuesday"
        3 -&gt; "Wednesday"
        4 -&gt; "Thursday"
        5 -&gt; "Friday"
        6 -&gt; "Saturday"
        else -&gt; "Not a valid day of the week!"
    }

}

btn.text
fun loopFunction(){
    for (i in 1 until 5 step 2) {

        if (i == 5){
           btn.text = "Timer End" //btn is Button
        }

        println(i)
    }
}

let
contract {
    callsInPlace(block, InvocationKind.EXACTLY_ONCE)
}
return block(this)

contract
contract
internal
inline fun func(a: () -&gt; Unit, b: () -&gt; Unit){
    a()
    b()
}

func {
    doSomething()
}

fun findupdatedFieldsList(cpayload: Customer, cEntity: Customer): List&lt;String&gt; {
//        var customerToPublish = Customer()
        val updatedFieldsList: MutableList&lt;String&gt;
        updatedFieldsList = ArrayList()
        for (field: Field in cpayload.javaClass.declaredFields) {
            field.isAccessible = true
            val value1 = field.get(cpayload).toString()
            val value2 = field.get(cEntity).toString()
            !Objects.equals(value1, value2).apply {
                if (this) {
//                  customerToPublish.birthDate=field.get(cpayload).toString()
                    updatedFieldsList.add(field.name)
                }
            }
        }
        return updatedFieldsList
    }

@Entity
@Table
data class Customer(
    @Id
    val partyKey: UUID,
    var preferredName: String?,
    var givenName: String?,
    var lastName: String?,
    var middleName: String?,
    var emailAddress: String,
    var mobileNumber: String,
    val birthDate: String?,
    val loginOnRegister: Boolean,
    var gender: Gender?,
    var placeOfBirth: String?,
    var createdDate: LocalDateTime = LocalDateTime.now(),
    var updatedDate: LocalDateTime = LocalDateTime.now()
)

val customer = Customer(
            preferredName = Updated name,
            partyKey = partyKey.value,
            givenName = Updated name,
            lastName = null,
            middleName = null,
            emailAddress = Updated email,
            mobileNumber = null,
            birthDate = null,
            gender = null,
            placeOfBirth = null
        )

hasAnagrams(listOf("restful", "elvis", "fluster")) -&gt; true
hasAnagrams(listOf("restful", "elvis", "real")) -&gt; false

fun hasAnagrams(words: List&lt;String&gt;): Boolean =
words.map { it.split(" ") }.forEach { item -&gt; return item.containsAll(item) }

.forEach
item -&gt; return item.containsAll(item)
fun &lt;T&gt; T.f(x: T) {
}

fun main(args: Array&lt;String&gt;) {
  "1".f("1") // ok
  "1".f(1) // should be error
}

import jdk.internal.joptsimple.internal.Strings

fun main(args: Array&lt;Strings&gt;){println("Hello")}

Error:(1, 41) Kotlin: Symbol is declared in module 'jdk.internal.opt' which does not export package 'jdk.internal.joptsimple.internal'

class Foo 
class Bar

fun Foo.run() = "Foo.run"
fun Bar.run() = "Bar.run"

fun main(args: Array&lt;String&gt;) {
    val x = listOf(Foo(), Bar())
    val y = x.map({a -&gt; a.run()}) //compiler error
    println("Hello, world!")
}

run
protocol
extension
private var raceLoadJob: Job? = null
if (raceLoadJob != null){
    if (raceLoadJob!!.isActive) return // null assertation
}

raceLoadJob?.let {
    if (it.isActive) return
}

Job var10000 = this.raceLoadJob;
if (this.raceLoadJob != null) {
   Job var1 = var10000;
   if (var1.isActive()) {
      return;
   }
}

this.raceLoadJob != null
var10000 != null
raceLoadJob
null
data class AppState(var list: List&lt;Image&gt; = ArrayList&lt;Image&gt;(),
                val uiState: UIState = UIState.LIST,
                val isFetching: Boolean = false)

...

val list = state!!.list.sublist(0,1);
state.copy(list = list)        // No change
state.copy(isFetching = true)  // Works like a charm

fun makeSalt(name:String) = Spice(name, "non-spicy")
fun main(args: Array&lt;String&gt;) {
    var salt : Spice = Spice("salt", "non-spicy")

    println("Salt heat = ${salt.heat}")

    val spicelist = listOf&lt;Spice&gt;(
        Spice("salt", "non-spicy"),
        Spice("turmeric", "mild"),
        Spice("Pepper", "hot"),
        Spice("Chilli", "hot"),
        Spice("Sugar", "non-spicy")
    )

    val mildSpices = spicelist.filter{it.heat &lt;=5}

    val salt2 = makeSalt("rock salt")

    val bhoot : SubSpice = SubSpice("bhoot", "hot")
}


open class Spice(open var name:String, open var spiciness:String = "mild" ){
    var heat : Int = 5
        get() = when (spiciness){
            "mild"-&gt;5
            "hot"-&gt;10
            "non-spicy"-&gt;1
            else -&gt; 0

        }

    init{
        if(spiciness === null) {println("spiciness is null")}
        else println("Spiciness of ${name} = ${spiciness}; heat = ${heat}")
    }
}

class SubSpice(override var name:String, override var spiciness:String = "hot") : Spice(name, spiciness){

}

Spiciness of salt = non-spicy; heat = 1
Salt heat = 1
Spiciness of salt = non-spicy; heat = 1
Spiciness of turmeric = mild; heat = 5
Spiciness of Pepper = hot; heat = 10
Spiciness of Chilli = hot; heat = 10
Spiciness of Sugar = non-spicy; heat = 1
Spiciness of rock salt = non-spicy; heat = 1
spiciness is null

spiciness
"mild"
var listA = listOf(null ,null)
var listB = [null, null]

[null, null]

error: cannot use 'Nothing?' as reified type parameter
var listB = [null,null]
            ^
error: unsupported [Collection literals outside of annotations]
var listB = [null,null]
            ^
error: unsupported [Array&lt;Nothing&gt; in return type is illegal]
var listB = [null,null]
            ^

var listC = [1,2]

error: unsupported [Collection literals outside of annotations]
var listC = [1,2]
            ^

public fun ByteBuffer.Companion.invoke(capacity: Int): ByteBuffer

abstract class BaseConverter&lt;T&gt; {
    abstract fun serializeValue(output: ByteArray, value: T, offset: Int = 0): Int
}

object BooleanConverter: BaseConverter&lt;Boolean&gt;() {
    override fun serializeValue(output: ByteArray, value: Boolean, offset: Int): Int {
        output[0 + offset] = if(value) 1.toByte() else 0.toByte()
        return 1
    }
}

BooleanConverter.serializeValue(array, value)
BooleanConverter.serializeValue(array, value, 0)
var pair = Pair(Color.RED, Color.WHITE)

pegColours
2 type arguments expected for class Pair&lt;out A, out B&gt;
lateinit private var pegColours: Array&lt;Pair&gt;

class MyAdapter(val context: Context)  {
    constructor(context: Context,  itemInfos: List&lt;ItemInfo&gt;): RecyclerView.Adapter&lt;ContentItemViewHolder&gt; {

    }
}

interface IRunnable&lt;T&gt; {
    fun doWork(): T
}

executor!!.execute(object : IRunnable&lt;Long&gt; {
    override fun doWork(): Long {
        return 0L
    }
})

 executor!!.execute(IRunnable2 { return@IRunnable2 0L })

interface A {
    fun  calculate(n: Int): Int
}

A
B
calculation
B
class B (f : (Int) -&gt; Int) : A {
    override fun  calculate(n: Int): Int  //...somehow assign f to calculate
}

f
B
interface A {
    val calculate: (n: Int) -&gt; Int
}

class B(f: (Int) -&gt; Int) : A {
    override val calculate = f
}

fun
val
enum
enum class Types(val value: Int) {
    FOO(1)
    BAR(2)
    FOO_BAR(3)
}

enum
Int
val type = Types.valueOf(1)

if (condition){
  console.log("")
}

condition &amp;&amp; console.log("")

launch
async
(1..100)
&gt;&gt;&gt; (1..100).toList().reduce { acc, i -&gt; acc * i }
0
&gt;&gt;&gt; (1..10).toList().reduce { acc, i -&gt; acc * i }
3628800

fun setSingleChoiceItems(items: Array&lt;CharSequence&gt;?, checkedItem: Int,
        listener: DialogInterface.OnClickListener?) {
    // ...
}

val str = listOf("1", "2", "3")
dialog.setSingleChoiceItems(str.toTypedArray(), currentChoice, null)

None of the following functions can be called with the arguments supplied
fun setSingleChoiceItems(items: Array&lt;String&gt;?, checkedItem: Int,
        listener: DialogInterface.OnClickListener?) {
    // Here's a warning: No cast needed
    val cs = items?.map { it as CharSequence }?.toTypedArray()
    setSingleChoiceItems(cs,checkedItem,listener)
}

Overload resolution ambiguity. All these functions match.
Map
toLinkedMap()
toSortedMap()
toHashMap()
Map
LinkedHashMap
HashMap
val matchesInClass: HashMap&lt;MessageClass, HashMap&lt;Int, Int&gt;&gt;

//...

for ((cl, matches) in matchesInClass) {
    matchesInClass[cl] = matches.filterKeys { it !in banned } //error: not a HashMap
}

HashMap(matches.filterKeys { it !in banned })
Class
Integer.class
Int::class.java
int.class
Integer.class
void foo(Class clazz);

foo(Int::class.java) // does not work, int.class gets passed to foo

EntityUtils.toString(httpGetRequest(***)!!.entity).removeSurrounding("arn:aws:s3:::","/*")

myVariables
myVariables
money
class MainActivity : myVariables, AppCompatActivity() {override val money = 0}
abstract class ShopActivity : myVariables, AppCompatActivity() {override val money = 0}

interface myVariables {
val money: Int
}

val map = HashMap&lt;Int, Any&gt;()
fun &lt;T&gt; test(t: T) = map.put(0, t) // Type mismatch: inferred type is T but kotlin.Any was expected

class Foo {

    fun getFilteredList(){
        val numbers = listOf(1, 2, 3)
        numbers.filter(::isOdd) // prints [1, 3]
    }

    fun isOdd(x: Int): Boolean = x % 2 != 0

}

class Bar {
    fun isOdd(x: Int): Boolean = x % 2 != 0
}

class Foo {

    fun getFilteredList(){
        val bar = Bar()
        val numbers = listOf(1, 2, 3)
        numbers.filter(bar::isOdd) // Use Bar's method
    }
}

data class CSVColumn(private val index: Int, val value: String) {
}

index
data class CSVColumn(private val index: Int, val value: String) {

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }
        if (javaClass != other?.javaClass) {
            return false
        }
        other as CSVColumn
        if (index != other.index) {
            return false
        }
        return true
    }

    override fun hashCode(): Int {
        return index
    }

}

@Value
@EqualsAndHasCode(of="index")
public class CsvColumn {
    private final int index;
    private final String value;
}

getInstance()
class GlobalHolder {

    private var pickerManager: PickerManager? = null

    private val ourInstance = GlobalHolder()

    fun getInstance() {
        return ourInstance
    }

    private fun GlobalHolder(){}


    fun getPickerManager(): PickerManager? {
        return pickerManager
    }

    fun setPickerManager(pickerManager: PickerManager) {
        this.pickerManager = pickerManager
    }
}

   lateinit var pickerManager: PickerManager
    pickerManager=GlobalHolder.getInstance().getPickerManager()

public class GlobalHolder {

    private PickerManager pickerManager;

    private static GlobalHolder ourInstance = new GlobalHolder();

    public static GlobalHolder getInstance() {
        return ourInstance;
    }

    private GlobalHolder() {
    }


    public PickerManager getPickerManager() {
        return pickerManager;
    }

    public void setPickerManager(PickerManager pickerManager) {
        this.pickerManager = pickerManager;
    }
}

var s = "abcdef"
var result = s.any('d')

fun CharSequence.any(predicate: (Char) -&gt; Boolean): Boolean 

println("%.6f".format(value))

ConnectivityManager
Supertype initialization is impossible without primary constructor
class InternetConnectivityHelper : ConnectivityManager.NetworkCallback() {

    constructor(context: Context, internetStatusChangedListener: InternetStatusChangedListener): super(){

    }
}

class InternetConnectivityHelper : ConnectivityManager.NetworkCallback() {

    constructor(context: Context, internetStatusChangedListener: InternetStatusChangedListener): this(){

    }
}

notify()
wait/notify
Any
LinkageError
class Test {
    fun notify(){}
}

//create instance throws LinkageError
Test()

public String getDisplayedValue(Context context) {
    if (PrefUtils.useImperialUnits(context)) {
        // return stuff
    } else {
        // return other stuff
    }
}

PrefUtils
Context
val displayedValue: String
    get(context: Context) {
        return if (PrefUtils.useImperialUnits(context)) {
            // stuff
        } else {
            // other stuff
        }
    }

.getDisplayedValue(Context)
.displayedValue
Context
scope
also { }
fun addFrom(appleTree: AppleTree) {
    val apple = appleTree.pick().also { apple -&gt;
        this.weight += apple.weight
        add(apple)
    }
    ...
}
...
fun add(fruit: Fruit) = ... }

also
also
peek
val times = 5

// First option
for (i in 0 until times) {
    print("Action $i")
}

// Second option
repeat(times) {
    print("Action $it")
}

repeat
for
repeat
repeat
repeat
times
public inline fun Int.times(body : () -&gt; Unit)

times
interface ITextWatcher {
    fun onTextChanged(text: String) {

    }
}

val textChangeHandler = object: ITextWatcher {
    override fun onTextChanged(text: String) 
         var t = text
    }
}

val textChangeHandler = object: ITextWatcher {text -&gt;

}

trait Foo {
    fun bar(): &lt;??&gt; /* what to put here? */ {
        return this
    }
}

class FooClassA : Foo {
    fun a() {}
}

class FooClassB : Foo {
    fun b() {}
}

// this is the desired effect:
val a = FooClassA().bar() // should be of type FooClassA
a.a()                     // so this would work

val b = FooClassB().bar() // should be of type FooClassB
b.b()                     // so this would work

instancetype
Self
kotlin
require()
assert()
require(value: Boolean)
IllegalArgumentException
value
assert(value: Boolean)
AssertionError
value
require()
assert()
class Foo(xs : ArrayList&lt;Int&gt;) : List&lt;Int&gt; by xs { }

class Foo() : List&lt;Int&gt; by ArrayList&lt;Int&gt;() { }

class Foo() : List&lt;Int&gt; by xs {
    val xs : List&lt;Int&gt; = ArrayList&lt;Int&gt;()
}

fun handle() : String {
    null?.let { return "Ololo"}
}

val result = handle()
result.trim() // kotlin.TypeCastException: null cannot be cast to non-null type kotlin.CharSequence

function putritanjungsari(data){
	console.log(data.name)
}

let data = {
	name:"putri",
	div:"m4th"
}
putritanjungsari(data)
kotlin-runtime
-Xno-param-assertions
-Xno-call-assertions
java.lang.NoClassDefFoundError: Failed resolution of: Lkotlin/jvm/internal/Intrinsics;
   at lt.neworld.yyy.&lt;init&gt;(Unknown Source:2)
   at lt.neworld.yyy.&lt;init&gt;(yyy.kt:13)

abstract class Element(val name: String) {

    var children = mutableListOf&lt;Element&gt;()

    override fun toString() = """
        &lt;$name&gt;
            ${children.joinToString("\n") { toString() }}
        &lt;/$name&gt;
    """.trimIndent()

}

{ toString() }
&lt;a&gt;
    &lt;b&gt;
    &lt;/b&gt;
    &lt;c&gt;
    &lt;/c&gt;
&lt;/a&gt;

fun main(args: Array&lt;String&gt;) {
    val a = Element("a")
    a.children.add(Element("b"))
    a.children.add(Element("c"))
    println(a)
}

private val factory = YamlConfigurationFactory(LinkedHashMap::class.java, validator, objectMapper, "dw")

 val yml = File(Paths.get("config.yml").toUri())
 var keyValues =  factory.build(yml)

type inference failed. the value of the type parameter k should be mentioned in input types

var keyValues =  LinkedHashMap&lt;String, Any&gt;()
keyValues =  factory.build(yml)

LinkedHashMap::class.java.kotlin

TextView textView = (TextView)findViewById(R.id.textView)
textView.setText(response)

val response = client.newCall(request).execute()
println(request)
println(response)
TextView textView = (TextView)findViewById(R.id.textView)
textView.setText(response)

clone
clone
fun foo(obj: Any?): Int {
   var ret: Int = 0

   if (obj === null) {
      // do Something
   }
   else if (obj is Cloneable) {
      var copied: Cloneable = (obj as Cloneable).clone() // Error occurs 
      // do Something 
   }
}

clone
Cloneable
main()
fun main(args: Array&lt;String&gt;) {
    // validation &amp; String to Integer conversion
}

String
class Person(firstName: String) {
}

class Person(val firstName: String) {
}

var filename = "ab_$type_$date.dat"

var filename = "ab_" + type + "_$date.dat"

val num = 12.12
val num2: Float = num.toFloat() // Works
val num3: Float = num as Float // Exception

num.toFloat()
num as Float
get()
LiveData
ViewModel
LiveData
ViewModel
class MyViewModel(ctx: Context) : AndroidViewModel(ctx as Application)
{
    private val _showLoadingPB = SingleLiveEvent&lt;Boolean&gt;()

    fun showLoadingPB(): SingleLiveEvent&lt;Boolean&gt;
    {
        return _showLoadingPB
    }
...
}

class MyViewModel(ctx: Context) : AndroidViewModel(ctx as Application)
{
    private val _showLoadingPB = SingleLiveEvent&lt;Boolean&gt;()

    val showLoadingPB: SingleLiveEvent&lt;Boolean&gt;
        get() =&gt; _showLoadingPB
}

data class EmailAddress(val address: String) {

    init {
        if (address.isEmpty() || !address.matches(Regex("^[a-zA-Z0-9]+@[a-zA-Z0-9]+(.[a-zA-Z]{2,})$"))) {
            throw IllegalArgumentException("${address} is not a valid email address")
        }
    }
}

@Configurable
data class EmailAddress(@Email val address: String) {

    @Autowired
    lateinit var validator: Validator

    init {
        validator.validate(this)
    }
}

val messageBroker: MessageBroker by lazy { MessageBroker() }
if (messageBroker == null) {
    // oops
}

private var isMessageBrokerInstantiated: Boolean = false
val messageBroker: MessageBroker by lazy {
    isMessageBrokerInstantiated = true
    MessageBroker()
}

...

if (!isMessageBrokerInstantiated) {
    // use case
}

if (Lazy(messageBroker).isInstantiated())
class.memberProperties
properties
collection&lt;KProperty1&lt;I, *&gt;&gt;
KProperty
KProperty
.get()
property
if (property.get(receiver) is ClassIWant) {
  //Do something
}

val properties = request.payload::class.memberProperties
  properties.forEach { property -&gt;
    run {
      if (property.name.equals("nameIWant")) {

      }
    }
  }

.get()
KProperty1
receiver
Nothing
.get()
data class RideDate(var enddate: String? = null,var startdate: String? = null) 



 fun main(args: Array&lt;String&gt;) {
var listOfRideDate = mutableListOf&lt;RideDate&gt;();
val date1 = RideDate()
date1.startdate = "2018-11-05 00:00:00 +0000"
date1.enddate = "2018-11-06 23:59:59 +0000"
listOfRideDate.add(date1)

val date2 = RideDate()
date2.startdate = "2020-01-20 00:00:00 +0000"
date2.enddate = "2020-02-20 00:00:00 +0000"
listOfRideDate.add(date2)

val date3 = RideDate()
date3.startdate = "2020-03-20 00:00:00 +0000"
date3.enddate = "2020-03-20 00:00:00 +0000"
listOfRideDate.add(date3)

val date4 = RideDate()
date4.startdate = "2020-04-20 00:00:00 +0000"
date4.enddate = "2020-04-20 00:00:00 +0000"
listOfRideDate.add(date4)

val date5 = RideDate()
date5.startdate = "2020-11-20 00:00:00 +0000"
date5.enddate = "2020-11-20 00:00:00 +0000"
listOfRideDate.add(date5)


for (i in 0..listOfRideDate.size -1) {
    // we have to remove 2018-11-05 00:00:00 +0000 and 2018-11-06 23:59:59 +0000  from list 
    println(listOfRideDate.get(i).startdate + " and " + listOfRideDate.get(i).enddate)
}

class ListManipulate(val list: List&lt;Char&gt;, val blockCount: Int) {

    val result: MutableList&lt;List&lt;Char&gt;&gt; = mutableListOf()

    fun permute(sequence: List&lt;Int&gt; = emptyList(), start: Int = 0, count: Int = blockCount) {
        if (count == 0) {
            result.add(constructSequence(sequence))
            return
        }
        for (i in start .. list.size - count) {
            permute(sequence + i, i + 1, count - 1)
        }
    }

    private fun constructSequence(sequence: List&lt;Int&gt;): List&lt;Char&gt; {
        var result = emptyList&lt;Char&gt;()
        for (i in sequence) {
            result += list[i]
        }
        return result
    }
}

result
    var result: List&lt;List&lt;Char&gt;&gt; = emptyList()
    // ...
            result += constructSequence(sequence)

Type mismatch. Require: List&lt;List&lt;Char&gt;&gt;; Found: List&lt;Any&gt;
class ListManipulate(val list: List&lt;Char&gt;, val blockCount: Int) {

    var result: List&lt;List&lt;Char&gt;&gt; = emptyList()

    fun permute(sequence: List&lt;Int&gt; = emptyList(), start: Int = 0, count: Int = blockCount) {
        if (count == 0) {
            result += constructSequence(sequence)
            return
        }
        for (i in start .. list.size - count) {
            permute(sequence + i, i + 1, count - 1)
        }
    }

    private fun constructSequence(sequence: List&lt;Int&gt;): List&lt;Char&gt; {
        var result = emptyList&lt;Char&gt;()
        for (i in sequence) {
            result += list[i]
        }
        return result
    }
}

result + constructSequence(sequence)
List&lt;Any&gt;
List&lt;List&lt;Char&gt;&gt;
var Last=0
for (Left in str){
    var num:Int=-1

    var index=str.indexOf(Left,Last)

        for (i in index..len)
        if (Left.equals(str[i],true)) {
            num++
        }
    Last=index
        println("The Char $Left repets $num Times on the right")
    }

kotlin
val addLike             = mulLike separatedBy addLikeSeparator
val expression          = 
  forwarded.second(addLike)
  addLike

addLike
kotlin
Error:(195, 5) Kotlin: Expecting a top level declaration

val addLike             = mulLike separatedBy addLikeSeparator
val expression          = forwarded.second(addLike); addLike

;
expressions
statement
,
val addLike             = mulLike separatedBy addLikeSeparator
val expression          = forwarded.second(addLike), addLike

kotlin
kotlin
run
val expression          = run () {
                                forwarded.second(addLike)
                                whitespaces keepRight addLike keepLeft expectEOS()
                          }

class User(age:Int, name:String)

for(component in aUserObject){
    //do some stuff with age or name
}

data class Foo(
  val id: String? = null
  val someStuff: String? = null,
)

val foo = listOf(Foo("id1"), Foo())
val bar = foo.filterNot { it.id == null }.associateBy { it.id }

bar
Map&lt;String?, Foo&gt;
Map&lt;String, Foo&gt;
!!
var foo: Map&lt;String, List&lt;String&gt;&gt; = emptyMap()
foo += mapOf(
        "1" to listOf("a", "b"),
        "2" to listOf("a", "b"),
        "3" to listOf("a", "b")
)

c
foo += "1" to (foo["1"] ?: emptyList()) + "c"

foo += "1" to foo["1"].orEmpty() + "c"

fun render(params: Map&lt;String, String&gt;): String {
    var acc:String = template
    for (entry in params.entries){
        acc = acc.replace("@${entry.key}", entry.value)
    }
    return acc
}

open
this
init
this
init
val
class Listener {
    fun onCreated(leaker: Leaker) = println("Listener hears that leaker created with a value of ${leaker.myVal}")
}

class Leaker(listener: Listener) {
    val myVal: Int

    init {
        listener.onCreated(this)
        myVal = 1
        println("Leaker knows that it's been created with a value of $myVal")
    }
}

Leaker(Listener())

Listener hears that leaker created with a value of 0
Leaker knows that it's been created with a value of 1

myVal
Leaker
Listener
Leaker
Listener
myVal
Listener
val
Caused by: org.json.JSONException: Value
{
  "result": {
    "response": {
      "airport": {
        "pluginData": {
          "schedule": {
            "arrivals": {
              "data": [
                {
                  "flight": {
                    "identification": {
                      "id": null,
                      "row": 4832637003,
                      "number": {
                        "default": "ZP4801",
                        "alternative": null
                      },
                      "callsign": null,
                      "codeshare": null
                    }
                  }
                }
              ]
            }
          }
        }
      }
    }
  }
}

  private fun handleJson (jsonString: String?){

        val jsonArray = JSONArray(jsonString)
        val list =  ArrayList&lt;FlightShdu&gt;()
        var x = 0
        while (x &lt; jsonArray.length()){

            val jsonObject = jsonArray.getJSONObject(x)


            list.add(FlightShdu(

                jsonObject.getInt("id"),
                jsonObject.getString("callsign")

            ))


            x++
        }
        val adapter = ListAdapte(this@MainActivity,list)
        flightShdu_list.adapter = adapter

    }

class ObjectA(val objectBs: List&lt;ObjectB&gt;,
              val otherFields: Any)

class ObjectB(val key: String,
              val otherFields: Any)

listOfA.mapNotNull { 
    it.objectBs.firstOrNull { 
        item -&gt; item.key == wantedKey
   } 
}.firstOrNull()

data class
data class ProductsResponse(
        val id:String,
        val ProductType:String
)

var productList: List&lt;ProductResponse&gt;
var productNameList: List&lt;String&gt;
ProductType
list
Strings
ProductType
Kotlin
list
list
Strings
var list=new List&lt;Person&gt;();
list.Add(new Person(25, "Tom"));
list.Add(new Person(25, "Dave"));
list.Add(new Person(20, "Kate"));
list.Add(new Person(20, "Alice"));

//will produce: Alice, Kate, Dave, Tom
var sortedList=list.OrderBy(person =&gt; person.Age).ThenBy(person =&gt; person.Name).ToList(); 

val sortedList = ArrayList(list.sortedBy { it.age }.sortedBy { it.name })) //wrong

fun displayTotalSelectedString(btn: ListItemButton, items: MutableList&lt;String&gt;?, resId: Int) {
    btn.text = if ((items == null) || (items.size == 0)) getString(resId) else getString(resId) + "  (" + items.size + ")"
}

fun displayTotalSelectedInt(btn: ListItemButton, items: MutableList&lt;Int&gt;?, resId: Int) {
    btn.text = if ((items == null) || (items.size == 0)) getString(resId) else getString(resId) + "  (" + items.size + ")"
}

MutableList&lt;Any&gt;?
val cities = listOf(
"Boston",
"Munich",
"Saint-Petersburg")

val fooCtor = ::Foo

fooCtor
KFunction3&lt;Int, Int, Int, Foo&gt;
KFunction3&lt;...&gt;
val fooCtor: KFunction3&lt;Int, Int, Int, Foo&gt; = ::Foo

KFunction3
errorClass
= StandardError::class
fun &lt;V, E : TypedError&gt; functionName(message: String = "Message", errorClass: KClass&lt;E&gt; = StandardError::class, action: () -&gt; V){
...
}

interface TypedError

data class StandardError(val code: Int) : TypedError

val n: Int = 10
val arr = Array(n, { it } )
val i: Int = 0
println(arr[i])

val n: Long = 10
val arr = Array(n, { it } )
val i: Long = 0
println(arr[i])

val n: Long = 10
val arr = Array(n.toInt(), { it } )
val i: Long = 0
println(arr[i.toInt()])

 val a: Int? = 1024
 println(a is Int) // true
 println(a is Int?) // true
 println(a is String) // **error: incompatible types: Long and Int? why the value cannot be checked with any type?**

fun checkType(x: Any?) {
    when(x) {
        is Int -&gt; ...
        is String -&gt; ... // **It works well here**
        else -&gt; ...
    }
}

class ItemBase(private val TOOLTIP: String) : Item(Settings().group(EnderIO.ENDERIO)) {
    fun check() {
        if (TOOLTIP.isNotBlank()) {
            override fun appendTooltip(itemStack: ItemStack?, world: World?, tooltip: MutableList&lt;Text?&gt;, tooltipContext: TooltipContext?) {
                tooltip.add(TranslatableText(TOOLTIP))
            }
        }
    }
}

appendTooltip
TOOLTIP
compareTo
equals
println("${'A'.compareTo('b')}")
println("${'A'.equals('b')}")

compareTo
-1
-1
equals
false
compareTo
equals
data class Foo(
    val id: FooId,
    val name: String,
    ... 10+ properties
}

data class NewFoo(
    val name: String,
    ... 10+ properties
}

sealed
var num = pref?.getInt("something", 1)

"java.lang.Long cannot be cast to java.lang.Integer, null"
var a=[1,2,3];
var b = a.expand((i)=&gt;List.generate(i,(_)=&gt;i.toString())).toList();
print(b.toString());
//Output: [1, 2, 2, 3, 3, 3]

map()
fun &lt;T, R&gt; Collection&lt;T&gt;.fold(initial: R,  combine: (acc: R, nextElement: T) -&gt; R): R {
    var accumulator: R = initial
    for (element: T in this) {
        accumulator = combine(accumulator, element)
    }
    return accumulator
}

fun &lt;T, R&gt; Collection&lt;T&gt;.fold(initial: R, someFun)

fun someFun (acc: R, nextElement: T) -&gt; R): R {
        var accumulator: R = initial
        for (element: T in this) {
            accumulator = combine(accumulator, element)
        }
        return accumulator
}

class MyClass {

    companion object {
        lateinit var myGlobalLateInit: String
    }

    lateinit var myLocalLateInit: String

    fun settingVariable() {
        if (!this::myLocalLateInit.isInitialized) {
            myLocalLateInit = "I am set"
        }

        if (!MyClass::myGloablLateInit.isInitialized) { // This line will error out. How could I set it?
            myGloablLateInit = "I am set"
        }

    }

}

transform(x)
x
y
while( col.any (p -&gt; predicate(p)) ) {
    val member = col.find { p -&gt; predicate(p) }!!
    transform(member)
}

do {
    val member = col.find { predicate(it) }?.also { transform(it) }
} while (member != null)


do {
} while (col.find { predicate(it) }?.also { transform(it) } != null)



while (col.find { predicate(it) }?.also { transform(it) } != null) {}

str = "abcde"
str.run {                                                                                                                                                                                              
this.substring(0..2).run {                                                                                                                                                                         
    println("${this} is a substring of ${???}")                                                                                                                                                    
}

data class Node(var other: Node = this)

data class Node(val _other: Node? = null) {
    var other: Node = _other ?: this
}

this
class Person {
    var children: MutableList&lt;Person&gt; = mutableListOf&lt;Person&gt;();
    constructor(parent: Person) {
        parent.children.add(this)
    }
}

class Person(val name: String) {
    var children: MutableList&lt;Person&gt; = mutableListOf&lt;Person&gt;();
    constructor(name: String, parent: Person) : this(name) {
        parent.children.add(this)
    }
}

fun num(num:Int):Int {
    if (num &gt; 0){ 
        print(num % 10)
        return num / 10
    }
} //here an error

fun main(args: Array&lt;String&gt;) {
    var num: Int? = null
    // Stuff happens that might make num not null
    ...
    if (num != null) doSomething(num)
}

fun doSomething(number: Int) {
    ...
}

forEach
bar
List
fun bar(collection: List&lt;String&gt;): Boolean {
    collection.forEach { value -&gt;
        if ("foo".equals(value))
            return true
    }
    return false
}

collection
Map
fun bar(collection: Map&lt;String, String&gt;): Boolean {
    collection.forEach { key, value -&gt;
        if ("foo".equals(key))
            return true // compilation error: 'return' is not allowed here. 
    }
    return false
}

data class Parent(val name: String, val age: Int, val children: Set&lt;Child&gt;)
data class Child(val name: String, val age: Int)

toCompilableString(
   Parent("Joe", 34, setOf(Child("Amy", 4), Child("Bob", 7)))
)

"""Parent("Joe", 34, setOf(Child("Amy", 4), Child("Bob", 7)))"""

MyKotlinClass
ThirdPartyJavaInterface
public interface ThirdPartyJavaInterface {
    String getName();
}

class MyKotlinClass (val name: String) : ThirdPartyJavaInterface 

MyKotlinClass
Accidental Override
getName()
name
getName()
class MyKotlinClass (val aName: String) : ThirdPartyJavaInterface {
    override fun getName(): String {
        return aName
    }
}

private fun display() {

    val mySongs = findSong(Environment.getExternalStorageDirectory())
    items = arrayOf(mySongs.size.toString())


    for (i in mySongs.indices) {
        items[i] = mySongs[i].name.toString().replace(".mp3", "").replace(".wav", "")
    }

    val adp = ArrayAdapter(this, android.R.layout.simple_list_item_1, items!!)

    listView!!.adapter = adp
    listView!!.onItemClickListener = AdapterView.OnItemClickListener { adapterView, view, position, l -&gt; startActivity(Intent(applicationContext, PlayerActivity::class.java).putExtra("pos", position).putExtra("songs", mySongs)) }
}

items[i] = mySongs[i].name.toString().replace(".mp3","").replace(".wav", "")
val i = intent
val b = i.extras
mySongs = b.getParcelableArrayList&lt;Parcelable&gt;(mySongs.toString())
position = b.getInt("pos", 0)
val u = Uri.parse(mySongs!![position].toString())
mediaPlayer = MediaPlayer.create(applicationContext, u)

b.getParcelableArrayList&lt;Parcelable&gt;(mySongs.toString())
     * Used for get User data
     */
    @UseExperimental(ObsoleteCoroutinesApi::class, ExperimentalCoroutinesApi::class)
    @Throws(APIFailureException::class)
    override fun getUserData(userId: String): Flow&lt;UserData&gt; {

        return flow&lt;UserData&gt; {
            supervisorScope {
                ​
                val userCount = userDataDao.getUserCount()
                ​
                val dbJob = async {
                    val userData: Observable&lt;UserDataEntity&gt; = userDataDao.getUserData()
                    val iterator = userData.openSubscription().iterator()
                    while (isActive &amp;&amp; iterator.hasNext()) {
                        val next = iterator.next()?.toDomainModel()
                        if (next != null) {
                            emit(next)
                        }
                    }
                }
                ​
                val cm =
                    context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
                val apiJob = if (cm.activeNetworkInfo.isConnected) { //Check for network
                    async {
                        try {
                            val responseUserData =
                                userServices.getUserDetail(userId, true).handledResponse()?.data
                            if (responseUserData != null) {
                                saveUserData(responseUserData.toDomainModel())
                                responseUserData.groupRole?.let { groupRole -&gt;
                                    saveGroupRole(groupRole.toDomainMode())
                                }
                                saveTeamInspectionTypes(responseUserData.teamInspectionTypes.toDomainModels())
                            } else {
                                throw APIFailureException("Unable to parse Userdata")
                            }
                        } catch (e: APIFailureException) {
                            if (userCount &lt;= 1) {
                                throw e
                            } else {
                                logger.error(e) { "Unable to update from network" }
                            }
                        }
                    }
                } else if (userCount &lt;= 1) {
                    throw NoSuchElementException("Unable to get data and no backup")
                } else null
                ​
                apiJob?.await()  // Do not pass this line until the api job is finished (or if it is null)
                dbJob.await()
            }
        }
    }

"e: D:\ARNextGenWorkSpace\ar-mobile-next\repository\src\main\java\com\arinspect\repository\UserRepositoryImpl.kt: (73, 9): Expecting an element
e: D:\ARNextGenWorkSpace\ar-mobile-next\repository\src\main\java\com\arinspect\repository\UserRepositoryImpl.kt: (76, 17): Expecting an element
e: D:\ARNextGenWorkSpace\ar-mobile-next\repository\src\main\java\com\arinspect\repository\UserRepositoryImpl.kt: (78, 17): Expecting an element
e: D:\ARNextGenWorkSpace\ar-mobile-next\repository\src\main\java\com\arinspect\repository\UserRepositoryImpl.kt: (89, 17): Expecting an element
e: D:\ARNextGenWorkSpace\ar-mobile-next\repository\src\main\java\com\arinspect\repository\UserRepositoryImpl.kt: (117, 17): Expecting an element"   

Tasks.db
Tasks.db
val result = Room.databaseBuilder(
            context.applicationContext,
            ToDoDatabase::class.java, "Tasks.db"
        ).build()

var myProperty: Type
    @Deprecated(AnkoInternals.NO_GETTER, level = DeprecationLevel.ERROR) 
    get() = AnkoInternals.noGetter()
    set(value) { field = value; /* setter logic */ }

for (j in 0..m - 1) {
    var b0 = a[j]
    var tt = j
    var b1: Int
    for (i in 0..n / m - 1) {
        tt = (tt + k) % n
        b1 = a[tt]
        a[tt] = b0
        if (b1 == 2)
            b0 = 2
        else
            b0 = b1
    }
}

b0
import java.util.*

/**
 * Created by Yrh on 2015/12/3.
 */

fun ff(a: Int, b: Int): Int {
    var t = 1
    var i = 2
    var a1 = a
    var b1 = b
    while (i &lt;= a1 &amp;&amp; i &lt;= b1) {
        t *= i
        a1 /= i
        b1 /= i
        i++
    }
    return t
}

fun main(args: Array&lt;String&gt;) {
    val scanner = Scanner(System.`in`)
    var a = IntArray(100)
    print("Input the number of data: ")
    val n = scanner.nextInt()
    print("Input the distant of moving: ")
    val k = scanner.nextInt()
    for (i in 0..n - 1)
        a[i] = scanner.nextInt()

    val m = ff(n, k)

    for (j in 0..m - 1) {
        var b0 = a[j]
        var tt = j
        var b1: Int
        for (i in 0..n / m - 1) {
            tt = (tt + k) % n
            b1 = a[tt]
            a[tt] = b0
            b0 = b1
        }
    }
    for (i in 0..n - 1) {
        print("${a[i]} ")
    }
}

import java.util.*

fun main() {

    /* Enter your code here. Read input from STDIN. Print output to STDOUT. */

    val scanValue = Scanner(System.`in`)
    val n = scanValue.nextInt()

    var phoneBook = mutableMapOf&lt;String, String&gt;()

    for (i in 0 until n) {
        val name =  scanValue.next()
        val phoneNumber =    scanValue.next()

        if (!phoneBook.containsKey(name) &amp;&amp; name != "") {
            phoneBook[name] = phoneNumber
        }
    }

    while (scanValue.hasNext()) {
        val names = scanValue.next()
        if (phoneBook.containsKey(names)) {
            println(names + "=" + phoneBook[names])
        } else {
            println("Not found")
        }
    }

    scanValue.close()

}

Vijay 198120230012
Ravi 323323323233
Akash 34343434344

Rakesh
Not found
Vijay
Vijay=98120230012
Ravi
Ravi=323323323233
Nisha
Not found!

Array&lt;Int&gt;

val na: Array&lt;Int&gt; = readLine()!!.split(' ').map{it.toInt()}.toTypedArray() // Array&lt;Int&gt;

na = [int(i) for i in input().split(' ')]

set.filter{a&gt;10}.filter{a&lt;20}.forEach{doSomething()}

for(e in set){ // Only iterate the set one time.
    if(e.a&gt;10){
        if(e.a&lt;20)
            doSomething()
    }
}

java.time.Clock
class TestClock(
    var instant: Instant = Instant.ofEpochSecond(0),
    zone: ZoneId = ZoneId.of("UTC")
) : Clock() {
    private val zone = zone

    override fun getZone(): ZoneId = zone

    override fun withZone(zone: ZoneId): Clock =
        if (zone == this.zone) this else TestClock(instant, zone)

    override fun instant(): Instant = instant
}

zone
class TestClock(
    var instant: Instant = Instant.ofEpochSecond(0),
    override val zone: ZoneId = ZoneId.of("UTC")
) : Clock() {
    override fun withZone(zone: ZoneId): Clock =
        if (zone == this.zone) this else TestClock(instant, zone)

    override fun instant(): Instant = instant
}

override val zone
getZone(): ZoneId!
var stringList = mutableListOf&lt;String&gt;()
    set(value) {
        field = value
        validateData()
    }


    import java.util.Scanner
fun main(){
    var loop = 0
var score = Array&lt;Int&gt;(2){0}
val reader = Scanner(System.`in`)
var alice:String = readLine().toString()
    var bob:String = readLine().toString()
    val numerosa: List&lt;String&gt; =  alice.split(" ")
    val numerosb:List&lt;String&gt; = bob.split(" ")
    for(a in 3..3) {

        when (numerosa[loop].toInt()) {
            in numerosb[loop].toInt() + 1..100 -&gt; score[0] += 1
            in numerosb[loop].toInt() - 1..0 -&gt; score[1] += 1
        }
        loop += 1
    }
println("${score[0]} ${score[1]}")

}

addHandler(HttpServiceHandler handler)

HttpServiceHandler
interface HttpServiceHandler extends Consumer&lt;HttpHandlerContext&gt;

Consumer&lt;HttpHandlerContext&gt;
addHandler({ context -&gt; context.blah(); })

private companion object {
    fun newHandler(notimportant: Long): HttpServiceHandler {
        return HttpServiceHandler { context -&gt; context.blah() }
    }
}

HttpServiceHandler {}
HttpServiceHandler
addHandler(newHandler(1L))

java.lang.ClassCastException: blah.BlahTest$Companion$newHandler$1 cannot be cast to kotlin.jvm.functions.Function1

at blah.BlahTest.test(BlahTest.kt:42)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)

addHandler(
    object : HttpServiceHandler {
        override fun accept(c: HttpHandlerContext) {
            c.complete()
        }
    }
)

fun newHandler(blah: Long): HttpServiceHandler {
    return object : HttpServiceHandler {
        override fun accept(c: HttpHandlerContext) {
            c.complete()
        }
    }
}

addHandler(newHandler(1L))

class Test:
  def __init__(self):
    self.one = "python"
    self.two = "is"
    self.three = "fun!"
t=Test()
print(vars(t))

{'one': 'python', 'two': 'is', 'three': 'fun!'}
val
var
val
val
var
l
val
val
let
.m
class AddressSpecification(private val address: Address) : Specification {
    override fun isSatisfiedBy(): Boolean {
        return (address.municipality.isNotBlank()
                &amp;&amp; if (address.neighbourhood == null) true else address.neighbourhood.isNullOrBlank()
                &amp;&amp; address.postalCode.isNotBlank()
                &amp;&amp; address.stateAbbreviation.isNotBlank())
                &amp;&amp; if (address.street.apartment == null) true else address.street.apartment &gt; 0

    }
}

fun getList(): List&lt;Animal&gt; = animals

fun test() {
    val list: Dog = getList().filter {
        it.age &gt; 5
    }
}

list
it
Animal
Dog
 val textViewList = arrayListOf&lt;TextView&gt;()

 textViewList.add(TextView)

  textViewList[0].textSize = 20f
  textViewList[0].text = "Programmatically created textView "
  myLayout.addView(textViewList[0])

textViewList.add(TextView)

mytable
columns
CollectionColumns
list
Column
name
val myTable = Table()
myTable.columns.add("Date")
myTable.columns.add("Name")
myTable.columns.add("Summ")

val find = myTable.columns.find("Summ")
println(find)

null
class Table() {

            var columns: CollectionColumns
            var rows: CollectionRows

            init {
                columns =  CollectionColumns()
                rows    =  CollectionRows()
            }

            inner class CollectionColumns() {

                var list = mutableListOf&lt;Column&gt;()

                fun add(_name: String): Table.Column{

                    val newColumn = Column(_name)
                    columns.list.add(newColumn)

                    for (row in rows.list) {
                        row.data.put(newColumn.name, null)
                    }

                    return newColumn
                }

                fun find(_name: String): Column?{

                    val findColumn = columns.list.find  { it.name == _name }
                    return findColumn
                }
            }

            class Column(_name: String) {
               val name = _name
            }

            inner class CollectionRows() {

                var list = mutableListOf&lt;Row&gt;()

                fun add() : Table.Row {
                    val newRow = Row()

                    for (column in columns.list) {
                        newRow.data.put(column.name, null)
                    }

                    rows.list.add(newRow)
                    return newRow
                }
           }

            class Row() {

                var data = mutableMapOf&lt;String, Any?&gt;()
                }
           }

if(root == null) return root;

public TreeNode invertTree(TreeNode root) {

        if(root == null) return root;

        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);
        if(root != null) {
            root.left = right;
            root.right = left;
        }

        return root;
    }

fun invertTree(root: TreeNode?): TreeNode? {
        return root ?: root
        var left = invertTree(root.left)
        var right = invertTree(root.right)

        root.right = left
        root.left = right

        return root;
    }

Line 14: Char 35: error: only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type TreeNode?
        var left = invertTree(root.left)

if(root == null) return root
==============================
Size 10
Lista: 62835 ns
Sekvenca: 7050134 ns
==============================

==============================
Size 100
Lista: 96139 ns
Sekvenca: 10376 ns
==============================

==============================
Size 1000
Lista: 702532 ns
Sekvenca: 9689 ns
==============================

==============================
Size 10000
Lista: 2598859 ns
Sekvenca: 26116 ns
==============================

==============================
Size 100000
Lista: 11004099 ns
Sekvenca: 45011 ns
==============================

==============================
Size 1000000
Lista: 623017128 ns
Sekvenca: 55156 ns
==============================

interface Control { id?: String, width?: number, height?: number }

function buildTextBoxControl(dataFromDb: any, options: Control) : TextBoxControl {
    return { ...options, text: dataFromDb.name }
}

buildTextBoxControl(objFromDb, { height: 45 })
buildTextBoxControl(objFromDb, { width: 25, id: "some-id" })

buildTextBoxControl
apply { }
&lt;data &gt;
    &lt;variable name="wordData"
        type="com.example.android.roomwordssample.Word"/&gt;
&lt;/data&gt;

&lt;LinearLayout
android:orientation="vertical"
android:layout_width="match_parent"
android:layout_height="wrap_content"&gt;



&lt;TextView
    android:id="@+id/textView"
    style="@style/word_title"
    android:text="@{word.word}"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="@android:color/holo_orange_light" /&gt;

inner class WordViewHolder(val binding: RecyclerviewItemBinding):
RecyclerView.ViewHolder(binding.root)

class MyValidator: MySubject {        
    override val subject = NonNullableBehaviourSubject(ValidationResponse())
}


class NonNullableBehaviourSubject&lt;T : Any&gt;(defaultValue: T) : Subject&lt;T&gt;() {
{

interface MySubject {
   var subject: ...
} 

data class Thing(val name: String, val attributes: List&lt;String&gt;)

List&lt;Thing&gt;
String
List&lt;Thing&gt;
flatMap
associateBy
var students: List&lt;Student&gt; = mutableListOf(Student("A", "X", 1), Student("A", "Y", 2), Student("B", "X", 2), Student("B", "Y", 2))

class Student {
    var name: String
    var subject: String
    var marks: Int
}

class GroupedStudent {
    var name: String
    var subMarks: MutableList&lt;SubjectMarks&gt; 
}

class SubjectMarks {
    var subject: String
    var marks: Int
}

@autoclosure
class Step(handler: () -&gt; Unit) {

    init {
        handler()
    }

}

Step(aFunctionThatTakesParameters(parameter: String)) // &lt;- Is there a way to get something like this working?

struct Step {

    init(_ handler: @autoclosure () -&gt; Void) {
        handler()
    }

}

Step(aFunctionThatTakesParameters(parameter: ""))

class MyBinder {
  ...

  fun bind(property: KMutableProperty&lt;Int&gt;): Unit {
     property.set(internalIntValue)
  }
}

  myBinder.bind(this::intProperty)

val remainderParts = arrayOf("/Company/Employees/Employee[Name='Michael", "Scott']/Salary", "45000")
var xpath: XPathExpression = (1..remainderParts.size).mapNotNull {
        try {
          XPathFactory.newInstance().newXPath().compile(remainderParts.subList(0, it).joinToString(" "))
        }
        catch (e: TransformerException) {
          null
        }
      }.first()

TransformerException
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(Age.List.class)
@Documented
@Constraint(validatedBy = { })
public @interface Age {
    String message() default "Must be greater than {value}";
    Class&lt;?&gt;[] groups() default { };
    Class&lt;? extends Payload&gt;[] payload() default { };
    long value();
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        Age[] value();
    }
}

@Target(AnnotationTarget.*)  
@Retention(RUNTIME)  
@Repeatable(Age.List::class)  
@Documented  
@Constraint(validatedBy = arrayOf())  
annotation class Age(  
  val value: Long,  
  val message: String = "Must be greater than {value}",  
  val groups: Array&lt;KClass&lt;*&gt;&gt; = arrayOf(),  
  val payload: Array&lt;KClass&lt;out Payload&gt;&gt; = arrayOf()) { 

  @Target(AnnotationTarget.FUNCTION,  
    AnnotationTarget.PROPERTY_GETTER,  
    AnnotationTarget.PROPERTY_SETTER,  
    AnnotationTarget.FIELD,  
    AnnotationTarget.ANNOTATION_CLASS,  
    AnnotationTarget.CONSTRUCTOR,  
    AnnotationTarget.VALUE_PARAMETER,  
    AnnotationTarget.TYPE)  
  @Retention(RUNTIME)  
  @Documented  
  annotation class List(vararg val value: Age)  
} 

for(int i=arr.length-1, j=0; i&gt;=0 &amp;&amp; j&lt;reverse.length; i--, j++){
    reverse[j] = arr[i];
}

class Person ( var name : String, var age : Int) {
    // putting main here
    fun main(args : Array&lt;String&gt;) {
        val person = Person("Neek", 34)
        println("my name is ${person.name}")
        println("my name is ${person.age}")
    }
}

warning: parameter 'args' is never used
    fun main(args : Array&lt;String&gt;) {
no main manifest attribute

sealed class MySealedClass(val thing: Thing) : MyPropertyInterface
{
    val name: String = thing.name

    /** Base Methods Here */

    /** Obj 1 Constructor */
    class ObjOne(thing: Thing) : MySealedClass(thing)
    {
        override val properties = PropertyTypeOne()
        override val otherProperties = PropertyTypeTwo()

        inner class PropertyTypeOne(){
            val one = 1
        }

        inner class PropertyTypeTwo(){
            val two = 2
        }
    }

    /** Obj 2 Constructor */
    class ObjTwo(thing: Thing) : MySealedClass(thing)
    {
        override val properties = PropertyTypeOne()
        override val otherProperties = PropertyTypeTwo()

        inner class PropertyTypeOne(){
            val one = 1
        }

        inner class PropertyTypeTwo(){
            val two = 2
        }
    }
}

interface Interface1&lt;T&gt;
interface Interface2&lt;T&gt;

private inline fun &lt;reified T&gt; createValue() = object : Interface1&lt;T&gt;, Interface2&lt;T&gt; { }

private val testPropertyInt = createValue&lt;Int&gt;()

VerifyError
private val testPropertyInt: Interface1&lt;Int&gt; = createValue&lt;Int&gt;()

interface Interface1&lt;T&gt;
interface Interface2&lt;T&gt;

class KotlinBugTest {
    private val testPropertyInt = createValue&lt;Int&gt;()

    @Test
    fun testBug() {
        assertEquals(4, 2 + 2)
    }

    private inline fun &lt;reified T&gt; createValue() = object : Interface1&lt;T&gt;, Interface2&lt;T&gt; { }
}

val disabledNos = intArrayOf(1, 2, 3, 4)
var integers = Arrays.asList(disabledNos)

void doStuff() {
    MyObject myObject = myObjectRepository.findById(myObjectId);
    if (myObject == null) {
        log.warn("myObject not found, aborting");
        return;
    }

    // More stuff
}

fun doStuff() {
    // I'd like to do something here that returns from the doStuff function when myObject is null
    val myObject = myObjectRepository.findById(myObjectId) 
                    ?: {log.warn("myObject not found, aborting") return}

   // More stuff
}

fun foo(m: String, bar: (m: String) -&gt; Unit) {
    bar(m)
}

// my function to pass into the other
fun buz(m: String) {
    println("another message: $m")
}

// someone passing buz into foo
fun something() {
    foo("hi", ::buz)
}

bar
foo("test", myOtherObj.myTestMethod())
val host by lazy { ... }

val host = lazy { ... }

val host by lazy {
        supportFragmentManager.findFragmentById(R.id.nav_host_fragment) as NavHostFragment
}

val host = lazy {
            supportFragmentManager.findFragmentById(R.id.nav_host_fragment) as NavHostFragment
}

someMap.get(someKey)
Please use !! or ?
someMap.getValue(someKey)
get
Map
getValue
object  DataHolder {
val time : MutableList&lt;Long&gt;

init {
    time = arrayListOf()
} ...

object  DataHolder {
val time = arrayListOf&lt;Long&gt;() ....

var test: String? = null
    get() {
        field?.also {
            return "has value"
        }
    }

return
null
var test: String? = null
    get() {
        if (field != null)
            return "has value"
    }

public interface CallbackWrapper {
    &lt;T&gt; Consumer&lt;T&gt; wrap(Consumer&lt;T&gt; consumer);
}

public class MainThreadWrapper implements CallbackWrapper {

    @Override
    public  &lt;T&gt; Consumer&lt;T&gt; wrap(Consumer&lt;T&gt; consumer) {
        return i -&gt; {
            Handler handler = new Handler(Looper.getMainLooper());
            handler.post(() -&gt; consumer.accept(i));
        };
    }
}

class Answers {
    enum class Answer(text: String) {
        YES("Yes."),
        No("No."),
        MAYBE("Maybe."),
        AGAIN("Ask again.")
    }
    val answers = Answer.values()
    val rand = Random()
    fun genAnswer ():String {
        val n = rand.nextInt(3)+1
//        return Answer[answers[n]].text
    }
}

inline fun &lt;reified T&gt; loadSync(path: String): T = loadSync(getAssetDescriptor(path))

enum class Asset (val path: String, val clazz: Class&lt;*&gt;){
    // Textures
    LOADER("splash-screen/loader.png", Texture::class.java),
    // ...
}

assetStorage.loadSync&lt;Asset.LOADER.clazz&gt;(Asset.LOADER.path)

clazz
Data
Container
Container
Data.printMe()
Container
containerVal
data class Data (val data: String)

class Container (private val containerVal: String, val data: Data){
    fun Data.printMe() {
        println("data: $data - in container: ${this@Container.containerVal}")
    }
}

fun main() {
    val c = Container("mycontainer", Data("mydata"))
    // Can I call Data.printMe without using `with`?
    // val d = c.data.printMe();
    with (c) {
        // Prints: data: mydata - in container: mycontainer
        data.printMe();
    }
}

Data.printMe
Container
with(c)
Cell
Board
Cell
Board
c.data.printMe
with
val resultSet: Set&lt;Pair&lt;Driver,Int&gt;&gt;

resultSet
ArrayList
ArrayList
ArrayList
fun &lt;T&gt; ArrayList&lt;T&gt;.findNext(cond: (T) -&gt; Boolean, p: Int = 0): Int {
    for (i in p..this.lastIndex) 
        if (cond(this[i]))  return i
    return -1
}    

data class Person (
    var name: String,
    var age: Int
)


fun main()  {
    var v = arrayListOf&lt;Person&gt;()
    v.add(Person("Paul", 22))
    v.add(Person("Laura", 24))
    v.add(Person("Paul", 50))
    v.add(Person("Mary", 24))

    println(v.findNext({it.name=="Paul"}))    // 0
    println(v.findNext({it.name=="Paul"}, 1)) // 2
    println(v.findNext({it.name=="Paul"}, 3)) // -1
}

data class User(
    val userNumber: Int = -1,
    val name: String,
    val userGroups; List&lt;String&gt; = emptyList(),
    val screenName: String = "new-user"
)

@JvmOverloads
User(int userNumber, @NotNull String name, @NotNull List userGroups,
     @NotNull String screenName)
User(int userNumber, @NotNull String name, @NotNull List userGroups)
User(int userNumber, @NotNull String name)
User(@NotNull String name)

User
User(name="John Doe", userGroups=listOf("admin", "super")
val userNumber: Int = -1
data class
Jackson
User(Integer userNumber, String name, List&lt;String&gt; userGroups, String screenName) {
    this.userNumber = (userNumber == null) ? -1 : userNumber;
    this.userGroups = (userGroups == null) ? Collections.emptyList() : userGroups;
    //...
}

data class User(
    val userNumber: Int = -1,
    val name: String,
    val userGroups; List&lt;String&gt; = emptyList(),
    val screenName: String = "new-user"
) {
    companion object {
        @JvmStatic
        @JsonCreator
        fun constructionSupport(
            @JsonProperty("userNumber") userNumber : Int?,
            @JsonProperty("name") name : String,
            @JsonProperty("userGroups") userGroups : List&lt;String&gt;?,
            @JsonProperty("screenName") screenName : String?
        ) = User(
            userNumber = userNumber ?: -1,
            name = name,
            userGroups = userGroups ?: emptyList(),
            screenName = screenName ?: "new-user"
        )
    }
}

kapt
Error: Could not find or load main class _DefaultPackage

updateTarget()
currentTarget()
x
class Targets(private val targets: ArrayList&lt;Target&gt;)
{
    init {
        require(targets.size &gt; 1) {"There must be more than one target in targets"}
    }

    // Keeps track of current index of target. Has a range of 0 to targets.size-1
    private var x = 0

    /**
     * Returns the current exercise target
     */
    fun currentTarget() : Target {
        return targets[x]
    }

    /**
     * Updates the current exercise target to the next target in the list
     *
     * Returns true if a repetition has been made.
     */
    fun updateTarget() : Boolean {
        x += 1
        x %= targets.size
        return x == 0
    }
}

if (target.isMetBy(value)) {
    val repetitionMade = currentExercise.targets.updateTarget()
    target = currentExercise.targets.currentTarget()
    if (repetitionMade) {
        numberRepetitions += 1
    }
}

var lowercases = ' '
do {
    println("Insert a name")
    val name = readLine()!!.toString()
    val First = name[0]
    if (First.isUpperCase()) {
        for (caracter in 1 until name.length) {
            lowercases = name[caracter]
            if (lowercases.isLowerCase()) {


            }
        }
    } else{
        println("olha nao da")
    }
} while (First.isLowerCase() || lowercases.isUpperCase())

import org.json.JSONObject

fun json(build: JsonObjectBuilder.() -&gt; Unit): JSONObject {
    val builder = JsonObjectBuilder()
    builder.build()
    return builder.json
}

class JsonObjectBuilder {
    val json = JSONObject()

    infix fun &lt;T&gt; String.To(value: T) {
        json.put(this, value)
    }
}

fun main(args: Array&lt;String&gt;) {
    val jsonObject =
            json {
                "name" To "ilkin"
                "age" To 37
                "male" To true
                "contact" To json {
                    "city" To "istanbul"
                    "email" To "xxx@yyy.com"
                }
            }
    println(jsonObject)
}

{"contact":{"city":"istanbul","email":"xxx@yyy.com"},"name":"ilkin","age":37,"male":true}

import kotlinx.coroutines.CompletableDeferred
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.channels.SendChannel
import kotlinx.coroutines.channels.actor
import kotlinx.coroutines.runBlocking

sealed class Message
class Ping(val replyTo: SendChannel&lt;Message&gt;) : Message()
object Pong : Message()

object Start : Message()

fun CoroutineScope.PingActor() = actor&lt;Message&gt;(capacity = 10) {
    for (msg in channel) { 
        when (msg) {
            is Ping -&gt;
                msg.replyTo.send(Pong)
        }
    }
}

fun CoroutineScope.PongActor(pinger: SendChannel&lt;Message&gt;, count: Int, done: CompletableDeferred&lt;Unit&gt;) =
    actor&lt;Message&gt; (capacity = 10){
        var counter = count 

        for (msg in channel) { 
            when (msg) {
                is Start -&gt;
                    for (i in 1..count) {
                        pinger.send(Ping(this.channel))
                    }

                is Pong -&gt; {
                    counter -= 1
                    if (counter == 0) {
                        done.complete(Unit)
                    }
                }
            }

        }
    }

fun main() = runBlocking&lt;Unit&gt; {

    val response = CompletableDeferred&lt;Unit&gt;()
    val pinger = PingActor() 
    val ponger = PongActor(pinger, 100, response) 
    val startTime = System.nanoTime()

    ponger.send(Start)
    response.await()

    println("total time taken is ${System.nanoTime() - startTime}")
    pinger.close() 
    ponger.close()
}

inline fun &lt;reified T: Any&gt; foo() = ...
inline fun &lt;reified T: Any, reified I: Any&gt; foo() = ...

inline fun &lt;reified T: Any&gt; foo() = foo&lt;T, MyDefaultType&gt;()
inline fun &lt;reified T: Any, reified I: Any&gt; foo(type1: KClass&lt;T&gt; = T::class, type2: KClass&lt;I&gt; = I::class) = ...

val x = foo&lt;A, B&gt;()
val y = foo&lt;C&gt;()

var
KMutableProperty
protected
KProperty
class FooA {
    var publicProp: String? = null
    protected var protectedProp: String? = null
    private var privateProp: String? = null

    fun foo() {
        val a = ::publicProp
        val b = ::protectedProp
        val c = ::privateProp
    }
}

open class FooB {
    var publicProp: String? = null
    protected var protectedProp: String? = null
    private var privateProp: String? = null

    fun foo() {
        val a = ::publicProp
        val b = ::protectedProp
        val c = ::privateProp
    }
}

class Bar : FooB() {
    fun bar() {
        val a = ::publicProp
        val b = ::protectedProp
    }
}

val fr = javax.swing.JFileChooser()
val fw = fr.fileSystemView
val documentsPath = fw.getDefaultDirectory().toString()

println(documentsPath)

sealed class
sealed class Foo {
    object Bar : Foo()
    data class Baz(val m: String) : Foo()
}

    val allergyList = recipeItem.allergies
    allergyList.joinToString()
    var allergyString: String = ""
    for (allergy in allergyList) {
        allergyList[1]
        allergyString += " ${allergy}"
        println(allergy.toString())
    }

    holder.recipeSearchPageAllergies.text = allergyString

Allergy@4e8f238
interface Foo

class Bar : Foo

fun main() {
    val l = initBar {

    }

    initFoo(l) // Doesnt work compile error: Type mismatch.
                                                //Required:
                                                //  Foo.() → Unit
                                                //Found:
                                                //  Bar.() → Unit
}

fun initBar(init: Bar.() -&gt; Unit) = init


fun initFoo(init: Foo.() -&gt; Unit) = Unit

Type mismatch.
Required:
Foo.() → Unit
Found:
Bar.() → Unit


Foo
class OkHttpService {

    companion object {
        fun httpGet(username: String, callback: Callback) {
            val fetchRepoUrl = "https://api.github.com/users/$username/repos?page=1&amp;per_page=20"

            val client = OkHttpClient()
            val request = Request.Builder()
                    .url(fetchRepoUrl)
                    .build()

            client.newCall(request).enqueue(callback)
        }
    }
}

fun OkHttpService_httpGet(username: String, callback: Callback) {
            val fetchRepoUrl = "https://api.github.com/users/$username/repos?page=1&amp;per_page=20"

            val client = OkHttpClient()
            val request = Request.Builder()
                    .url(fetchRepoUrl)
                    .build()

            client.newCall(request).enqueue(callback)

repeat
repeat(3) {
  println("This will print 3 times")
}

action
inline fun repeat(times: Int, action: (Int) -&gt; Unit)

repeat(3, 2 -&gt; anotherFun()) {
    println("This will show 2 times?")
}

fun anotherFun() {
    println("head into the 2nd time and print this out.")
}

(Int) -&gt; Unit
EnumClass.values()
Array
class FrameWorkClass // Third party class we cannot modify
class MyDerivedFrameWorkClass(c:FrameWorkClass) : FrameWorkClass by c

emit(timeStampToTime(currentTime.value))
emit(timeStampToTime(currentTime.value?:0))
val currentTime
currentTime.value
liveData { emit(timeStampToTime(it)) }
liveData { emit(timeStampToTime(it?:0)) }
class LiveDataViewModel(
    private val dataSource: DataSource
) : ViewModel() {

    val currentTime = dataSource.getCurrentTime()

    val currentTimeTransformed: LiveData&lt;String&gt; = liveData {
       //emit(timeStampToTime(currentTime.value))  // It will cause error     
       emit(timeStampToTime(currentTime.value?:0))

    }


    //Original Code
    // Coroutines inside a transformation
    //  val currentTimeTransformed = currentTime.switchMap {
    //   timeStampToTime is a suspend function so we need to call it from a coroutine.
    //    liveData { emit(timeStampToTime(it)) }
    // }

    private suspend fun timeStampToTime(timestamp: Long): String {
        delay(500)  // Simulate long operation
        val date = Date(timestamp)
        return date.toString()
    }

}



class DefaultDataSource(private val ioDispatcher: CoroutineDispatcher) : DataSource {

    override fun getCurrentTime(): LiveData&lt;Long&gt; =
        liveData {
            while (true) {
                emit(System.currentTimeMillis())
                delay(1000)
            }
        }
   ...
}

[A, B, C, E]
[A, D]
[A, B, C, E, D]
val numbers = listOf("one", "two", "three", "four")

Map&lt;Int, String&gt;

abstract class MapActivity: AppCompatActivity(), OnMapReadyCallback {

    lateinit var map: GoogleMap

    fun initializeMap() {
        val mapFragment = supportFragmentManager.findFragmentById(R.id.map) as SupportMapFragment
        mapFragment.getMapAsync(this)
    }

    override fun onMapReady(map: GoogleMap?) {
        this.map = map //error here
    }
}

override fun onMapReady(map: GoogleMap?) {
        if (map != null) 
            this.map = map
    }

override fun onMapReady(map: GoogleMap?) {
    if (map != null) {
        this.map = map
    } else {
        Log.d("Activity","MapIsNull")
    }    
}

MyTest.kt
package my.test
fun sayHello(): String = "Hello"

MyTestKt
MyTestKt.sayHello() // Returns "Hello"
MyTestKt myTestKt = new MyTestKt() // Instantiate

object
companion object
data class UserRto(val lastName: String, val firstName: String, val email: String, val password: String) {
    constructor() : this("", "", "", "")
}

import com.github.salomonbrys.kotson.get
import com.github.salomonbrys.kotson.int
import com.github.salomonbrys.kotson.jsonObject
import com.google.gson.JsonElement
import com.google.gson.JsonObject

abstract class BatchJobPayload {
    abstract fun toJson(): JsonObject
}

class BookingConfirmationMessagePayload(val bookingId: Int) : BatchJobPayload() {
    constructor(payload: JsonElement) : this(payload["bookingId"].int)

    override fun toJson() = jsonObject(
        "bookingId" to bookingId
    )
}

BatchJobPayload
constructor(payload: JsonElement): BatchJobPayload
BookingConfirmationMessagePayload
BatchJobPayload
reduce and fold
 val numbers = listOf("one", "two", "three", "four", "five")
 println(numbers.groupingBy { it.first() }.eachCount())      // Output:- {o=1, t=2, f=2}

class SettingsPage {
  lateinit var tagCharacters: JTextField
  lateinit var tagForegroundColorChooser: ColorPanel
  lateinit var tagBackgroundColorChooser: ColorPanel

  var allowedChars: String
    get() = tagCharacters.text
    set(value) = tagCharacters.setText(value)

  var tagForegroundColor by tagForegroundColorChooser
  var tagBackgroundColor by tagBackgroundColorChooser
}

  operator fun ColorPanel.getValue(a: SettingsPage, p: KProperty&lt;*&gt;) = selectedColor
  operator fun ColorPanel.setValue(a: SettingsPage, p: KProperty&lt;*&gt;, c: Color?) { selectedColor = c }

class SettingsPage {
  lateinit var tagCharacters: JTextField
  lateinit var tagForegroundColorChooser: ColorPanel
  lateinit var tagBackgroundColorChooser: ColorPanel

  var allowedChars: String by Alias(tagCharacters.text)
  var tagForegroundColor by Alias(tagForegroundColorChooser.selectedColor)
  var tagBackgroundColor by Alias(tagBackgroundColorChooser.selectedColor)
}

Alias
CheeseViewModel
Application
Application
Application
class MainActivity : AppCompatActivity() {
    private val viewModel by viewModels&lt;CheeseViewModel&gt;()
    ...
}

class CheeseViewModel(app: Application) : AndroidViewModel(app) {
    val dao = CheeseDb.get(app).cheeseDao()

    ...
}

//sweet
for ((key,value) in System.getProperties())
    println("$key = $value")

//sour
val properties = System.getProperties()
val list = properties.map((key,value) -&gt; "$key = $value")

properties.map{case (key, value) =&gt; s"$key = $value"}
when(transaction.state) {
    Transaction.Type.EXPIRED,
    //about 10 more types
    Transaction.Type.BLOCKED -&gt; {
        if (transaction.type == Transaction.Type.BLOCKED &amp;&amp; transaction.closeAnyway) {
            close(transaction)
            break //close if type is blocked and has 'closeAnyway' flag
        }
        //common logic
    }
    //other types
}

break
return/break
when
player
private var playbackPosition = 0
    get() {
        return if (player == null) 0 else player?.currentPosition?.toInt() as Int / 1000
    }

private var playbackPosition = if (player == null) 0 else player?.currentPosition?.toInt() as Int / 1000

private var playbackPosition = when(player)  {
    null -&gt; 0
    else -&gt; player?.currentPosition?.toInt() as Int / 1000
} 

val listA = listOf("A", "B", "C")

listA.intersect(setOf("E", "C")).isNotEmpty()

listA.any { it in listOf("E","C") }

fun &lt;T&gt; List&lt;T&gt;.containsAny(vararg other : T) =
      this.intersect(other.toSet()).isNotEmpty()

fun List&lt;Files&gt;.totalSize(){
    return this.map {
        it.length()
    }.reduce { current, total -&gt; current + total }
}

Unresolved reference: length
it
data class Properties( val actionBarColor : Int , val fileName : String) : 
 Serializable{
var title : String = ""
var readModeOnly : Boolean = false
}

var properties = Properties()

if(properties?.readModeOnly){

}

Boolean
Boolean?
interface Base {
var url: URL?
}

class BaseImpl: Base {
override var url: URL? = null
}

fun get(context: Context, s: String): MyObjectDb? {
    return context.database.use {
        return@use select(MyObjectDb.TABLE_NAME, *MyObjectDb.PROJECTION)
                    .whereArgs("${MyObjectDb.COLUMN_S} = {s}", "s" to s)
                        .exec {
                            return@exec getOne(MyObjectDb::fromCursor)
                        }
    }
}

class MyObject(var string1: String, var string2: String, var string3: String)
{
    constructor(presetCode: PresetCode ) : this("", "", "")
    {
      when (presetCode)
      {
       PresetCode.Code1 -&gt;
        {
         string1 = "aaa"
         string2 = "bbb"
         string3 = "ccc"
        }
       }
      }

   var anotherObject = AnotherObject(string1)

}

HashMap
String
var tablica = arrayListOf&lt;String&gt;()

var haszmapa = hashMapOf&lt;String, Int&gt;()
haszmapa.put("Tadek", 1)
haszmapa.put("Maniek", 1)
haszmapa.put("Juras", 1)

import java.util.logging.Logger

class MyClass(private val myNum: Int) {

  companion object {
    private val LOG = Logger.getLogger(MyClass::class.java.canonicalName)
  }

  constructor() : this(1337)

  fun addTo(num: Int): Int  {
    LOG.fine { "Adding num $num to $myNum" }
    return myNum + num
  }

  fun doubleAdd(num: Int): Int = 2 * addTo(num)
}

@Deprecated("Don't use!", level = DeprecationLevel.WARNING)
class MyClass(private val myNum: Int) {
  // ...
}

DeprecationLevel.ERROR
@Deprecated("Don't use!", level = DeprecationLevel.ERROR)
class MyClass(private val myNum: Int) {
  // ...
}

e: /path/to/project/src/main/kotlin/MyClass.kt: (7, 44): Using 'MyClass' is an error. Don't use!                                                               
e: /path/to/project/src/main/kotlin/MyClass.kt: (10, 23): Using 'MyClass' is an error. Don't use!  

MyClass
this
DeprecationLevel.ERROR
1.2.21
listOf()
arrayListOf()
  data class SearchResult(
      @SerializedName("photos")
      var photos: SearchResponse
)

 data class SearchResponse(
     @SerializedName("page")
     var page: Int,
     @SerializedName("pages")
     var pages: Int,
     @SerializedName("perpage")
     var perpage: Int,
     @SerializedName("total")
     var total: Int,
     @SerializedName("photo")
     var photos: List&lt;Photo&gt;
 )

  data class Photo(
    @SerializedName("id")
    var id: String? = null,
    @SerializedName("owner")
    var owner: String? = null,
    @SerializedName("secret")
    var secret: String? = null,
    @SerializedName("server")
    var server: String? = null,
    @SerializedName("farm")
    var farm: Int? = 0,
    @SerializedName("title")
    var title: String? = null,
    @SerializedName("ispublic")
    var ispublic: Int,
    @SerializedName("isfriend")
    var isfriend: Int,
    @SerializedName("isfamily")
    var isfamily: Int
) {

fun getUrl(): String {
    return "https://farm$farm.staticflickr.com/$server/$id" + "_" + "$secret" + "_" + "m.jpg"
  }

}

      &lt;layout 
         ....&gt;
        &lt;data&gt;
          &lt;variable
             name="property"
             type="com.example.android.searchphotoapp.network.Property" /&gt;
        &lt;/data&gt;
        &lt;ImageView
            ....
            app:imageUrl="@{property.photos}"/&gt;
     &lt;/layout&gt;

var atmarray = arrayListOf&lt;ATM&gt;()
class ATM(
    val AccountName:String="",
    val Pin:Int=0,
    val IntialDeposit:Double=0.0
)
fun main(args: Array&lt;String&gt;) {
mainmenu()
}

fun mainmenu(){
println("WELCOME TO BANK AL BILAL ATM MACHINE")
println("1- Add Account\n2- Login Account\n3-Exit")
var input1= readLine()!!.toInt()
when(input1){
    1-&gt;add()
    2-&gt;login()
    3-&gt; Exit()
}
}

fun add(){
println("Enter Your Name")
val Name= readLine()!!.toString()
println("Enter Your 4-Digit Account Pin")
var Pin= readLine()!!.toInt()
println("Confirm Your 4-Digit Account Pin")
var Pin1= readLine()!!.toInt()
if (Pin!=Pin1){
    println("Sorry Your Pin didn't Match, Try Again")
    add()
}
else{
    println("Pin Verified Successfully")
}
println("Enter the Amount to Deposit")
var FirstDeposit= readLine()!!.toDouble()
atmarray.add(ATM(Name,Pin,FirstDeposit ))
mainmenu()
}

fun login(){
println("Enter your Account Name")
var AcName=readLine()!!.toString()
println("Enter your 4-digit Account Pin")
var AcPin= readLine()!!.toInt()
// Need help here how to verify login by accessing atmarray class
}

fun Exit(){
println("GOOD BYE VALUEABLE CUSTOMER")
mainmenu()
}

    var allData: List&lt;ResponseData&gt;

    FileInputStream(dataPath).use { input -&gt;
        // allData is initialized here
        allData = ResponseData.parse(input)
    }

    // Kotlin can't tell that allData was initialized
    useAllData(allData)

use
useAllData
use
with
class Main {
    companion object {

        @JvmStatic
        fun main(args: Array&lt;String&gt;) {

            GlobalScope.run {
                launch {
                    FetchMovies().execute(7)
                }
            }
        }
    }
} 

apply plugin: 'application'

mainClassName = 'br.com.alessi.parser.main.Main'

// optional:  add one string per argument you want as the default JVM args
applicationDefaultJvmArgs = ["-Xms512m", "-Xmx1g"]

$ ./gradlew run
val job = GlobalScope.run {
                launch {
                    FetchMovies().execute(7)
                }
            }

            job.join()

1   -&gt; A
45  -&gt; A
88  -&gt; R
98  -&gt; X
105 -&gt; A

A
// Version 1
myMap.forEach { key, value -&gt; if (value == "A") myMap.remove(key) }

// Version 2
with (myMap) {
    val filtered = filterValues { it != "A" }
    clear()
    putAll(filtered)
}

Map&lt;String, Double&gt;
Map&lt;String, String&gt;
Map&lt;Result, Double&gt;
Result
abstract class ScriptResult {
    void ifSuccess(Consumer&lt;Object&gt; block) {
    }

    void ifError(Consumer&lt;Throwable&gt; block) {
    }

    static class Success extends ScriptResult {
        private final Object returnValue;

        Success(Object returnValue) {
            this.returnValue = returnValue;
        }

        @Override
        void ifSuccess(Consumer&lt;Object&gt; block) {
            block.accept(returnValue);
        }
    }

    static class Error extends ScriptResult {
        private final Throwable throwable;

        Error(Throwable throwable) {
            this.throwable = throwable;
        }

        @Override
        void ifError(Consumer&lt;Throwable&gt; block) {
            block.accept(throwable);
        }
    }
}

private lateinit var scriptResult: ScriptResult

inline fun &lt;reified T : Throwable&gt; shouldHaveThrown(): T {
    scriptResult.ifSuccess { result -&gt;
        fail("should have thrown ${T::class.java.name}, but returned `$result´")
    }
    lateinit var holder: T // (1)
    scriptResult.ifError { throwable -&gt;
        if (throwable is T) {
            holder = throwable // (2)
        } else {
            fail("expected ${T::class.java.name} to be thrown, but threw `$throwable´")
        }
    }
    return holder // (3)
}

    val thrown = execution.shouldHaveThrown&lt;MissingMethodException&gt;()
    assertThat(thrown.message).contains("missedMethod")

throwable
shouldHaveThrown
idCounter++

idCounter@OuterClass++

idCounter++@OuterClass

src/resources/
pairs_ids.txt
key=value

open class AppStarter : Application&lt;AppConfig&gt;() {
    override fun getName() = "stats"

    override fun run(configuration: AppConfig?, environment: Environment?) {
        val logger = LoggerFactory.getLogger(this::class.java)

        val inputStream = javaClass.getResourceAsStream("/pairs_ids.txt")
        val isr = InputStreamReader(inputStream)
        val br = BufferedReader(isr)
        for (line in br.lines()) {
            logger.info("current_line = " + line)
        }
        br.close()
        isr.close()
        inputStream.close()
    }
}

fun main(args: Array&lt;String&gt;) {
    AppStarter().run(*args)
}

val tripList: List&lt;Trip&gt;
data class Trip(
       val driver: Driver,
       val passengers: Set&lt;Passenger&gt;,
       // the trip duration in minutes
       val duration: Int,
       // the trip distance in km
       val distance: Double,
       // the percentage of discount (in 0.0..1.0 if not null)
       val discount: Double? = null
){// the total cost of the trip
    val cost: Double
    get() = (1 - (discount ?: 0.0)) * (duration + distance)}

trip.cost
tripList
                }
                view.id == R.id.tvPlay -&gt; {
                    val fileName = Helper.getFileName(dataList[position].ayatAudioPath)
                    playAyat(Helper.getFileName("$localStoragePath$fileName"))
                    dataList[position].isPlayingAudio = true
                    parahSurahDetailAdapter.notifyDataSetChanged()

                    mediaPlayer.setOnCompletionListener(object :
                        MediaPlayer.OnCompletionListener {
                        override fun onCompletion(mp: MediaPlayer?) {
                            dataList[position].isPlayingAudio = false
                            parahSurahDetailAdapter.notifyDataSetChanged()
                        }
                    })
                }
                view.id == R.id.tvPause -&gt; {
                    if (!mediaPlayer.isPlaying) {
                        mediaPlayer.start()
                    }
                    mediaPlayer.pause()
                    dataList[position].isPlayingAudio = false
                    parahSurahDetailAdapter.notifyDataSetChanged()
                    mediaPlayer.setOnCompletionListener(object :
                        MediaPlayer.OnCompletionListener {
                        override fun onCompletion(mp: MediaPlayer?) {
                            dataList[position].isPlayingAudio = true
                            parahSurahDetailAdapter.notifyDataSetChanged()
                        }
                    })
                }
            }
        }
    })

calculateWeight(150.0).toString().toDouble()
}
fun calculateWeight(bodyWeight: Double) {
    val mercury = bodyWeight * 0.38
    val venus = bodyWeight * 0.91
    val earth = bodyWeight * 1.00
    val mars = bodyWeight * 0.38
    val jupiter = bodyWeight * 2.34
    val saturn = bodyWeight * 1.06
    val uranus = bodyWeight * 0.92
    val neptune = bodyWeight * 1.19
    val pluto = bodyWeight * 0.06

    println("My body weight is $bodyWeight pounds and on the different planets it equals:\n" +
                "Mercury: $mercury, \nVenus: $venus, \nEarth: $earth, " +
                "\nMars: $mars, \nJupiter: $jupiter, \nSaturn: $saturn, \nUranus: $uranus," +
                "\nNeptune: $neptune, \nPluto: $pluto")

val t1 = 23.0
print (t1!!.pow(4.9))
print (Math.pow(t1,4.0))
import kotlin.math.pow
print (t1.pow(4.9))
import kotlin.Math.pow
pow
t1.math.pow(2.3)
C:\tmp&gt;type Main.kt
import java.nio.file.Files
import java.nio.file.Paths

fun main() {
    Files.lines(Paths.get("t.txt"))
            .use { lines -&gt; lines.forEach { println(it) } }
}

C:\tmp&gt;kotlinc -version
info: kotlinc-jvm 1.3.11 (JRE 1.8.0_192-b12)

C:\tmp&gt;kotlinc Main.kt
Main.kt:6:14: error: unresolved reference. None of the following candidates is applicable because of receiver type mismatch:
@InlineOnly public inline fun &lt;T : Closeable?, R&gt; ???.use(block: (???) -&gt; ???): ??? defined in kotlin.io
            .use { lines -&gt; lines.forEach { println(it) } }
             ^
Main.kt:6:20: error: cannot infer a type for this parameter. Please specify it explicitly.
            .use { lines -&gt; lines.forEach { println(it) } }
                   ^
Main.kt:6:35: error: cannot choose among the following candidates without completing type inference:
@HidesMembers public inline fun &lt;T&gt; Iterable&lt;???&gt;.forEach(action: (???) -&gt; Unit): Unit defined in kotlin.collections
@HidesMembers public inline fun &lt;K, V&gt; Map&lt;out ???, ???&gt;.forEach(action: (Map.Entry&lt;???, ???&gt;) -&gt; Unit): Unit defined in kotlin.collections
            .use { lines -&gt; lines.forEach { println(it) } }
                                  ^
Main.kt:6:53: error: unresolved reference: it
            .use { lines -&gt; lines.forEach { println(it) } }
                                                    ^

C:\tmp&gt;

fun &lt;T&gt; safe(t: T?): T {
    return Optional.ofNullable(t).orElseThrow { IllegalStateException("safe value should not be null") }
}

class SomeType(val someOtherType: SomeOtherType?)

someOtherType
class SomeThirdType(val someOtherType: SomeOtherType)

SomeType
class SomeType(val someOtherType: SomeOtherType?) {
  fun doSomeDamage(): SomeThirdType {
    //some work
    return SomeThirdType(safe(someOtherType))
  }
}

safe
class CustomList&lt;T&gt;(private val data: ArrayList&lt;T&gt; = ArrayList&lt;T&gt;()) : List&lt;T&gt; by data

CustomList
class CustomList&lt;T&gt; : List&lt;T&gt; by data { 
    private val data = ArrayList&lt;T&gt;()
}

data
Factory
Factory2
data class Car(val horsepowers: Int) {
companion object Factory {
    val cars = mutableListOf&lt;Car&gt;()

    fun makeCar(horsepowers: Int): Car {
        val car = Car(horsepowers)
        cars.add(car)
        return car
    }
}
object Factory2 {
    val cars = mutableListOf&lt;Car&gt;()
    fun makeCar(horsepowers: Int): Car {
        val car = Car(horsepowers)
        cars.add(car)
        return car
    }
}
}

"Failed to resolve: org.jetbrains.kotlin:kotlin-stdlib-jre7..."

var list = File("src/resources/words_threeLetters.txt").readText()

print(list)
[aaa, aah, aal, aam, aas, aba, abb, abc, abd . . . etc

print(list[0])
print(list[1])
mutableListOf&lt;String&gt;()
list
mutableListOf&lt;String&gt;
mutableListOf&lt;Char&gt;
val toRemove = min(preferredQuantity - taken, stock.quantity) 

class BindableTextInputEditText : TextInputEditText {

    constructor(context: Context) : super(context)
    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs)
    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr)

    fun bind() {
        setTextAndCursor(text)
    }

    private fun TextInputEditText.setTextAndCursor(text: String?) {

    }
}

class Test {
  val A: Car
  val B: Truck

  init {
    (A, B) = returnCarAndTruck()
  }

  fun returnCarAndTruck() = Pair(Car(), Truck())
}


override fun onCreate(savedInstanceState: Bundle?) {
      super.onCreate(savedInstanceState)
      setContentView(R.layout.activity_main)  

      val b: String?  = "hello"
      val l = b?.length ?: -1
 }

   override fun onCreate(savedInstanceState: Bundle?) {
      super.onCreate(savedInstanceState)
      setContentView(R.layout.activity_main)

      val b: String?  = "hello"
      val l = b?.length ?: return -1

    }

 fun getLength(b: String?): Int {
        val l = b?.length ?: return -1       
        return l
    }

this
(this@run as String).equals("")
fun main(args: Array&lt;String&gt;) {
    "".run  {
        1.0.run {
            (this@run as String).equals("")
        }
    }
}

package com.example.dagger.kotlin.ui
class HomeActivity : DemoActivity() {
    @Inject
    lateinit var locationManager: LocationManager

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        (application as DemoApplication).component.inject(this)

        // TODO Do something with the injected dependencies here
        locationInfo.text = "Injected LocationManager:\n$locationManager"


        Toast.makeText(this, b, Toast.LENGTH_LONG).show();

    }



}

package com.example.dagger.kotlin.ui
var  b="New Girl"

enum class Color(val rgb: Int) {
        RED(0xFF0000),
        ORANGE(0xffa500),
        YELLOW(0xffff00),
        GREEN(0x00FF00),
        BLUE(0x0000FF),
        INDIGO(0x4b0082),
        VIOLET(0x8F5E99)
}
fun getHexColor (Color: Enum)
{
    when(x){
        Color.BLUE -&gt; println("Battle")
        else -&gt; print("otherwise")
    }

}

One type argument expected for class Enum&lt;E: Enum&lt;E&gt;&gt;

private var firstTime: Boolean = true
...

    if (firstTime) {
        // do something for the first time here
        firstTime = false
    }

if (firstTime.checkAndUnset()) {
    // do something for the first time here
}

data class precioSuper(var producto:String, var precio: Int, val codigoDeBarras:String)

fun main(args: Array&lt;String&gt;) {
    //Qué vende o super?
    val galletas = precioSuper("galletas", 3, "0001")
    val chocolate = precioSuper("chocolate", 5, "0002")
    val leite = precioSuper("leite", 2, "0003")

    var productos = arrayListOf&lt;String&gt;("galletas", "chocolate", "leite")

    var totalProductos = productos.size
    var codigoDeBarras2 = for(producto in totalProductos)

}

abstract class Wrapper&lt;T&gt;
class StringWrapper : Wrapper&lt;String&gt;()

fun &lt;O, P&gt; wrap(property: KProperty1&lt;O, P&gt;, wrapper: Wrapper&lt;P&gt;) {

}

wrap
data class NonNullableExample(val value: String)
wrap(NonNullableExample::value, StringWrapper())

wrap
P
StringWrapper
data class NullableExample(val value: String?)
wrap(NullableExample::value, StringWrapper())

P
fun &lt;O, P&gt; wrap(property: KProperty1&lt;O, P&gt;, wrapper: Wrapper&lt;P&gt;): Unit
(KProperty1&lt;NullableExample, String&gt;, Wrapper&lt;String&gt;)
(KProperty1&lt;NullableExample, String?&gt;, Wrapper&lt;String?&gt;)
(KProperty1&lt;NullableExample, String?&gt;, StringWrapper)
P
P
Wrapper&lt;P&gt;
P
class Foo private constructor(private val arg1: Any) {
    //more code here..
    companion object {
        fun newFoo(arg1: Any) = Foo(arg1 = arg1)
    }
}

class Foo(private val arg1: Any) {
    //more code here..
}

throw Error("Code not yet implemented")

// Using Apply to insert another entry : 

fun getParamsUsingApply(): HashMap&lt;String, String&gt; {
    return getBasicParams().apply { KEY to ANOTHER_VALUE }
}


// Using also to insert another entry :  

fun getParamsUsingAlso(): HashMap&lt;String, String&gt; {
    return getBasicParams().also { KEY to ANOTHER_VALUE }
}

enum class Enum(val someValue: Int, val someMethod: () -&gt; Unit)
{
    FIRST_VALUE(0, {method0()}),
    SECOND_VALUE(1, {method1()})

    fun method0() {

    }

    fun method1() {

    }
}

method0()
method1()
Unresolved reference: method0
data class Somebody(var id: String, var created: Date, var address1: String, var address2: String,
                         var city: String, var county: String, var hitCount: Integer, var lat: Double,
                         var lon: Double, var lookupSuccessful: Boolean, var name: String,
                         var neghiborhood: String, var partialMatch: Boolean, var searchedAddress: String,
                         var state: String, var zip4: String, var zip5: String, var active: Boolean,
                         var instructions: String, var  maxValue: Integer) {

}

@Configuration
import android.os.Bundle
import android.widget.Button
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
class MainActivity: AppCompatActivity(){
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        val etOutput = findViewById&lt;TextView&gt;(R.id.textView2)//Natural numbers are displayed
        val but1 = findViewById&lt;Button&gt;(R.id.But1)//When click on the button "Generator" in first TextView
        but1.setOnClickListener {
            val t = Routines.gen()
            etOutput.text = ("Array of natural numbers:  $t")
        }
        val etEven = findViewById&lt;TextView&gt;(R.id.textView3)//Even numbers are displayed
        val but2 = findViewById&lt;Button&gt;(R.id.But2)// When click on the button "Result" in second TextView
        but2.setOnClickListener{
            val f =Routines.res() //error here
            etEven.text = ("Even numbers:  $f")
        }
    }
}

import kotlin.random.Random
@Suppress("UNUSED_PARAMETER")
object Routines {
    fun gen(): List&lt;Int&gt; = List(10) { Random.nextInt(1, 100) }
    fun res(its:List&lt;Int&gt;): List&lt;Int&gt;{
        val a = gen()
        val b = res(a)
        return b.filter {it%2==0}
        }
}

enum class Section(val position: Int, val textKey: Int, val fragment: Fragment) {

    GUIDE(0, R.string.main_pager_guide, QotGuideFragment()),
    LEARN(1, R.string.main_pager_learn, QotLearnFragment()),
    ME(2, R.string.main_pager_me, QotToBeVisionFragment()),
    PREPARE(3, R.string.main_pager_prepare, QotPrepareFragment()),
    ;
}

data class
object
val leadDetails = AddLeadDetails(AgentId = agent.UserId,
                Name = leadUserName.text.toString().trim(),
                MobileNo = leadMobileNumber.text.toString().trim(),
                ProductType = productTypeId,
                LoanType = productTypeItem,
                ApplicationStatus = //if condition to put value i.e if(string == "s") "One value" else "Second Value"
                Amount = productAmountText.text.toString().trim(),
                Pincode = pinCodeText.text.toString().trim(),
                Remarks = customerRemarks.text.toString().trim(),
                Type = referType!!)

ApplicationStatus
if
val view : View = LayoutInflater.from(context,this).inflate(R.layout.arr_list,parent,false)
class fragment_Arr :Fragment(), View.OnClickListener {
        override fun onClick(v: View?) {
    //        val intent = Intent(context, FlightsArrbefor::class.java)
    //        context!!.startActivity(intent)
        }


        override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
            val view = inflater.inflate(R.layout.fragment_arrivel,container,false)


            val url = "xxxxxxxx/airport.json?code=BGW"
            Arr().execute(url)

            return view
        }
        inner class Arr : AsyncTask&lt;String, String, String&gt;(){



            override fun onPreExecute() {
                super.onPreExecute()



            }

            //        for build connection
            override fun doInBackground(vararg url: String?): String{

                var text : String
                val connection = URL(url[0]).openConnection() as HttpURLConnection

                try {
                    connection.connect()
                    text = connection.inputStream.use { it.reader().use{reader -&gt; reader.readText()} }


                } finally{

                    connection.disconnect()

                }
                return text
            }

            override fun onPostExecute(result: String?) {

                super.onPostExecute(result)
                handleJson(result)


            }

            override fun onProgressUpdate(vararg text: String?) {


            }
            @SuppressLint("WrongViewCast")
            private fun handleJson (jsonString: String?) {

                val jsonObj = JSONObject(jsonString)
                val result = jsonObj.getJSONObject("result")
                val response = result.getJSONObject("respe")
                val airport = response.getJSONObject("airport")
                val pluginData = airport.getJSONObject("Data")
                val schedule = pluginData.getJSONObject("schedule")
                val arrivals = schedule.getJSONObject("arrivals")

    //        val data = arrivals.getJSONObject("data")
                val jsonArray = JSONArray(arrivals.get("data").toString())

                val list = ArrayList&lt;FlightShdu&gt;()
                var x = 0
                while (x &lt; jsonArray.length()) {

                    val jsonObject = jsonArray.getJSONObject(x)



                    list.add(
                        FlightShdu(
                            jsonObject.getJSONObject("flight").getJSONObject("identification").getJSONObject("number").getString("default"),
                            jsonObject.getJSONObject("flight").getJSONObject("airline").getString("short"),
                            jsonObject.getJSONObject("flight").getJSONObject("status").getJSONObject("generic").getJSONObject("status" )

                        )
                    )


                    x++
                }
                list.forEach(::println)

                var adapter = ListAdapteArr(this@MainActivity, list)
                flight_arrivel_list.adapter = adapter




            }

        }

class ListAdapteArr (val context: fragment_Arr, var list: ArrayList&lt;FlightShdu&gt;): BaseAdapter() {

    @SuppressLint("ViewHolder", "NewApi")
    override fun getView(p0: Int, convertView: View?, parent: ViewGroup?): View {

        val view : View = LayoutInflater.from(context,this).inflate(R.layout.arr_list,parent,false)

           val list = list[p0]

        val code = view.findViewById(R.id.code_id) as AppCompatTextView

        view.callsign_id.text=list.Callsign
        view.airline_id.text=list.Airline
        code.text = list.code


        view.setOnClickListener {

            val intent = Intent(context, FlightDeatilasArr::class.java)

            intent.putExtra("Stauts",list.Stauts!!)
            intent.putExtra("Callsign",list.Callsign!!)
            intent.putExtra("Airline",list.Airline!!)

            context!!.startActivity(intent)
        }











    }

    private fun getDateTime(s: String): String? {
        try {
            val sdf = SimpleDateFormat("EE, MMM d KK:mm a")
            val netDate = Date(s.toLong() * 1000)
            return sdf.format(netDate)
        } catch (e: Exception) {
            return e.toString()

        }
    }

    override fun getItem(p0: Int): Any {
        return list [p0]
    }

    override fun getItemId(p0: Int): Long {
        return p0.toLong()
    }

    override fun getCount(): Int {
        return list.size
    }



}

 var x: Int = 0
 var y: Int = 0
 editText1.addTextChangedListener(object : TextWatcher {
        override fun afterTextChanged(s: Editable?) {
        }
        override fun beforeTextChanged(
            s: CharSequence?,
            start: Int,
            count: Int,
            after: Int
        ) {
        }
        override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
            y= y+1
            if (editText.text.length &lt; 8 &amp;&amp; x &gt; 6) {
                editText.error = "Number Should Have At Least 8 Digits"
            }
            }
    })
   editText.addTextChangedListener(object : TextWatcher {
        override fun afterTextChanged(s: Editable?) {
        }
        override fun beforeTextChanged(
            s: CharSequence?,
            start: Int,
            count: Int,
            after: Int
        ) {
        }
        override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
            x = x+1
            if (editText.text.length &lt; 6 &amp;&amp; y &gt; 8) {
                editText.error = "Password Needs To Be 6 Characters"
                login.isEnabled = false
            }

            }
        }
    })

fun addAttributes(vararg attributes: String) {
  ...
}

attributes
val atts = arrayOf("1", "2", "3")
addAttributes(atts)

enum class Player { PLAYER, COMPUTER }

interface BoardCell {
    val x: Int
    val y: Int
    var player: Player?
}

data class Cell(val x: Int, val y: Int, var player: Player?, var value: Int)
data class BoardCellClass(override val x: Int, override val y: Int, override var player: Player?) : BoardCell
data class Request(val board: MutableList&lt;MutableList&lt;BoardCellClass&gt;&gt;? = null, val occupied: MutableList&lt;BoardCellClass&gt;? = null)

class AI(board: MutableList&lt;MutableList&lt;BoardCell&gt;&gt;, private var occupied: MutableList&lt;BoardCell&gt;) {
    private var board: MutableList&lt;MutableList&lt;Cell&gt;&gt; = board.map { it.map { Cell(it.x, it.y, it.player, 0) } .toMutableList() } .toMutableList()
}

// in main

val request = call.receive&lt;Request&gt;()

if (request.board == null || request.occupied == null) {
    // respond with 403
} else {
    val ai = AI(request.board, request.occupied) // Kotlin: Type mismatch: inferred type is MutableList&lt;MutableList&lt;BoardCellClass&gt;&gt;? but MutableList&lt;MutableList&lt;BoardCell&gt;&gt; was expected
                                                 // Kotlin: Type mismatch: inferred type is MutableList&lt;BoardCellClass&gt;? but MutableList&lt;BoardCell&gt; was expected
}

MutableList&lt;MutableList&lt;BoardCellClass&gt;&gt;?
MutableList&lt;MutableList&lt;BoardCellClass&gt;&gt;
MutableList&lt;MutableList&lt;BoardCellClass&gt;&gt;
MutableList&lt;MutableList&lt;BoardCell&gt;&gt;
when
seal class
T
sealed class State
object Empty : State()
class Load&lt;T&gt;(val presentable: Presentable&lt;T&gt;) : State()
class Data&lt;T&gt;(val presentable: Presentable&lt;T&gt;) : State()

class LoadableContentController&lt;T&gt;(
        private val presenter: LoadableContentPresenter&lt;T&gt;) {

    private var state: State = Empty

    fun present(content: Presentable&lt;T&gt;?) {
        this.state = if (content == null) {
            Empty
        } else {
            Data(content)
        }
        this.performSideEffects()
    }

    private fun performSideEffects() {
        when (this.state) {
            is Data&lt;*&gt; -&gt; {
                presenter.present((state as Data&lt;T&gt;).presentable)
            }
            is Load&lt;*&gt; -&gt; {
                presenter.present((state as Load&lt;T&gt;).presentable)
            }
        }
    }
}

interface LoadableContentPresenter&lt;T&gt; {
    fun present(presentable: Presentable&lt;T&gt;)
}

interface Presentable&lt;T&gt; {
    val TAG: String
    fun createView(): () -&gt; T
}

Unchecked cast: State to Load&lt;T&gt;
presenter.present((state as Load&lt;T&gt;).presentable) 

class Box&lt;T&gt;(t: T) {
    var value = t
}

abstract class SomeAdapter&lt;T, WH: SomeViewHolder&gt;(private val viewModel: SomeModel&lt;T&gt;?) {

}

fun&lt;T&gt; parse(a: Any): T = when (a) {
    is String -&gt; a
    else -&gt; false
}

user.error = "Number Should Have At Least 8 Digits"

public class LongArrayDemo {

private long[] array = new long[2];

public static void main(String[] arg){
    LongArrayReflection.Companion.test();
}
}

class LongArrayReflection {

companion object {

   public fun test() {
       val demo = LongArrayDemo()
       val field = LongArrayDemo::class.java.getDeclaredField("array")
       field.isAccessible = true
        //I want get array(long[]) value
        val array = field.get(demo) as LongArray

   }
} }

class Formatter {
    fun format(input: Number?) : String? {return number?.toString()}
    fun format(input: Number) : String {return number.toString()}
}

class Formatter {
    @Nullable String format(@Nullable Number input) : String {return number != null ? number.toString(): null;}
}

@NonNull String formatNonNull(@NonNull Number input) : String {return number.toString();}

QueryHandler
QueryHandler
handle
QueryHandler
Query
QueryHandler
Query
handle
QueryHandler
Query
Query
interface Query&lt;R&gt;

interface QueryHandler&lt;R, Q : Query&lt;R&gt;&gt; {
    fun handle(query: Q): R
    fun listenTo(): String
}

// DTOs
data class BookDto(val name: String)

// List books query
data class ListBooksQuery(val page: Int = 1): Query&lt;List&lt;BookDto&gt;&gt;

class ListBooksQueryHandler: QueryHandler&lt;List&lt;BookDto&gt;, ListBooksQuery&gt; {
    override fun handle(query: ListBooksQuery): List&lt;BookDto&gt; {
        return listOf(BookDto("Dune"), BookDto("Dune II"))
    }

    override fun listenTo(): String = ListBooksQuery::class.toString()
}

// Get book query
data class GetBookQuery(val name: String): Query&lt;BookDto?&gt;

class GetBookQueryHandler: QueryHandler&lt;BookDto?, GetBookQuery&gt; {
    override fun handle(query: GetBookQuery): BookDto {
        return BookDto("Dune")
    }

    override fun listenTo(): String = GetBookQuery::class.toString()
}

// Run it!

fun main(args: Array&lt;String&gt;) {
    // Initializing query bus
    val queryHandlers = mapOf(
        with(ListBooksQueryHandler()) {this.listenTo() to this},
        with(GetBookQueryHandler()) {this.listenTo() to this}
    )

    val command = ListBooksQuery()
    val result = queryHandlers[command::class.toString()].handle(command)

    // Should print the list of BookDto
    print(result)
}

List
QueryHandler
object WalletConfig {

    init {
        fill(HashMap&lt;String, String&gt;())
    }

    var clientUrl: String by Delegates.notNull()
        private set

    fun fill(settingMap: Map&lt;String, String&gt;) {
        try {
            clientUrl = settingMap["URL_CLIENT"] ?: ""
        } catch(ex:Exception) { }
    }
}

A.to(that: B)
Pair&lt;A,B&gt;
to
to
// following return Pair&lt;k,v&gt;
fun convert(value:K, converter: org.jooq.Converter&lt;K,V&gt;) = converter.to(value)

fun convert
inline fun &lt;T : Closeable?, R&gt; T.use(block: (T) -&gt; R): R (source)

Ratio(1, 2) == Ratio(2, 4 /* or 4, 8 */) or Ratio(2, 4 /* or 4, 8 */).numerator == 1, .denominator == 2
class Ratio(num : Int, denom : Int) {
    val numerator = num / gcd(num, denom)
    val denominator = denom / gcd(num, denom) // GCD calculated twice!
}

data class Ratio(num : Int, denom : Int) {
  val numerator : Int
  val denominator : Int

  {
    val gcd = calcGcd(num, denom)
    numerator = num / gcd
    denominator = denom / gcd
  }
}

data class Ratio(num : Int, denom : Int) {
  val numerator : Int
  val denominator : Int

  {
    val gcd = BigInteger.valueOf(num.toLong()).gcd(BigInteger.valueOf(denom.toLong())).intValue();
    numerator = num / gcd;
    denominator = denom / gcd
  }
}

data class Ratio2(val num : Int, val denom : Int)

fun main(args: Array&lt;String&gt;) {
  println("r = " + Ratio(1, 6).toString())
  println("r2 = " + Ratio2(1, 6).toString())
}

r = Ratio@4ac68d3e
r2 = Ratio2(num=1, denom=6)

jq("#element").click {
    console.log(it.target)
}

r.Event {originalEvent: MouseEvent, type: "click", target: button, currentTarget: button, relatedTarget: null…}

fun doSomething(vararg pairs: Pair&lt;String, *&gt;) {
    // Do things with the pairs
}

Pair
Pair&lt;String, CustomType1&gt;
fun doSomethingSimpler(param: Boolean) {
    // Boolean implementation
}

fun doSomethingSimpler(param: Int) {
    // Int implementation
}

// etc.

sealed class Root
class Child1 : Root()
class Child2 : Root()

fun doSomethingICanControl(param: Root) {
    // Root implementation
}

*
MyBoolean
doSomething(
    "key1" to false,
    "key2" to "value2",
    "key3" to 86
)

Pair
"blah" to 10
"save" to 20

HashMap
map.get("somethingElse")
 open header class ArrayList&lt;E&gt; : MutableList&lt;E&gt; {

 //...

 header inline fun &lt;reified T&gt; Array&lt;out T&gt;?.orEmpty(): Array&lt;out T&gt;

impl
false
map.equals(map2)
.toString()
comparison
true
map.toString().equals(map2.toString())
Kluent library
shouldEqual
values
maps
arrays
arrays
false
fail
class MapsTesting {


    class Items(name1: String, amount1: String, price1: String) {
        var name: String = name1
        var amount: String = amount1
        var price: String = price1

        override fun toString(): String {
            return "name:$name,amount:$amount,price:$price \n"
        }
    }

    @Test
    fun mapTest() {

        val mapOfItems: MutableMap&lt;String, Items&gt; = mutableMapOf()
        mapOfItems["Materials"] = Items("STEP 1", "STEP 2", "View All Stones")

        val mapOfItems2: MutableMap&lt;String, Items&gt; = mutableMapOf()
        mapOfItems2["Materials"] = Items("STEP 1", "STEP 2", "View All Stones")

        mapOfItems.forEach { t, u -&gt;
            println("map key:$t,map value:${u.toString()}")
        }

        mapOfItems2.forEach { t, u -&gt;
            println("map key:$t,map value:${u.toString()}")
        }

        val comparison : Boolean = mapOfItems.toString().equals(mapOfItems2.toString())
        //this returns true
        val comparison2 : Boolean = mapOfItems.equals(mapOfItems2)
         //this returns false
        println(comparison)
        println(comparison2)


        val map1 = mapOfItems.toString()
        val map2 = mapOfItems2.toString()
        //this returns true 
        //if I delete toString() it will return false
        map1 shouldEqual  map2
    }
}

java.lang.AssertionError: expected: java.util.LinkedHashMap&lt;{Materials=name:STEP 1,amount:STEP 2,price:View All Stones 
}&gt; but was: java.util.LinkedHashMap&lt;{Materials=name:STEP 1,amount:STEP 2,price:View All Stones 
}&gt;

class Pair&lt;T, U&gt;(var product: Product, var quantity: Int) {
    for ( (product,quantity) in productAndQuantityList) {
        println("Name: ${product.productName}")
        println("Quantity: $quantity")
    }
}

class ShoppingCart{
    private val productAndQuantityList = mutableListOf&lt;Pair&lt;Product,Int&gt; &gt;()
...
}

open class Product(
    val productName: String,
    var basePrice: Double,
    open val salesPrice: Double,
    val description: String) {
...}

private static final int JANUARY = 1
private static final int FEBRUARY = 2
...

val listNumbers = generateSequence(1) { it + 1 }
val listNumber1to100 = listNumbers.takeWhile { it &lt; 100 }
val secNum:Unit = listNumber1to100.forEach {it}

println(listNumber1to100.asSequence().filter { it%(listNumber1to100.forEach { it })!=0 }.toList())

val hashedPolicies = policyProperties.map { it.key to it.value.hash() }.toMap()

toMap()
List
.toMap()
sealedSubclasses
sealed class Person {
  abstract var name:String
     // ...
}

data class Doctor(      
  var license: String = "",   
    // ....
  override var name:String = ""
) : Person()

// ....
data class Fireman ( 
  var medals: Int=0, 
  // ....   
  override var name:String = ""
) : Person()

var p:Person = Doctor("123","Louis")
var q:Person
  // ...
Person.copy  // it is forbidden

var p:Person = Doctor("123","Louis")
var q:Person
when (p) {
is Doctor -&gt; q = p.copy()   
   // ...
is Fireman -&gt; q = p.copy()
}   

sealedSubclasses
ClassNotFoundException
javafx.scene.control.skin.BehaviorSkinBase
Project Structure
Project Settings
Project
Project Structure
Project Settings
Facets
Settings
Build, Execution, Deployment
Compiler
Kotlin Compiler
Run/Debug Configurations
override fun findBasicById(deliveryAddressId: Long): BasicDeliveryAddress? {
    val basicDeliveryAddress = findById(deliveryAddressId) as BasicDeliveryAddress? // returns a DeliveryAddress object
    return basicDeliveryAddress // Here I still get the full DeliveryAddress!
}

basicDeliveryAddress
interface BasicDeliveryAddress {
    var street: String
    // some other fields
}

data class DeliveryAddress (
        override var name: String,
        // override all other fields
) : BasicDeliveryAddress {
    var user: User? = null
}

Neversummer
Abelhaven
Phandoril
Tampa
Sanortih
Trell
Zan'tro
Hermi Hermi
Curlthistle Forest

import java.io.File

fun main() {
    var string = File("data/towns.txt")
        .readText()
        .split("\n")
        .shuffled()
        .first()
    println("$string has printed")
}

Curlthistle Forest has printed

 has printed

protected String aVariable;

public setAVariable(String aValue){
    aVariable = aValue;
}

protected var aVariable: String? = null

fun setAVariable(value: String?){
    aVariable = value
}

class Sound() {
var id: Int? = null
}

val sound = Sound()
...
//smarcat imposible becouse 'sound.id' is mutable property that
//could have changed by this time
if(sound.id != null)
    soundPool.play(sound.id, 1F, 1F, 1, 0, 1F)

//smarcat imposible becouse 'sound.id' is mutable property that
//could have changed by this time
sound.id?.let {
    soundPool.play(sound.id, 1F, 1F, 1, 0, 1F)
}

fun foo() {
    var number = 5

    val view = object : View() {
        override fun init(number: Int) {
            number = number // ERROR
        }
    )

    // do something with 'number' (and 'view')…
}

fun getOperationsList(
        vararg typesList: OperationType,
        operationStatusList: Array&lt;OperationStatus&gt;,
        from: Date, to: Date,
        callback: Callback&lt;List&lt;Operation&gt;&gt;
    ) {...}

 fun getDraftList(callback: Callback&lt;List&lt;Operation&gt;&gt;) {
        getOperationsList(
            operationStatusList = arrayOf(OperationStatus.CREATED),
            from = Date(),
            to = Date(),
            callback = callback
        )
    }

 fun getDraftList2(callback: Callback&lt;List&lt;Operation&gt;&gt;) {
        getOperationsList(operationStatusList = arrayOf(OperationStatus.CREATED), callback = callback)
    }
}

No value passed for parameter 'from' No value passed for parameter 'to'

from
to
import java.util.Scanner
fun main(args: Array&lt;String&gt;) {
    val sc: Scanner = Scanner(System.`in`)
    var a = sc.nextInt()
    var max= 0.0
    var min= 0.0
    var avg = 0.0
    if(a.equals(0)){
       println(String.format("%.6f %.6f %.6f",max,min,avg))
    }else{
        val numbers = readLine()!!.split(" ").map{ it.toDouble() }
        println(String.format("%.6f %.6f %.6f",numbers.max(),numbers.min(),numbers.sum()/a))
    }

}

4
1.0 2.0 3.0 4.0

4\n1.0 2.0 3.0 4.0

 Exception in thread "main" java.util.InputMismatchException
            at java.base/java.util.Scanner.throwFor(Scanner.java:939)
            at java.base/java.util.Scanner.next(Scanner.java:1594)
            at java.base/java.util.Scanner.nextInt(Scanner.java:2258)
            at java.base/java.util.Scanner.nextInt(Scanner.java:2212)
            at MainKt.main(main.kt:4)

a
"abc"
null
val params: MutableMap&lt;String, Any&gt; = mutableMapOf()
params["abc"] = 10.4

println("${params["abc"]}")         // prints "10.4"

val a: Any? = params["abc"]

println(a)                          // prints "null"
println(params["abc"] is Double)    // prints "true"

.kts
val params: MutableMap&lt;String, Any&gt; = mutableMapOf("abc" to 10.4)
     data class classA (
      field1
      field2
      ....
       classBlst:List&lt;classB&gt;
      )

      data class classB (
       field3
       field4
       ...
      dateField:String
      )

TextWatcher
val StartFragment.textWatcher: TextWatcher
    get() = object : TextWatcher {
        override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
            searchPlaces(s)
        }

        override fun afterTextChanged(s: Editable?) {}
        override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
    }

searchPlaces(s)
changeData.firstname?.let { updatedUser.firstname = it }
changeData.lastname?.let { updatedUser.lastname = it }
...

updatedUser.copy( 
    firstname = changeData?.firstname,  
    lastname = changeData?.lastname, 
    ...)

C
A
B
C
interface A
interface B

class C: A, B

fun &lt;T&gt; foo(bar: T) where T: A, T: B {

}

A
B
val c = C()
foo(c) // works

val d: Any = c
if (d is A &amp;&amp; d is B) {
    foo(d) // smart cast doesn't work here, compiler error
}

// Something like this maybe?
foo(d as A &amp;&amp; B)

A
B
@Test
fun `should do "something"`() {
    // ...
}

'
"
my.framework
import my.framework.*
kotlin.collections
kotlin.text
val visibility = if (itemView.img_playstore.visibility == View.VISIBLE)  View.GONE else View.VISIBLE

val visibility : Int = itemView.img_playstore.visibility == View.VISIBLE ?  View.GONE : View.VISIBLE

fun &lt;P&gt;onChange(oldObj: P, newObj: P, select: (P) -&gt; Any, handler: (P) -&gt; Unit) {
   val newValues = select(newObj)
   val oldValues = select(oldObj)
   if (oldValues != newValues) { handler(newObj) }
}

data class TestObj(
    val foo: String,
    val bar: String? = null
)

val oldObj = TestObj(foo = "foo")
val newObj = TestObj(foo = "foo1", bar = "bar")

onChange(oldObj, newObj, { it.foo }) {
    print("foo did change: ${it.foo}")
}

bar
fun &lt;P&gt;onChange(oldObj: P, newObj: P, select: (P) -&gt; Any?, handler: (P) -&gt; Unit) {
...
}

Duplicate method name&amp;signature
select
override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent) {
        AppLog.dMethodIn()
        super.onActivityResult(requestCode, resultCode, data)
        if (REQUEST_CODE_SCAN != requestCode) {
            AppLog.w("Unknown request code : $requestCode")
            return
        }
        if (BleScanActivity.RESPONSE_CODE_CONNECT != resultCode) {
            return
        }

        val discoverPeripheral = data.getParcelableExtra&lt;DiscoverPeripheral?&gt;(BleScanActivity.EXTRA_CONNECT_REQUEST_PERIPHERAL)
        if (null == discoverPeripheral) {
            AppLog.e("null == discoverPeripheral")
            return
        }

        initDeviceInfoView()
        initConnectionView()

        onConnect(discoverPeripheral)
    }

private val eventListeners = mutableListOf&lt;IEventInterface&gt;() // List filled somewhere else!

private fun sendConnectionEvent(dummyString: String) {
    val deadListeners = mutableListOf&lt;IEventInterface&gt;()

    eventListeners.forEach {
        try {
            it.onConnectionEvent(dummyString)
        } catch (e: DeadObjectException) {
            Log.d(TAG, "Removing listener - Exception ${e.message}")
            deadListeners.add(it)
        }
    }

    deadListeners.forEach { it -&gt;
        eventListeners.remove(it)
    }
}

private fun sendWonderfulEvent(dummyString: String, dummyInt: Int) {
    val deadListeners = mutableListOf&lt;IEventInterface&gt;()

    eventListeners.forEach {
        try {
            it.onWonderfulEvent(dummyString, dummyInt)
        } catch (e: DeadObjectException) {
            Log.d(TAG, "Removing listener - Exception ${e.message}")
            deadListeners.add(it)
        }
    }

    deadListeners.forEach { it -&gt;
        eventListeners.remove(it)
    }
}

totalFee
daysRented
if (daysRented &lt;= 10){
    if(insPolicy == true){
       val totalFee = (shortTermRate * daysRented) + (insRate * daysRented)
    }
    else{
        val totalFee = shortTermRate * daysRented
    }
}
else{
    if(insPolicy == true){
        val totalFee = (longTermRate * daysRented) + (insRate * daysRented)
    }
    else{
        val totalFee = longTermRate * daysRented
    }
}
println("Rental fee: $totalFee")

The initializer, getter and setter are optional. Property type is optional
if it can be inferred from the initializer or from the base class member being overridden.

Examples:
var allByDefault: Int? // error: explicit initializer required, default 
getter and setter implied

typealias Handler = (cmd: String, obj: Any?) -&gt; Any?

fun doSomething(cmd: String, obj: Any?): Any? {...}

fun addHandler(name: String, handler: Handler) {...}

fun foo() {
    addHandler("doSomething", { cmd, obj -&gt; doSomething(cmd, obj) })
    // or in other syntax
    addHandler("doSomething") { cmd, obj -&gt; doSomething(cmd, obj) }
}

{ cmd, obj -&gt; doSomething(cmd, obj) }

null
!!
private fun stuff() {
    var possibleNull: String? = "test"
    if (testNull(possibleNull)) {
        mustPassNonNull(possibleNull)
    }
}

private fun mustPassNonNull(possibleNull: String) {
    //use value that isn't null
}

private fun testNull(possibleNull: String?): Boolean {
    return possibleNull != null
}

testNull
true
possibleNull
null
if
mustPassNonNull
!!
class test{
     infix fun equalsTen(value:Int):Boolean = value.equals(10)
}

fun doSomething(value: Int){
    val testClazz = test()
    if(testClazz equalsTen value){//line 3
        //do something
    }
}

if(testClazz.equalsTen(value)){...}
if(!testClazz.equalsTen(value)){...}
enum class MediaType() {
    AUDIO,
    VIDEO,
    ARTICLE;
}

var mediaType = MediaType.AUDIO
var text = mediaType.toText() // returns the string "MP3"

mediaType = MediaType.VIDEO
text = mediaType.toText() // returns the string "mpeg"

String
0
fun formatDuration(val duration):String {
    val minutes = duration.toInt() / 60
    return  "$minutes"
}

minutes
06
6
m.getColumns(*((count.. count + 35).toList().toIntArray()))

it.javaClass.typeName
it.javaClass.kotlin
KClassImpl
    fun getBitmap(id: Int): Bitmap{
        if (!(id in bitmapStorage))
            bitmapStorage.put(id, BitmapFactory.decodeResource(resources, id))
        return bitmapStorage.get(id)
    }

Bitmap
Bitmap?
!!
as Bitmap
.first
.second
typealias PlayerPair&lt;A&gt; = Pair&lt;A, A&gt;

enum class PlayerNumber {
    One,
    Two
}

myPair[Player.One]

operator fun PlayerPair.get(i: PlayerNumber) = when (i) {
    PlayerNumber.One -&gt; PlayerPair.first
    PlayerNumber.Two -&gt; PlayerPair.sexond
}

package io.shido.learning

import java.time.Instant

fun typeCheck(any: Any): Any = when (any) {
  (any is Int &amp;&amp; any &lt; 10) -&gt; "(small) integer"
  is Int -&gt; "integer"
  is Double -&gt; "double"
  is String -&gt; "string"
  else -&gt; "another Any"
}

fun main(args: Array&lt;String&gt;) {
  println("type check for: 5 (${typeCheck(5)})")
  println("type check for: 20 (${typeCheck(20)})")
  println("type check for: 56.0 (${typeCheck(56.0)})")
  println("type check for: \"a string\" (${typeCheck("a string")})")
  println("type check for: Instant (${typeCheck(Instant.now())})")
}

typeCheck(5)
(small) integer
integer
true
5
val list = mutableListOf("1", "2", "3")

val listOfLists = mutableListOf(list, list, list)

val firstList = listOfLists[0]     //get reference to *list* variable

firstList[0] = "Hello"            // replace "1" in firstList with "Hello"

print(listOfLists)

[[Hello, 2, 3], [Hello, 2, 3], [Hello, 2, 3]]

listOfLists
firstList
while(n &gt; 0) {
    if(sibice[i].first &gt; 0) {
        sum += sibice[i].second
        //sibice[i].first-- will not compile
        n--
    } else i++
}

timer.schedule(1000) {
    println("hello world!")
}

C:\Users\User\Desktop&gt;java _DefaultPackage

Exception in thread "main" java.lang.NoClassDefFoundError: jet/runtime/Intrinsics
    at _DefaultPackage.main(Finder.kt)
Caused by: java.lang.ClassNotFoundException: jet.runtime.Intrinsics
    at java.net.URLClassLoader$1.run(URLClassLoader.java:366)
    at java.net.URLClassLoader$1.run(URLClassLoader.java:355)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.net.URLClassLoader.findClass(URLClassLoader.java:354)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:423)
    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:356)
    ... 1 more

C:\Users\User\Desktop&gt;java -cp kotlin-runtime.jar _DefaultPackage

Error: Could not find or load main class _DefaultPackage

C:\Users\User\Desktop&gt;java -cp kotlin-runtime.jar';_DefaultPackage.class _DefaultPackage

Error: Could not find or load main class _DefaultPackage

listAccounts.forEachIndexed { index, account -&gt;
    if (idParamether == account.id) {
        listAccounts.remove(account)
    }
}

foo?.let{
        if(!foo.isBlank()) {
            bar?.let { 
                if(!bar.isBlank()) {
                    println("foo and bar both valid strings")
                }
            }
        }
    }

if(foo.isNullOrEmpty &amp;&amp; !bar.isNullOrEmpty)
for (b in buf.sliceArray(0 until bufLimit).reversedArray()) {}

sliceArray
reversedArray
for (bIdx in bufLimit - 1 downTo 0) {
    val b = buf[bIdx]
}

var scoreView: TextView? = null
val bgImageView: ImageView? = null

fun foo() { 
    scoreView?.apply {
       text = getScore()
       textColor = getColor()
       ...
    }

    bgImageView?.apply {
        Glide.with(context)
             .load(xxx)
             .into(this)
    }
}

fun foo() {
    scoreView?.text = getScore()
    scoreView?.textColor = getColor()
    ...
    Glide.with(context)
         .load(xxx)
         .into(bgImageView?:return)
}

class Foo {
    fun bar() : Int {
        fun a() : Int {
            // Do a load of stuff
            return 1
        }
        fun b() : Int {
            // Do a load of stuff
            return 1
        }

        return a() + b()
    }
}

class Foo {
    fun bar() : Int {
        return a() + b()
    }

    private fun a() : Int {
        // Do a load of stuff
        return 1
    }

    private fun b() : Int {
        // Do a load of stuff
        return 1
    }
}

private lateinit var socket = Option.None 

socket = socket.map {
    selectedDevice.createRfcommSocketToServiceRecord(MY_UUID).apply {
    connect()
    }
}

Option.None

private lateinit var socket: Option&lt;BluetoothSocket&gt; = Option.None    

Option&lt;Nothing&gt;

Option&lt;BluetoothSocket&gt;

private var user:User?= null// this is put directly inside the file
fun saveMe(user: User?){
    saveObject(user, USER_FILE)
    FileStorage.user = user// this method is not allowed. How to access the top level user variable from here?
}

var a=[[1, 0], [0, 1]]

var a: Array&lt;Array&lt;Int&gt;&gt; = [[1, 0], [0, 1]]

Person
class Person(val firstName: String, val lastName: String, val age: Int)

fun replaceFirstName(person: Person, newFirstName: String): Person {
    return Person(newFirstName, person.lastName, person.age)
}

val
var
fun replaceName(person: Person, newFirstName: String): Person {
    return person.copy { firstName = newFirstName }
}

val a
var aImpl = 0
val a: Int get() = aImpl

fun seta(){
    aImpl=5
}

C
inline fun
@Java
javac
fun main(args: Array&lt;String&gt;) {

   val n = readLine()!!.toInt()
   var arr = Array(n)
   for(i in 0 until n)
   {
      arr[i] = readLine()!!.toInt() //Not Working? nor does readLine()!!.split(' ').toInt()

   }
   for(item in arr.size - 1 downTo 0)
   {
      print("${item} ")
   }
}

Class&lt;Any&gt;
kaptKotlin
kaptKotlin
e: cannot find symbol
Class&lt;Any&gt;
correctErrorTypes = true
fun main() {
    // copy object in object
    data class Person (var name: String = "Orig", var type: String = "piece",
                       var age: Int = 18, var high: Double = 25.7, var code: Int = 1522)
    {
        var info: String = "0"
        get() = "Name: $name Age: $age Type: $type High: $high Code: $code"
    }
    val ann: Person = Person("Ann", "man", 10, 0.5, 1408) // 1st object with some properties
    var bob: Person = Person("Bob", "girl", 20, 15.0, 1239) // 2nd object without prop
    println(ann.info)// props 1st object
    println(bob.info)// props 2nd object
    print(" ---- ")
    bob = ann.copy() // copy 1st in 2nd
    println("Bob has Anns' props: ")
    print("final " + bob.info) // new props 2nd object
    bob.delete()

}

  private fun getIndexByIntent(data: Intent): Int{
        var index=-1
        var id=getIDByIntent(data)

        for (aIndex in mListBackupItem.indices){
            if (mListBackupItem[aIndex]._id==id){
                index=aIndex
            }
        }    
        return index
    }

private fun getIndexByIntent(data: Intent): Int{
        var index=-1
        var id=getIDByIntent(data)

        for (aIndex in mListBackupItem.indices){
            if (mListBackupItem[aIndex]._id==id){
                return aIndex
            }
        }
        return index
    }

fun main(args: Array&lt;String&gt;) {
    println(transform(readLine()!!))
}

fun transform(n: String): Int {
    var count = 0
    var sum : Int
    var s = n
    while(s.length &gt; 1) {
        sum = (0 until s.length).sumBy { s[it].toInt() - '0'.toInt() }
        s = sum.toString()
        count++
    }
    return count
}

sum = (0 until s.length).sumBy { s[it].toInt() - '0'.toInt() }
fun fun1(map: Map&lt;*, *&gt;) {
    assert(map.get("key") === map["key"])
}

fun fun2(map: Map&lt;*, *&gt;?) {
    assert(map?.get("key") === map?["key"])
}
                                  ^^^ 

        println(listOf(1, 2, 4).foldRight(0) { total, next -&gt;
            total - next
        })

    var x = ArrayList&lt;Resources &gt; 
    x.add(R.raw.cat)

fun myFun(res:Resources ){
   mp=MediaPlayer()
   mp.start(res)
 }

 private fun setCashPaymentContainer(isSelected: Boolean) {      
        if (isSelected) {
            dataBinding.cashPaymentCheckImageViewContainer.visibility = View.VISIBLE
        } else {
            dataBinding.cashPaymentCheckImageViewContainer.visibility = View.GONE
        }
    }

abstract class Abstr{
    protected abstract fun m()
}

class Child : Abstr(){
    private val subChild: Abstr = Child()

    override fun m() = subChild.m()// Error:(12, 18) Kotlin: Cannot access 'm': it is protected in 'Abstr'
}

Kotlin: Cannot access 'm': it is protected in 'Abstr'
data class Person(val name: string=""):Entity { }

open class Entity() { var id: Long=0 }

id
fun simplePresent(presentable: Presentable?) {
    when {
        presentable != null -&gt; execute(presentable)
        else -&gt; skip()
    }
}

fun execute(presentable: Presentable) { // Do something }

fun simplePresent(presentable: Presentable?) {
    when {
        hasPresentable(presentable) -&gt; execute(presentable)
        else -&gt; skip()
    }
}

fun execute(presentable: Presentable) { // Do something }
fun hasPresentable(presentable: Presentable?) = presentable != null

execute
required Presentable found Presentable?
.replace()
fun main(args: Array&lt;String&gt;) {

    var w_text = "welcome his name is John"

    println("${w_text.replace("his","here")}")
}

.replace()
if (xList.isEmpty()) {
   throw SomeException("xList was empty")
}

Number
 val file = File(data?.data.toString())
 if(file.exists()) {
     Log.d("WTF", "lastModified   " + file.lastModified())
 }

 fun getLastModifiedFromUri(contentUri: Uri, contentResolver: ContentResolver, callback: (String) -&gt; Unit) {
  contentResolver.query(contentUri, null, null, null, null)?.use {c -&gt;
     val dateMod: Long = try {
        val colDateModified = c.getColumnIndexOrThrow(DocumentsContract.Document.COLUMN_LAST_MODIFIED)
        c.moveToFirst()
        c.getLong(colDateModified)

     } catch(e: Exception) {
        0
     }

     callback(dateMod.toString())
  }

val s = listOf(1, 9)
val u = listOf(listOf(1, 2, 3), listOf(1, 4, 7), listOf(1, 5, 9))

Map&lt;Int, List&lt;List&lt;Int&gt;&gt;&gt;
s
{1=[ [1, 2, 3], [1, 4, 7], [1, 5, 9] ], 9=[ [1, 5, 9] ]}   

s.groupBy({ it }, { x -&gt; u.filter { it.contains(x) } })

{1=[[[1, 2, 3], [1, 4, 7], [1, 5, 9]]], 9=[[[1, 5, 9]]]}         

foo
return is not allowed here
fun bar( baz: () -&gt; Unit ) {

    // Empty function
}

fun foo() : Unit? {

    return null // this works fine

    bar {

        return null // shows error 'return is not allowed here'
    }
}

...

bar {

    return@bar null
}

...

Null can not be a value of a non-null type Unit
fun fn_x(x: Int, fn: (Int) -&gt; Int ):Int {
        return fn(x)
}

@Test
{
    assertEquals(3, fn_x(2, ???))
}

n-&gt;n+1
(n)-&gt;n+1
{n -&gt; n+1}
Length: 5
fun  main(args: Array&lt;String&gt;) {
var list1: MutableList&lt;Int&gt; = mutableListOf(1,2,3,4,5)
list1.add(6)
println("Length: ${list1.size}")

// Problem is in these 2 lines

var list3 = list1.subList(0,3)              // Line no. 1

list3.clear()                               // Line no. 3

list1.remove(5)

println("Length: ${list1.size}")

list1.forEach{n -&gt; println(n)}
}

Length: 6
List 3: 1
List 3: 2
List 3: 3

Length: 2
4
6

Process finished with exit code 0

immutableMap: Map&lt;String, Int&gt;
mutableMap: MutableMap&lt;String, Int&gt;
org.jetbrains.kotlin.gradle.dsl.KotlinJvmOptions

var useIR: kotlin.Boolean

-Xuse-ir

fun &lt;T : Number&gt; sqr(value: T): T {    
    return value * value
}

fun main() {
    print("${sqr(5)}")    
}

maxBy
maxWith
var myMap: Map&lt;String, Int&gt; = mutableMapOf()
// ...
var best = myMap.maxBy { ??? }

maxBy
maxWith
class|object X {
  [override] val y = Z
}

class|object X {
  [override] val y: Y
    get() = Z
}

import kotlin.jvm.JvmMultifileClass.*
kotlin.jvm.JvmMultifileClass.checkRadix(radix)

class Test(
    val test : Int
)

data class Test2 (
    val test : Int
)

fun test(map : Map&lt;String, /* compile error on Test, but accept Test2 or any other data class */&gt;) {
}

fun &lt;T: Cloneable&gt; test(map : Map&lt;String, T&gt;) {
     // test clone
     map.map { it.key.uuid to it.value.clone() } .toMap() // error on .clone() Cannot access 'clone': it is protected in 'Cloneable'
}

Cloneable
.copy()
Cloneable
val asc = Array(5, { i -&gt; (i * i).toString() })
["0", "1", "4", "9", "16"]
{ i -&gt; (i * i).toString() }
fun main() {
    var number = 8675309;
    val string = number.toString()
    println(string)
    val numbers = string.map {
        println(it)
        it.toInt()
    }
    numbers.forEach { println(it) }
}

toString()
toInt()
forEach()
number
private volatile var instanceState: InstanceState = InstanceState.starts

Error:  'Expected member declaration'

private volatile var instanceState: InstanceState = InstanceState.starts

Error:  'Property getter or setter expected'

sampleVideoView? = findViewById&lt;VideoView&gt;(R.id.videoView)
sampleVideoView?.setVideoURI(Uri.parse(HLS_STREAMING_SAMPLE))
if (sampleVideoView!=null){sampleVideoView.setVideoURI(Uri.parse(HLS_STREAMING_SAMPLE))}
    class MainActivity : AppCompatActivity(){

        private var sampleVideoView: VideoView? = null

        override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContentView(R.layout.activity_main)

            sampleVideoView = findViewById&lt;VideoView&gt;(R.id.videoView)
            sampleVideoView?.setVideoURI(Uri.parse(HLS_STREAMING_SAMPLE))
...

fun foo(p1:Int,p2:String?=null)

fun foo(p1:Int,p2:Int=0)

foo(1)
 //properties
    private String var;

    //constructor
    public SampleClass(String var){
        this.var = var;
    }

    public SampleClass(){
    }

    //getters and setters
    public String getVar(){
        return this.var;
    }
    public String setVar(String var){
        this.var = var;
    }

a = ArrayList&lt;String&gt;()
a.add("eat")
a.add("animal")
a.add("internet")

a[0] = "animal" // there is no e in animal
a[1] = "eat" // there is one e in animal
a[2] = "internet" // there is two e in internet

class Message(val int: Int, val msg:String)
class Test {
    fun test1(objList: List&lt;Any?&gt;) {
        for (i in objList.size - 1 downTo 0) {
            val item = objList.get(i)
            if (item is Message) {
                println(item)
            }
        }
    }

    fun test2(objList: List&lt;Any?&gt;) {
        for (i in objList.size - 1 downTo 0) {
            (objList.get(i) as? Message)?.let {item -&gt;
                println(item)
            }
        }
    }
}

class Normal() {

var name: String = "hallo"


companion object {
    fun printName() {
        println(name) // ERROR!!! unresolved reference name
    }
}}

isInitialized
lateinit private var localCacheBillingClient: LocalBillingDb

val inappSkuDetailsListLiveData: LiveData&lt;List&lt;AugmentedSkuDetails&gt;&gt; by lazy {
    if (::localCacheBillingClient.isInitialized == false) {
          localCacheBillingClient = LocalBillingDb.getInstance(application)
    }
     ...
}

lateinit private var localCacheBillingClient: LocalBillingDb

val inappSkuDetailsListLiveData: LiveData&lt;List&lt;AugmentedSkuDetails&gt;&gt; by lazy {
    if (localCacheBillingClient == null) {
          localCacheBillingClient = LocalBillingDb.getInstance(application)
    }
    ...
}

      if (it.records.isNotEmpty()) {
        if (it.records[0].fields.isNotEmpty()) {
          if (it.records[0].fields["lastModifiedDate"] != null) {
            RECORD_DATA_LAST_MODIFIED_DATE_FORMAT.parse(
                it.records[0].fields["lastModifiedDate"])
          } else {
            Date(0)
          }
        } else {
          Date(0)
        }
      } else {
        Date(0)
      }

readLine()
cat &gt;so.kt &lt;&lt;EOF
fun readLine():String{return "5"}
fun main() {
print("Enter an Integer value: ") 
var an_int = readLine()?.toInt()  
    println("Which readLine() -- an_int: \$an_int")
    }
EOF
kscript so.kt 
Enter an Integer value: Which readLine() -- an_int: 5

val item: Any = items[position]
item::class.java // compiler complains about "Unresolved reference: item"

fun foo(key: String, value: Int?) {
    if (value == null) {
        bar(value)
    }
}

fun bar(key: String?) {
}

foo
value
Int?
bar
String?
value
null
bar(value)
foo
bar(key)
Kotlin version 1.3.50-release-112 (JRE 1.8.0_152-b16)
fun foo(key: String, value: Int?) {
    bar(value)
}

fun bar(key: String?) {
}

k2.kt:2:9: error: type mismatch: inferred type is Int? but String? was expected
    bar(value)

val xyz = abc
ALT-ENTER
ALT-ENTER
ALT-ENTER
//noinspection
@SupressWarnings
var (start, end) = startEndDate(198502)

// intellij neither accept this ...
start, end = startEndDate(200137)

// ... nor this
(start, end) = startEndDate(200137)

internal object UNINITIALIZED_VALUE

class SynchronizedReassignableImpl&lt;out T&gt;(private val initializer: () -&gt; T,
                                          private val expiredPredicate: (T) -&gt; Boolean,
                                          lock: Any? = null) : Reassignable&lt;T&gt; {
    @Volatile
    private var _value: Any? = UNINITIALIZED_VALUE
    private val lock = lock ?: this
    override val value: T
        get() {
            if (!isExpired()) {
                @Suppress("UNCHECKED_CAST") (_value as T)
            }
            return synchronized(lock) {
                val _v2 = _value
                @Suppress("UNCHECKED_CAST")
                if (_v2 !== UNINITIALIZED_VALUE &amp;&amp; !expiredPredicate.invoke(_value as T)) {
                    _v2 as T
                } else {
                    val typedValue = initializer()
                    _value = typedValue
                    typedValue
                }
            }
        }

    @Suppress("UNCHECKED_CAST")
    override fun isExpired(): Boolean = !isInitialized() || expiredPredicate.invoke(_value as T)
    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE
    override fun toString(): String = if (isInitialized()) value.toString() else "Reassignable value not initialized yet."
    operator fun getValue(any: Any, property: KProperty&lt;*&gt;): T = value
    operator fun getValue(any: Nothing?, property: KProperty&lt;*&gt;): T = value
}

fun &lt;T&gt; reassignable(initializer: () -&gt; T, expiredPredicate: (T) -&gt; Boolean, lock: Any? = null): SynchronizedReassignableImpl&lt;T&gt; {
    return SynchronizedReassignableImpl(initializer, expiredPredicate, lock)
}

interface Reassignable&lt;out T&gt; {
    val value: T
    fun isInitialized(): Boolean
    fun isExpired(): Boolean
}

class SynchronizedReassignableImplTests {
    @Test
    fun isReassignable() {
        val initializer = { mutableListOf&lt;String&gt;() }
        val expiredPredicate = { l: List&lt;String&gt; -&gt; l.size == 2 }
        val list by reassignable(initializer, expiredPredicate)
        Assertions.assertEquals(0, list.size)
        list.add("item ${list.size}")
        Assertions.assertEquals(1, list.size)
        list.add("item ${list.size}") // list size is 2 on next getter's call it will be reassigned
        Assertions.assertEquals(0, list.size)
        list.add("item ${list.size}")
        Assertions.assertEquals(1, list.size)
    }
}

fun Int.operationA() { 
    println("A $this")
}

fun Int.operationB() { 
    println("B $this")
}

// and use it like:
123.operationA()
123.operationB()

123.framework.operationA()
123.framework.operationB()

// Declaring it like this would be nice
fun Int.framework.operationA() { 
    println("A $this")
}

fun main(args:Array&lt;String&gt;){
   var a = "eat,animal,banana"
   var a1 = a.split(",")
   a1.sortBy{z.toCharArray().count() { z == 'a' } }
}

(19, 22) Kotlin: Unresolved reference: a1

val sports = listOf&lt;Sports&gt;(
        Sports("cricket", "7"),
        Sports("gilli", "10"),
        Sports("lagori", "8"),
        Sports("goli", "6"),
        Sports("dabba", "4")
    )

    sports.sortedBy { it.rating } // sortedByDescending is to sort in descending
        .forEach({ println("${it.name} ${it.rating}") })


}

class Sports(name: String, rating: String) {
    var name: String = name
    var rating: String = rating
}


sortedBy
sorted
sortBy
sortWith
 fun check(list){ list.forEach{ when(it){
   is Int -&gt; something()
   is String -&gt; something()
   //is method -&gt; ??? 
   else -&gt; consume{it}
   }}}

inline fun consume(f: () -&gt; Unit){ f() }

fun devId(): Any {
    var str = Build.CPU_ABI
    if (Build.VERSION.SDK_INT &gt;= 21) {
        var i = 0
        val hashSet = HashSet(listOf(arrayOf("armeabi", "armeabi-v7a", "arm64-v8a", "x86", "x86_64", "mips", "mips64")))
        val strArr = Build.SUPPORTED_ABIS
        val length = strArr.size
        while (true) {
            if (i &gt;= length) { break }
            val str2 = strArr[i]
            if (hashSet.contains(str2)) {
                str = str2
                break
            }
            i++
        }
    }
    return println(Build.BOARD + Build.BRAND + str + Build.DEVICE + Build.MANUFACTURER + Build.MODEL + Build.PRODUCT)
}

in
open class A
class B:A()

data class DataContainer(val a:String,
                         val b:A)

interface Repo&lt;T:A&gt;{
    fun setParam(param:T)
    fun getParam():T
}
abstract class RepoImp&lt;T:A&gt;:Repo&lt;T&gt;{
    private lateinit var parameter:T
    override fun setParam(param: T) {
        parameter = param
    }

    override fun getParam(): T {
        return parameter
    }
}
class BRepo:RepoImp&lt;B&gt;()

class Repo2(val repo: Repo&lt;in A&gt;){

    fun process(b:DataContainer){
        repo.setParam(b.b)
    }
}

val repoB = BRepo()

val repo2 = Repo2(repoB)// Here I got: Type mismatch: inferred type is BRepo but Repo&lt;in A&gt; was expected 

customers
fun Shop.getSetOfCustomers(): Set&lt;Customer&gt; = customers.toSet()

data class Shop(val name: String, val customers: List&lt;Customer&gt;)

data class Customer(val name: String, val city: City, val orders: List&lt;Order&gt;) {
    override fun toString() = "$name from ${city.name}"
}

data class Order(val products: List&lt;Product&gt;, val isDelivered: Boolean)

data class Product(val name: String, val price: Double) {
    override fun toString() = "'$name' for $price"
}

data class City(val name: String) {
    override fun toString() = name
}

val mThing
by lazyThing()
lazyThing()
mThing
.kt
error: source entry is not a Kotlin file:

val a = 2
if (a==1 | a==2) {

}

all()
fun Shop.checkAllCustomersAreFrom(city: City): Boolean =
    customers.all { it.city == city }

inline fun &lt;T&gt; Iterable&lt;T&gt;.all(
    predicate: (T) -&gt; Boolean
): Boolean

fun main(args:Array&lt;String&gt;){
var a = "banana, eat, one"
var a1 = a1.split("a").toMutableList()
a1.sortBy { it.toCharArray().count { it == 'a' } }
} 

class School {

    val roster: MutableMap&lt;Int, MutableList&lt;String&gt;&gt; = mutableMapOf&lt;Int, MutableList&lt;String&gt;&gt;()

    fun add(name: String, grade: Int): Unit {
        val students = roster.getOrPut(grade) { mutableListOf() }
        if (!students.contains(name)) {
            students.add(name)
        }
    }

    fun sort(): Map&lt;Int, List&lt;String&gt;&gt; {
        return db().mapValues { entry -&gt; entry.value.sorted() }
                .toSortedMap()
    }

    fun grade(grade: Int) = db().getOrElse(grade, { listOf() })
    fun db(): Map&lt;Int, List&lt;String&gt;&gt; = roster //Uh oh!
}

Map
List
mutableMapOf()
mutableListOf()
[INFO] Scanning for projects...
[INFO] 
[INFO] Using the builder org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder with a thread count of 1
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building webapp 0.1
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] &gt;&gt;&gt; spring-boot-maven-plugin:1.2.0.RELEASE:run (default-cli) @ webapp &gt;&gt;&gt;
[INFO] 
[INFO] --- kotlin-maven-plugin:0.10.4:compile (compile) @ webapp ---
[info] Kotlin Compiler version 0.10.4
[info] Compiling Kotlin sources from [src/main/resources, src/main/java]
[info] Classes directory is /Users/peisong/Google Drive/java/vio/target/classes
[debug] Removed target directory from compiler classpath (/Users/peisong/Google Drive/java/vio/target/classes)
[info] Classpath: src/main/resources:src/main/java:/Users/peisong/.m2/repository/org/springframework/boot/spring-boot-starter-actuator/1.2.0.RELEASE/spring-boot-starter-actuator-1.2.0.RELEASE.jar:/Users/peisong/.m2/repository/org/springframework/boot/spring-boot-starter/1.2.0.RELEASE/spring-boot-starter-1.2.0.RELEASE.jar:/Users/peisong/.m2/repository/org/springframework/boot/spring-boot/1.2.0.RELEASE/spring-boot-1.2.0.RELEASE.jar:/Users/peisong/.m2/repository/org/springframework/boot/spring-boot-autoconfigure/1.2.0.RELEASE/spring-boot-autoconfigure-1.2.0.RELEASE.jar:/Users/peisong/.m2/repository/org/springframework/boot/spring-boot-actuator/1.2.0.RELEASE/spring-boot-actuator-1.2.0.RELEASE.jar:/Users/peisong/.m2/repository/org/springframework/spring-core/4.1.3.RELEASE/spring-core-4.1.3.RELEASE.jar:/Users/peisong/.m2/repository/org/springframework/boot/spring-boot-starter-security/1.2.0.RELEASE/spring-boot-starter-security-1.2.0.RELEASE.jar:/Users/peisong/.m2/repository/org/springframework/spring-beans/4.1.3.RELEASE/spring-beans-4.1.3.RELEASE.jar:/Users/peisong/.m2/repository/org/springframework/spring-context/4.1.3.RELEASE/spring-context-4.1.3.RELEASE.jar:/Users/peisong/.m2/repository/org/springframework/spring-expression/4.1.3.RELEASE/spring-expression-4.1.3.RELEASE.jar:/Users/peisong/.m2/repository/org/springframework/spring-web/4.1.3.RELEASE/spring-web-4.1.3.RELEASE.jar:/Users/peisong/.m2/repository/org/springframework/security/spring-security-config/3.2.5.RELEASE/spring-security-config-3.2.5.RELEASE.jar:/Users/peisong/.m2/repository/aopalliance/aopalliance/1.0/aopalliance-1.0.jar:/Users/peisong/.m2/repository/org/springframework/security/spring-security-core/3.2.5.RELEASE/spring-security-core-3.2.5.RELEASE.jar:/Users/peisong/.m2/repository/org/springframework/security/spring-security-web/3.2.5.RELEASE/spring-security-web-3.2.5.RELEASE.jar:/Users/peisong/.m2/repository/org/springframework/spring-aop/4.1.3.RELEASE/spring-aop-4.1.3.RELEASE.jar:/Users/peisong/.m2/repository/org/springframework/boot/spring-boot-starter-data-mongodb/1.2.0.RELEASE/spring-boot-starter-data-mongodb-1.2.0.RELEASE.jar:/Users/peisong/.m2/repository/org/mongodb/mongo-java-driver/2.12.4/mongo-java-driver-2.12.4.jar:/Users/peisong/.m2/repository/org/springframework/spring-tx/4.1.3.RELEASE/spring-tx-4.1.3.RELEASE.jar:/Users/peisong/.m2/repository/org/springframework/data/spring-data-mongodb/1.6.1.RELEASE/spring-data-mongodb-1.6.1.RELEASE.jar:/Users/peisong/.m2/repository/org/springframework/data/spring-data-commons/1.9.1.RELEASE/spring-data-commons-1.9.1.RELEASE.jar:/Users/peisong/.m2/repository/org/springframework/boot/spring-boot-starter-logging/1.2.0.RELEASE/spring-boot-starter-logging-1.2.0.RELEASE.jar:/Users/peisong/.m2/repository/org/slf4j/jcl-over-slf4j/1.7.7/jcl-over-slf4j-1.7.7.jar:/Users/peisong/.m2/repository/org/slf4j/jul-to-slf4j/1.7.7/jul-to-slf4j-1.7.7.jar:/Users/peisong/.m2/repository/org/slf4j/log4j-over-slf4j/1.7.7/log4j-over-slf4j-1.7.7.jar:/Users/peisong/.m2/repository/ch/qos/logback/logback-classic/1.1.2/logback-classic-1.1.2.jar:/Users/peisong/.m2/repository/ch/qos/logback/logback-core/1.1.2/logback-core-1.1.2.jar:/Users/peisong/.m2/repository/org/springframework/boot/spring-boot-starter-web/1.2.0.RELEASE/spring-boot-starter-web-1.2.0.RELEASE.jar:/Users/peisong/.m2/repository/com/fasterxml/jackson/core/jackson-databind/2.4.4/jackson-databind-2.4.4.jar:/Users/peisong/.m2/repository/com/fasterxml/jackson/core/jackson-annotations/2.4.4/jackson-annotations-2.4.4.jar:/Users/peisong/.m2/repository/com/fasterxml/jackson/core/jackson-core/2.4.4/jackson-core-2.4.4.jar:/Users/peisong/.m2/repository/org/hibernate/hibernate-validator/5.1.3.Final/hibernate-validator-5.1.3.Final.jar:/Users/peisong/.m2/repository/javax/validation/validation-api/1.1.0.Final/validation-api-1.1.0.Final.jar:/Users/peisong/.m2/repository/org/jboss/logging/jboss-logging/3.1.3.GA/jboss-logging-3.1.3.GA.jar:/Users/peisong/.m2/repository/com/fasterxml/classmate/1.0.0/classmate-1.0.0.jar:/Users/peisong/.m2/repository/org/springframework/spring-webmvc/4.1.3.RELEASE/spring-webmvc-4.1.3.RELEASE.jar:/Users/peisong/.m2/repository/org/springframework/boot/spring-boot-starter-jade4j/0.1.2-SNAPSHOT/spring-boot-starter-jade4j-0.1.2-SNAPSHOT.jar:/Users/peisong/.m2/repository/de/neuland-bfi/spring-jade4j/0.4.2/spring-jade4j-0.4.2.jar:/Users/peisong/.m2/repository/de/neuland-bfi/jade4j/0.4.2/jade4j-0.4.2.jar:/Users/peisong/.m2/repository/org/apache/commons/commons-jexl/2.1.1/commons-jexl-2.1.1.jar:/Users/peisong/.m2/repository/commons-logging/commons-logging/1.1.1/commons-logging-1.1.1.jar:/Users/peisong/.m2/repository/commons-collections/commons-collections/3.2.1/commons-collections-3.2.1.jar:/Users/peisong/.m2/repository/org/apache/commons/commons-lang3/3.1/commons-lang3-3.1.jar:/Users/peisong/.m2/repository/com/googlecode/concurrentlinkedhashmap/concurrentlinkedhashmap-lru/1.3.1/concurrentlinkedhashmap-lru-1.3.1.jar:/Users/peisong/.m2/repository/org/pegdown/pegdown/1.1.0/pegdown-1.1.0.jar:/Users/peisong/.m2/repository/org/parboiled/parboiled-core/1.0.2/parboiled-core-1.0.2.jar:/Users/peisong/.m2/repository/org/parboiled/parboiled-java/1.0.2/parboiled-java-1.0.2.jar:/Users/peisong/.m2/repository/asm/asm/3.3.1/asm-3.3.1.jar:/Users/peisong/.m2/repository/asm/asm-util/3.3.1/asm-util-3.3.1.jar:/Users/peisong/.m2/repository/asm/asm-tree/3.3.1/asm-tree-3.3.1.jar:/Users/peisong/.m2/repository/asm/asm-analysis/3.3.1/asm-analysis-3.3.1.jar:/Users/peisong/.m2/repository/commons-io/commons-io/2.1/commons-io-2.1.jar:/Users/peisong/.m2/repository/com/google/guava/guava/18.0/guava-18.0.jar:/Users/peisong/.m2/repository/org/apache/commons/commons-compress/1.9/commons-compress-1.9.jar:/Users/peisong/.m2/repository/com/ning/async-http-client/1.9.3/async-http-client-1.9.3.jar:/Users/peisong/.m2/repository/io/netty/netty/3.9.5.Final/netty-3.9.5.Final.jar:/Users/peisong/.m2/repository/org/slf4j/slf4j-api/1.7.7/slf4j-api-1.7.7.jar:/Users/peisong/.m2/repository/org/springframework/boot/spring-boot-starter-tomcat/1.2.0.RELEASE/spring-boot-starter-tomcat-1.2.0.RELEASE.jar:/Users/peisong/.m2/repository/org/apache/tomcat/embed/tomcat-embed-core/8.0.12/tomcat-embed-core-8.0.12.jar:/Users/peisong/.m2/repository/org/apache/tomcat/embed/tomcat-embed-el/8.0.12/tomcat-embed-el-8.0.12.jar:/Users/peisong/.m2/repository/org/apache/tomcat/embed/tomcat-embed-logging-juli/8.0.12/tomcat-embed-logging-juli-8.0.12.jar:/Users/peisong/.m2/repository/org/apache/tomcat/embed/tomcat-embed-websocket/8.0.12/tomcat-embed-websocket-8.0.12.jar:/Users/peisong/.m2/repository/org/springframework/session/spring-session-data-redis/1.0.0.RC1/spring-session-data-redis-1.0.0.RC1.jar:/Users/peisong/.m2/repository/org/apache/commons/commons-pool2/2.2/commons-pool2-2.2.jar:/Users/peisong/.m2/repository/org/springframework/data/spring-data-redis/1.4.1.RELEASE/spring-data-redis-1.4.1.RELEASE.jar:/Users/peisong/.m2/repository/org/springframework/spring-context-support/4.1.3.RELEASE/spring-context-support-4.1.3.RELEASE.jar:/Users/peisong/.m2/repository/org/springframework/session/spring-session/1.0.0.RC1/spring-session-1.0.0.RC1.jar:/Users/peisong/.m2/repository/redis/clients/jedis/2.5.2/jedis-2.5.2.jar:/Users/peisong/.m2/repository/com/paypal/sdk/rest-api-sdk/0.12.2/rest-api-sdk-0.12.2.jar:/Users/peisong/.m2/repository/com/paypal/sdk/paypal-core/1.6.6/paypal-core-1.6.6.jar:/Users/peisong/.m2/repository/com/google/code/gson/gson/2.3/gson-2.3.jar:/Users/peisong/.m2/repository/org/projectlombok/lombok/1.14.8/lombok-1.14.8.jar:/Users/peisong/.m2/repository/org/jetbrains/kotlin/kotlin-stdlib/0.10.4/kotlin-stdlib-0.10.4.jar:/Users/peisong/.m2/repository/org/jetbrains/kotlin/kotlin-runtime/0.10.4/kotlin-runtime-0.10.4.jar
[info] Classes directory is /Users/peisong/Google Drive/java/vio/target/classes
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/boot/spring-boot-starter-actuator/1.2.0.RELEASE/spring-boot-starter-actuator-1.2.0.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/boot/spring-boot-starter/1.2.0.RELEASE/spring-boot-starter-1.2.0.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/boot/spring-boot/1.2.0.RELEASE/spring-boot-1.2.0.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/boot/spring-boot-autoconfigure/1.2.0.RELEASE/spring-boot-autoconfigure-1.2.0.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/boot/spring-boot-actuator/1.2.0.RELEASE/spring-boot-actuator-1.2.0.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/spring-core/4.1.3.RELEASE/spring-core-4.1.3.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/boot/spring-boot-starter-security/1.2.0.RELEASE/spring-boot-starter-security-1.2.0.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/spring-beans/4.1.3.RELEASE/spring-beans-4.1.3.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/spring-context/4.1.3.RELEASE/spring-context-4.1.3.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/spring-expression/4.1.3.RELEASE/spring-expression-4.1.3.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/spring-web/4.1.3.RELEASE/spring-web-4.1.3.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/security/spring-security-config/3.2.5.RELEASE/spring-security-config-3.2.5.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/aopalliance/aopalliance/1.0/aopalliance-1.0.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/security/spring-security-core/3.2.5.RELEASE/spring-security-core-3.2.5.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/security/spring-security-web/3.2.5.RELEASE/spring-security-web-3.2.5.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/spring-aop/4.1.3.RELEASE/spring-aop-4.1.3.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/boot/spring-boot-starter-data-mongodb/1.2.0.RELEASE/spring-boot-starter-data-mongodb-1.2.0.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/mongodb/mongo-java-driver/2.12.4/mongo-java-driver-2.12.4.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/spring-tx/4.1.3.RELEASE/spring-tx-4.1.3.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/data/spring-data-mongodb/1.6.1.RELEASE/spring-data-mongodb-1.6.1.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/data/spring-data-commons/1.9.1.RELEASE/spring-data-commons-1.9.1.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/boot/spring-boot-starter-logging/1.2.0.RELEASE/spring-boot-starter-logging-1.2.0.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/slf4j/jcl-over-slf4j/1.7.7/jcl-over-slf4j-1.7.7.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/slf4j/jul-to-slf4j/1.7.7/jul-to-slf4j-1.7.7.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/slf4j/log4j-over-slf4j/1.7.7/log4j-over-slf4j-1.7.7.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/ch/qos/logback/logback-classic/1.1.2/logback-classic-1.1.2.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/ch/qos/logback/logback-core/1.1.2/logback-core-1.1.2.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/boot/spring-boot-starter-web/1.2.0.RELEASE/spring-boot-starter-web-1.2.0.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/com/fasterxml/jackson/core/jackson-databind/2.4.4/jackson-databind-2.4.4.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/com/fasterxml/jackson/core/jackson-annotations/2.4.4/jackson-annotations-2.4.4.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/com/fasterxml/jackson/core/jackson-core/2.4.4/jackson-core-2.4.4.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/hibernate/hibernate-validator/5.1.3.Final/hibernate-validator-5.1.3.Final.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/javax/validation/validation-api/1.1.0.Final/validation-api-1.1.0.Final.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/jboss/logging/jboss-logging/3.1.3.GA/jboss-logging-3.1.3.GA.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/com/fasterxml/classmate/1.0.0/classmate-1.0.0.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/spring-webmvc/4.1.3.RELEASE/spring-webmvc-4.1.3.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/boot/spring-boot-starter-jade4j/0.1.2-SNAPSHOT/spring-boot-starter-jade4j-0.1.2-SNAPSHOT.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/de/neuland-bfi/spring-jade4j/0.4.2/spring-jade4j-0.4.2.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/de/neuland-bfi/jade4j/0.4.2/jade4j-0.4.2.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/apache/commons/commons-jexl/2.1.1/commons-jexl-2.1.1.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/commons-logging/commons-logging/1.1.1/commons-logging-1.1.1.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/commons-collections/commons-collections/3.2.1/commons-collections-3.2.1.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/apache/commons/commons-lang3/3.1/commons-lang3-3.1.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/com/googlecode/concurrentlinkedhashmap/concurrentlinkedhashmap-lru/1.3.1/concurrentlinkedhashmap-lru-1.3.1.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/pegdown/pegdown/1.1.0/pegdown-1.1.0.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/parboiled/parboiled-core/1.0.2/parboiled-core-1.0.2.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/parboiled/parboiled-java/1.0.2/parboiled-java-1.0.2.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/asm/asm/3.3.1/asm-3.3.1.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/asm/asm-util/3.3.1/asm-util-3.3.1.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/asm/asm-tree/3.3.1/asm-tree-3.3.1.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/asm/asm-analysis/3.3.1/asm-analysis-3.3.1.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/commons-io/commons-io/2.1/commons-io-2.1.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/com/google/guava/guava/18.0/guava-18.0.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/apache/commons/commons-compress/1.9/commons-compress-1.9.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/com/ning/async-http-client/1.9.3/async-http-client-1.9.3.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/io/netty/netty/3.9.5.Final/netty-3.9.5.Final.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/slf4j/slf4j-api/1.7.7/slf4j-api-1.7.7.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/boot/spring-boot-starter-tomcat/1.2.0.RELEASE/spring-boot-starter-tomcat-1.2.0.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/apache/tomcat/embed/tomcat-embed-core/8.0.12/tomcat-embed-core-8.0.12.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/apache/tomcat/embed/tomcat-embed-el/8.0.12/tomcat-embed-el-8.0.12.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/apache/tomcat/embed/tomcat-embed-logging-juli/8.0.12/tomcat-embed-logging-juli-8.0.12.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/apache/tomcat/embed/tomcat-embed-websocket/8.0.12/tomcat-embed-websocket-8.0.12.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/session/spring-session-data-redis/1.0.0.RC1/spring-session-data-redis-1.0.0.RC1.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/apache/commons/commons-pool2/2.2/commons-pool2-2.2.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/data/spring-data-redis/1.4.1.RELEASE/spring-data-redis-1.4.1.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/spring-context-support/4.1.3.RELEASE/spring-context-support-4.1.3.RELEASE.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/springframework/session/spring-session/1.0.0.RC1/spring-session-1.0.0.RC1.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/redis/clients/jedis/2.5.2/jedis-2.5.2.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/com/paypal/sdk/rest-api-sdk/0.12.2/rest-api-sdk-0.12.2.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/com/paypal/sdk/paypal-core/1.6.6/paypal-core-1.6.6.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/com/google/code/gson/gson/2.3/gson-2.3.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/projectlombok/lombok/1.14.8/lombok-1.14.8.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/jetbrains/kotlin/kotlin-stdlib/0.10.4/kotlin-stdlib-0.10.4.jar
[debug] Scanning for kotlin annotations in /Users/peisong/.m2/repository/org/jetbrains/kotlin/kotlin-runtime/0.10.4/kotlin-runtime-0.10.4.jar
[info] Using kotlin annotations from /Users/peisong/.m2/repository/org/jetbrains/kotlin/kotlin-jdk-annotations/0.10.4/kotlin-jdk-annotations-0.10.4.jar
[debug] Using Kotlin home directory &lt;no_path&gt;
[debug] Configuring the compilation environment
[debug] Output:
/Users/peisong/Google Drive/java/vio/target/classes/io/vord/webapp/domain/pay/Kotlin.class
Sources:
/Users/peisong/Google Drive/java/vio/src/main/java/io/vord/webapp/domain/pay/Audit.kt
[debug] Output:
/Users/peisong/Google Drive/java/vio/target/classes/io/vord/webapp/domain/pay/PayPackage$Audit$6a5fae39.class
Sources:
/Users/peisong/Google Drive/java/vio/src/main/java/io/vord/webapp/domain/pay/Audit.kt
[debug] Output:
/Users/peisong/Google Drive/java/vio/target/classes/io/vord/webapp/domain/pay/PayPackage.class
Sources:
/Users/peisong/Google Drive/java/vio/src/main/java/io/vord/webapp/domain/pay/Audit.kt
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ webapp ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 2 resources
[INFO] Copying 59 resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ webapp ---
[INFO] Nothing to compile - all classes are up to date
[INFO] 
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ webapp ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory /Users/peisong/Google Drive/java/vio/src/test/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ webapp ---
[INFO] Nothing to compile - all classes are up to date
[INFO] 
[INFO] &lt;&lt;&lt; spring-boot-maven-plugin:1.2.0.RELEASE:run (default-cli) @ webapp &lt;&lt;&lt;
[INFO] 
[INFO] --- spring-boot-maven-plugin:1.2.0.RELEASE:run (default-cli) @ webapp ---

val a = arrayOf("Pushups", "Benchpress", "Squats")
val b = arrayOf("Pushups", "Squats", "Benchpress")
val c = arrayOf("Pushups", "Squats", "Sit Ups")

checkSameInfo(a,b) //Should return true
checkSameInfo(a,c) //Should return false

class A {
    companion object {
        val a = 0
        fun b() = 1
        object C {
            val d = 0
        }
    }
}

fun main(args: Array&lt;String&gt;) {
    println(A.a)
    println(A.b())
    println(A.C.d) // doesn't compile
    println(A.Companion.C.d)
}

Companion
A.C
a
b()
var someModel: someViewModel by notNullAndObservable { vm -&gt;
  ...
}

by
fun main() {
    var rowAndColumn = readLine()!!.split(" ")
    var rows = rowAndColumn[0].toInt()
    var columns = rowAndColumn[1].toInt()
    val board = Array(rows) { IntArray(columns).toMutableList() }
    for (i in 0 until rows) {
        var stringColumn = readLine()!!.split("").toMutableList()
        stringColumn.removeAll(listOf(""))
        var column = stringColumn.map {it.toInt()}.toMutableList()
        board[i] = column

    }
    for(i in 0 until rows) {
        println(board[i].toString())
    }
}

fun main(args:Array&lt;String&gt;){

    var a = "eat, banana, one"
    var a1 = a.split(",").toMutableList()
    a1.sortBy { it.toCharArray().count { it == 'a' } }
    var a2 = a1.associateWith { word -&gt; word.count { char -&gt; char == 'a' } }

    a2.keys.filterNot { c -&gt; "a".contains(c)}
   }

a2.keys.filterNot { c -&gt; "a".contains(c)}
null
Calendar
fun Calendar.fromIsoString(date: String): Calendar = this.apply {
    time = SimpleDateFormat(SERVER_DATE_PATTERN, Locale.US).parse(date)
}

fun Calendar.fromIsoString(date: String?): Calendar? {
    if (date == null) return null
    time = SimpleDateFormat(SERVER_DATE_PATTERN, Locale.US).parse(date)
    return this
}

Unit
fun Calendar.fromIsoString(date: String?, a: Unit = Unit): Calendar? {
if (date == null) return null
    time = SimpleDateFormat(SERVER_DATE_PATTERN, Locale.US).parse(date)
    return this
}

class MutableOptional&lt;T&gt; {
    private var value: T? = null
    private var isSet: Boolean = false

    fun set(value: T)
    {
        this.value = value
        isSet = true
    }

    fun unset()
    {
        isSet = false
        value = null
    }

    fun get(): T
    {
        if (!isSet) {
            throw Error("Value not set")
        }
        return value!! // &lt;&lt;&lt; NPE here
    }
}

fun f()
{
    val opt = MutableOptional&lt;Int?&gt;()
    opt.set(null)
    assertNull(opt.get())
}

import kotlin.Double.Companion.POSITIVE_INFINITY
import kotlin.Double.Companion.NaN

const val inf = POSITIVE_INFINITY
const val nan = NaN

 @ParameterizedTest
 @ValueSource(doubles = doubleArrayOf(nan, inf, -2* epsilon,  1.5, -0.5, 1.0 + 2* epsilon))
 fun ensureNotAProbability(number: Double)
 {
     ...
 }  

fun main(args: Array&lt;String&gt;) {
    Sample("T","U")
}

class Sample(private var s : String) {
    constructor(t: String, u: String) : this(t) { // I don't get what "this(t)" is!
        this.s += u
    }
    init {
        s += "B"
    }
}

fun main(args: Array&lt;String&gt;) {
    var number: Long ? = null // or number = 0
    val simpleObject = SimpleClass()
    number = 1000
    println("Hi + $number")
}

import java.util.*

fun main(args: Array&lt;String&gt;) {
    var number: Long = 0
    val simpleObject = SimpleClass()
    number = simpleObject.getValue&lt;Long&gt;()
    println("Hi + $number")
}

class SimpleClass() {
    fun &lt;T&gt;getValue(): T {
        return 1000 as T
    }
}

import java.util.*

fun main(args: Array&lt;String&gt;) {
    var number: Long? = null
    val simpleObject = SimpleClass()
    number = simpleObject.getValue&lt;Long&gt;()
    println("Hi + $number")
}

class SimpleClass() {
    fun &lt;T&gt;getValue(): T {
        return 1000 as T
    }
}

number = simpleObject.getValue&lt;Long&gt;()
Exception in thread "main" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.Long 

var number: Long ? = null
var number: Long = 0
import java.util.*

fun main(args: Array&lt;String&gt;) {
    var number: Long? = null
    val simpleObject = SimpleClass()
    val temp = simpleObject.getValue&lt;Long&gt;()
    number = temp
    println("Hi + $number")
}

class SimpleClass() {
    fun &lt;T&gt;getValue(): T {
        return 1000 as T
    }
}

JsonNode
val mm = ... //JsonNode
val xs = mm.fieldNames()

when mm.size() {
  1 -&gt; myFunction1(xs[0])
  2 -&gt; myFunction2(xs[0], xs[1])
  3 -&gt; myFunction3(xs[0], xs[1], xs[2])
  else -&gt; print("invalid")
}

xs
mm.toList()
data class A(
var x1:Float?,
var y1:Float?
)

data class B(
var x:Float?,
var y:Float?,
// other variables and methods
)

Boolean::class.java
Boolean.TYPE
Boolean.class
 val clickListener = View.OnClickListener { view -&gt;
        when(view.id) {
            R.id.button_upload -&gt; {
                progressDialog = ProgressDialog(activity)
                progressDialog!!.setMessage("Looking for the server. Please wait...")
                progressDialog!!.setCancelable(false)
                progressDialog!!.show()
                if(findServer()) {
                   Log.i("TAG", "FOUND")
                } else {
                   Log.i("TAG", "NOT FOUND")
                }
            }
        }
    } 

    private fun findServer(): Boolean {
        if(canPingServer()) {
            Toast.makeText(context, "We are connected to the server server", Toast.LENGTH_LONG).show()
            gView.button_upload.setText("Upload")
            gView.button_upload.isEnabled = true
            progressDialog!!.dismiss()
            return true
        } else {
            Toast.makeText(context, "We cannot connect to the server.", Toast.LENGTH_LONG).show()
            gView.button_upload.setText("Server not found")
            gView.button_upload.isEnabled = false
            progressDialog!!.dismiss()
            return false
        }
    }

private fun canPingServer(): Boolean {
        val runtime = Runtime.getRuntime()
        try {
            val mIpAddrProcess = runtime.exec("/system/bin/ping -c 1 192.168.1.4")
            val mExitValue = mIpAddrProcess.waitFor()
            Log.i("TAG","mExitValue $mExitValue")
            return mExitValue == 0
        } catch (ignore: InterruptedException) {
            ignore.printStackTrace()
            Log.i("TAG"," Exception:$ignore")
        } catch (e: IOException) {
            e.printStackTrace()
            Log.i("TAG"," Exception:$e")
        }
        return false
    }

AsyncTask&lt;Void, Void, String&gt;
class UploadFragment : BaseFragment() {.....}

variable = object : AClass()
{
    // inside the declaration of anonymous object

    override fun aFunction(i: Int)
    {
        // do something inside aFunction
    }
}.apply {
    // do something inside apply
}

fun bFunction(i: Int)
variable
AClass
variable.bFunction(1)

fun AClass.bFunction(i: Int)
AClass
bFunction
.apply {}
bFunction
.apply {}
.apply {}
JFrame
contentPane.graphics.drawXXX
Thread.sleep
paint
var image = BufferedImage(...)
painting = object : JFrame()
{
    override fun paint(g: Graphics?)
    {
        contentPane.graphics.drawImage(image, 0, 0, this)
    }
}.apply { /* do some initialization */ }

paint
updatePainting()
painting
data class MyData(val pop1:Long,val pop2:String,...)

fun class MyGenericClass&lt;T : isDataClass&gt;(o : T){
    // This is the important part
    fun useCopy(value : Long) = t.copy(pop1 = value)
}

val s = "John Doe, 13, \"Subject 1, Subject 2, Subject 3\""
var list: List&lt;String&gt; = s.split(",(?=([^\"]*\"[^\"]*\")*[^\"]*$)")
Log.d("size:", list.size.toString() + " - subjects:" + list[2])

java.lang.IndexOutOfBoundsException: Index: 2, Size: 1

Unit
val list = listOf("Hey", "this", "code", "runs")
val unit = list.forEach {
    print(it.plus(" "))
}

val unit
unit.invoke()
T!
T
T?
T!
val t: T! = ...
fun f(): T! = ...

private val repositories = mutableListOf&lt;String&gt;()

private val repositories = ArrayList&lt;String&gt;()

mutableListOf
ArrayList
/**
 * Example:
 * var ti = TreeNode(5)
 * var v = ti.`val`
 * Definition for a binary tree node.
 * class TreeNode(var `val`: Int) {
 *     var left: TreeNode? = null
 *     var right: TreeNode? = null
 * }
 */
class Solution {
    fun pathSum(root: TreeNode?, sum: Int): List&lt;List&lt;Int&gt;&gt; {
        var result : List&lt;MutableList&lt;Int&gt;&gt; = listOf(mutableListOf())
        var path : MutableList&lt;Int&gt; = mutableListOf()
        dfs(root, sum, result, path)
        return result
    }

    fun dfs(root: TreeNode?, sum: Int, result: List&lt;MutableList&lt;Int&gt;&gt;, path: MutableList&lt;Int&gt;){

        if(root == null) return

        path.add(sum)

        dfs(root.left, sum - root.val, result, path)
        dfs(root.right, sum - root.val, result, path)

        if(sum == 0 &amp;&amp;
                root.left == null &amp;&amp;
                root.right == null) {           
            result.add(path)
        }

        path.remove(path.size() - 1)

    }
}

Line 24: Char 38: error: expecting property name or receiver type
            dfs(root.left, sum - root.val, result, path)
                                         ^
    Line 24: Char 46: error: expecting an element
            dfs(root.left, sum - root.val, result, path)

with
with
with
with(foo, bar){
    fooFunction()
    barFunction()
}

var item: Item
    get() {...}
    set(value) {...}

private var _table: Map&lt;String, Int&gt;? = null
public val table: Map&lt;String, Int&gt;
    get() {
      if (_table == null)
        _table = HashMap() // Type parameters are inferred
      return _table ?: throw AssertionError("Set to null by another thread")
    }

downTo
interface NewsItemState {

    final fun delete(newsItem: NewsItem) {
        validateCanDelete(newsItem)
        deleteNewsItem(newsItem)
    }

    fun validateCanDelete(newsItem: NewsItem)
    fun deleteNewsItem(newsItem: NewsItem)
}

delete
final
validateCanDelete
deleteNewsItem
final
when
when(value) {
    1 -&gt; "One"
    2, 3 -&gt; "Two or three"
    else -&gt; "The rest"
}

Pair
when(Pair(value1, value2)) {
    (1, "One") -&gt; "One"
    (2, "Two"), (3, "Three") -&gt; "Two or three"
    else -&gt; "The rest"
}

when
when(value) {
    1 -&gt; "One"
    2, 3 -&gt; "Two or three"
    else -&gt; "The rest"
}

Pair
when(Pair(value1, value2)) {
    (1, "One") -&gt; "One"
    (2, "Two"), (3, "Three") -&gt; "Two or three"
    else -&gt; "The rest"
}

when(Pair(value1, value2)) {
    (1, _), (_, "One") -&gt; "One"
    (2, _), (_, "Two"), (3, _), (_, "Three") -&gt; "Two or three"
    else -&gt; "The rest"
}

when(Pair(value1, value2)) {
    (1, else), (else, "One") -&gt; "One"
    (2, else), (else, "Two"), (3, else), (else, "Three") -&gt; "Two or three"
    else -&gt; "The rest"
}

private var zipCode: Long by DelegatesExt.preference(this, ZIP_CODE, DEFAULT_ZIP)
private val zipCode: Long by Preference(this, ZIP_CODE, DEFAULT_ZIP)
object DelegatesExt {
    fun &lt;T&gt; notNullSingleValue() = NotNullSingleValueVar&lt;T&gt;()
    fun &lt;T&gt; preference(context: Context, name: String,
            default: T) = Preference(context, name, default)
}

class NotNullSingleValueVar&lt;T&gt; {

    private var value: T? = null

    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T =
            value ?: throw IllegalStateException("${property.name} not initialized")

    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) {
        this.value = if (this.value == null) value
        else throw IllegalStateException("${property.name} already initialized")
    }
}

class Preference&lt;T&gt;(private val context: Context, private val name: String,
        private val default: T) {

    private val prefs: SharedPreferences by lazy {
        context.getSharedPreferences("default", Context.MODE_PRIVATE)
    }

    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T = findPreference(name, default)

    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) {
        putPreference(name, value)
    }

    @Suppress("UNCHECKED_CAST")
    private fun findPreference(name: String, default: T): T = with(prefs) {
        val res: Any = when (default) {
            is Long -&gt; getLong(name, default)
            is String -&gt; getString(name, default)
            is Int -&gt; getInt(name, default)
            is Boolean -&gt; getBoolean(name, default)
            is Float -&gt; getFloat(name, default)
            else -&gt; throw IllegalArgumentException("This type can be saved into Preferences")
        }

        res as T
    }

    @SuppressLint("CommitPrefEdits")
    private fun putPreference(name: String, value: T) = with(prefs.edit()) {
        when (value) {
            is Long -&gt; putLong(name, value)
            is String -&gt; putString(name, value)
            is Int -&gt; putInt(name, value)
            is Boolean -&gt; putBoolean(name, value)
            is Float -&gt; putFloat(name, value)
            else -&gt; throw IllegalArgumentException("This type can't be saved into Preferences")
        }.apply()
    }
}

class NotNullSingleValueVar&lt;T&gt; {

    private var value: T? = null

    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T =
            value ?: throw IllegalStateException("${property.name} not initialized")

    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) {
        this.value = if (this.value == null) value
        else throw IllegalStateException("${property.name} already initialized")
    }
}

class Preference&lt;T&gt;(private val context: Context, private val name: String,
        private val default: T) {

    private val prefs: SharedPreferences by lazy {
        context.getSharedPreferences("default", Context.MODE_PRIVATE)
    }

    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T = findPreference(name, default)

    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) {
        putPreference(name, value)
    }

    @Suppress("UNCHECKED_CAST")
    private fun findPreference(name: String, default: T): T = with(prefs) {
        val res: Any = when (default) {
            is Long -&gt; getLong(name, default)
            is String -&gt; getString(name, default)
            is Int -&gt; getInt(name, default)
            is Boolean -&gt; getBoolean(name, default)
            is Float -&gt; getFloat(name, default)
            else -&gt; throw IllegalArgumentException("This type can be saved into Preferences")
        }

        res as T
    }

    @SuppressLint("CommitPrefEdits")
    private fun putPreference(name: String, value: T) = with(prefs.edit()) {
        when (value) {
            is Long -&gt; putLong(name, value)
            is String -&gt; putString(name, value)
            is Int -&gt; putInt(name, value)
            is Boolean -&gt; putBoolean(name, value)
            is Float -&gt; putFloat(name, value)
            else -&gt; throw IllegalArgumentException("This type can't be saved into Preferences")
        }.apply()
    }
}

when
let
else
val list = mutableListOf&lt;Int?&gt;(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

let
when
else
fun `remove element inside let and when`(random: Int) {
    list[random]?.let {
        when {
            it &gt; 4 -&gt; list.remove(it)
            else -&gt; { //else branch required
            }
        }
    }
}

when
let
else
fun `remove element inside when`(random: Int) {
    when {
        random &gt; 4 -&gt; list.remove(random)
        //no else branch required
    }
}

if
when
let
else
fun `remove element inside let and if `(random: Int) {
    list[random]?.let {
        if (it &gt; 4) {
            list.remove(it)
        } //no else required
    }
}


when
else
fun `modify element inside let and when`(random: Int) {
    list[random]?.let {
        when {
            it &gt; 4 -&gt; list[random] = 10
            //no else branch required
        }
    }
}

sealed class UrlType : Parcelable {
    @Parcelize class Valid private constructor(val url: String) : UrlType() {
        companion object : CompanionTest&lt;UrlType.Valid, String&gt;(::Valid)
    }

    @Parcelize object None : UrlType()
    @Parcelize class Invalid(val invalidUrl: String) : UrlType()

    companion object {

        fun getUrlType(url: String?): UrlType {
            return if (url == null) {
                UrlType.None
            } else if (!url.isValidUrl()) {
                UrlType.Invalid(url)
            } else {
                Valid.create(url)
            }
        }
    }
}

open class CompanionTest&lt;out T, in A&gt;(creator: (A) -&gt; T) {

    private var creator: ((A) -&gt; T)? = creator

    fun create(arg1: A): T {
        return creator!!(arg1)
    }
}

@Parcelize
data class NewsPost(
        val id: String,
        val title: String,
        val description: String?,
        val webContentUrl: UrlType,
        val imageUrl: UrlType,
        val created: String,
        val updated: String,
        val feeds: List&lt;Feed&gt;
) : Parcelable

sealed class NewsLaunchType : Parcelable {
    @Parcelize object FeedList : NewsLaunchType()
    @Parcelize class FeedDetail(val newsFeedType: NewsFeedType) : NewsLaunchType()
    @Parcelize class PostDetail(val newsPost: NewsPost) : NewsLaunchType()
}

NewsLaunchType.PostDetail(newsPost)
fun startActivity(){
    val intent = Intent(context, NewsActivity::class.java).apply {                      
      putExtra("key", NewsLaunchType.PostDetail(newsPost))
    }      
    startActivity(intent)
}

 override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContentView(R.layout.activity_news)

        val newsActivityLaunchType = intent.getParcelableExtra&lt;NewsLaunchType&gt;("key")
}

2018-11-08 11:08:33.897 17030-17030/com.something.internal E/AndroidRuntime: FATAL EXCEPTION: main
    Process: com.something.internal, PID: 17030
    java.lang.IllegalAccessError: Method 'void com.something.somethingkit.helper.UrlType$Valid.&lt;init&gt;(java.lang.String)' is inaccessible to class 'com.something.somethingkit.helper.UrlType$Valid$Creator' (declaration of 'com.something.somethingkit.helper.UrlType$Valid$Creator' appears in /data/app/com.something.internal-QTiupS4yw25rZK5uXP7UCQ==/base.apk:classes2.dex)
        at com.something.somethingkit.helper.UrlType$Valid$Creator.createFromParcel(Unknown Source:11)
        at android.os.Parcel.readParcelable(Parcel.java:2798)
        at com.something.somethingkit.model.news.local.NewsPost$Creator.createFromParcel(Unknown Source:25)
        at android.os.Parcel.readParcelable(Parcel.java:2798)
        at com.something.screens.news.NewsLaunchType$PostDetail$Creator.createFromParcel(Unknown Source:13)
        at android.os.Parcel.readParcelable(Parcel.java:2798)
        at android.os.Parcel.readValue(Parcel.java:2692)
        at android.os.Parcel.readArrayMapInternal(Parcel.java:3059)
        at android.os.BaseBundle.unparcel(BaseBundle.java:257)
        at android.os.Bundle.getParcelable(Bundle.java:888)
        at android.content.Intent.getParcelableExtra(Intent.java:7734)
        at com.something.screens.news.NewsActivity.onCreate(NewsActivity.kt:31)
        at android.app.Activity.performCreate(Activity.java:7183)
        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1220)
        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2908)
        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3030)
        at android.app.ActivityThread.-wrap11(Unknown Source:0)
        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1696)
        at android.os.Handler.dispatchMessage(Handler.java:105)
        at android.os.Looper.loop(Looper.java:164)
        at android.app.ActivityThread.main(ActivityThread.java:6938)
        at java.lang.reflect.Method.invoke(Native Method)
        at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:327)
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1374)

 fun startActivity(){
        val intent = Intent(context, NewsActivity::class.java).apply {                      
          putExtra("key", NewsLaunchType.PostDetail(newsPost))
        }      

        val test = intent.getParcelableExtra&lt;NewsLaunchType&gt;("key")
        startActivity(intent)
    }

companion object {
    fun newInstance(newsPost: NewsPost): NewsDetailFragment {
                val bundle = Bundle()
                bundle.putParcelable(extraNewsPost, newsPost)

                val fragment = NewsDetailFragment()
                fragment.arguments = bundle
                return fragment
            }
}

 override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        val newsPost = arguments?.getParcelable&lt;NewsPost&gt;(extraNewsPost)

}

value: String?
"true" -&gt; a Boolean that has a true value
"20" -&gt; an Int that contains 20
"1223.2" -&gt; a Dobule
private fun insertRealType(map: WritableMap, key: String, value: String?) {

    val test = getValueType(value)

    when (test) {
        is String -&gt; map.putString(key, test)
        is Boolean -&gt; map.putBoolean(key, test)
        is Int -&gt; map.putInt(key, test)
        is Double -&gt; map.putDouble(key, test)
        else -&gt; map.putNull(key)
    }
}

private fun getValueType(value: String?): Any {

    var returnValue: Any?

    returnValue = value?.toDoubleOrNull()

    if (returnValue != null)
        return returnValue

    returnValue = value?.toIntOrNull()

    if (returnValue != null)
        return returnValue

    // ETC......
}

task { } successUi { }
succesUi
android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.
kovenant-callback-2
iv
ImageView
    val promesa1 = task {
        val nazwa = Thread.currentThread().name
        print(nazwa)
    } successUi {
        val nazwa = Thread.currentThread().name
        print(nazwa)

        try {
            iv!!.setImageBitmap(null)
        } catch (ex : Exception) {
            print("Mamy:"+ex.toString())
        }
    }

 private fun bindCameraUseCases() {      
       val metrics = DisplayMetrics().also { viewFinder.display.getRealMetrics(it) }
       ...
    }

 private fun bindCameraUseCases() {      
    val metrics = DisplayMetrics()
    viewFinder.display.getRealMetrics(metrics)
 }

override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

            if (currentUser != null) {


                for (profile in currentUser.getProviderData()) {
                    // check if the provider id matches "facebook.com"
                    if (FacebookAuthProvider.PROVIDER_ID.equals(profile.getProviderId())) {
                        facebookUserId = profile.getUid()
                    }
                }
            }

            val photoUrl =
                "https://graph.facebook.com/$facebookUserId/picture?height=500"

            Glide.with(this).load(photoUrl).into(buttonpp)

  buttonpp.setOnClickListener {
            val intent = Intent(Intent.ACTION_PICK)
            intent.type = "image/*"
            startActivityForResult(intent, 0)
        }
    }

    var selectedPhotoUri: Uri? = null

    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)

        if (requestCode == 0 &amp;&amp; resultCode == Activity.RESULT_OK &amp;&amp; data != null) {

            selectedPhotoUri = data.data

            val bitmap = MediaStore.Images.Media.getBitmap(getActivity()?.getContentResolver(), selectedPhotoUri)

            val bitmapDrawable = BitmapDrawable(bitmap)

            buttonpp.setImageBitmap(bitmap)


            uploadImageToFirebaseStorage()
        }


    }


    private fun uploadImageToFirebaseStorage(){
        if (selectedPhotoUri == null) return
        val filename = UUID.randomUUID().toString()
        val ref =FirebaseStorage.getInstance().getReference("/profileImaUrl/$filename")

        ref.putFile(selectedPhotoUri!!)
            .addOnSuccessListener {

                ref.downloadUrl.addOnSuccessListener {
                    it.toString()

                    saveUserToFirebaseDatabase(it.toString())
                }
            }

    }

    private fun saveUserToFirebaseDatabase(profileImaUrl: String) {
        val uid = FirebaseAuth.getInstance().uid ?: ""
        val ref = FirebaseDatabase.getInstance().getReference("/path/$uid")

        val user = User(uid, username.text.toString(), profileImaUrl)

        ref.setValue(user)


    }

}

private &lt;T&gt; Callable&lt;T&gt; createCallable(final Callable&lt;T&gt; task) {
    return () -&gt; {
        try {
            return task.call();
        } catch (Exception e) {
            handle(e);
            throw e;
        }
    };
}

private fun &lt;T&gt; createCallable(task: Callable&lt;T&gt;): Callable&lt;T&gt; {
    return {
        try {
            return task.call()
        } catch (e: Exception) {
            handle(e)
            throw e
        }
    }
}

sealed class Seal {
        object Type1
        object Type2
    }

when (thing) {
    is Type1 -&gt; {}//this returns true    
    is Seal -&gt; {}//this returns false
}

private fun openAboutDialogue() {
    //get a fragment manager
    val fm = fragmentManager
    val abtDialogue = GetStartedFragment()
    abtDialogue.show(fm, "About the App")
}

private fun openNewRouteDialogue() {
    val confirmNewDialogue = NewRouteFragment()
    val fm = fragmentManager
    confirmNewDialogue.show(fm, "NewRoute")
}

private fun openEndRouteDialogue() {
    val confirmEndDialogue = TrafficDataFragment()
    val fm = fragmentManager
    confirmEndDialogue.show(fm, "GetTraffic")
}

startActivityforResult
startActivityForResult(Intent(this@MainActivity2,MainActivity::class.java),1))

InputStream
OutputStream
val num = BigDecimal(3.div(6))

    println("%.6f".format(num))

when
Double?
Double::class.java
Double
?
?
     valueToSet = when(member?.getter?.returnType?.javaType) {
                Date::class.java -&gt; {                    
                    DateUtil.asDate(LocalDateTime.parse(value))
                }

                Integer::class.java -&gt; value.toInt()               
                Double::class.java -&gt; value.toDouble()

                else -&gt;value.toString();

            }

val myModule : Module = module {
  viewModel { MyViewModel(get()) } 
  single { MyRepository() }
}

var bookDetailsMap: MutableMap&lt;Long, MutableMap&lt;Long, Book&gt;&gt; = mutableMapOf()

var books: MutableList&lt;Book&gt; = this.bookDao.findAll()

var bookDetailsMap: MutableMap&lt;book.publisherId, MutableMap&lt;book.bookId, Book&gt;&gt;

myString.getBytes()
List
List
List
val rewards = ArrayList&lt;Map&lt;String, Int&gt;&gt;()
rangeExams
  .forEach { examAnswer -&gt;
    var reward = hashMapOf("Score" to examAnswer.answerScore)
    var questionIds = examAnswer
      .answers
      .map { it.id }

    reward.put("NewQuestion", questionIds.size)
    rewards.add(reward)
  }

class ExamAnswer (val id: String, val answerScore: Int, val answers:List&lt;Answer&gt;) 

Stream&lt;T&gt;
forEachIndexed {index, value -&gt; }
List&lt;T&gt;
private var destinies: MutableList&lt;String&gt; = ArrayList()

fun createDestinies(sources: List&lt;Source&gt;) {
    for (source in sources) {
        destinies.add(source.endpoint)
    }
}

interface Humenable{
    fun Run()
}

fun main(args:Array&lt;String&gt;)
{   


    class Student : Humenable{
    Overrides fun Run(){

            println("Pass")
            }

        }
    }

val AllPersons = mutableMapOf&lt;Long,Person&gt;() 
val ClassAttendants = mutableMapOf&lt;Long,Person&gt;()

data class Person( PID : Long
    Name: String
    Surname: String
    Father: Person?)

package some.meaningless.package.name

import kotlin.reflect.full.memberProperties

annotation class MyAnnotation()

@MyAnnotation
data class TestDto(@MyAnnotation val answer: Int = 42)

fun main(args: Array&lt;String&gt;) {
    TestDto::class.memberProperties.forEach { p -&gt; println(p.annotations) }
    println(TestDto::class.annotations)
}

[] 
[@some.meaningless.package.name.MyAnnotation()]

binding.pry
some_method          # Execution will stop here.
puts 'Goodbye World' # Run 'next' in the console to move here.

  class ListAdapter(var c: Context, var lists: ArrayList&lt;Employee&gt;,
     itemClickListener: Any?): RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() {
      override fun onCreateViewHolder(parent: ViewGroup?, viewType: Int): RecyclerView.ViewHolder {
       var v = LayoutInflater.from(c).inflate(R.layout.list_layout, parent, false)
        return Item(v)
      }
      override fun onBindViewHolder(holder: RecyclerView.ViewHolder?, position: Int) {
       (holder as Item).bindData(lists.get(position))
      }
      override fun getItemCount(): Int {
        return  lists.size;
        }
     class Item(itemView: View) : RecyclerView.ViewHolder(itemView) {
      fun bindData(_list: Employee)
      {
       itemView.textViewfirstname.text = _list.firstName
       itemView.textViewlastname.text = _list.lastName
      }
     }
    }

list.adapter = ListAdapter(this, getLists())

DelegateManager
IViewData
class DelegateManager&lt;T : IViewData&gt; {
    private val delegates: MutableList&lt;AdapterDelegate&lt;T&gt;&gt; = mutableListOf()

    fun addDelegate(adapterDelegate: AdapterDelegate&lt;T&gt;) {
        delegates.add(adapterDelegate)
    }
    ...
}

TrackListAdapter
AdapterDelegate&lt;TrackViewData&gt;
TrackViewData
IViewData
TrackListAdapter
class TrackListAdapter : BaseListAdapter&lt;IViewData&gt;() {
    init {
        delegateManager.addDelegate(TrackViewDelegate()) // error: Type mismatch -&gt; Required: AdapterDelegate&lt;IViewData&gt;, Found: TrackViewDelegate
    }
}

class TrackViewDelegate : AdapterDelegate&lt;TrackViewData&gt;() {
    override fun onCreateViewHolder(parent: ViewGroup): ListViewHolder&lt;TrackViewData&gt; {
        val itemView = LayoutInflater.from(parent.context).inflate(R.layout.track_item, parent, false)
        return TrackViewHolder(itemView)
    }

    override fun isDelegateForDataType(data: IViewData) = data is TrackViewData
}

OuterScope.this
open class SomeClass {
    open fun doSomething() {
        // ...
    }
}

class MyClass {
    fun someFunc() {
        object : SomeClass() {
            override fun doSomething() {
                super&lt;SomeClass&gt;.doSomething()
                // Access the outer class context, in Java
                // this would be MyClass.this
            }
        }
    }
}

        val myFiles = FileUtils.listFiles(mediaStorageDir, extensions, true) as ArrayList&lt;File&gt;

?:
null
  private fun extractProductAttributes(productEntity: JSONObject): List&lt;JSONObject&gt; {
        return productEntity.optJSONObject("Entity")
                ?.optJSONObject("Attributes")
                ?.optJSONArray("Attribute")
                ?.toList() as List&lt;JSONObject&gt;
                ?: listOf()
    }

null
    val startNight = "18:00"
    val startDay = "6:00"
    val formatDate = SimpleDateFormat("HH:mm")
    val parseNight = formatDate.parse(startNight)
    val parseDay = formatDate.parse(startDay)

    val currentTime = Calendar.getInstance().time;

    if (currentTime.after(parseNight)) {
        mMap.setMapStyle(MapStyleOptions.loadRawResourceStyle(this, R.raw.night_style))
    } else if (currentTime.after(parseDay)) {
        mMap.setMapStyle(MapStyleOptions.loadRawResourceStyle(this, R.raw.day_style))
    }

open class Base(open val input: String) {
  lateinit var derived: String

  init {
    derived = input.toUpperCase() // throws!
  }
}

class Sub(override val input: String) : Base(input)

println(Sub("test").derived)    

toUpperCase
input
null
input
this.input
this
input
input
class OuterClass {

    var myData:List&lt;MyData&gt; = List&lt;&gt;() //gets populated elsewhere

    fun getItemFragment(position:Int) : Fragment() {
        return InnerClass.Factory.newInstance(position)
    }

    inner class InnerClass : Fragment() {

        companion object Factory {

            fun newInstance(position:Int) : InnerClass {
                var ic : InnerClass = InnerClass()
                var bundle:Bundle = Bundle()
                bundle.putInt("index", position)
                ic.arguments = bundle
                return ic
            }

        }

        override fun onCreateView(inflater:LayoutInflater, container: ViewGroup, savedInstanceState:Bundle): View? {
            //create and return view, omitted. Need access to myData
    }
}

class User() {
    var i = 0

    fun simpleFoo() {
        println("Unit")
    }
}

class Either {
    lateinit var b: User

    fun foo(fnR: (User) -&gt; Any): Any = fnR(b)
}

class A {
    fun main() {
        val either = Either&lt;User&gt;()
        either.foo(::handleUser) // works fine
        either.foo() { user -&gt;
            user.i = 3 // Expected value of type Any
        }
    }

    fun handleUser(user: User) {
        user.simpleFoo()
    } 
}

public class CurrentPlayer(override val game: PewGame, spriteSheet: String) : Player(game, spriteSheet)

public open class Player(override val game: PewGame, spriteSheet: String) : MovingEntity, InputAdapter()

this.sprite = CharacterSpriteSheet(Utilities.createTextureFromFile(spriteSheet), this.game.getSpriteBatch(), 0.25f)

game
this
game
this.game
fun main(args: Array&lt;String&gt;): Unit { 
    println("Hello world!") 
}

E:\kotlinc\bin&gt;kotlinc-js -output test -sourceFiles test.kt
ERROR: E:\kotlinc\bin\test.kt: (4, 5) Unresolved reference: println
exec() finished with COMPILATION_ERROR return code

#!/usr/bin/env kscript
@file:DependsOn("oracle.jdbc:ojdbc8:12.2.0.1")
@file:MavenRepository("infosynergi","http://maven.infosynergi.no" )

import java.sql.*

"If readLine() is null or empty assign default value, else parse readLine()"

var inp = readLine()
val double = if(inp.isNullOrEmpty()) 0.0 else inp.toDouble()

offsetHeight
offsetWidth
Element
var e : Element? = document.getElementById("text")
e.offsetHeight //Error

HTMLInputElement
fun c2f(self: Any) {
   console.log("Self object: ${self} ")
   val celsius = document.getElementById("celcius")?.getAttribute("value") as Double
   val fahrenheit = celsius * 1.8 + 32
   console.log("Fahrenheit value: ${fahrenheit} ")
   window.alert("Celcius (${celsius}) -&gt; Fahrenheit (${fahrenheit}) ")
 }

toDouble()
String
when(row &amp;&amp; column) {
     in 0..2 -&gt; end = true;
     else -&gt; {
         end = false;
         println("Invalid move!")
     }
}

class Participant {
   var email = ""
}

class Reservation {
   var participants = ArrayList&lt;Participant&gt;()
}

val reservations = ArrayList&lt;Reservation&gt;()

reservations
fun randomDay() : String {
    val days = arrayOf("Monday", "Tuesday", "Wednesday")
    return days[Random().nextInt(3)]
}

Random().nextInt(3)
Random.nextInt(3)
sum()
val nums = listOf&lt;Long&gt;(-2, -1, 1, 2, 3, 4)
val sum = nums.sum(it &gt; 0)

 val fis = FileInputStream("resources/pairs_ids.txt")
    prop.load(fis);
    logger.info("ETH_BTC_id = " + prop.get("ETH_BTC"))

Exception in thread "main" java.io.FileNotFoundException: resources\pairs_ids.txt (The system cannot find the path specified)

class BaseParameterizedType&lt;T&gt;

fun &lt;U: BaseParameterizedType&lt;*&gt;&gt; getSpecific(clazz: KClass&lt;in U&gt;) : U {
     TODO()
}

fun example(arg: KClass&lt;out BaseParameterizedType&lt;*&gt;&gt;)) {
    getSpecific(arg.innerType)
}

public static final void example(@NotNull KClass arg) {
  Intrinsics.checkParameterIsNotNull(arg, "arg");
  getSpecific(arg.getInnerType());
  throw null;  // &lt;-- The problem
}

getSpecific(clz: KClass&lt;in U&gt;) : U
getSpecific(clz: KClass&lt;out U&gt;) : U
getSpecific(clz: KClass&lt;U&gt;) : U
getSpecific(clz: KClass&lt;in U&gt;) : BaseParameterizedType&lt;*&gt;
example(arg: KClass&lt;out BaseParameterizedType&lt;*&gt;)
example(arg: KClass&lt;BaseParameterizedType&lt;*&gt;&gt;)
public static final void example(@NotNull KClass arg) {
  Intrinsics.checkParameterIsNotNull(arg, "arg");
  getSpecific(arg.getInnerType());
}

getSpecific(BaseParameterizedType::class)

throw null
arg.innerType
KClass&lt;out BaseParameterizedType&lt;*&gt;&gt;
KClass&lt;in BaseParameterizedType&lt;*&gt;&gt;
U
BaseParamterizedType&lt;*&gt;&gt;
throw null
getSpecific
interface class  IPage {

}

enum class Page1 : IPage{ ..... }
enum class Page2 : IPage{ ..... }

fun getPage(isSomeCondition : Boolean) : IPage{
    if(isSomeCondition) return Page1 
    else return Page2
}

enum Page1(val title: String, val data : Data)

 enum Page1(val title: String, val data : Data){
    PARENT("Heiachi", ParentData(...)),
    CHILD("JIN", ChildData(...))

 }


enum Page2(val title: String, val data : Data){
        PARENT("Hworang", FriendData(...)),
        CHILD("Yoshimitsu", FoeData(....))

}

class ParentData : Data 
class ChildData : Data
class FriendData : Data
class FoeData : Data

Ctrl+Alt+B
List&lt;&gt;
Activity::class.java
val list3: MutableList&lt;Int&gt; = mutableListOf(6,7,8) 
list3.add(5)
println("list3 last item: ${list3.last()}")

list3 last item: 5

class Tag {
  protected val children = arrayListOf&lt;Tag&gt;()
  operator fun String.unaryPlus() = children.add(Text(this))
}
class TagWithChildren : Tag() {
  fun head(init: Head.() -&gt; Unit) = initializeTag(Head(), init)
  fun script(init: Script.() -&gt; Unit) = initializeTag(Script(), init)
  fun &lt;T : Tag&gt; initializeTag(tag: T, init: T.() -&gt; Unit): T {
    tag.init()
    children.add(tag)
    return tag
  }
}
class Head : TagWithChildren()
class Script : Tag()
class Text(val str: Text) : Tag()

Head
head
script
Script
head {
    script {
        +"alert('hi');"
    }
}

script
Script
head {
    script {
        script {
            +"alert('hi');"
        }
    }
}

head {
    script {
    }
    script {
        +"alert('hi');"
    }
}

let
    someMethodCall()?.let{
        // ....
        // some code here
        // ....
        val resultCall = it
        someMethod2Call()?.let {
            // ...
            val myVariable = it + resultCall
            // ... 
        }
    }

let
it
let
resultCall
class Person(first: String, last: String, age: Int){ 

    init{
        println("Initializing")
    }

}

first
last
class Person(first: String, last: String, age: Int){  

    // Secondary constructor
    constructor(fullname: String, age: Int):
        this("first", "last", age)
        {
            println("In secondary constructor")
        }

    init{
        println("Initializing")
    }
}

fullname
constructor(fullname: String, age: Int):
var first = fullname.split()[0];
...
{
    println("In secondary constructor")
}

this
constructor(fullname: String, age: Int):
{
    var first = fullname
    this(first, "foo", age)
    println("In secondary constructor")
}

invoke
somevariable.value?.add()
kotlinc-js -output binom.js -library-files sample-library.jar binom.kt

Invalid argument: -library-files
Usage: kotlinc-js &lt;options&gt; &lt;source files&gt;
where possible options include:
  -output &lt;path&gt;             Output file path
  -no-stdlib                 Don't use bundled Kotlin stdlib
  -libraries &lt;path&gt;          Paths to Kotlin libraries with .meta.js and .kjsm files, separated by system file separator
  -source-map                Generate source map
  -meta-info                 Generate .meta.js and .kjsm files with metadata. Use to create a library
  -target { v5 }             Generate JS files for specific ECMA version
  -module-kind { plain, amd, commonjs, umd }
                         Kind of a module generated by compiler
  -main {call,noCall}        Whether a main function should be called
  -output-prefix &lt;path&gt;      Path to file which will be added to the beginning of output file
  -output-postfix &lt;path&gt;     Path to file which will be added to the end of output file
  -language-version &lt;version&gt; Provide source compatibility with specified language version
  -api-version &lt;version&gt;     Allow to use declarations only from the specified version of bundled libraries
  -nowarn                    Generate no warnings
  -verbose                   Enable verbose logging output
  -version                   Display compiler version
  -help (-h)                 Print a synopsis of standard options
  -X                         Print a synopsis of advanced options
  -P plugin:&lt;pluginId&gt;:&lt;optionName&gt;=&lt;value&gt;
                         Pass an option to a plugin

@ExperimentalTime
withType&lt;org.jetbrains.kotlin.gradle.tasks.KotlinCompile&gt;().all {
    kotlinOptions.freeCompilerArgs += "-Xuse-experimental=kotlin.time.ExperimentalTime"
}

data class PenceAmount(
    val one: Int,
    val two: Int,
    val five: Int,
    val ten: Int,
    val twenty: Int,
    val fifty: Int,
    val pound: Int,
    val twoPound: Int) {}

PenceAmount
+
operator fun plus(other: PenceAmount) : PenceAmount {
    return PenceAmount(this.one + other.one,
            this.two + other.two,
            this.five + other.five,
            this.ten + other.ten,
            this.twenty + other.twenty,
            this.fifty + other.fifty,
            this.pound + other.pound,
            this.twoPound + other.twoPound)
}

List&lt;Week&gt;
Week
List&lt;Day&gt;
MultiValuedMap
keySet()
platform declaration clash: The following declarations have the same JVM signature (keySet()Ljava/util/Set;)

abstract class ConfigProperties&lt;K, V&gt;(delegate: Map&lt;K, V&gt;?): MultivaluedMap&lt;String, String&gt; {

  protected val delegate: Map&lt;K, V&gt;

  init {
      if (delegate == null) {
          throw NullPointerException("Config properties delegate must not be null.")
      }
      this.delegate = delegate
  }

  abstract fun putCacheProperty(key: Parameter, value: Any)

  abstract fun getCacheProperty(key: Parameter): Any

  protected val UNSUPPORTED_MESSAGE = "ConfigProperties is immutable."


  override fun keySet(): Set&lt;String&gt; {
      return delegate.keys
  }

Long.valueOf(String s)
var products = HashMap&lt;Int, Pair&lt;String, Double&gt;&gt;()

val highestPricedProduct = products.maxBy { it.value.second }
println("The highest priced product is: ")
println()
println("Item#    Description      Price")
println("-----    -------------    -------")
println("$highestPricedProduct")

The highest priced product is:

Item#    Description      Price
-----    -------------    -------
123=(jeans, 19.5)

The highest priced product is:

Item#    Description      Price
-----    -------------    -------
123      jeans            $19.50

// unresolved reference: defaultText
class MyThing(val text: String = defaultText()) {  
    fun defaultText() = "hi"
}

class MyThing {

    private val text: String

    constructor(text: String) {
        this.text = text
    }

    constructor() {
        this.text = defaultText()
    }

    private fun defaultText(): String {
        return "hi"
    }
}

package maxindex

import kotlin.collections.*

fun indexOfMax(a: IntArray): Int? {
    if (a.isNotEmpty()) {
        var maxValue = a.max()
        return a.indexOf(maxValue) // Type mismatch
    } else {
        return null
    }
}

typealias TestContext&lt;F&gt; = ContextBuilder&lt;F&gt;

@Deprecated("TestContext is now ContextBuilder", 
    replaceWith = ReplaceWith("ContextBuilder&lt;F&gt;"))

TextContext&lt;Unit&gt;
ContextBuilder&lt;F&gt;
@Deprecated("TestContext is now ContextBuilder", 
    replaceWith = ReplaceWith("ContextBuilder"))

TextContext&lt;Unit&gt;
ContextBuilder
TextContext&lt;Unit&gt;
ContextBuilder&lt;Unit&gt;
fun prepareDots(currentSlidePosition: Int, maxsize : Int) {
        if (dotContainer.childCount &gt; 0) {
            dotContainer.removeAllViews()
        }
        val params : LinearLayout.LayoutParams = LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT, // This will define text view width
            ViewGroup.LayoutParams.WRAP_CONTENT // This will define text view height
        )
        val dots = ArrayList&lt;ImageView&gt;()
        for (i in 0.. maxsize) {
            val imageView = ImageView(this)
            imageView.layoutParams =params
            params.setMargins(4,0,4,0)
            if (i == current_position) {
                imageView.setImageResource(R.drawable.inactive_dot)
                Log.d("Ok","Ok")
                dots.add(i, imageView)
            } else {
                imageView.setImageResource(R.drawable.inactive_dot)
                dots.add(i, imageView)
                Log.d("Ok","Fail")
            }
            Log.d("indicator", i.toString())
//            dotContainer.addView(dots[i], i)
        }
        dots.forEachIndexed{index, imageView -&gt;
            dotContainer.addView(imageView, index)
        }
    }

class A
{
    val b:B
    val at:String
    init
    {
        b=B(this)
        at="A's text"
    }
}

class B(a:A)
{
    val bt:String
    init
    {
        bt= if(a.at!=null) a.at.replaceFirst("A's","B's") else "else's text"
    }

}

play-billing-samples
localCacheBillingClient
lateinit
if (::localCacheBillingClient.isInitialized == false) {...}
class BillingRepository private constructor(private val application: Application) :
        PurchasesUpdatedListener, BillingClientStateListener {

     lateinit private var localCacheBillingClient: LocalBillingDb


    val subsSkuDetailsListLiveData: LiveData&lt;List&lt;AugmentedSkuDetails&gt;&gt; by lazy {
        if (::localCacheBillingClient.isInitialized == false) {
            localCacheBillingClient = LocalBillingDb.getInstance(application)
        }
        localCacheBillingClient.skuDetailsDao().getSubscriptionSkuDetails()
    }

    val inappSkuDetailsListLiveData: LiveData&lt;List&lt;AugmentedSkuDetails&gt;&gt; by lazy {
        if (::localCacheBillingClient.isInitialized == false) {
            localCacheBillingClient = LocalBillingDb.getInstance(application)
        }
        localCacheBillingClient.skuDetailsDao().getInappSkuDetails()
    }

   fun startDataSourceConnections() {
        Log.d(LOG_TAG, "startDataSourceConnections")
        instantiateAndConnectToPlayBillingService()
        localCacheBillingClient = LocalBillingDb.getInstance(application)
    }
    ...
}

class BillingRepository private constructor(private val application: Application) :
        PurchasesUpdatedListener, BillingClientStateListener {

    private val localCacheBillingClient: LocalBillingDb by lazy {
         LocalBillingDb.getInstance(application)
    }

    val subsSkuDetailsListLiveData: LiveData&lt;List&lt;AugmentedSkuDetails&gt;&gt; by lazy {
        localCacheBillingClient.skuDetailsDao().getSubscriptionSkuDetails()
    }


    val inappSkuDetailsListLiveData: LiveData&lt;List&lt;AugmentedSkuDetails&gt;&gt; by lazy {
        localCacheBillingClient.skuDetailsDao().getInappSkuDetails()
    }

   fun startDataSourceConnections() {
        Log.d(LOG_TAG, "startDataSourceConnections")
        instantiateAndConnectToPlayBillingService()        
    }
    ...
}

public class Code {
    public static final int SUCCESS = 0;
    public static final int FAIL = 1;
}

object ResponseCode : Code() {
    val SKU_STOCK_NOT_ENOUGH = 2000
}

document.getElementById("jvmLink").unsafeCast&lt;HTMLDivElement&gt;().innerHTML = buildString {
    appendHTML().a(href = "$url&amp;jvm=false", target = "_blank") {
        +"Open JVM image in new window"
    }
}

SupportUsLevel
numeric
Int
other
enum class SupportUsLevel(val value: String) {

    red("red"),
    blue("blue"),
    black("black");

    val numeric: Int
        get() {
            when (this) {
                red -&gt; return 1
                blue -&gt; return 5
                black -&gt; return 7
            }
        }

    //return 0 if equal, negative (-1) is smaller, positive(+1) is bigger
    operator fun SupportUsLevel.compareTo(other: SupportUsLevel?) : Int {
        //if other is null, since I cannot be null, I am always bigger
        if (other == null) {
            return 1
        }
        //return numeric comparison since we both now have a value (due to null-check before)
        return numeric.compareTo(other.numeric)
       }
}

val a = listOf("foo bar", "foo bar baz", "bar", "bar")
val b = a.count {it.contains("bar")}
val aa = a.map { it.replace("bar", "baz") }
var c = aa.count {it.contains("bar")}
println("replaced: ${b-c}")

var a = 1
var b = 2
var c = 3

var d = a +
    b +
    c

println(d) // prints "6"

var e = a
    + b
    + c

println(e) // prints "1"

var e = a
+ b
+ c

+ somevariable
println(+somevariable)
println(somevariable)
fun main (){
    run(::topLevel)
    run{::topLevel}
    run{topLevel()}
    run(topLevel())
    }
fun topLevel() = println("print something")

val dateTime = DateTime()
val withTimeAtStartOfDay = dateTime
        .minusYears(1)
        .withTimeAtStartOfDay()

println(withTimeAtStartOfDay.toString())

inline fun createUtcDate(block: DateTime.() -&gt; DateTime): String {
    val dateTime = DateTime()
    return dateTime.block().toString()
}

withTimeAtStartOfDay()
val utcDate = createUtcDate {
    minusYears(1)
    withTimeAtStartOfDay()
}
println(utcDate)

private var foo: Foo? = null

fun generateFoo(bar: Bar): Foo {
    var localFoo = foo
    if (localFoo == null) {
        localFoo = Foo(bar)
        foo = localFoo
    }
    return localFoo
}

fun generateFoo(bar: Bar): Foo {
    var localFoo = foo ?: Foo(bar)
    foo = localFoo
    return localFoo
}

"a vect" -&gt; [
     a vect  :
     a vec   :   t
     a ve    :   ct
     ...
] 

val seq = sequenceOf(canonicalisedInput.lastIndex + 1 downTo 0).map {
    canonicalisedInput.substring(0, it) to canonicalisedInput.substring(it)
}

substring
Int
it
downTo
IntProgression
substring
class A { MutableList&lt;B&gt; array1 = mutableListOf() }

class B { }

class Ba : B { MutableList&lt;C&gt; array2 = mutableListOf() }

class C { var name: String }

val itemA = A()
val itemBa = Ba()
itemBa.array2.add(C("name"))
itemA.array1.add(ItemBa)

for(arr1 in itemA.array1)
   for(arr2el in arr1.array2)
      print(arr2el.name)

GlobalScope.launch {

}

fun myMethod() {
    GlobalScope.launch {
        // do some networking code
    }   
}

GlobalScope
runBlocking {
    async {
        // do some networking code
    }
}

runBlocking
public class ProxyRetrofitQueryMap extends HashMap&lt;String, Object&gt; {
public ProxyRetrofitQueryMap(Map&lt;String, Object&gt; m) {
    super(m);
}

@Override
public Set&lt;Entry&lt;String, Object&gt;&gt; entrySet() {
    Set&lt;Entry&lt;String, Object&gt;&gt; newSet = new HashSet&lt;&gt;();

    return newSet;
}

Pair&lt;out A, out B&gt;

first
second
Pair(first: A, second: B)

OtherClass&lt;Int, Int&gt;
Pair
https://pastebin.com/n6UgNXS2

 &lt;GridLayout
            android:alignmentMode="alignMargins"
            android:columnOrderPreserved="false"
            android:layout_marginTop="20sp"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:columnCount="3"
            android:rowCount="11"&gt;




            &lt;!-- A - B - C --&gt;
            &lt;androidx.cardview.widget.CardView
                android:layout_gravity="center"
                android:id="@+id/letteraA"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_row="0"
                android:layout_rowWeight="1"
                android:layout_column="0"
                android:layout_columnWeight="0"
                android:layout_margin="10dp"

                app:cardCornerRadius="30dp"&gt;

                &lt;LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="match_parent"
                    android:gravity="center"
                    android:orientation="vertical"
                    android:padding="20dp"&gt;

                    &lt;ImageView
                        android:layout_width="70dp"
                        android:layout_height="70dp"
                        android:src="@drawable/lettera" /&gt;

                &lt;/LinearLayout&gt;

            &lt;/androidx.cardview.widget.CardView&gt;

val input = arrayOf(1.3, 4.5)
val output = arrayOf(3) // Error Kotlin: Type mismatch: inferred type is Array&lt;Int&gt; but Array&lt;Any&gt; was expected

magic(input, output)

fun magic(input: Array&lt;Any&gt;, output: Array&lt;Any&gt;) {
  // Do the magic
}

data class Test(val value: Int)

Int
class Foo {
  companion object {
     fun a() : Int = 1
  }
  fun b() = a() + 1
}

object FooStatic {
   fun a() : Int = 1
}

class Foo {
  fun b() = FooStatic.a()
}

associateBy
    data class Combine(val alpha: String, val num: Int)
    val list = arrayListOf(Combine("a", 1), Combine("b", 2), Combine("c", 3), Combine("a", 4))
    val mapOfList = list.associateBy ( {it.alpha}, {it.num} )
    println(mapOfList)

class Car{
    //any code you imagine
}

class Garage{
//any code
fun Car.boost(){
    //boost implementation
}
}

fun wrapInTransaction(code: () -&gt; Unit) {
        realmInstance.beginTransaction();
        code.invoke()
        realmInstance.commitTransaction();
}

realmInstance
mutableList
fun Classroom.setNewParameters(id: String, modifiedName: String) {
    this.students.filter { l -&gt; l.id == id }
                 .map { l -&gt; l.name = modifiedName }
                 .toList()
}

students
fun Classroom.setNewParameters(id: String, modifiedName: String) {
    for (l : Student in this.students) {
        if (l.id == id) {
            l.name = modifiedName
            break
        }
    }
}

var dog = Animal(true, 5)
var cat = Animal(true, 4)
var turtle = Animal(false, 3)
val animalList = listOf&lt;Animal&gt;(dog, cat, turtle)

class Animal(isMammal: Boolean, numberOfAnimal: Int) {
    private var _isMammal:Boolean = false
    private var _count: Int = 0
    init {
        _isMammal = isMammal
        _count = numberOfAnimal
    }
    fun getType(): String {
        if(_isMammal) {
            return "Mammal"
        }
        else {
            return "Not A Mammal"
        }
    }
    fun updateCount(modifyAnimalCountBy:Int)
    {
        _count = _count + modifyAnimalCountBy
    }
    fun getCount(): Int {
        return _count
    }
}

public void doSomething() {
    final boolean promote = false;
    final String bob;

    if (promote) {
        try(StringWriter sw = new StringWriter()) {
            sw.write("this is a test");
            bob = sw.toString();
        } catch (IOException e) {
            e.printStackTrace();
            throw new IllegalStateException();
        }
    } else {
        bob = "anaconda";
    }

    System.out.println(bob);
}

    val promote = false
    val bob: String

    if (promote) {
        try {
            StringWriter().use { sw -&gt;
                sw.write("this is a test")
                bob = sw.toString()
            }
        } catch (e: IOException) {
            e.printStackTrace()
            throw IllegalStateException()
        }
    } else {
        bob = "anaconda"
    }

    println(bob)

Variable 'bob' must be initialized.
bob
bob
var
val calendar = Calendar.getInstance()
calendar.add(Calendar.DAY_OF_YEAR, -daysAgo)

            val date = LocalDate.parse(time)    
            val cal = Calendar.getInstance()
            cal.time = java.sql.Date.valueOf(date.toString())
            cal.add(Calendar.DAY_OF_YEAR, -daysAgo)

KClass&lt;T&gt;
@Suppress(&quot;UNCHECKED_CAST&quot;)
inline fun &lt;reified T : Any&gt; KClass&lt;T&gt;.getProperties(): Iterable&lt;KProperty1&lt;T, *&gt;&gt; {
    return members.filter { it is KProperty1&lt;*, *&gt; }.map { it as KProperty1&lt;T, *&gt; }
}

data class Foo(val bar: Int) {
    val baz: String = String.EMPTY
    var boo: String? = null
}

val properties = Foo::class.getProperties()

fun getNewSet(oldSet: Set&lt;String&gt;): Set&lt;String&gt; {
return oldSet
        .map{ getNewStringFromOld(it) }
        .toSet()
}

public class Constants {
    public static final String KIND_NAME = "user";
    public static final String AVATAR_IMAGE_ID = "avatarImageId";
    public static final String AVATAR_IMAGE_URL = "avatarImageUrl";
    public static final String NAME_COLUMN = "name";
    public static final String TOTAL_SCORE_COLUMN = "totalScore";
    ...
}

...
String userName = user.getProperty(Constants.KIND_NAME);
...

compareTo
dog
dog
compareTo
Animal
abstract class Animal{
    abstract fun compareTo(other: Animal)
    // I want to implement like `abstract fun compareTo(other: this::class)`
}

class Dog: Animal(){
    override fun compareTo(other: Animal) {
        assert(other is Dog)
        // do something
    }
}

class Cat: Animal(){
    override fun compareTo(other: Animal) {
        assert(other is Cat)
        // do something
    }
}

URL url = new URL(urlSpec);
HttpURLConnection connection = (HttpURLConnection)url.openConnection();
InputStream in = connection.getInputStream();
int bytesRead = 0;
byte[] buffer = new byte[1024];
while ((bytesRead = in.read(buffer)) &gt; 0) {
    out.write(buffer, 0, bytesRead);
}
out.close();

while(bytesRead = in.read(buffer))

class Foo {
    fun bar(foo: List&lt;String&gt;): String {
        return ""
    }

    fun bar(foo: List&lt;Int&gt;): Int {
        return 2;
    }
}

class Foo {
    fun bar(foo: List&lt;String&gt;): String {
        return ""
    }

    fun bar(foo: List&lt;Int&gt;): String {
        return "2";
    }
}

Error:(8, 5) Kotlin: Platform declaration clash: The following declarations have the same JVM signature (foo(Ljava/util/List;)Ljava/lang/String;):
    fun foo(layout: List&lt;Int&gt;): String
    fun foo(layout: List&lt;String&gt;): String

class Foo {
    String bar(List&lt;Integer&gt; foo) {
        return "";
    }

    Integer bar(List&lt;String&gt; foo) {
        return 2;
    }
}

class Foo {
    String bar(List&lt;Integer&gt; foo) {
        return "";
    }

    String bar(List&lt;String&gt; foo) {
        return "2";
    }
}

Error:(13, 12) java: name clash: bar(java.util.List&lt;java.lang.String&gt;) and bar(java.util.List&lt;java.lang.Integer&gt;) have the same erasure

val num1: Int? = someObject.number
val num2: Int? = anotherObject?.anotherNumber
val numToFallBack = 2

val result: Int
if(number1 != null &amp;&amp; number2 != null) {
   result = minOf(number1, number2)
}
else {
   result = number1?:number2?:numToFallBack
}

num1
num2
null
null
class NavigationItem(
    val title: String,
    val parent: NavigationItem?
) {
    val children: MutableList&lt;NavigationItem&gt; = mutableListOf()
    val isLeaf: Boolean
        get() = children.count() == 0

    val allChildren: List&lt;NavigationItem&gt;
        get() = children.flatMap {
            it.allChildren
        }
}

allChildren
allChildren
@Test
fun testAllChildrenProperty() {
    val root = NavigationItem("Root", null).apply {
        children.add(NavigationItem("Level 1", this))
        children.add(NavigationItem("Level 1", this))
    }
    assertEquals(2 ,root.allChildren.count())
}

(0..6).forEach { colorized(colors, it) }
(6 downTo 0).forEach { colorized(colors, it) }

fun test(a: Int, b: Int) : Int {
    return a / b
}

interface CoroutineActivity {

    // how can I call this function in example below?
    fun CoroutineScope.onCreate(savedInstanceState: Bundle?)
}

class CoroutineActivityDelegate(private val coroutineActivity: CoroutineActivity) {

    fun onCreate(savedInstanceState: Bundle?) {

        val onCreateScope = CoroutineScope(Dispatchers.Main + Job())

        // how do I call an extension function with a receiver? This doesn't compile
        coroutineActivity.onCreate(onCreateScope, savedInstanceState)
    }
}

CoroutineScope
fun main(args: Array&lt;String&gt;) {
    class Foo {
        val check: Boolean get() = 3 % 2 == 0
    }

    val f = Foo()
    println(f.check)
}

fun main(args: Array&lt;String&gt;) {
    class Foo {
        val check: Boolean = 3 % 2 == 0
    }

    val f = Foo()
    println(f.check)
}

class SportMan(
   val name: String,
   val points: Double,
}

SportGuysList
Sportman
SportGuysList
Sportman
    var myvar = mapOf("x" to 0.000001, "y" to 0.00000023)

    for((k, v) in myvar){
        println(v)
    }
//Its showing the result
1.0E-6
2.3E-7


    val x: Array&lt;Int&gt; = arrayOf(1, 2, 3, 4, 5)
    val y: List&lt;Int&gt; = listOf(1, 2, 3, 4, 5)
    println(x.javaClass)
    println(y.javaClass)

[Ljava.lang.Integer
// base class
class Whatever() {
    ...
}

// constructor method extension
fun Whatever.constructor(potato: String) {
    setPotato(potato)
}

fun main(args: Array&lt;String&gt;) {
    println(Whatever("holi"))
}

fun task(): List&lt;Boolean&gt; {
    val isEven: Int.() -&gt; Boolean = { this % 2 == 0 }
    val isOdd: Int.() -&gt; Boolean = { this % 2 != 0 }

    return listOf(42.isOdd(), 239.isOdd(), 294823098.isEven())
}

task()
interface A {
    fun move(s:Boolean): Int
}

class X{
    fun draw (x: A): String{
        return "A"
    }

    fun main() {
      val temp = A {
          s -&gt; 100
      }
      val a = draw ( { x -&gt; 100} )
    }
}

temp
a
temp
val temp = object : A {
        override fun move(s: Boolean): Int {
            return 100
        }
    }

a
for in
native("document")
val ndoc: dynamic = noImpl

fun jsInterOp() {
    js("console.log('JS inling from kotlin')")

    val ies = ndoc.getElementsByTagName("input")
    for (e in ies) {
      console.log("Input element ID: ${e.id}")
    } 
}

Uncaught TypeError: r.iterator is not a functionKotlin.defineRootPackage.kotlin.Kotlin.definePackage.js.Kotlin.definePackage.iterator_s8jyvl$ @ kotlin.js:2538

    jsInterOp: function () {
      var tmp$0;
      console.log('JS inling from kotlin');
      var ies = document.getElementsByTagName('input');
      tmp$0 = Kotlin.modules['stdlib'].kotlin.js.iterator_s8jyvl$(ies);
      while (tmp$0.hasNext()) {
        var e = tmp$0.next();
        console.log('Input element ID: ' + e.id);
      }
    },

 Caused by: java.lang.ExceptionInInitializerError
    at com.myapp.model.location.CountryList.getSelectableCountryList(CountryList.kt:19)
    at com.myapp.ui.util.CountryStateSpinnerSet.&lt;init&gt;(CountryStateSpinnerSet.java:43)
    at java.lang.reflect.Constructor.newInstance0(Native Method) 
    at java.lang.reflect.Constructor.newInstance(Constructor.java:343) 
    .
    .
    .
 Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'java.lang.Object java.util.HashMap.get(java.lang.Object)' on a null object reference
    at com.myapp.model.location.Country.&lt;init&gt;(Country.kt:31)
    at com.myapp.model.location.Country.&lt;init&gt;(Country.kt:17)
    at com.myapp.model.location.Country.&lt;clinit&gt;(Country.kt:19)
    at com.myapp.model.location.CountryList.getSelectableCountryList(CountryList.kt:19) 
    at com.myapp.ui.util.CountryStateSpinnerSet.&lt;init&gt;(CountryStateSpinnerSet.java:43) 
    at java.lang.reflect.Constructor.newInstance0(Native Method) 
    at java.lang.reflect.Constructor.newInstance(Constructor.java:343) 
    .
    .
    .

object CountryList {
  val countryList: List&lt;Country&gt;
    get() {
        return listOf(
                Country.UNITED_STATES, Country.CANADA
        )
    }

  @JvmStatic val selectableCountryList: List&lt;Country&gt;
    get() {
        val countryList: MutableList&lt;Country&gt; = mutableListOf(Country.SELECT) &lt;-- the ExceptionInInitializerError occurs on this line
        countryList.addAll(countryList)

        return countryList
    }
}

data class Country(val name: String, val abbrev: String = ""): Parcelable {
  companion object {
    val SELECT = Country("Select Country")

    val UNITED_STATES = Country("United States", "US")
    val CANADA = Country("Canada", "CA")

    private var countryStateMap: HashMap&lt;Country, StateList&gt; = hashMapOf(
        UNITED_STATES to USStateList(),
        CANADA to CanadaProvinceList()
    )
  }

@IgnoredOnParcel
val stateList: StateList = countryStateMap[this]!!

@IgnoredOnParcel
val selectableStateList: List&lt;State&gt;
    get() = if (null != countryStateMap[this]) {
        countryStateMap[this]!!.selectableStateList
    }
    else {
        throw IllegalStateException("Can't retrieve selectable state list with country: $this")
    }

override fun toString(): String {
    val sb = StringBuilder()
    if (abbrev.isNotEmpty()) {
        sb.append(abbrev)
        sb.append(" - ")
    }
    sb.append(name)
    return sb.toString()
}
}

sealed class SubscriptionServiceResponse&lt;T&gt;
data class UserRecognized&lt;T&gt;(val recognizedUser: RecognizedUser, val response: T) : SubscriptionServiceResponse&lt;T&gt;()
data class UserNotRecognized&lt;T&gt;(val ignored: Boolean = true) : SubscriptionServiceResponse&lt;T&gt;()

UserNotRecognized
object
object UserNotRecognized : SubscriptionServiceResponse()

ignored
object
sealed class
import com.a.typical.super.long.package.which.contains.ModelId

interface ClientOrca {

  fun test(): ModelId
}

[ERROR] &lt;ClientKt&gt;:[1,8] Unresolved reference: com
[ERROR] &lt;ClientKt&gt;:[5,15] Unresolved reference: ModelId

fun main(args: Array&lt;String&gt;) {
val warehouse = Warehouse()
...
println("Show info")
showInfo(warehouse)
}

    fun showInfo(warehouse: Warehouse) {
    println("Get Info")
    val input = readLine() ?: "-"
    val p = warehouse.getProductByName(input)
    if (p != null) {
        println("Product: $p")
        println("Number of items: ${p.availableItems}")
        println("Profit: ${p.profitPerItem}")
    }
}

    class Warehouse {
    private val products = mutableListOf&lt;Product&gt;()
    ...
    fun getProductByName (productName: String): Product? {
        for (prod in products)
            if (prod.productName == productName) return prod
    return null
    }

  fun fillWarehouse (productName: String,
                   basePrice: Double,
                   productDescription: String,
                   chargeOnTop: Double = 50.0,
                   intialStockUnits: Int = 3) {

    val newProduct = Product(productName, basePrice, basePrice * (1 + chargeOnTop / 100), productDescription)
    //add quantity, daysBeforeExpiration
    for (i in 1 .. intialStockUnits){
        val unit = StockUnit(Random.nextInt(),Random.nextInt() )
            newProduct.addStock(unit)
    }

    open class Product(
   val productName: String,
    var basePrice: Double,
    open val salesPrice: Double,
    val description: String) {

   ...
    var stockUnits = mutableListOf&lt;StockUnit&gt;()
   ...
    // availableItems = Total of stockUnits
    var availableItems: Int = 0
        get() = stockUnits.sumBy { it.quantity }
    }

    class StockUnit(var quantity:Int, var daysBeforeExpiration:Int){
    ...
}

inner class TodoListFragmentRecyclerViewAdapter : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() {
        val doListDTOs =  ArrayList&lt;DoListDTO&gt;()

        init {
            Log.e("1","1")
            doListListenerRegistration = fireStore.collection("doList").whereEqualTo("doListName",todoList_name).orderBy("doListTimestamp", Query.Direction.DESCENDING).limit(100)
                .addSnapshotListener { querySnapshot, firebaseFirestoreException -&gt;
                    if (querySnapshot == null) return@addSnapshotListener
                    doListDTOs.clear()
                    for (snapshot in querySnapshot.documents) {
                        val item = snapshot.toObject(DoListDTO::class.java)
                        doListDTOs.add(item!!)
                        Log.e("2",doListDTOs.toString())
                        notifyDataSetChanged()
                    }
                }
            Log.e("3",doListDTOs.toString())
        }
}

1 -&gt; 2 -&gt; 3
1 -&gt; 3 -&gt; 2
&lt;TOKENS, Strings&gt;
...
Pair(IDENTIFIER, "A"),
Pair(TICKTICK, "``"),
Pair(IDENTIFIER, "_B")
...

...
Pair(IDENTIFER, "A_B")
...

TICKTICK
for
TICKTICK
iterator().previous
^=
a ^= b
// a = a ^ b

a = a xor b

a
interface ResponseCallback&lt;T&gt; {
    fun onSuccess(response: T)
    fun onError(code: Int, message: String)
}

createRequest(getLogin(id), object : API.ResponseCallback&lt;LoginResponse&gt;{
    override fun onError(code: Int, message: String) {
    }

    override fun onSuccess(response: LoginResponse) {
    }
})

fun createRequest(source: Observable&lt;*&gt;, callback: ResponseCallback&lt;*&gt;) {
    disposable.add(
        source.subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(
                { it -&gt;
                    //
                    // callback.onSuccess(it)

                },
                {

                }
            )
    )
}

callback.onSuccess()
Nothing
callback.onSuccess(it)
compareTo()
compare()
data class MyDate(val year: Int, val month: Int, val dayOfMonth: Int) : Comparable&lt;MyDate&gt; {
    override fun compareTo(otherDate: MyDate): Int = when {
        year != otherDate.year -&gt; year - otherDate.year
        month != otherDate.month -&gt; month - otherDate.month
        else -&gt; dayOfMonth - otherDate.dayOfMonth
    }
}

fun compare(date1: MyDate, date2: MyDate) = date1 &lt; date2

val sql = getResource(this.javaClass, "foo.sql")

val sql = getResource(::MyClass.javaClass, "foo.sql")

public
@Inject
var repository: MyExampleRepository? = null
    private get

private
public
@Inject
private var repository: MyExampleRepository? = null
    public set

service.repository = null
Kotlin: Cannot access 'repository': it is 'private' in 'MyService'

computed properties
class Car(val color: String)

true
fun isWhite(car: Car): Boolean {
  return car.color == "WHITE"
}

member function
class Car(val color: String) {
  fun isWhite(): Boolean = color == "WHITE"
}

class Car(val color: String) {
  val isWhite: Boolean get() = color == "WHITE"
}

fun myMethod(thing: T){}

class MyClass : IMyInterface{}

    interface IMyInterface &lt;T&gt;{
fun myMethod(thing: T){}
}

class MyClass: IMyInterface&lt;MyClass&gt;{
  override fun myMethod(thing: MyClass){} // &lt;&lt;&lt;-- the type is set because I explicitly set it above
    }

interface IMyInterface{
fun myMethod(thing: T){}
}

class MyClass: IMyInterface{
  override fun myMethod(thing: MyClass){} // &lt;&lt;&lt;-- the template type &lt;T&gt; of the interface is resolved by the compiler by checking what type I provided in method signature (
    }

class MyQueryHandler(): QueryHandler&lt;MyQuery, MyReturnType&gt;

class MyQuery(val query: String) : Query&lt;MyReturnType&gt;

registerQueryHandler
registerQueryHandler

fun &lt;Q : Query&lt;V&gt;, V&gt; registerQueryHandler(aClass: Class&lt;Q&gt;, queryHandler: QueryHandler&lt;Q, V&gt;)

class SimpleQueryBusPostProcessor(
    private val queryHandlers: List&lt;QueryHandler&lt;Q&lt;V&gt;, V&gt;&gt;,
    private val beanNameSelector: String
) : BeanPostProcessor {

    override fun postProcessAfterInitialization(bean: Any, beanName: String): Any? {
        if (beanName == beanNameSelector &amp;&amp; bean is SimpleMessageBus) {
            queryHandlers.forEach {
                bean.registerQueryHandler(#runtimeClassForQ&lt;V&gt;onIt, it)
            }
        }
        return bean
    }
}

private inline fun &lt;reified T: Q&lt;P&gt;, P&gt; getClazz(handler: QueryHandler&lt;T, P&gt;) : Class&lt;T&gt; {
        return T::class.java
    }

val userNames = ArrayList&lt;String&gt;()

for (user in users)
  userNames.add(user.name)

return userNames

class Tile(var value: Int = 0){

}

class Board() {
    var _tiles = Array&lt;Tile&gt;(100) {Tile()} //Represents a 10x10 playing board

    var tiles
    get(x: Int, y: Int) {return _tiles[y * 10 + x]}
    set(x:Int, y: Int, value: Tile) {_tiles[y * 10 + x] = value}

}

fun main(args: Array&lt;String&gt;) {
    val board = Board()
    board.tiles[0,0].value = 42
}

data class ComplexSearchQueryParameter(
        val key: String,
        val value: String,
        val isOneOfMany: Boolean = false
)

List&lt;ComplexSearchQueryParameter&gt;
ComplexSearchQueryParameter.key
ComplexSearchQueryParameter.isOneOfMany
   return query.split(QUERY_PARAMETERS_DELIMITER).map { queryParameter -&gt;
        val splitedParameterKeyValue = queryParameter.split(QUERY_PARAMETER_KEY_VALUE_DELIMITER)
        val parameterKey = splitedParameterKeyValue.first().substringBefore(QUERY_PARAMETERKEY_SUFFIX)
        val parameterValue = splitedParameterKeyValue.last()

        ComplexSearchQueryParameter(parameterKey, parameterValue)
    }

val a: String
init {
    a = "aaa"
}

fun sum(f: (Int) -&gt; Int): (Int, Int) -&gt; Int {
    fun sumF(a: Int, b: Int): Int =
            if (a &gt; b) 0
            else f(a) + sumF(a + 1, b)
    return sumF
}

val names = listOf("John", "Tom")
val days = listOf(1, 2, 3)

f: (String, Int): Unit
f("John", 1)
f("John", 2)
f("John", 3)
f("Tom", 1)
f("Tom", 2)
f("Tom", 3)

a.map { itA -&gt; 
  b.map { itB -&gt;
    f(itA, itB)
  }
}

[() -&gt; kotlin.collections.List&lt;kotlin.Unit&gt;, () -&gt; kotlin.collections.List&lt;kotlin.Unit&gt;]

Any().javaClass

java.lang.Object
Any
Object
proxy.http.host: localhost
proxy.http.port: 3128

@Component
@ConfigurationProperties(prefix = "proxy.http")
data class ProxyConfig(var host: String = "", var port: Int = -1) {
}

object
object RestUtils {

    @Autowired
    lateinit var proxyConfig: ProxyConfig

    fun createRestTemplate(): RestTemplate {            
        val proxy = Proxy(Proxy.Type.HTTP, InetSocketAddress(proxyConfig.host, 3128))

kotlin.UninitializedPropertyAccessException
kotlin.UninitializedPropertyAccessException: lateinit property proxyConfig has not been initialized
    at com.test.infrastructure.RestUtils.createRestTemplate(RestUtils.kt:16) ~[classes/:na]
    at com.test.monitoring.MonitoringController.getComponentsStatus(MonitoringController.kt:36) ~[classes/:na]
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_20]
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_20]
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_20]
    at java.lang.reflect.Method.invoke(Method.java:483) ~[na:1.8.0_20]
    at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:221) ~[spring-web-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:136) ~[spring-web-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:110) ~[spring-webmvc-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:832) ~[spring-webmvc-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:743) ~[spring-webmvc-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) ~[spring-webmvc-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:961) ~[spring-webmvc-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:895) ~[spring-webmvc-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:967) ~[spring-webmvc-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:858) ~[spring-webmvc-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at javax.servlet.http.HttpServlet.service(HttpServlet.java:622) ~[tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:843) ~[spring-webmvc-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at javax.servlet.http.HttpServlet.service(HttpServlet.java:729) ~[tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:292) ~[tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) ~[tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) ~[tomcat-embed-websocket-8.0.33.jar:8.0.33]
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) ~[tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) ~[tomcat-embed-core-8.0.33.jar:8.0.33]
    at com.daimlertss.repocar.service.infrastructure.CorsFilter.doFilter(CorsFilter.kt:24) ~[classes/:na]
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) ~[tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) ~[tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:316) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:114) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:122) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:169) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:48) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.authentication.www.BasicAuthenticationFilter.doFilterInternal(BasicAuthenticationFilter.java:213) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:120) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:64) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:91) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:53) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:213) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:176) ~[spring-security-web-4.0.4.RELEASE.jar:4.0.4.RELEASE]
    at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:346) ~[spring-web-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:262) ~[spring-web-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) ~[tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) ~[tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) ~[spring-web-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) ~[tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) ~[tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:87) ~[spring-web-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) ~[tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) ~[tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:77) ~[spring-web-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) ~[tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) ~[tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:121) ~[spring-web-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.2.6.RELEASE.jar:4.2.6.RELEASE]
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) ~[tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) ~[tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:212) ~[tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:106) [tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:502) [tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:141) [tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79) [tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88) [tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:522) [tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1095) [tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:672) [tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1502) [tomcat-embed-core-8.0.33.jar:8.0.33]
    at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1458) [tomcat-embed-core-8.0.33.jar:8.0.33]
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_20]
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_20]
    at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-8.0.33.jar:8.0.33]
    at java.lang.Thread.run(Thread.java:745) [na:1.8.0_20]

class Test {
    var presni: Int = 1
        set(value) {
            if (value &lt; 0) {
                throw IllegalArgumentException("Negative value");
            }

            presni = value
        }
}

presni = value
var classList = ArrayList&lt;Class&lt;Any&gt;&gt;()
init {
    classList.add(ClassA::class.java)
    classList.add(ClassB::class.java)
}

Type inference failed. Expected type mismatch: inferred type is Class&lt;ClassA&gt; but Class&lt;Any&gt; was expected

domainClasses.add(NameIdMapping::class.java as Class&lt;Any&gt;)

converter
data
listitem
data class RawData(val type: String, val data: Data)
interface Converter {
    fun convert(data: Data): ListItem
}

fun transform(): List&lt;ListItem&gt; {
    val providerTypeMap = modelViewProvider.associateBy({it.type}, {it})

    return rawDataList.filter { 
        converter[it.type] != null
    }.map {
        converter[it.type]?.create(it.data) ?: object: ListItem {}
    }
}

List&lt;ListItem&gt;
List&lt;ListItem?&gt;
converter[it.type]?.create(it.data) ?: object: ListItem {}

?
?:
converter[it.type] != null
?
?: ListItem{}
fun main(args: Array&lt;String&gt;) {
    try {
        var sum: Long = 0
        val n: Int = readLine()!!.toInt()

        for (i in 0..(n - 1)) {
            var input: Long?
            input = readLine()!!.toLong()
            sum += input
        }
        println(sum)
    } catch (ex: Exception) {
        println(ex.message)
    } 
}

interface I { /* some stuff */ }

object A: I { /* some stuff */ }

object B: I { /* some more stuff */ }

class Cell&lt;J: I&gt;(val n: Int, val j: J) {
   /* some more stuff that uses j */
   fun eq(c: Cell&lt;J&gt;): Boolean {
       return n == c.n
   }
}

Cell(1, A).eq(Cell(2, A))
Cell(1, A).eq(Cell(2, B))
eq
==
class Cell&lt;J: I&gt;(val i: Int, val j: J) {
   override fun equals(c: Any?): Boolean {
       c as Cell&lt;J&gt;
       return i == c.i
   }
}

Cell(1, A) == Cell(2, B)
generateSequence
generateSequence
fun &lt;T : Any&gt; generateSequence(
    seed: T?, 
    nextFunction: (T) -&gt; T?
): Sequence&lt;T&gt;

Sequence
fun fibonacci(): Sequence&lt;Int&gt; {
    return generateSequence(Pair(0, 1), { Pair(it.second, it.first + it.second) }).map { it.first }
}
​
println(fibonacci().take(10).toList()) // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

Sequence
Int
Pair&lt;Int, Int&gt;
Pair&lt;Int, Int&gt;
Int
Pair&lt;Int, Int&gt;
Int
null
I/UI_Msg: &lt;  
I/UI_Msg: 7:16&gt;  
I/UI_Msg: &lt;  
I/UI_Msg: 7:16&gt;  
etc

private fun beginListenForData() {
  val handler = Handler()
    stopThread = false
    buffer = ByteArray(10)
    val thread = Thread(Runnable {
        while (!Thread.currentThread().isInterrupted &amp;&amp; !stopThread) {
            try {
                val byteCount = inputStream!!.available()
                if (byteCount &gt; 0) {
                    //Thread.sleep(1000)      // wait for buffer finish filling
                    val rawBytes = ByteArray(byteCount)
                    inputStream!!.read(rawBytes)
                    val string = String(rawBytes, StandardCharsets.UTF_8)
                    //handler.post {txt_message.text=""}
                    Log.i(TAG,""+ string)
                    //handler.post {txt_message.append(string)}
                   // processInput(string)
                }
            } catch (ex: IOException) {
                stopThread = true
            }
        }

    })

    thread.start()

}

interface Source {
    val type: String
    val viewTypes: List&lt;String&gt;
}

val sources = arrayListOf(source1, source2, source3)

viewTypes
List&lt;String&gt;
List&lt;String&gt;
viewTypes
List&lt;List&lt;String&gt;&gt;
val listOfListViewType = sources.map { it.viewTypes }

Uncaught TypeError: Kotlin.defineModule is not a function
    at C:\src\main\kotlin\kotlinext\js\Object.kt:20
    at Object.&lt;anonymous&gt; (C:\src\main\kotlin\kotlinext\js\Object.kt:20)
    at __webpack_require__ (C:\my_workspace\bwa-js\webpack\bootstrap e6d8ae87c0ef02bf2708:678)
    at fn (C:\my_workspace\bwa-js\webpack\bootstrap e6d8ae87c0ef02bf2708:88)
    at Object.map../index/index.css (C:\src\ui\tabbar\workout\changeWorkout\ChangeWorkoutPage.kt:90)
    at __webpack_require__ (C:\my_workspace\bwa-js\webpack\bootstrap e6d8ae87c0ef02bf2708:678)
    at fn (C:\my_workspace\bwa-js\webpack\bootstrap e6d8ae87c0ef02bf2708:88)
    at Object.&lt;anonymous&gt; (C:\my_workspace\bwa-js\stream.kt:137)
    at __webpack_require__ (C:\my_workspace\bwa-js\webpack\bootstrap e6d8ae87c0ef02bf2708:678)
    at module.exports (C:\my_workspace\bwa-js\webpack\bootstrap e6d8ae87c0ef02bf2708:724)
    at C:\my_workspace\bwa-js\webpack\bootstrap e6d8ae87c0ef02bf2708:724

git status
package ui.tabbar.workout.changeWorkout

import external.onsenui.Ons
import external.onsenui.OnsNav
import kotlinext.js.js
import kotlinx.html.style
import model.Workout
import react.RBuilder
import react.dom.div
import service.state.WorkoutStateService

private lateinit var navigator: OnsNav

fun RBuilder.changeWorkoutPage(_navigator: OnsNav) {
  navigator = _navigator
  Ons.Page {
    attrs {
      key = "ChangeWorkoutPage"
      renderToolbar = this@changeWorkoutPage.renderToolbar
    }
    Ons.List {
      attrs {
        dataSource = WorkoutStateService.workouts.toTypedArray()
        renderRow = renderListItem
      }
    }
  }
}

private val RBuilder.renderToolbar: Function&lt;Any&gt;
  get() = {
    Ons.Toolbar {
      attrs {
        modifier = "material"
      }
      div("left") {
        Ons.BackButton {
          attrs {
            onClick = {
              navigator.popPage()
            }
          }
        }
      }
      div("center") {
        attrs {
          style = js {
            textAlign = "center"
          }
        }
        +"Workouts"
      }
      div("right") {
        Ons.Icon {
          //placeholder to center text in the center div
        }
      }
    }
  }

private val RBuilder.renderListItem
  get() = { row: Workout, index: Int -&gt;
    Ons.ListItem {
      attrs {
        key = row.name + index
        className = "workoutDaysListItem"
        tappable = true
        onClick = {
          setCurrentWorkout(row)
          navigator.popPage()
        }
      }
      Ons.Card {
        attrs {
          className = "workoutDaysListCard"
        }
        div("innerWorkoutDaysListCard") {
          div {
            +row.name
          }
          div {
            +"${row.dayList.size} days"
          }
        }

      }
    }
  }

private val setCurrentWorkout = { workout: Workout -&gt; //The error is here
  WorkoutStateService.currentWorkout = workout
}

var _id: Long by map
class CityForecast(val map: MutableMap&lt;String, Any?&gt;, val dailyForecast: List&lt;DayForecast&gt;) {
    var _id: Long by map
    var city: String by map
    var country: String by map

    constructor(id: Long, city: String, country: String, dailyForecast: List&lt;DayForecast&gt;)
        : this(HashMap(), dailyForecast) {
        this._id = id
        this.city = city
        this.country = country
    }
}

data class OneThing(val x: Int, val y: Int, val foo: String)
data class ASimilarThing(val x: Int, val y: Int, val bar: String)

fun &lt;THING&gt; process(thing: THING) {
    println(thing.x)
    println(thing.y)
}

fun main() {
    val oneThing = OneThing(1, 2, "hi")
    val aSimilarThing = ASimilarThing(3, 4, "ho")
    process(oneThing)
    process(aSimilarThing)
}

OneThing
ASimilarThing
process
process
fun &lt;THING: [OneThing, ASimilarThing]&gt; process(thing: THING) { ... }

lateinit
lateinit var a: String 
lateinit var b: String

lateinit var b, c: String // error: Property getter or setter expected

Property getter or setter expected
selectedMedias.filter { !File(it.path).exists() }

selectedMedias
selectedMedias = selectedMedias.filter { !File(it.path).exists() }

val
class Person1(val name: String, var age: Int){
    lateinit var surname: String
    companion object myc{
        var cname: String =""
        var cage: Int = 0
        fun constructor(cname: String, cage: Int){
            this.cage = cage
            this.cname = cname
        }
        fun changeAge(age: Int ?= 0){
//            access to surname or name or age 

        }
    }
}

val c1 = Person1.myc.constructor("john",10)
val c2= Person1("jack",20)

DayForecast(HashMap(it))
parseList { DayForecast(HashMap(it)) }
override fun requestForecastByZipCode(zipCode: Long, date: Long) = forecastDbHelper.use {

        val dailyRequest = "${DayForecastTable.CITY_ID} = ? AND ${DayForecastTable.DATE} &gt;= ?"
        val dailyForecast = select(DayForecastTable.NAME)
                .whereSimple(dailyRequest, zipCode.toString(), date.toString())
                .parseList { DayForecast(HashMap(it)) }
}



class DayForecast(var map: MutableMap&lt;String, Any?&gt;) {
    var _id: Long by map
    var date: Long by map
    var description: String by map
    var high: Int by map
    var low: Int by map
    var iconUrl: String by map
    var cityId: Long by map

    constructor(date: Long, description: String, high: Int, low: Int, iconUrl: String, cityId: Long)
            : this(HashMap()) {
        this.date = date
        this.description = description
        this.high = high
        this.low = low
        this.iconUrl = iconUrl
        this.cityId = cityId
    }
}

val doubled = ints.map {it * 2 }
val dailyForecast = select(DayForecastTable.NAME).whereSimple(dailyRequest, zipCode.toString(), date.toString()).parseList { DayForecast(HashMap(it)) }
 var  ints= listOf(10,20,30);

 val doubled = ints.map {it * 2 }


 fun &lt;T, R&gt; List&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; {
        val result = arrayListOf&lt;R&gt;()
        for (item in this)
            result.add(transform(item))
        return result
  }

  fun main(args : Array&lt;String&gt;) {
    val set = HashSet&lt;Integer&gt;()
    set.add(Integer(1)) //OK

    val seti : Set&lt;Integer&gt; = HashSet&lt;Integer&gt;()
    seti.add(Integer(2)) //FAILING: Unresolved reference to add**
  }

val objectType = when (directoryType) {
    UnixFileType.D -&gt; "d"
    UnixFileType.HYPHEN_MINUS -&gt; "-"
    UnixFileType.L -&gt; "l"
}

val objectType = when (directoryType.UnixFileType) {
   D -&gt; "d"
   HYPHEN_MINUS -&gt; "-"
   L -&gt; "l"
}

val list: MutableList&lt;out X&gt; = mutableListOf(...)
val list2 = list as MutableList&lt;X&gt;

Unchecked cast: MutableList&lt;out X&gt; to MutableList&lt;X&gt;
dataConfig
urlIsabled
dataConfig.urlIsabled
dataConfig.urlIsabled
val result = if (dataConfig.urlIsabled != null) (dataConfig.urlIsabled != true) else true)

fun &lt;T&gt; identity(x: T): T = x
fun &lt;T, P&gt; Channel&lt;T&gt;.dedupe(by: (T) -&gt; P = ::identity): ReceiveChannel&lt;T&gt;
{
    ...
}

Function invocation 'identity(...)' expected
fun main(args: Array&lt;String&gt;) {
    val warehouse = Warehouse()
    val shoppingCart = ShoppingCart()
...
addProductToCart(shoppingCart, warehouse)

            fun addProductToCart(shoppingCart:ShoppingCart, warehouse: Warehouse){
                println("Product name input:")
                val iName : String = readLine() ?: "-"
                val p = warehouse.getProductByName(input)
                if (p =!null) {
                ???
                println("Number of items:")
                val inum : Int = readLine() ?: "-"
                ???
            }

class ShoppingCart{

    private val productList = mutableListOf&lt;Pair&lt;Product,Int&gt; &gt;()
...
    fun addProduct(product: Product, quantity: Int){
        productList.forEachIndexed{:index,(savedProduct, saveQuantity}-&gt;
        if (savedProduct.productName == product.productName){
        productList[index]=product to quantity + savedQuantity
        return
        }
     }   
     if (quantity !=0) productList += product to quantity
}

class Warehouse {

    private val products = mutableListOf&lt;Product&gt;()

    val productDescriptions:String
    get() {
            var value = ""
            for (prod in products){
            if (prod.availableItems!=0) value += "$prod\n"
            }
        return value
        }

    fun hasProduct (productName: String): Boolean {
        for (prod in products)
            if (prod.productName == productName) return true
        return false
    }

fun fillWarehouse (productName: String,
                       basePrice: Double,
                       productDescription: String,
                       chargeOnTop: Double = 50.0,
                       intialStockUnits: Int = 3) {

        val newProduct = Product(productName, basePrice, basePrice * (1 + chargeOnTop / 100), productDescription)
        for (i in 1 .. intialStockUnits){
            val unit = StockUnit(Random.nextInt(),Random.nextInt() )
                newProduct.addStock(unit)
        }
        products.add(newProduct)
    }

src/test/resources
class MySpec : Spek({

    describe("blah blah") {

        given("blah blah") {

            var fileContent : String = ""

            beforeEachTest {
                // How to read the file file.html in src/test/resources/html
                fileContent = ...  
            }

            it("should blah blah") {
                ...
            }
        }
    }
})

fun &lt;E, T : Collection&lt;E&gt;&gt; constructCollectionType(collectionClass: Class&lt;T&gt;, elementClass: Class&lt;E&gt;): JavaType {
    return mapper.typeFactory.constructCollectionType(collectionClass, elementClass)
}

val type = constructCollectionType&lt;Sku, MutableList&lt;Sku&gt;&gt;(MutableList&lt;Sku&gt;::class, Sku::class.java)

Only classes are allowed on the left hand side of a class literal.
inline fun &lt;reified E, reified T: Collection&lt;E&gt;&gt; constructCollectionType():JavaType {
        return mapper.typeFactory.constructCollectionType(T::class.java, E::class.java)
} 

jsonMapper.constructCollectionType&lt;Sku, MutableList&lt;Sku&gt;&gt;()

thisString
toUpperCase()
thisString
var thisString: String = "this string"
var thatString: String = "that string"

thisString.toUpperCase()
thatString = thatString.toUpperCase()

println(thisString)
println(thatString)

this string
THAT STRING

override fun update(message: String) {
    var text = textViewInstructions.text.toString()

    val timer = object : CountDownTimer(3000, 1000) {
        override fun onTick(millisUntilFinished: Long) {
            textViewInstructions.setText(newText)
            textViewInstructions.setSelection(textViewInstructions.text.length)
        }

        override fun onFinish() {
            textViewInstructions.text = ""  // this line here ??
        }
    }
    timer.start()
}

class FragmentViewBindingDelegate&lt;T : ViewBinding&gt;(
    val fragment: Fragment, // &lt;&lt;&lt; "this" object is passed upon initialization
    val viewBindingFactory: (View) -&gt; T
) : ReadOnlyProperty&lt;Fragment, T&gt; {

    // ...

    override fun getValue(thisRef: Fragment, property: KProperty&lt;*&gt;): T {
        return viewBindingFactory(thisRef.requireView()).also { this.binding = it }
        // ^^^ Same object. Can fragment.requireView() be used instead of thisRef.requireView()?
    }
}

fun printHello(name : String?) : Unit { 
   if (name != null) 
     print("Hello, $name!") 
   else 
     print("Hi there!") 
   // We don't need to write 'return Unit.VALUE' or 'return', although we could 
}

class Parent {
    private abstract class Item&lt;out T&gt;(val data: T)
    // This subclass should contain data
    private class ItemContent(val data: String): Item&lt;String&gt;(data)
    // This subclass doesn't contain data
    private class ItemNoContent: Item&lt;Any?&gt;(null)
}

class Object()

fun main(){
    var obj = Object()
    println(obj)
}

println(obj.hashCode())

interface Test {

    fun test(message: String, delay: Int =100)
}

class A: Test
{
    override fun test(message: String, delay: Int) {
    }

}

@JvmOverloads
@JvmOverloads
@JvmOverloads annotation cannot be used on interface method
@JvmOverloads
platform declaration clash....
var a=A()
a.test("1234")

A a=new A();
a.test("123");//Compile error

class A
{
    @JvmOverloads
     fun test(message: String, delay: Int=100) {
    }

}

 A a=new A();
 a.test("123");

class Car {
    var speed: Int = 0
        get() = field 
        set(value) {
            field = value
        }
}

class Car(var speed: Int)

data class Bst&lt;T: Comparable&lt;T&gt;&gt;(var left: Bst&lt;T&gt;?, var value: T, var right: Bst&lt;T&gt;?) {
    tailrec fun contains(key: T): Boolean {
        return if (key &lt; value) {
            left?.contains(key) ?: false
        } else if (key &gt; value) {
            right?.contains(key) ?: false
        } else {
            true
        }
    }
}

left?.contains
left == null
left
if
fun first() = { println("first")}
fun second() = println("second")

first()
second()

second()
package com.material.utils;

object Utils {
    fun init() {
        System.loadLibrary("utils-jni")
    }
}

Short
Operator '==' cannot be applied to 'Short' and 'Int'
val myShort: Short = 4
if (myShort == 4) // &lt;-- ERROR
    println("all is well")

val myShort: Short = 4
if (myShort == 4.toShort())
    println("all is well")

val myShort: Short = 4
if (myShort.toInt() == 4)
    println("all is well")

class Node(parent: Node?, child: Node?)

fun exampleFail() {
    val root = Node(null, Node(root, null)) // Not possible because of compiler
}

package org.kotlin.mpp.mobile.BusinessLogic

abstract class Model{

var _id:Long = 0

abstract fun PolymorphismTest()
}

package org.kotlin.mpp.mobile.BusinessLogic

class Sales : Model() {

init {
    this._id = _counter
    _counter++

}
companion object {

    private var _counter: Long = 0

}

fun get_counter(): Long {
    return _counter
}

private val _salesItems:MutableList&lt;SalesItem&gt; = ArrayList()

fun SalesItems(): MutableList&lt;SalesItem&gt; {
    return _salesItems
}

fun TotalAmount():Double
{
    var totalAmount:Double = 0.0
    for(aSalesItem in _salesItems)
    {
        totalAmount += aSalesItem.SubTotal()
    }

    return totalAmount
}

fun AddSalesItem(salesItem: SalesItem)
{
    this._salesItems.add(salesItem)
}

fun AddSalesItem(itemName:String, itemCode:String, quantity:Double, amount:Double )
{
    val aSalesItem = SalesItem()
    aSalesItem._itemCode = itemCode
    aSalesItem._itemName = itemName
    aSalesItem._quantity = quantity
    aSalesItem._amount = amount
    this.AddSalesItem(aSalesItem)
}

fun ToString(): String {
    return "Sales: $this._id"
}


override fun PolymorphismTest() {
    println("This is method from Sales")
}

}

package org.kotlin.mpp.mobile.BusinessLogic

class SalesItem : Model() {

init {
    this._id = _counter
    _counter++
}
companion object {

    private var _counter: Long = 0
}

fun get_counter(): Long {
    return _counter
}

var _sales: Sales? = null

var _amount:Double = 0.toDouble()
var _quantity:Double = 0.toDouble()

fun SubTotal(): Double {
    return _amount * _quantity
}

var _itemName:String? = null
var _itemCode:String? = null


fun Sales():Sales?{
    return _sales
}

fun SalesItem(sales:Sales)
{
    _sales = sales
    this._id = _counter
    _counter++
}

fun ToString(): String {
    return "Sales: $this._id"
}

override fun PolymorphismTest() {
    println("This is method from SalesItem")
}
}

import UIKit
import SharedCode
class ViewController: UIViewController{

override func viewDidLoad(){
     super.viewDidLoad()

     print("Creating Sales Object")
     let sales = Sales() //error here

   }
 }

clicks
var clicks
interface Button {
    fun onClick(function: () -&gt; Unit)
}

fun main() {
    var clicks = 0

    fun tryToClickOnButton(button: Button): Int{
        button.onClick{println("UPP $clicks")}
        button.onClick{clicks++}
        button.onClick{println("UPP $clicks")}
        return clicks
    }

    class SpecialButton: Button{
        override fun onClick(function: () -&gt; Unit) {
            println("AAAAAA $clicks")
        }
    }

    val button = object: Button {
        override fun onClick(function: () -&gt; Unit) {
            println("BBBBB $clicks")
        }
    }

    println(tryToClickOnButton(button))

    println(tryToClickOnButton(object : Button{
        override fun onClick(function: () -&gt; Unit) {
            println("CCCCCCC $clicks")
        }
    }))

    println(tryToClickOnButton(SpecialButton()))

}

enum class OpCode(val code:Byte) {
    foo(1),
    bar(2),
    yak(3),
}

while(stream.available() &gt; 0) {
    val opCode = stream.read().toByte()
    when (opCode) {
        OpCode.foo.code -&gt; { // do foo stuff }
        OpCode.bar.code -&gt; { // do bar stuff }
        OpCode.yak.code -&gt; { // do yak stuff }
    }
}

.code
val opCode = OpCode(stream.read().toByte())

new String()
//Java    
System.out.println("First" == new String("First")); // false always

//Kotlin
println("First" == String(StringBuilder("First"))) //true always

String(StringBuilder(..))
fun use(consumer: (T) -&gt; Unit) {
    consumer(this.value)
}

suspend fun useS(consumer: suspend (T) -&gt; Unit) {
    consumer(this.value)
}

suspend
this.value
private
inline
value
var approvedEvents = ArrayList&lt;Event&gt;()

class Event() {

    var eventID : String = ""
    var createdBy: String = "" // uid of user creator
    var creatorFullName: String = ""
    var creatorIsVerified : Boolean = false
    var creatorProfilePictureImagePath = ""
    var createdAt : Date = Calendar.getInstance().time
    var hasBeenApproved : Boolean = false
    var title : String = ""
    var speaker : String? = null
    var coordinate : GeoPoint = City.defaultCityCoordinate
    var address : String = ""
    var city : String = ""
    var venue : String = ""

}

approvedEvents
selectedEvent.eventID
(e1, e2, e3, e4, e5...)
e1
e3
e2
e4
items.map { item -&gt; item.zipWithNext() } 
[e1, e2, e3, e4, e5, e6, e7, e8] -&gt; [(e1, e3), (e2, e4), (e5, e7), (e6, e8)]

CalendarMonthTitleModelBuilder.()
.()
add ()
inline fun EpoxyController.calendarMonthTitle(modelInitializer: CalendarMonthTitleModelBuilder.() -&gt;
        Unit) {
    CalendarMonthTitleModel_().apply  {
        modelInitializer()
    }
    .addTo(this)
}

()
   private fun showMember(member: Member) {
    val memberN: String = "" + member.name
    val moveIntent = Intent(this@MainActivity, memberN::class.java)
    startActivity(moveIntent)
}

var name: String by Delegates.observable("no name") {
        d, old, new -&gt;
        println("$old - $new")
    }

 private val observablePropertyDelegate 
= Delegates.observable("&lt;none&gt;")
     { pName, oldValue, newValue -&gt;println("$pName is updated,$oldValue to $newValue")
            }
   var name: String by observablePropertyDelegate
   var name1: String by observablePropertyDelegate
   var name2: String  by observablePropertyDelegate

private val observablePropertyDelegate 
    = Delegates.observable("myOwnProperty","&lt;none&gt;")
         { oldValue, newValue -&gt;println("myOwnProperty is updated,$oldValue to $newValue")
                }

when (x) {
    parseInt(s) -&gt; print("s encodes x")
    else -&gt; print("s does not encode x")
}

x.parseInt(s)
when(myString)) {
    isNullOrBlank() -&gt; removeValue()
    else -&gt; setValue(myString)
}

isNullOrBlack()
when(myString)) {
    it.isNullOrBlank() -&gt; removeValue()
    else -&gt; setValue(it)
}

fun main(args: Array&lt;String&gt;) {
var word= readLine()!!.toString()
var letter:Char='a'
println(CharCount(word,'a'))

}

fun CharCount(word:String, letter:Char):Int{
var a=0
var b=word
var length=b.length
for (i in 0 .. length-1){
    if (letter==b[i]) {
        a++
        }
    }
return a

}

fun &lt;P&gt; configure(property: KProperty1&lt;R, P&gt;, transform: (source: S) -&gt; P) {
    ...
}

Foo::bar
::bar
configure(Foo::bar, { null })

fun main(args: Array&lt;String&gt;) {

    var k = listOf&lt;Double&gt;(1.2,77.8,6.3,988.88,0.1)

        k.forEach(::println)
}

Thread
    override val t: Thread = Thread {
        try {
            transmit()
        } catch (e: Exception) {
            println("Transmitter throws exception: $e")
        }
    }

203.14
Double
203.13999938964844
203.13
203.14
"203.14"
float
Double
double
abstract class AbsApiTestCase&lt;T&gt; {
    T mApi;

    @Before
    public void setUp() throws Exception {
        mApi = instanceApi((Class&lt;T&gt;) (
                  (ParameterizedType) getClass().getGenericSuperclass())
                     .getActualTypeArguments()[0]);
    }

    static &lt;T&gt; T instanceApi(Class&lt;T&gt; clazz) throws Exception {
        return new Retrofit.Builder()
            .baseUrl(clazz.getField("BASE_URL").get(null).toString())
            .addConverterFactory(GsonConverterFactory.create(
                    new GsonBuilder().setDateFormat("yyyy-MM-dd HH:mm:ss").create()))
            .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
            .client(getClient())
            .build().create(clazz);

    }
    // some code
}

public interface GithubApi {
    String BASE_URL = "https://api.github.com/";
    // some code
}

public class GithubApiTest extends AbsApiTestCase&lt;GithubApi&gt; {
    // some code
}

BASE_URL
interface GithubApi {
    companion object {
        val BASE_URL = "https://api.github.com/"
    }
    // some code
}

BASE_URL
@JvmField
JvmField cannot be applied to a property defined in companion object of interface
private final HashMapper&lt;Post, String, String&gt; postMapper =
   new DecoratingStringHashMapper&lt;Post&gt;(
        new JacksonHashMapper&lt;Post&gt;(Post.class));

private val postMapper = DecoratingStringHashMapper&lt;Post&gt;(
JacksonHashMapper&lt;Post&gt;(Post::class.java))

data class Client(val name: String, val pastAddresses: ArrayList&lt;String&gt;)

val aClient = Client("Alice", arrayListOf("foo", "bar"))
println(aClient)
val cClient = aClient.copy()
cClient.pastAddresses.add("Blah")
cClient.pastAddresses.remove("foo")
println(aClient)  

Client(name=Alice, pastAddresses=[foo, bar])
Client(name=Alice, pastAddresses=[bar, Blah])

 list.asSequence().flatMap { i -&gt; 
         list.asSequence().map { j -&gt; /* perform operation here */ }
 }

for(i in list){
    for(j in list){

    }
}

if (theme.isNotEmpty() &amp;&amp; body.isNotEmpty()) {
   sendToCons()
}
if (theme.isEmpty() &amp;&amp; body.isEmpty()) {
   alertDialog(getString(R.string.alert_1), 0)
}
if (theme.isNotEmpty() &amp;&amp; body.isEmpty()) {
   alertDialog(getString(R.string.alert_2), 0)
}
if (theme.isEmpty() &amp;&amp; body.isNotEmpty()) {
   alertDialog(getString(R.string.alert_3), 0)
}

when {
      theme.isNotEmpty() &amp;&amp; body.isNotEmpty() -&gt; sendToCons()
      theme.isEmpty() &amp;&amp; body.isEmpty() -&gt; alertDialog(getString(R.string.alert_1), 0)
      theme.isNotEmpty() &amp;&amp; body.isEmpty() -&gt; alertDialog(getString(R.string.alert_2), 0)
      theme.isEmpty() &amp;&amp; body.isNotEmpty() -&gt; alertDialog(getString(R.string.alert_3), 0)
}

.run{condition}
alertDialog(getString(R.string.alert_1), 0).run{theme.isEmpty() &amp;&amp; body.isEmpty()}

alerDialog
enum class State {
    EMPTY, LOADING, DATA, ERROR
}
private var currentState = State.EMPTY

private var timer: Timer? = null

fun startTimer() {
    if (timer == null) {
        timer = fixedRateTimer(period = 1000, action = {

            mainvView.showView(currentState)
            currentState = when (currentState) {
                State.EMPTY -&gt; State.LOADING
                State.LOADING -&gt; State.DATA
                State.DATA -&gt; State.ERROR
                State.ERROR -&gt; State.EMPTY
            }
        })
    }
}

            currentState = when (currentState) {
                State.EMPTY -&gt; State.LOADING
                State.LOADING -&gt; State.DATA
                State.DATA -&gt; State.ERROR
                State.ERROR -&gt; State.EMPTY
            }

            if (currentState == State.ERROR) {
                currentState = State.EMPTY
            } else {
                currentState++
            }

currentState++
class CompositeJob : MutableList&lt;Job&gt; {
    fun cancelAllJobs() {
        for (job in this) {
            job.cancel()
        }
    }
}

fun &lt;I&gt; calculateStuff(valueType: Class&lt;I&gt;, defaultValue: I): I {
    // do some work

    return defaultValue;
}

fun doStuff() {
    // works fine!
    val myVar1 = calculateStuff(String::class.java, "")

    // FAIL (null is not accepted... Error: "Cannot infer type parameter I in....")
    val myVar2 = calculateStuff(String::class.java, null)
}

fun &lt;I&gt; calculateStuff(valueType: Class&lt;I&gt;, defaultValue: I?): I? {
    return defaultValue;
}

val myVar2 = calculateStuff(String?::class.java, null)

try (res1, res2, res3...) {
  ...
}

val database = Databases.openDatabase(dbFile)

database.use {
  database.createResource(ResourceConfiguration.Builder(resPathName, config).build())

  val resMgr = database.getResourceManager(ResourceManagerConfiguration.Builder(resPathName).build())

  resMgr.use {
    val wtx = resMgr.beginNodeWriteTrx()

    wtx.use {
      wtx.insertSubtreeAsFirstChild(XMLShredder.createStringReader(resFileToStore))
    }
  }
}

open class User

class Admin(val name: String) : User()

fun main1() {
    val user: User
    user = Admin("John")
    user.name
}

fun main2() {
    val user: User = Admin("John")
    user.name  // "Unresolved reference: name"
}

user
Admin
git_repo?.add().addFilepattern()

add()
AddCommand!
git_repo?.add()!!.addFilepattern("test.txt")

git_repo?.add()?.addFilepattern("test.txt")

add()
add()
public
private
public
internal
  interface MyInterface {
        fun foo() = "foo"
        fun bar() = 120        
    }

MyInterface
fun(param1: String, param2: Int, myInterface: MyInteface = MyInterface())
fun &lt;T : Comparable&lt;T&gt;&gt; compareSortedLists(
        list1: Iterable&lt;T&gt;,
        list2: Iterable&lt;T&gt;,
        onlyInList1: MutableCollection&lt;T&gt;,
        onlyInList2: MutableCollection&lt;T&gt;) {
    val it1 = PeekingIterator(list1.iterator())
    val it2 = PeekingIterator(list2.iterator())
    while (it1.hasNext() &amp;&amp; it2.hasNext()) {
        val comp = it1.peek().compareTo(it2.peek())
        if (comp &lt; 0)       // &lt;-- ERROR: type inference failure
            onlyInList1.add(it1.next())
        else if (comp &gt; 0)
            onlyInList2.add(it2.next())
        else {
            it1.next()
            it2.next()      // &lt;---- Error: type mismatch
        }
    }
    it1.forEachRemaining { onlyInList1.add(it) }
    it2.forEachRemaining { onlyInList2.add(it) }
}

Type mismatch.
Required: Comparable&lt;Boolean&gt;!
Found: T!

if
if
if
when
        when {                // &lt;-- Look, no error! ;-)
            comp &lt; 0 -&gt;
                onlyInList1.add(it1.next())
            comp &gt; 0 -&gt;
                onlyInList2.add(it2.next())
            else -&gt; {
                it1.next()
                it2.next()
            }
        }

if
Comparable&lt;Boolean&gt;!
fun Any?.foo() = this != null

fun &lt;T&gt; T?.foo() = this != null

when
internal
reified
myJsonString.toData(MyDataClass::class)

myJsonString.toData&lt;MyDataClass&gt;()

@Entity
data class Record(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false, name = "name")
    var name: String? = null
)

if ()
1
2
if(it.first().property.value == 1 || it.first().property.value == 2) {
    // Do stuff
}

if(listOf(1, 2).contains(it.first().property.value)) {
    // Do stuff
} 

list
to
Pair
0 to "hero"

Pair(0, "hero")

Map
mapOf(0 to "hero", 1 to "one", 2 to "two")

Pair
"to be or not" to "be"

(0..10).map { it to it * it }

to
fun f(func: () -&gt; Any?)

fun f( (func: () -&gt; Any?)? )

onMapReady
getMapAsync
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_side_menu)
    val toolbar: Toolbar = findViewById(R.id.toolbar)
    setSupportActionBar(toolbar)

    val mapFragment = supportFragmentManager.findFragmentById(R.id.map) as? SupportMapFragment
    mapFragment?.getMapAsync(this)

    val drawerLayout: DrawerLayout = findViewById(R.id.drawer_layout)
    val navView: NavigationView = findViewById(R.id.nav_view)
    val navController = findNavController(R.id.nav_host_fragment)
    // Passing each menu ID as a set of Ids because each
    // menu should be considered as top level destinations.
    appBarConfiguration = AppBarConfiguration(
        setOf(
            R.id.nav_home, R.id.nav_gallery, R.id.nav_slideshow,
            R.id.nav_tools, R.id.nav_share, R.id.nav_send
        ), drawerLayout
    )
    setupActionBarWithNavController(navController, appBarConfiguration)
    navView.setupWithNavController(navController)

    fusedLocationClient = LocationServices.getFusedLocationProviderClient(this)

    checkIfUserIsAuthenicated()
}

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;fragment  xmlns:android="http://schemas.android.com/apk/res/android"
xmlns:map="http://schemas.android.com/apk/res-auto"
xmlns:app="http://schemas.android.com/apk/res-auto"
xmlns:tools="http://schemas.android.com/tools"
android:id="@+id/map"
android:name="com.google.android.gms.maps.SupportMapFragment"
android:layout_width="match_parent"
android:layout_height="match_parent"
tools:context=".SideMenuActivity"&gt;


&lt;/fragment&gt;

sortedBy{}
List
String
var animals: List&lt;String&gt; = listOf("tiger", "cat", "dragon", "elephant")
fun strLength(it: String) = it.length
animals.sortedBy { strLength(it) }
animals.forEach {println(it)}

buildscript {
ext.kotlin_version = '1.1.51'
repositories {
    jcenter()
}
dependencies {
    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
}
}
apply plugin: "kotlin"
dependencies {
compile "org.jetbrains.kotlin:kotlin-stdlib-jre7"
}

var
Printer
val
open class Printer(override var anString: String) : MyInterface

interface MyInterface {

    var anString: String

    val anInt: String
        get() = anInt + 50
}

fun main() {
    println(Printer("string").anInt)
}

&gt; "C:\Program Files\Java\jdk1.8.0_102\bin\java.exe"
&gt; "-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA
&gt; 2019.2.1\lib\idea_rt.jar=52595:C:\Program Files\JetBrains\IntelliJ IDEA 2019.2.1\bin" -Dfile.encoding=UTF-8 -classpath "C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\charsets.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\deploy.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\ext\access-bridge-64.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\ext\cldrdata.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\ext\dnsns.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\ext\jaccess.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\ext\jfxrt.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\ext\localedata.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\ext\nashorn.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\ext\sunec.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\ext\sunjce_provider.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\ext\sunmscapi.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\ext\sunpkcs11.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\ext\zipfs.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\javaws.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\jce.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\jfr.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\jfxswt.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\jsse.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\management-agent.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\plugin.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\resources.jar;C:\Program
&gt; Files\Java\jdk1.8.0_102\jre\lib\rt.jar;D:\Work\IntelliJ\KotlinDataTypes\out\production\KotlinDataTypes;C:\Users\Neo\.IntelliJIdea2019.2\config\plugins\Kotlin\kotlinc\lib\kotlin-stdlib.jar;C:\Users\Neo\.IntelliJIdea2019.2\config\plugins\Kotlin\kotlinc\lib\kotlin-reflect.jar;C:\Users\Neo\.IntelliJIdea2019.2\config\plugins\Kotlin\kotlinc\lib\kotlin-test.jar;C:\Users\Neo\.IntelliJIdea2019.2\config\plugins\Kotlin\kotlinc\lib\kotlin-stdlib-jdk7.jar;C:\Users\Neo\.IntelliJIdea2019.2\config\plugins\Kotlin\kotlinc\lib\kotlin-stdlib-jdk8.jar"
&gt; com.example.accessmodifiers.pack.Test2Kt Exception in thread "main"
&gt; java.lang.StackOverflowError  at
&gt; com.example.accessmodifiers.pack.MyInterface$DefaultImpls.getAnInt(Test2.kt:10)
&gt;   at com.example.accessmodifiers.pack.Printer.getAnInt(Test2.kt:3)    at
&gt; com.example.accessmodifiers.pack.MyInterface$DefaultImpls.getAnInt(Test2.kt:10)
&gt;   at com.example.accessmodifiers.pack.Printer.getAnInt(Test2.kt:3)    at
&gt; com.example.accessmodifiers.pack.MyInterface$DefaultImpls.getAnInt(Test2.kt:10)
&gt;   at com.example.accessmodifiers.pack.Printer.getAnInt(Test2.kt:3)    at
&gt; .
&gt; .
&gt; .
&gt; 
&gt; Process finished with exit code 1

var planets: ArrayList&lt;Planet&gt;? = null

planets = arrayListOf(earth, mars, saturn, jupiter, uranus, neptune, pluto)

Required: ArrayList&lt;Planet&gt;?
Found: ArrayList&lt;Planet?&gt;

continue
break
when
while (!mStopped &amp;&amp; c.moveToNext()) {

    val itemType = c.getInt()
    when (itemType) {
        1, 2 -&gt; {
            doSomething()
            if (condition)
                continue
            doSomethingElse()
        }
    }
    doTheLastStuff()
}

continue
break
while
editTextPassword.setOnFocusChangeListener { view, hasFocus -&gt;
    if (!hasFocus) validatePassword()
}

editTextPassword.setOnFocusChangeListener(object : View.OnFocusChangeListener {
    override fun onFocusChange(p0: View?, p1: Boolean) {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
})

if let a = b.val {

}
else {

}

class Route(var vehicle: Vehicle?, var  jobs: List&lt;Job&gt;?) {
    constructor()
    constructor(vehicle: Vehicle?)

    fun isOverCapacity() : Boolean {
        val vehicleCapacity = vehicle?.capacity
        if (vehicleCapacity != null){
            val totalDemand = jobs?.sumBy { job -&gt; job.demand }
            if (totalDemand != null) {
                return totalDemand &gt; vehicleCapacity
            } 
        }
        return false
    }
}

fun withDefault&lt;A&gt;(computation: () -&gt; A, default: A) =
    try { computation() } catch (e: Exception) { default }

fun getHostname1() = withDefault(InetAddress.getLocalHost().getCanonicalHostName, "localhost")

Kotlin: Type inference failed: fun &lt;A&gt; withDefault(computation: () -&gt; A, default: A): A
cannot be applied to
(kotlin.String!,kotlin.String)

class Employee(var person: String = "Employee", var worksAt: String = "California", var mood: String = "Happy") {
   var name: String = "Name: "
        set(value){
            name = "Name: $value"
        }

    var allString: String
        private set

    init {
        this.allString = "$name works at $worksAt is $mood"
        this.person = "Person: " + person!!
        this.worksAt = "Work at: " + worksAt
        this.mood = "Mood :" + mood
    }

    override fun toString(): String {
        return this.name + "\n" + worksAt + "\n" + mood
    }
}

        val reaEmployee = Employee()
        reaEmployee.name = edt_main.text.toString()

Name: Name: .... $value
open class A(var s : Int){
    var a : Int = 5
    var b : Int = 4
    var c : Int = 0
    constructor() : this(7) {
        //println("class A constructor has been called !!!")
        println("primary constructor value is $s")
    }
   fun add(h:Int) {
        c = a.plus(b)
        println("h is for class A $h")
    }
    fun dis(){
        println("sum of a &amp; b is $c")

    }
}
fun A.sub(){

    println("sub of class A is ${a.minus(b)}")

}
class B: A{

    constructor(){
        println("primary constructor for class B")

    }
    fun sub(){
        super.sub();
        println("sub of class B is ${a.minus(b)}")

    } 

}
fun main(args:Array&lt;String&gt;){
    var b = B()
    b.add(2)
    b.dis()
    b.sub()
}

sealed class PointOf(val location: LatLng) {
    data class Interest(val point: DbHotelPointOfInterest) : PointOf(point.location!!)
    data class Hotel(val hotel: DbHotel) : PointOf(hotel.location!!)
}

fun main() {
val input = readLine()!!

if (input.isEmpty()){
    println(input)
} else if (input.first().equals('i')) {
    println(input.drop(1).toInt() + 1)
} else if (input.first().equals('s')) {
    println(input.drop(1).reversed())
}}

view.setOnClickListener { callAnotherMethod() }

interface TestListener {
    fun onTest()
}

fun
private fun setTest(listener: TestListener) {

}

setTest{ callAnotherMethod() }
setOnClickedListener()
setTest
OnClickListener
TestListener
TestListener
"mystring".toCharArray()
CharArray
Array&lt;Char&gt;
CharArray
CharArray
Array&lt;Char&gt;
Array&lt;Char&gt;
"mystring".toCharArray().map { it }.toTypedArray()
open class Base{
    val simple = 3
    open val open = 3
    open val openGet = 3
    open val getter get()= 3
    open val getOpen get()= 3
    open val getDelg by GetDelg(3)
    init {
        println("base simple $simple open $open openG $openGet "+
                "getOpen $getOpen getter $getter "+
                " getDelg $getDelg")
    }
    //open fun add(a:Int,b:Int) = a + b
}

class SubClass:Base(){
    override val open = 4
    override val openGet get()= 4
    override val getter get() = 4
    override val getOpen = 4
    //override val getDelg by GetDelg(4)  //uncomment for null pointer
    init {
        println("sub simple $simple open $open openG $openGet "+
                "getOpen $getOpen getter $getter "+
                " getDelg $getDelg")

    }
}
class GetDelg(val value:Int){
    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): Int {
        return value
    }
} 

init()
init()
Closable.use
public inline fun &lt;T : Closeable?, R&gt; T.use(block: (T) -&gt; R): R {
    var exception: Throwable? = null
    try {
        return block(this)
    } catch (e: Throwable) {
        exception = e
        throw e
    } finally {
        when {
            apiVersionIsAtLeast(1, 1, 0) -&gt; this.closeFinally(exception)
            this == null -&gt; {}
            exception == null -&gt; close()
            else -&gt;
                try {
                    close()
                } catch (closeException: Throwable) {
                    // cause.addSuppressed(closeException) // ignored here
                }
        }
    }

Closable.use
    BufferedReader(FileReader("test.file")).use { return it.readLine() }

data class Model(val mId, val mList: List&lt;AnotherModel&gt;)

val fakeList: List&lt;Model&gt;

mList: List&lt;AnotherModel&gt;
List&lt;NeoAnotherModel&gt;
forEach
Observable.just(fakeList).map { models: List&lt;Model&gt; -&gt;
  val IWantNeoAnotherModelList = models.forEach { model: Model -&gt;
    model.mList.map { list: List&lt;AnotherModel&gt; -&gt;
      NeoAnotherModel(...)
    }
  }
}

package myapp.mybeans;

data class Foo(val name : String?);

package myapp.global;

public fun makeNewBar(name : String) : Bar
{
  ...
}

Bar
Foo
package myapp.someplaceElse;

public fun getFoo() : Foo? { }
...
val foo : Foo? = getFoo();

if (foo == null) { ... return; }


// I know foo isn't null and *I know* that foo.name isn't null
// but I understand that the compiler doesn't.
// How do I convert String? to String here? if I do not want
// to change the definition of the parameters makeNewBar takes?
val bar : Bar = makeNewBar(foo.name);

foo.name
package bookyard.contracts;

public interface IAuthenticationManager&lt;T&gt; {
    fun authenticateUser(userName: String, password : String,
                            appId: String, appSecret : String) : OperationResult&lt;T&gt;;
}

package bookyard.server.util

import bookyard.contracts.IAuthenticationManager;

public class DatabaseAuthenticationManager :  IAuthenticationManager&lt;User&gt; {

    /* override public fun authenticateUser(userName : String?,
                                password : String?,
                                appId : String?,
                                appSecret : String?) : OperationResult&lt;User&gt; {
    }

    public override fun authenticateUser(userName : String?,
                                password : String?,
                                appId : String?,
                                appSecret : String?) : OperationResult&lt;User&gt; {
    }

    public fun authenticateUser(userName : String?,
                                password : String?,
                                appId : String?,
                                appSecret : String?) : OperationResult&lt;User&gt; {
    } */
}

class CityForecast(val map: MutableMap&lt;String, Any?&gt;, val dailyForecast: List&lt;DayForecast&gt;) {
    var _id: Long by map
    var city: String by map
    var country: String by map

    constructor(id: Long, city: String, country: String, dailyForecast: List&lt;DayForecast&gt;)
            : this(HashMap(), dailyForecast) {
        this._id = id
        this.city = city
        this.country = country
    }
}

fun test(a: List&lt;String&gt;) { }

public static final void test(@NotNull List&lt;? extends String&gt; a)
{
    Intrinsics.checkParameterIsNotNull(a, "a");
}

a
data class mutableClass(val list: List&lt;Foo&gt;) {

    private val mutableList: MutableList&lt;Foo&gt;
        get() = ImmutableList.copyOf(field)

    init {
       mutableList = mutableListOf()
       list.forEach {
          mutableList.add(it.copy()) // Exception is thrown here.
          // It actually calls its getter method which is an immutable 
          // list, so when init this class, it throw exception                   
       }
    }
}

data class Foo {}

interface APIService{
    @get:GET("users/{id}")
    var getUserDetails(@Query("id") id:Int):Observable&lt;UserDetails&gt;
}

class Remember private constructor() {

  private var data: ConcurrentMap&lt;String, Any&gt; = ConcurrentHashMap()

  private fun &lt;T&gt; saveValue(key: String, value: T): Remember {
    data[key] = value
    return this
  }

  private fun &lt;T&gt; getValue(key: String, clazz: Class&lt;T&gt;): T? {
    val value = data[key]
    var castedObject: T? = null


    //Failed here
    if (clazz.isInstance(value)) {
        castedObject = clazz.cast(value)
    }

    return castedObject
  }

  fun putInt(key: String, value: Int): Remember {
    return saveValue(key, value)
  }

  fun getInt(key: String, fallback: Int): Int {
    val value = getValue(key, Int::class.java)
    return value ?: fallback
  }

}

putInt(key, 123)
123
java.lang.Integer
Map
value
Any
Class&lt;T&gt;
Int:class.java
clazz.isInstance(value)
sealed class Expr {
    class Const(val number: Double) : Expr()
    class Sum(val e1: Expr, val e2: Expr) : Expr()
    object NotANumber : Expr()
}

NotANumber
class NotANumber : Expr()
import java.util.Date

object InnerFactory {

    class Inner private constructor(startDate: Date? = null, endDate: Date? = null) {
        fun getTimeDifference(): Long? {
            //calculates time difference but doesn't matter to this example
        }
    }

    fun createInnerObject(startDate: Date? = null, endDate: Date? = null): Inner? {
        if (startDate != null &amp;&amp; endDate != null &amp;&amp; !endDate.after(startDate)) {
            return null
        }

        return Inner(startDate, endDate)
    }

}

val date1 = Date(1547600000)
val date2 = Date(1547600600)
val inner = InnerFactory.createInnerObject(date1, date2) //should return an instance
val invalidInner = InnerFactory.createInnerObject(date2, date1) //should not return an instance because the "endDate" is before "startDate"
val difference = inner?.getTimeDifference()

"fields.field":"value"
val number = 829
val length = number.toString().length

when
when
when
sealed class SomeType
object Foo: SomeType()
object Bar: SomeType()

fun test(input: SomeType) {
    when(input) {
        is Foo -&gt; {}
    }
}

when
else
SomeType
Bar
sealed class SomeType
object Foo: SomeType()
object Bar: SomeType()

fun test(input: SomeType) {
    var result = when(input) {
        is Foo -&gt; {}
    }
}

when
Unit
when
when
when
when
Boolean
val foos = mutableListOf&lt;Foo&gt;()
...
fun fooBar(bar: Bar) = if (null != foos.find { it.bar == bar }) true else false

fun Any?.exists() = null != this
fun fooBar(bar: Bar) = foos.find { it.bar == bar }.exists()

null
filterIsInstance()
inline fun &lt;reified R&gt; Iterable&lt;*&gt;.findIsInstance(): R? {
    for (element in this) if (element is R) return element
    return null
}

val str = list.findIsInstance&lt;String&gt;() ?: return

return SpUtils.loadEMail()?.isEmpty() ?: false
return !SpUtils.loadEMail()?.isEmpty() ?: false
class MediaData(val path: String,val durationMs: Int)

ArrayList1:
object 1 - path : x, reference:0x12e2e
object 2 - path : y, reference:0x11ad4

ArrayList2:
object 1 - path : x, reference:0x13as2
object 2 - path : z, reference:0x14ed4

ArrayList1:
object 1 - path : x, reference:0x13as2
object 2 - path : y, reference:0x11ad4

ArrayList2:
object 1 - path : x, reference:0x12e2e
object 2 - path : z, reference:0x14ed4

class HourlyActivity : Fragment(){

    override fun onCreateView(inflater: LayoutInflater?, container: ViewGroup?, savedInstanceState: Bundle?): View? 
    {
        textView_hourly.text = "yo"
        return inflater!!.inflate(R.layout.fragment_hourly,container,false)
    }
}

lateinit
private fun displaySelectedScreen(itemID: Int) {
    //creating fragment object
    val fragment: Fragment
    //initializing the fragment object which is selected
    when (itemID) {
        R.id.nav_schedule -&gt; fragment = ScheduleFragment()
        R.id.nav_coursework -&gt; fragment = CourseworkFragment()
        R.id.nav_settings -&gt; {
            val i = Intent(this, SettingsActivity::class.java)
            startActivity(i)
        }
        else -&gt; throw IllegalArgumentException()
    }
    //replacing the fragment, if not Settings Activity
    if (itemID != R.id.nav_settings) {
        val ft = supportFragmentManager.beginTransaction()
        ft.replace(R.id.content_frame, fragment)// Error: Variable 'fragment' must be initialized
        ft.commit()
    }
    drawerLayout.closeDrawer(GravityCompat.START)
}

    for (i in position until effectList.size) {
        var holder = mRecyclerView.findViewHolderForAdapterPosition(i) as EffectsHolder
        holder.bindEffect(holder.effect, i)
    }

kotlin.TypeCastException: null cannot be cast to non-null type com.mobileer.androidfxlab.EffectsAdapter.EffectsHolder

mRecyclerView.findViewHolderForAdapterPosition(i)
mRecyclerView.findViewHolderForAdapterPosition(i)
holder?.bindEffect(holder.effect, i)
Component
@Suppress("UNCHECKED_CAST")
open class GameObjectImpl : GameObject {
    private val attachedComponents = mutableSetOf&lt;Component&gt;()

    @Suppress("UNCHECKED_CAST")
    override fun &lt;TComponent : Component&gt; getComponent(type: KClass&lt;TComponent&gt;): TComponent? {
         return attachedComponents.find { type.isInstance(it) } as? TComponent
    }
}

for ((x, y) in (1..100, 50 downTo 0)) {}

for ((x, y, z) in (1..100, 50 downTo 0, 500..1000 step 2)) {}

**
when (pendingOperation) {
    "=" -&gt; operand1 = value
    "÷" -&gt; operand1 = if (value == 0.0) {
        Double.NaN // handle attempt to divide by zero
    } else {
        operand1!! / value
    }
    "x" -&gt; operand1 = operand1!! * value
    "−" -&gt; operand1 = operand1!! - value
    "+" -&gt; operand1 = operand1!! + value
    "a^b" -&gt; operand1 = operand1!! ** value

weekOfMonth
day
simpleDatePicker.weekOfMonth
simpleDatePicker.day
public interface BaseColumns {
    public static final String _ID = "_id";
    public static final String _COUNT = "_count";
}

object UserEntry : BaseColumns {
    // some code
}

UserEntry._ID
_ID
fun main(args: Array&lt;String&gt;) {

    println("Enter Integer Input  X: ")
    val x = Integer

    return when(x) {
       x &gt; y -&gt; -1
       x&lt;y -&gt; 1


 }

   println("Enter Integer Y: ")

   val y = Integer

    return when(y) {
       x &gt; y -&gt; -1
       x&lt;y -&gt; 1

val list1 = listOf("my", "list")
val list2 = listOf(1, 2, 3)
val list3 = listOf&lt;Double&gt;()

/* ... */

when(list.genericType()) {
    is String -&gt; handleString(list)
    is Int -&gt; handleInt(list)
    is Double -&gt; handleDouble(list)
}

input = "Hello World"
output = "hELLO wORLD"

private fun createNotification(){
        //prepares the file to be opened
        val selectedUri: Uri =
            Uri.parse(mFilePath)
        val intent = Intent(Intent.ACTION_VIEW)
        intent.setDataAndType(selectedUri, "application/pdf") // here we set correct type for PDF
        intent.flags = Intent.FLAG_GRANT_READ_URI_PERMISSION
        val pendingIntent: PendingIntent =
            PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT)
        //creates the notification
        if(Build.VERSION.SDK_INT &gt;=Build.VERSION_CODES.O) {
            notificationChannel =
                NotificationChannel(channelId, description, NotificationManager.IMPORTANCE_HIGH)
            notificationChannel.enableLights(true)
            notificationChannel.lightColor = Color.GREEN
            notificationChannel.enableVibration(true)
            notificationManager.createNotificationChannel(notificationChannel)

            builder = Notification.Builder(this, channelId)
                .setContentTitle("Création de l'attestation")
                .setContentText("Cliquez pour ouvrir le fichier PDF")
                .setSmallIcon(R.drawable.ic_baseline_arrow_downward_24)
                .setContentIntent(pendingIntent)
        }else{
            builder = Notification.Builder(this, channelId)
                .setContentTitle("Création de l'attestation")
                .setContentText("Cliquez pour ouvrir le fichier PDF")
                .setSmallIcon(R.drawable.ic_baseline_arrow_downward_24)
                .setContentIntent(pendingIntent)
        }
        notificationManager.notify(1234,builder.build())
    }

if
when
fun main() {
    var cardPoints = 7_000


    val cardLevel: String = if (cardPoints &gt;= 0 &amp;&amp; cardPoints &lt; 1000) {
        "pearl"
    } else if (cardPoints &gt;= 1000 &amp;&amp; cardPoints &lt; 5_000) {
        "silver"
    } else if (cardPoints &gt;= 5_000 &amp;&amp; cardPoints &lt; 10_000) {
        "gold"
    } else {
        "platinum"
    }

    val plural = if(cardPoints &gt; 1 || cardPoints == 0) "s" else ""
    println("You have $cardPoints point$plural and are at the $cardLevel level.")
}

fun main() {
    var cardPoints = 7_000

    val cardLevel: String = when {
        cardPoints &gt;= 0 &amp;&amp; cardPoints &lt; 1000 -&gt; "pearl"

        cardPoints &gt;= 1000 &amp;&amp; cardPoints &lt; 5_000 -&gt; "silver"

        cardPoints &gt;= 5_000 &amp;&amp; cardPoints &lt; 10_000 -&gt; "gold"
        else -&gt; "platinum"

    }
    val plural = if(cardPoints &gt; 1 || cardPoints == 0) "s" else ""
    println("You have $cardPoints point$plural and are at the $cardLevel level.")
}

val todayCount = keyValue.value.filter {
        val after = it.expectedArrivalDate?.after(today)
        val before = it.expectedArrivalDate?.before(tomorrow)
        after != null &amp;&amp; before != null &amp;&amp; after &amp;&amp; before
    }.size

it.expectedArrivalDate
nullable
val todayCount = keyValue.value.filter {
    it.expectedArrivalDate.after(today) &amp;&amp; it.expectedArrivalDate.before(tomorrow)
}.size

private Observable observable = Observable.just("http://myurl.com/")
        .map(new Function&lt;String, Person&gt;() {
            @Override
            public Person apply(String url) throws Exception {

                Request request = new Request.Builder().url(url).build();
                Call call = okHttpClient.newCall(request);
                Response response = call.execute();

                if (response.isSuccessful()) {
                    ResponseBody responseBody = response.body();
                    if (responseBody != null) {
                        return Person.parseFrom(responseBody.byteStream());
                    }
                }

                return null;
        }
}).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread());

private val observable = Observable.just("http://myurl.com/")
        .map{
            val request = Request.Builder().url(it).build()
            val call = okHttpClient.newCall(request)
            val response = call.execute()

            if (response.isSuccessful) {
                val responseBody = response.body()
                if (responseBody != null) {
                    Person.parseFrom(responseBody.byteStream())
                } else {
                    null
                }
            } else {
                null
            }
        }.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread())

null
null
alpha
fun foo(alpha: String.(Int, Int) -&gt; Unit) {
    bar { x, y -&gt; "george".alpha(x, y) }
}

fun bar(beta: (Int, Int) -&gt; Unit) {
    // ...
}

"george"
alpha
bar("george".bind(alpha))

alpha
apply
arrayOf(1,2,3).forEach(println)

forEach
::println
forEach
println
val addA: (Int)-&gt;Int = {it+1}
fun addB(i: Int) = i+1

fun main(args: Array&lt;String&gt;){
    var x: Int=0
    x.let(addA).let(::addB).let(::print)
}

::
inline fun &lt;T: Any, R: Any&gt; List&lt;T&gt;.test(prop1: KProperty1&lt;T, R&gt;, prop2: R): List&lt;T&gt;

class Foo

class Bar(val foo: Foo)

fun main(args: Array&lt;String&gt;): Unit {
    val list = listOf(Bar(Foo()))
    list.test(Bar::foo, Foo()) // This should work
    list.test(Bar::foo, "") // I want this to be a type error since a string is not a Foo
}

inline fun &lt;T: Any, R: Any&gt; List&lt;T&gt;.test(prop1: KProperty1&lt;T, R&gt;, prop2: R): List&lt;T&gt; {
    println(prop1.invoke(this.first())::class == prop2::class)
    return listOf()
}

package com.zetcode

import java.io.File

fun main() {

    val fileName = "P3.txt"

    val content = File(P3.txt).readText()

    println(content)
}

if(v is BaseModel)

if(v is from BaseModel)


class Thing(var amount: Int, var id: Int){
     fun editAttributes(object: Thing, editor: RemoteEdit){
          //My initial thought here was to do the following:
          var editing = editor.attributeToEdit
          object.editing = editor.newValue
          //But this raises an error since class 'thing' has no attribute 'editing'
     }
}

var bananas = Thing(amount = 12, id = 21)

class RemoteEdit(var attributeToEdit: KMutableVar1, var newValue: Int)

var remoteEditor = RemoteEdit(attributeToEdit = Thing::amount, newValue = 23)

bananas.amount
listOf('a'..'z','A'..'Z').flatMap { it }

listOf(1..20, 25..100).flatMap { it }

fun main(args : Array&lt;String&gt;) {
    printNum()
    val fn = ::printNum
    fn(0)
    fn()    // error: no value passed for parameter 'i'
}
fun printNum(i: Int = 10) = println(i)

[["1","2","4"], ["5","6"], ["7"]]
[["1","5","7"], ["2","5","7"],["2","5",7"] continue...]
fun test():List&lt;List&lt;String&gt;&gt; {
        val test = mutableListOf(listOf("1","2","3"), listOf("5"), listOf("6"))
        val result:MutableMap&lt;Int,MutableList&lt;List&lt;String&gt;&gt;&gt; = mutableMapOf()
        for(i in test.indices) {
            if (!result.containsKey(i)) result[i] = mutableListOf()
            if (i == 0) test[i].forEach { result[i]!!.add(listOf(it)) }
            else {
                if (i-2 &gt;= 0) result.remove(i-2)
                result[i-1]!!.forEach {prev -&gt;
                    test[i].forEach {
                        result[i]!!.add(prev + listOf(it))
                    }
                }
            }
        }
        return result[test.size-1]
    }

fun test():List&lt;List&lt;String&gt;&gt; {
        return result[test.size-1]
    }

fun cartesianProduct(input: List&lt;List&lt;*&gt;&gt;): List&lt;List&lt;*&gt;&gt; {
        if (input.isEmpty()) return listOf()
        return if (input.size == 1) input[0].map { listOf(it) }
        else {
            val a = input[0]
            val b = input[1]
            val rest = input.filterIndexed{index, set -&gt; index&gt;1 }.toSet()
            (setOf(a, b).plus(rest))
                    .fold(listOf(listOf&lt;Any?&gt;())) { acc, set -&gt;
                        acc.flatMap { list -&gt; set.map { element -&gt; list + element } }
                    }
        }
    }

class Sample&lt;T: Any&gt; (val type: KClass&lt;T&gt;,
                      val allowNulls: Boolean){
    private var value: T?

    operator fun getValue(thisRef: Any, property: KProperty&lt;*&gt;): T? {
        return if (allowNulls)
            value
        else
            value?: throw Exception("Value is null!")
    }

    operator fun setValue(thisRef: Any, property: KProperty&lt;*&gt;, value: T?) {
        this.value = value
    }
}

val nullableString by sample&lt;String?&gt;()
val nonnullString by sample&lt;String&gt;()
val nullableString2: String? by sample()
val nonnullString2: String by sample()

inline fun &lt;reified T: Any&gt; sample(): Sample&lt;T&gt;{
    return Sample(T::class, /** T is nullable */)
}

val hello1 = "hello"
val hello2 = "hello"
printf(hello1 === hello2)

ID
compare
ID
compare
val outer : String? = ""
val inner : String? = null

outer?.let {
    inner?.let {
        // do something
    }
} ?: System.out.println("Outer else")

outer?.let {
    inner?.let {
        // do something
    } ?: System.out.println("Inner else")
} ?: System.out.println("Outer else")

startActivity(intent)
Toast.makeText
R.id.menu_share -&gt; {
    val intent = Intent(Intent.ACTION_VIEW, Uri.parse("https://web.whatsapp.com"))
    startActivity(intent)
}
R.id.menu_info -&gt; {
    Toast.makeText(this,"Ada Toast", Toast.LENGTH_LONG).show()
}
else -&gt; false

nullable
T
R
R
null
fun &lt;T, R&gt; T?.func(mapper: (T) -&gt; R, supplier: () -&gt; R): R =
    when(this) {
        null -&gt; supplier()
        else -&gt; mapper(this) // smart cast
    }

fun foo(value: String?): Int =
    value.func({ it.length + 20}) { 30 }

nullable
R
R
fun bar(value: T?): R =
    when(value) {
        null -&gt; func1()
        else -&gt; func2(value) // smart cast
    }

fun storeUser(datastore: Any) {
   datastore.storeName("John")
}

// Call the function
val datastore1 = DataStore1()
storeUser(datastore1)

val datastore2 = DataStore2()
storeUser(datastore2)

myVar?.let { print(it) } ?: run { print("its null folks") }

myVar?.let { print(it) } ?:  print("its null folks")

import android.os.Parcel
import android.os.Parcelable

class adel constructor(var lel : String, var skl: String) : Parcelable {
    constructor(parcel: Parcel) : this(
             parcel.readString(),
             parcel.readString()
         ) {}

    override fun writeToParcel(parcel: Parcel, flags: Int) {
        parcel.writeString(lel)
        parcel.writeString(skl)
    }

    override fun describeContents(): Int {
        return 0
    }

    companion object CREATOR : Parcelable.Creator&lt;adel&gt; {
        override fun createFromParcel(parcel: Parcel): adel {
            return adel(parcel)
        }

        override fun newArray(size: Int): Array&lt;adel?&gt; {
            return arrayOfNulls(size)
        }
    }
}

var optionsList = ArrayList&lt;String&gt;()
        optionsList.add("Alpha")
        optionsList.add("Bravo")
        optionsList.add("Charlie")
        optionsList[2] = "Foxtrot"// Assignment works (only) if initialization has been done previously through add()

var optionsList = ArrayList&lt;String&gt;(3)
        optionsList[0] = "Alpha"
        optionsList[1] = "Bravo"
        optionsList[2] = "Charlie"

public static final int[][][] data = {{{0,0},{0}},{{0,1},{0}},{{1,0},{0}},{{1,1},{1}}};

[11, 22, 33, 44]
[A, B]
zip
[11 -&gt; A, 22 -&gt; B, 33 -&gt; null, 44 -&gt; null]

java.io.Serializable
android.os.Parcelable
companion object CREATOR : Parcelable.Creator&lt;MyClass&gt; {
    override fun createFromParcel(parcel: Parcel): MyClass
    ...
}

companion object {
    private val serialVersionUid: Long = 123
}


only one companion object per class
filter
filterNot
val trueList = list.filter(predicate)
val falseList = list.filterNot(predicate)

filter
subtract
val trueList = list.filter(predicate)
val falseList = list.subtract(trueList)

groupBy
val groupBy = list.groupBy(predicate)
val trueList = groupBy[true]
val falseList = groupBy[false]

subtract
name = ""
name = name
fun simpleFunction(name: String?) {
      ...
}

fun simpleFunction(name: String? = null ? "" : name) {
   ...
}

OperationResult&lt;String&gt;
val mapper : ObjectMapper = ObjectMapper();
val type : JavaType = mapper.getTypeFactory()
         .constructParametricType(*/ class of OperationResult */,, 
          /* class of String */);
val result : OperationResult&lt;String&gt; = mapper.readValue(
                  responseString, type);

val type : JavaType = mapper.getTypeFactory()
            .constructParametricType(
             javaClass&lt;OperationResult&gt;, 
             javaClass&lt;String&gt;); // Unresolved javaClass&lt;T&gt;

val type : JavaType = mapper.getTypeFactory()
            .constructParametricType(
             OperationResult::class, 
             String::class);

Consumer
class EventBus(controller: Controller) {
    private val consumerMap : MutableMap&lt;KClass&lt;out Event&gt;, MutableSet&lt;Consumer&lt;out Event&gt;&gt;&gt; = ConcurrentHashMap()
    private val controller : Controller = controller

    public fun &lt;T : Event&gt; register(clazz: KClass&lt;T&gt;, handler: Consumer&lt;T&gt;) {
        consumerMap.getOrPut(clazz, { HashSet() }).add(handler)
    }

    public fun &lt;T : Event&gt; post(event : T) {
        consumerMap[event.javaClass.kotlin]?.forEachIndexed { i, handler -&gt;
            controller.getLogger().trace("Firing handler ${i + 1} for event ${event.javaClass.name}")
            handler.accept(event)
        }
    }
}

when(month){
        1 or 7 -&gt; arrHoangDao = arrayListOf("Tý", "Sửu", "Tỵ", "Mùi")
        2 or 8 -&gt; arrHoangDao = arrayListOf("Dần", "Mão", "Mùi", "Dậu")
        3 or 9 -&gt; arrHoangDao = arrayListOf("Thìn", "Tỵ", "Dậu", "Hợi")
        4 or 10 -&gt; arrHoangDao = arrayListOf("Ngọ", "Mùi", "Sửu", "Dậu")
        5 or 11 -&gt; arrHoangDao = arrayListOf("Thân", "Dậu", "Sửu", "Mão")
        /* 6 or 12 is duplicate */
        6 or 12 -&gt; arrHoangDao = arrayListOf("Tuất", "Hợi", "Mão", "Tị")
    }

val (_,time) = time { Thread.sleep(1000) }

(_,time)
fun compareWithIntermediate(output: SHR, input: Intpos): CompareResult{
 val matched = mutableListOf&lt;String&gt;()
 val mismatched = mutableListOf&lt;String&gt;()
 val modifiableAttr = mutableListOf&lt;String&gt;()

 compareValue(output.a.b.c, input.a.b.c,matched,mismatched)
 ......
 compareValue(output.x.y.z, input.x.y.z,matched,mismatched)

 return CompareResult(matched,mismatched)       

}


private fun compareValue(outputVal: String, inVal: String, matched:MutableList&lt;String&gt;, 
   mismatched:MutableList&lt;Diff&gt;){

   when(outputVal.compareTo(inVal)==0){
      true -&gt; matched.add("abc")
       false -&gt; mismatched.add(Diff("abc",outputVal,inVal))
   }
 }

var numbers : IntArray = intArrayOf(11, 12, 13, 14, 15)
var strList : MutableList&lt;String&gt; = mutableListOf&lt;String&gt;()

println("Now adding nos to strList")
for (number in numbers) {
    strList.add(numbers.toString())
}

println(strList)

Now adding nos to strList
[[I@3bc04539, [I@3bc04539, [I@3bc04539, [I@3bc04539, [I@3bc04539]

typealias Celsius = Double

fun Double.Companion.foo() {} // Works
fun Celsius.Companion.foo() {} // Does not work

Companion
Double
Celsius
continue
let
fun foo(elements: List&lt;String?&gt;) {
    for (element in elements) {
        element?.let {
            continue  // error: 'break' or 'continue' jumps across a function or a class boundary
        }
    }
}

fun foo(elements: List&lt;String?&gt;) {
    loop@ for (element in elements) {
        element?.let {
            continue@loop  // error: 'break' or 'continue' jumps across a function or a class boundary
        }
    }
}

filterNotNull
continue
class DateRange(val start: MyDate, val end: MyDate) : Iterable&lt;MyDate&gt; {
    override fun iterator(): Iterator&lt;MyDate&gt; = DateIterator(this)
}

class DateIterator(val daterange: DateRange) : Iterator&lt;MyDate&gt; {
    var currentDay: MyDate = daterange.start
    override fun hasNext(): Boolean = currentDay.next() &lt;= daterange.end

    override fun next(): MyDate {
        val result = currentDay
        currentDay = currentDay.nextDay()
        return result

    }
}

Unresolved reference: next
currentDay()
next()
currentDay
MyDate
next()
MyDate
class Class {
    class InnerClass {
    }

}
EOF

class Class {
    class InnerClass {
    }
}

EOF

 override fun requestForecastByZipCode(zipCode: Long, date: Long) = forecastDbHelper.use {

        val dailyRequest = "${DayForecastTable.CITY_ID} = ? AND ${DayForecastTable.DATE} &gt;= ?"
        val dailyForecast = select(DayForecastTable.NAME)
                .whereSimple(dailyRequest, zipCode.toString(), date.toString())
                .parseList { DayForecast(HashMap(it)) }

        val city = select(CityForecastTable.NAME)
                .whereSimple("${CityForecastTable.ID} = ?", zipCode.toString())
                .parseOpt { CityForecast(HashMap(it), dailyForecast) }

        city?.let { dataMapper.convertToDomain(it) }
    }

 override fun requestForecastByZipCode(zipCode: Long, date: Long) = forecastDbHelper.use {

        val dailyRequest = "${DayForecastTable.CITY_ID} = ? AND ${DayForecastTable.DATE} &gt;= ?"
        val dailyForecast = select(DayForecastTable.NAME)
                .whereSimple(dailyRequest, zipCode.toString(), date.toString())
                .parseList { DayForecast(HashMap(it)) }

        val city = select(CityForecastTable.NAME)
                .whereSimple("${CityForecastTable.ID} = ?", zipCode.toString())
                .parseOpt { CityForecast(HashMap(it), dailyForecast) }

        return  dataMapper.convertToDomain(city)
    }

ObjectStream&lt;DocumentSample&gt; bin 
    = ObjectStreamUtils.createObjectStream(categoryStreams.toArray(new ObjectStream[0]));

fun getHours() = int
    val openHours = 7
    val now = getHours()
    val office: String
    office = if (now &gt; 7){
        "Office already open"
    } else if(now == openHours){
        "wait a minute, office will be open"
    }else{
        "office is closed"
    }
    println(office)

public fun String?.indexesOf(substr: String, ignoreCase: Boolean = true): List&lt;Int&gt; {
    var list = mutableListOf&lt;Int&gt;()
    if (substr.isNullOrBlank()) return list
    var count = 0;
    this?.split(substr, ignoreCase = ignoreCase)?.forEach {
        count += it.length
        list.add(count)
        count += substr.length
    }
    list.remove(list.get(list.size-1))
    return list
}

open class Foo(val bar: String)

class Bar(val baz: String) : Foo("bar") {

}

interface Foo {
    fun bar() = "bar"
}  

class Bar(val foo: Foo) : Foo by foo {

}

Bar
Foo
class Bar&lt;T&gt;(val t: T) : T by t

fun doWithFoo(s: String) {
    print(s)
}

fun unknownFoo() {
    val bar = Bar("baz")
    doWithFoo(bar)
}

fun foo(b: Bar){
    print(b.toString())
}

foo
class Capturer&lt;T&gt;(t: T) {
    //code that captures the value and make assertions over it
}

val capturer = Capturer&lt;Bar&gt;(Bar("X"))
foo(capturer) //Invalid

foo
open
incorrect behavior or a runtime failure
   when (t) {
      is SubType1 -&gt; ...
      is SubType2 -&gt; ...
      is SubType44 -&gt; ...
   }


    fun test() {
        val e = Example()

        val i1 = 123 as Number
        val i2 = 123.0

        e.sqrt(i1)
        e.sqrt(i2)
    }

    class Example {

        fun sqrt(i: Int) {

        }

        fun sqrt(i: Double) {

        }
   }
}

@Test
fun shouldException()  {
    assertThrows&lt;WrongArgumentsException&gt; {
        val request = HttpEntity&lt;String&gt;("{\"username\": \"example\", \"password\": \"12345\"")
        val responseEntity = restTemplate.postForEntity("http://localhost:$port/api/user/registration", request, String::class.java)
    }
}

if (bindingResult.hasErrors()) {
    throw WrongArgumentsException(bindingResult.allErrors[0].defaultMessage)
}

2020-06-05 17:39:43.214 DEBUG 11308 --- [o-auto-1-exec-1] .w.s.m.a.ResponseStatusExceptionResolver : Resolved [com.example.utils.exceptions.basic.WrongArgumentsException: Password should be from 6 to 32 length]

org.opentest4j.AssertionFailedError: Expected com.example.utils.exceptions.basic.WrongArgumentsException to be thrown, but nothing was thrown.

for(int i = 0; i &lt; 5 ; i++) {
    //Body            
}

fun getMDetailByID(aMDetailsList:MDetailsList, _id:Long)...
class UIMain : AppCompatActivity() {

    data class BluetoothDef(val Status:Boolean=false)
    data class WiFiDef(val Name:String, val Status:Boolean=false)

    data class MDetail (
            val _id: Long,
            val bluetooth: BluetoothDef,
            val wiFi:WiFiDef
    )

    data class MDetailsList(val mListMetail: MutableList&lt;MDetail&gt;)


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.layout_main)

        var mBluetoothDef1=BluetoothDef()
        var mWiFiDef1=WiFiDef("MyConnect 1",true)
        var aMDetail1= MDetail(5L,mBluetoothDef1,mWiFiDef1)

        var mBluetoothDef2=BluetoothDef(true)
        var mWiFiDef2=WiFiDef("MyConnect 2")
        var aMDetail2= MDetail(6L,mBluetoothDef2,mWiFiDef2)

        val mListMetail:MutableList&lt;MDetail&gt; = mutableListOf(aMDetail1,aMDetail2)

        var aMDetailsList=MDetailsList(mListMetail)

        var c=getMDetailByID(aMDetailsList,5L)

    }

    fun getMDetailByID(aMDetailsList:MDetailsList, _id:Long):MDetail?{
        var aMDetail: MDetail?=null

        var a=aMDetailsList.mListMetail

        for (b in a){
            if (b._id==_id){
                aMDetail=b
            }
        }

        return aMDetail

    }

}

@BillingClient.SkuType
@BillingClient.SkuType
class BillingRepository private constructor(private val application: Application) :
        PurchasesUpdatedListener, BillingClientStateListener {
   ...

    private fun querySkuDetailsAsync( @BillingClient.SkuType skuType: String, skuList: List&lt;String&gt;) {
      ...
    }
  ...
}

javax.script.ScriptException: error: unresolved reference: mrpowergamerbr
fun loritta(context: com.mrpowergamerbr.loritta.commands.CommandContext) {
                         ^

// extension
inline fun &lt;T : Any&gt; T?.runIfNotNull(function: (T) -&gt; Unit) {
    this?.let { function(it) }
}

// some function
fun doSomething(int: Int){
    // do something
}

// doSomething will be called with maybeNullInt as argument, 
// when maybeNullInt is not null
maybeNullInt?.runIfNotNull { doSomething }

maybeNullInt?.let{ doSomething(it) }

maybeNullInt?.runIfNotNull { doSomething }

Map&lt;DAO, Int&gt;
Map&lt;String, Boolean&gt;
itemsWithQuantity.mapTo(mutableMapOf&lt;String, Boolean&gt;(), { it.key.toString() to it.value != 0 })

MutableMap&lt;String, Boolean&gt; is not a subtype of MutableCollection&lt;Pair&lt;String, Boolean&gt;&gt;.

val detailsIds = mutableMapOf&lt;String, Boolean&gt;()
itemsWithQuantity.forEach { item, quantity -&gt; detailsIds.put(it.key.toString(), it.value != 0) }

if (myCollection.size == 1){

}

if (myCollection.isSingle()){

}

isSingle()
fun fromAtoB(a: A) = B (fb1 = a.fa1, fb2 = a.fa2,  fb3 = a.fa3) 

val listOfA: List&lt;A&gt; = ...
val listOfB: listOfA.map { fromAtoB(it) }

fromAtoB(it)

v.text
v.text
Charsequence!
v.text
v.text.toString
v.text as String
override fun onClick(v: View?) {
        when(v) {
            is TextView -&gt; {
                Log.d("v.text", v.text)
                // v.text is Charsequence but msg need String
            }
        }
    }

Set&lt;Pair&lt;String,Int&gt;&gt;
Map&lt;String, Set&lt;Int&gt;&gt;

setStringInt.stream()
            .collect(
                groupingBy(
                    Projection::stringObj,
                    mapping(Projection::intObj,
                        toSet&lt;Int&gt;())
                )
            )

            .groupBy { it.stringobj }
            .mapValues { it.value.map { it.intobj }.toSet() }

    fun addToCart(){
    println("Productname : ")
    var nameInput= readLine() ?: "-"
    println("Num of $nameInput ")
    var num = readLine()!!.toInt()
    var got : Product? = warehouse.getProductByName(nameInput)
    shoppingCart.addToList(nameInput, num)

}

class ShoppingCart () {
            private val productAndQuantityList = mutableListOf&lt;Pair&lt;Product, Int&gt;&gt;()
            fun addToList(name: String, quantity: Int){
                productAndQuantityList.add(Pair(name, quantity))
            }
        ....
        }

fun main(args: Array&lt;String&gt;) {
    print("Hello " x_x "world")
}


infix fun String.x_x(s: String) {
    println("$this x_x $s x_x")
}

Hello  x_x world x_x
Process finished with exit code 0

 Hello  x_x world x_x
 kotlin.Unit
 Process finished with exit code 0

var downloadUrl: String? = null

fun upload(bytes: ByteArray) {

    val storageReference = FirebaseStorage.getInstance().reference
        .child(
            "images/users/${FirebaseAuth.getInstance().currentUser!!.uid}/profile_image"
        )

    val metadata = StorageMetadata.Builder()
        .setContentType("image/jpg")
        .setContentLanguage("en")
        .build()

    storageReference.putBytes(bytes, metadata).addOnSuccessListener {

        model.listener!!.progressBarGone()
        model.listener!!.toast("Uploaded Successfully")

        val urlTask = it.storage.downloadUrl
        while (!urlTask.isSuccessful);
        this.downloadUrl = urlTask.result.toString()

        Log.d("Upload", "DownloadUrl $downloadUrl")

fun saveProfile() {

    val user = User()

    if (model.name.isNullOrEmpty() || model.phone.isNullOrEmpty()) {
        model.listener!!.toast("Fields cannot be empty")
        return
    }
    if (downloadUrl.isNullorEmpty()) {

       log.d(TAG, "URL empty")

    }

    user.name = model.name
    user.phone = model.phone
    user.profile_image = downloadUrl

public class Thing {

    private String property;

    public Thing(String property) {
        this.property = property;
    }

    public String getProperty() {
        if (property == null) {
            return "blah blah blah";
        } else {
            return property;
        }
    }

}

class Thing(val property: String?)

class Thing(property: String?) {

    val property: String? = property
        get() = property ?: "blah blah blah"

}

property
val logoutDt = history?.getBody() as? LocalDateTime

logoutDt
history?.getBody()
MyUtils.kt
package app.utils

fun log(message: String) {
    println(message)
}

log()
App.kt
package app

import app.utils.log

fun main() {
   log("hey")
}

log()
MyUtils.kt
MyUtils.kt
package app.utils.MyUtils
object
class
operator fun &lt;T1&gt; ((T1) -&gt; Double).plus(f1: (T1) -&gt; Double): (T1) -&gt; Double = { t1: T1 -&gt; TODO() }

operator fun &lt;T1, T2&gt; ((T1) -&gt; Double).plus(f2: (T2) -&gt; Double): (T1, T2) -&gt; Double = { t1: T1, t2: T2 -&gt; TODO() }

object A

object B

fun test(a: (A) -&gt; Double, b: (B) -&gt; Double): (A, B) -&gt; Double = a + b

Overload resolution ambiguity: 
public operator fun &lt;T1&gt; ((TypeVariable(T1)) -&gt; Double).plus(f1: (TypeVariable(T1)) -&gt; Double): (TypeVariable(T1)) -&gt; Double defined in root package
public operator fun &lt;T1, T2&gt; ((TypeVariable(T1)) -&gt; Double).plus(f2: (TypeVariable(T2)) -&gt; Double): (TypeVariable(T1), TypeVariable(T2)) -&gt; Double defined in root package

var s: String = "hello"
s[1]='a'

Array&lt;Char&gt;
listOf(Pair('bob', UGLY), Pair('sue', PETTY), Pair('bob', FAT))

first
second
mapOf('bob' to setOf(UGLY, FAT), 'sue' to setOf(PETTY))

fun main(args: Array&lt;String&gt;) {
    var m = HashMap&lt;Int, MutableSet&lt;Int&gt;&gt;()
    listOf(1 to 1, 2 to 2, 1 to 3).map {
        val set = m.getOrPut(it.first, { listOf&lt;Int&gt;().toMutableSet() })
        set.add(it.second)
        set
    }
    println (m)
}
-&gt; {1=[1, 3], 2=[2]}

// yet another version, yields the correct result, but I feel a lack of clarity 
// that maybe I'm missing a library function that would suit the purpose.
listOf(1 to 1, 2 to 2, 1 to 3).fold(m, {
    mapSet, pair -&gt;
    val set = mapSet.getOrPut(pair.first, { listOf&lt;Int&gt;().toMutableSet() })
    set.add(pair.second)
    mapSet
})
-&gt; {1=[1, 3], 2=[2]}

filterIsInstance
val misc: List&lt;Any&gt; = listOf(42, 3.14, true, "foo", "bar")
val strings: List&lt;String&gt; = misc.filterIsInstance&lt;String&gt;()
println(strings) // =&gt; [foo, bar]

val miscByType: Map&lt;KType, Collection&lt;???&gt;&gt;

val miscByClass: Map&lt;KClass, Collection&lt;???&gt;&gt;

import kotlin.reflect.KClass

class InstanceMap {
    // INVARIANT: map from KClass to a set of objects of *that concrete class*
    private val map: MutableMap&lt;KClass&lt;*&gt;, MutableSet&lt;Any&gt;&gt; = mutableMapOf()

    // this is the only public mutator, it guarantees the invariant
    fun add(item: Any): Boolean =
        map.getOrPut(item::class) { mutableSetOf() }.add(item)

    // public non-inline accessor, only needed by the inline accessor
    fun get(cls: KClass&lt;*&gt;): Set&lt;*&gt;? = map[cls]

    // inline accessor that performs an unsafe, but sound, cast
    @Suppress("UNCHECKED_CAST")
    inline fun &lt;reified T&gt; get(): Set&lt;T&gt; = get(T::class) as Set&lt;T&gt;? ?: setOf()
}

fun instanceMapOf(vararg items: Any): InstanceMap = InstanceMap().apply {
    items.forEach { add(it) }
}

val misc = instanceMapOf(42, 3.14, true, "foo", "bar")
val strings = misc.get&lt;String&gt;()
println(strings) // =&gt; [foo, bar]

Person
name
Device
name
data class Device(val name: String, val price: Int)
data class Person(val name: String, val age: Int, val devices: List&lt;Device&gt;)
data class PersonFinal(val name: String, val age: Int, val count: Int)

val person1 = Person("Jack", 20, listOf(Device("Samsung", 1500), Device("iPhone", 2500)))
val person2 = Person("Jack", 20, listOf(Device("Samsung", 3500), Device("iPhone", 5500)))
val person3 = Person("John", 20, emptyList())

// [PersonFinal(name=Jack, age=20, count=4), PersonFinal(name=John, age=20, count=0)]

class Solution {
    fun plusOne(digits: IntArray): IntArray {

        println(digits.toString()) // does not work
        println(Arrays.toString(digits)) // does work but its java way of doing
        for(i in 0 until digits.size) {
           ...
        }

        return digits
    }
}

Hardcoded Strings
.java
.kt
onSee
interface EventHandler
{
    fun onSee()
    fun onHear()
    fun onSmell()
    fun onTouch()
    fun onAwake()
    fun onSleep()
}

fun addEventHandler(handler:EventHandler)
{

}

fun Main()
{
    addEventHandler(object:EventHandler
    {
        override fun onSee()
        {
            print("I see.")
        }
    })
}

class SmsData (
    private var _id : String,
    private var thread_id : String,
)

class SmsData {
    private var _id : String = ""
    private var thread_id : String = ""
}

IntArray
intArrayOf(1..9)

TypeError
Int
IntRange
sealed class
when
private val handleDealOperation: (DealOperation) -&gt; State.Change = {
            operation -&gt;
            when (operation) {
                //how to enforce type safety? `DealOperation` is a sealed class
            }
        }

source.map(handleDealOperation)

(transactionFun:SQLiteDatabase.()-&gt;Unit)
(transactionFun: ()-&gt;Unit)
fun excuteTransaction(transactionFun:()-&gt;Unit){
    val db = dbHelper.writableDatabase
    try{
        db.beginTransaction()
        transactionFun()
        db.setTransactionSuccessful()
    }finally {
        db.endTransaction()
    }
}

fun SQLiteDatabase.executeTransaction(transactionFun:SQLiteDatabase.()-&gt;Unit){
    try{
        beginTransaction()
        transactionFun()
        setTransactionSuccessful()
    }finally {
        endTransaction()
    }
}

fun &lt;T&gt; convert(val foo: String, fooT: KType) : T {
    ...?
}

Int
foo.toInt()
Double
foo.toDouble()
val parameters = call.receiveParameters()
val firstName = parameters["firstName"]
val lastName = parameters["lastName"]

firstName?.let {
    lastName?.let { userService.add(UserDTO(firstName = firstName, lastName = lastName)) }
}

fun  &lt;T&gt; List&lt;Any?&gt;.safeLet(block: () -&gt; T) {
    if(this.contains(null)) return

    block()
}


listOf(firstName, lastName).safeLet {
    userService.add(UserDTO(firstName = firstName, lastName = lastName))
}

@ExperimentalContracts
fun  &lt;T&gt; List&lt;Any?&gt;.safeLet(block: () -&gt; T) {
    contract {
        returnsNotNull() implies {ALL ELEMENTS ARE NOT NULLABLE}
    }    

    if(this.contains(null)) return

    block()
}

allNotNull(firstName, lastName)?.apply {
    userService.add(UserDTO(firstName = this[0], lastName = this[1]))
}


fun &lt;T : Any&gt; allNotNull(vararg elements: T?): List&lt;T&gt;? = if(elements.contains(null)) null else elements.filterNotNull()

fun main(args: Array&lt;String&gt;) {
    val userInput = readLine()!!
    val output = userInput 

    for(a in output){
        when{
            a.isUpperCase() -&gt; a.toLowerCase()
            a.isLowerCase() -&gt; a.toUpperCase()
            else -&gt; a
        }
    }

    println(output)
}

class AlarmReceiver : WakefulBroadcastReceiver() {

    companion object {
        const val ACTION_NOTIFY = "..."
    }

    override fun onReceive(context: Context, intent: Intent) { ... }
}

WakefulBroadcastReceiver
static boolean completeWakefulIntent(Intent intent)
static ComponentName startWakefulService(Context context, Intent intent)
AlarmReceiver
AlarmReceiver.completeWakefulIntent(intent)
AlarmReceiver
AlarmReceiver.Companion
class AlarmReceiver : WakefulBroadcastReceiver() {

    companion object {
        const val ACTION_NOTIFY = "..."

        // Just call the superclass implementation for now
        fun completeWakefulIntent(intent: Intent): Boolean =
            WakefulBroadcastReceiver.completeWakefulIntent(intent)
    }

    ...
}

fun main() {
    val input: String = readLine()
    val outputs = input.toCharArray()
    for (i in 0 until input.length) {
        print("${outputs[i]}${outputs[i]}")
    }
}

Error:(2, 25) Kotlin: Type mismatch: inferred type is String? but String was expected.
data class Student(
    val id: Int?,
    val firstName: String?,
    val lastName: String?,
    val hobbyId: Int?,
    val address1: String?,
    val address2: String?,
    val created: String?,
    val updated: String?,
    ...
)

// creating a student 
Student(
    firstName = "Mark"
    lastName = "S"
)

data class Student(
    val id: Int? = null,
    val firstName: String? = null,
    val lastName: String? = null,
    val hobbyId: Int? = null,
    val address1: String? = null,
    val address2: String? = null,
    val created: String? = null,
    val updated: String? = null,
    ...
)

interface IIntCalculation {
    fun Add(a:Int, b:Int): Int
}

interface IDoubleCalculation {
    fun Add(a:Int, b:Int): Double
}

class Calculation : IIntCalculation, IDoubleCalculation {
    override fun Add(a: Int, b: Int): Int {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }

    override fun Add(a: Int, b: Int): Double {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
}

@Entity
internal class FooJpaEntity (
  @Id var id: UUID,
  @Column var foo: String, // Never null in DB
)

class FooWrapper internal constructor(internal val entity: FooJpaEntity) {
  val id: UUID by Delegate(entity::id)
  val foo: String by Delegate(entity:foo)
}

Delegate
class Delegate&lt;T&gt;(private val delegate: KMutableProperty0&lt;T&gt;) {
  operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T = delegate.get()
  operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) { delegate.set(value) }
}

class FooWrapper ... {
  constructor(id: UUID, foo: String): this(FooJpaEntity(id, foo))
  // delegated properties
}

foo
class FooWrapper internal constructor(internal val entity: FooJpaEntity) {
  constructor(id: UUID, foo: String): this(FooJpaEntity(id, foo))
  val id: UUID by Delegate(entity::id)
  val foo: String
    get() = entity.foo
    set(value) { entity.foo = value.trim() }
}

kotlinc -Xfriend-paths=xxxx.jar ...

class A{
    var myVariable:String?=null

    constructor(myVariable:String){
        this.myVariable = myVariable
    }

    init {
        println("Success !")
    }

    inner class B{
        init {
            println(myVariable)
        }
    }
}

fun main(args:Array&lt;String&gt;){
    var b = A("test").B // this does not work
}

Error:(20, 23) Kotlin: Nested class 'B' accessed via instance reference
Error:(20, 23) Kotlin: Classifier 'B' does not have a companion object, and thus must be initialized here

interface Base{
    fun method()
}

class DervA():Base{
    fun override method(){
        ...
    }
}

class DervB():Base{
    fun override method(){
        ...
    }
}

fun test_method(inst){
    inst.method()
}

fun test_method_for_DervA(inst:DervA){
    inst.method()
}

fun test_method_for_DervB(inst:DervB){
    inst.method()
}

array
arrayOf
hashmap
hashmapOf
class RepeatedTimeInterval(val timeInterval: TimeInterval, val number: Int)
operator fun TimeInterval.times(number: Int) = RepeatedTimeInterval(this, number)

operator
{}
class Point(val x: Int = 0, val y: Int = 10) {

    // overloading plus function
    operator fun plus(p: Point) : Point {
        return Point(x + p.x, y + p.y)
    }
}

typealias Meter = Int
typealias Pixel = Int

fun Meter.toPixel() = this * 100
fun Pixel.toMeter() = this / 100

fun calcSquareMeters(width: Meter, height: Meter) = width * height
fun calcSquarePixels(width: Pixel, height: Pixel) = width * height

fun main(args: Array&lt;String&gt;) {
    val pixelWidth: Pixel = 50
    val pixelHeight: Pixel = 50

    val meterWidth: Meter = 50
    val meterHeight: Meter = 50

    calcSquareMeters(pixelWidth, pixelHeight) // (a) this should not work

    pixelWidth.toPixel() // (b) this should not work
}

lateinit
var something: Something? = null
Element
lateinit
lateinit var applicationHolder: ApplicationHolder

applicationHolder = env.getElementsAnnotatedWith(InjectApplication::class.java)
        .map {
            ApplicationHolder(it, (it as TypeElement).asClassName(), it.simpleName.toString()).apply {
                val component = it.getAnnotation(InjectApplication::class.java).getComponent()
                componentClass = component
            }
        }.firstOrNull()

applicationHolder
first
firstOrNull
val item = env.getElementsAnnotatedWith(InjectApplication::class.java)
        .map {
            ApplicationHolder(it, (it as TypeElement).asClassName(), it.simpleName.toString()).apply {
                val component = it.getAnnotation(InjectApplication::class.java).getComponent()
                componentClass = component
            }
        }.firstOrNull()

if (item != null) {
    applicationHolder = item
}

val applicationHolder: ApplicationHolder
    get() {
        return _applicationHolder ?: throw NullPointerException("Not initialized")
    }

private var _applicationHolder: ApplicationHolder? = null

_applicationHolder = env.getElementsAnnotatedWith(InjectApplication::class.java)
        .map {
            ApplicationHolder(it, (it as TypeElement).asClassName(), it.simpleName.toString()).apply {
                val component = it.getAnnotation(InjectApplication::class.java).getComponent()
                componentClass = component
            }
        }.firstOrNull()

    &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"&gt;

    &lt;FrameLayout
        android:id="@+id/settings"
        android:layout_width="match_parent"
        android:layout_height="match_parent" /&gt;
&lt;/LinearLayout&gt;

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;ListPreference
        android:dialogTitle="Select bluetooth adapter"
        android:key="bluetoothName"
        android:summary="Click to show a list to choose from"
        android:title="Bluetooth adapter" /&gt;
    &lt;ListPreference
        android:dialogTitle="Select units"
        android:entries="@array/units_names"
        android:entryValues="@array/units_values"
        android:key="units"
        android:summary="Click to show a list to choose from"
        android:title="Units" /&gt;
&lt;/PreferenceScreen&gt;

class SettingsActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.settings_activity)
        supportFragmentManager
            .beginTransaction()
            .replace(R.id.settings, SettingsFragment())
            .commit()
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
    }

    class SettingsFragment : PreferenceFragmentCompat() {
        override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
            setPreferencesFromResource(R.xml.root_preferences, rootKey)
        }
    }
}

&lt;resources&gt;
    &lt;string-array name="units_values"&gt;
        &lt;item&gt;miles&lt;/item&gt;
        &lt;item&gt;km&lt;/item&gt;
    &lt;/string-array&gt;
    &lt;string-array name="units_names"&gt;
        &lt;item&gt;miles and mpg&lt;/item&gt;
        &lt;item&gt;km and l/100km&lt;/item&gt;
    &lt;/string-array&gt;
&lt;/resources&gt;

...
    override fun onCreateOptionsMenu(menu: Menu?): Boolean {
        menuInflater.inflate(R.menu.toolbar, menu);
        return true;
    }

    override fun onOptionsItemSelected( item: MenuItem) : Boolean {
        when (item.itemId) {
            R.id.toolbar_item_settings -&gt; {
                val intent: Intent = Intent(this, SettingsActivity::class.java)
                startActivity(intent)
                return true
            }
        }
        return true
    }
...

.parseList{ DayForecast(HashMap(it)) }
val dailyForecast ...
.parseList{ DayForecast(HashMap(it)) }
override fun requestForecastByZipCode(zipCode: Long, date: Long) = forecastDbHelper.use {

    val dailyRequest = "${DayForecastTable.CITY_ID} = ? AND ${DayForecastTable.DATE} &gt;= ?"
    val dailyForecast = select(DayForecastTable.NAME)
            .whereSimple(dailyRequest, zipCode.toString(), date.toString())
            .parseList { DayForecast(HashMap(it)) }

     val city = select(CityForecastTable.NAME)
            .whereSimple("${CityForecastTable.ID} = ?", zipCode.toString())
            .parseOpt { CityForecast(HashMap(it), dailyForecast) }


     city?.let { dataMapper.convertToDomain(it) }

}

fun boo(): Int {
    sth.apply {
        return sthElse
    }
    throw Exception("Unkown View type")
}

override fun onCreateViewHolder(parent: ViewGroup?, viewType: Int): RecyclerView.ViewHolder {
    LayoutInflater.from(parent?.context)
            .inflate(R.layout.item_category_node, parent, false)
            .apply {
                return CategoryNodeViewHolder(this, this@CategoriesAdapter)
    }
    throw Exception("View type error")
}

package com.test

fun A(){

}

package com.test

fun Any.A(){

}

 Class OrderProcessing {
        var first: OrderNode? = null
      // Linked List
        data class OrderNode(val order: Order, var next: OrderNode?)

    fun sortByTotal () {
    var run = first
        var temp = Double
            while (run?.next != null) {
    32        if (run.order.shoppingCart.totalprice  &lt;= run.next.order.shoppingCart.totalprice){
    33            temp = run.order.shoppingCart.totalprice
    34            run.order.shoppingCart.totalprice = run.next.order.shoppingCart.totalprice
                run.next.order.shoppingCart.totalprice = temp
                }

    38        run?.next = OrderNode(order, run?.next)
            }
        }

Class ShoppingCart () {
    private val shoppingList = mutableListOf&lt;Pair&lt;Product, Int&gt;&gt;
  // totalprice = sum of item price in each cart
   val totalprice : double
... }

data class Order(
    val shoppingCart: ShoppingCart,
    val address: Address
)

fun main(){

    // while loop until "exit", Menu with functions to add goods to cart, clear cart, show shopping list (items and price)

var atLeastOneValue: Boolean
var i = 0

for (x in list) {
    if (x != null) atLeastOneValue = true
    else i++
}
if (list.size == i) atLeastOneValue = false

return atLeastOneValue

MutableList&lt;String&gt;
fun maker(type: Class&lt;Animal&gt;): Animal {
    if(type == Class&lt;Dog&gt;) {
       return Dog()
    } 
    else if (type == Class&lt;Cat&gt;) {}
    ...
}

private fun method() {
    operator fun Float.rangeTo(other: Int) {
        (this.toInt()..other).forEach { print(it) }
    }
    0f..4
}

01234
float
Int
01234
private fun method() {
    operator fun Int.rangeTo(other: Int) {
        (this..other).forEach { print(it) }
    }
    0..4
}

inline fun &lt;R&gt; Logger.logStuff(
    crossinline f: () -&gt; R
): R {
    val methodName = object {}.javaClass.enclosingMethod.name
    try {
        this.debug("$methodName : Begin")
        f()
        this.debug("$methodName : End")
    } catch (ex: Exception) {
        this.error("$methodName : Threw exception : $ex")
        throw ex
    }
}

class Foo {
    fun doStuff() = log.logStuff {
        1 + 3
    }
}

Foo : doStuff : Begin
Foo : doStuff : End

Foo : logStuff : Begin
Foo : logStuff : End

currentThread().stackTrace[1].methodName
val map = Map&lt;String, Any?&gt;
val map = Map&lt;String, Any&gt;
uploadImageToParse(imageFile, saveCall1())
uploadImageToParse(imageFile, saveCall2())
uploadImageToParse(imageFile, saveCall3())

private fun uploadImageToParse(file: ParseFile?, saveCall: Unit) {
        saveCall()//Throws an error saying 'Unit cannot be invoked as function'
} 

sortByTotal
order
OrderNode
val
order
val
Class OrderProcessing {
      var first: OrderNode? = null
      // Linked List
     data class OrderNode(val order: Order, var next: OrderNode?)

     fun sortByTotal () {
     var run = first
     while (run?.next != null) {
        if (run.order.shoppingCart.totalPrice &lt; run.next!!.order.shoppingCart.totalPrice) {
            15  var temp = run.order
                run.order = run.next.order
                run.next.order = temp
        }
        run = run?.next
    }
}

  Class ShoppingCart () {
        private val shoppingList = mutableListOf&lt;Pair&lt;Product, Int&gt;&gt;
      // totalprice = sum of item price in each cart
       val totalprice : double
    ... }

data class Order(
    val shoppingCart: ShoppingCart,
    val address: Address
)

    fun main(){

        // while loop until "exit", Menu with functions to add goods to cart, clear cart, show shopping list (items and price)

Unit
def foo: Int = ???
def bar(x: String): Unit = x match {
  case "error" =&gt; println("There was an error")
  case _ =&gt; foo      

match
Any
Unit
fun bar(x: String): Unit = when(x) {
 "error" -&gt;  println("There was an error") 
 else -&gt; foo()
}

foo
inferred type is Int but Unit was expected
=
foo.let {}
class Student(name : String, roll : Int){
    val name: String

    init {
        name = "Asif"
    }
}

&gt; Error:(9, 5) Kotlin: Property must be initialized or be abstract
&gt; Error:(12, 9) Kotlin: Val cannot be reassigned

val name : String
name : String
class Student(pName : String, roll : Int){
    val name: String

    init {
        name = "Asif"
    }
}

// CASE 1
Int::class.javaPrimitiveType!!.kotlin == Int::class.javaObjectType.kotlin // true

// CASE 2
Int::class.javaPrimitiveType!!.kotlin === Int::class.javaObjectType.kotlin // false

val myObject = myObjectRepository.findById(myObjectId);    
when {        
    matchesSomething(myObject) -&gt; doSomethingWithMyObject(myObject)
    matchesSomethingElse(myObject) -&gt; doSomethingElseWithMyObject(myObject)
    else -&gt; log.warn("No match, aborting");
}

myObject
when
when(myObjectRepository.findById(myObjectId)) { myObject -&gt;
    matchesSomething(myObject) -&gt; doSomethingWithMyObject(myObject)
    matchesSomethingElse(myObject) -&gt; doSomethingElseWithMyObject(myObject)
    else -&gt; log.warn("No match, aborting"); 
}

fun &lt;T, U&gt; process(t: T, call: (U) -&gt; Unit, map: (T) -&gt; U) = call(map(t))

fun &lt;T&gt; processEmpty(t: T, call: () -&gt; Unit) = process(t, call, {}) // error

processEmpty
Type mismatch: inferred type is () -&gt; kotlin.Unit but (kotlin.Unit) -&gt; kotlin.Unit was expected
fun &lt;T&gt; processEmpty2(t: T, call: (Unit) -&gt; Unit) = process(t, call, {}) // OK

() -&gt; Unit
(Unit) -&gt; Unit
processEmpty
fun main() {

    //explain game
    println("Welcome to Rock - Paper - Scissors!")
    println("This is a simple game of choosing on of either Rock, Paper, or Scissors against the computer's choice")
    println("The rules are:  ")
    println("   Rock beats Scissors")
    println("   Scissors beasts paper")
    println("   Paper beast Rock")
    println()

    //Prompt user if they would like to play
    print("Would you like to play ( Y or N )")

    var play = readLine()
// end of game stats


    if (play == "N" || play == "n") {  // if N or n
        println("Sorry you don't want to play with me!")
    }  else if (play == "Y" || play == "y") {

        // print the menu if Y or y
        println("1. Rock")
        println("2. Paper")
        println("3. Scissors")
        println()
        println("4. Quit ")
        println()
        print("Enter your choice:")
        // perform that action // display users choice
        var userChoice = readLine()!!.toInt()
        while (userChoice != 5) {
            println()



                // computer choice random
                var rand = (1..3).random()

                // stats
                var tie = 0
                var win = 0
                var losses = 0


                // computer choice display
                if (rand == 1) {
                    println(" Computer chose: Rock")
                }

                if (rand == 2) {
                    println(" Computer chose: Paper")
                }

                if (rand == 3) {
                    println(" Computer chose: Scissors")
                }


                // Players choice display
                if (userChoice == 1) {
                    println(" You chose: Rock ")
                }
                if (userChoice == 2) {
                    println(" You chose: Paper")
                }
                if (userChoice == 3) {
                    println(" You chose: Scissors")
                }
                if (userChoice == 4) {
                    println("Have a nice day!")
                    println("Stats")
                    //print stats here

                } else {
                    println("ERROR Please enter a valid menu choice.")
                }

                // win,lose.tie

                //win
                if (rand == 1 &amp;&amp; userChoice == 2) {
                    win++
                }
                if (rand == 2 &amp;&amp; userChoice == 3) {
                    win++
                }
                if (rand == 3 &amp;&amp; userChoice == 1) {
                    win++
                }

                //losses
                if (rand == 1 &amp;&amp; userChoice == 3) {
                    losses++
                }
                if (rand == 2 &amp;&amp; userChoice == 1) {
                    losses++
                }
                if (rand == 3 &amp;&amp; userChoice == 2) {
                    losses++
                }
                //ties
                if (rand == userChoice) {
                    tie++
                }

                //Stats
                println("----Stats----")
                println("Wins: $win")
                println("Losses: $losses")
                println("Ties: $tie")

                // menu
                println("1. Rock")
                println("2. Paper")
                println("3. Scissors")
                println()
                println("4. Quit ")
                println()
                print("Enter your choice:")
                // get users choice
                userChoice = readLine()!!.toInt()


            }

        }


}

val input = Scanner(System.`in`)
val inp = input.nextLine() //hello
val alp = mutableListOf('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')

for (i in inp) {
    if (i in alp) {
        val a = alp.remove(i)
        print(a)
    }
}

class Person(email: String) {
    var email: String = email
        set(value) {
            require(value.trim().isNotEmpty(), { "The email cannot be blank" })
            field = value
        }

    init {
        require(email.trim().isNotEmpty(), { "The email cannot be blank" })
    }
}

fun process(call: () -&gt; Int) {
}

fun aa() = 5

class A {
    companion object Factory {
        fun bb() = 6
    }
}

fun test() {
    process(::aa)   // OK
    process(::A.bb) // Overload resolution ambiguity
}

process(::A.bb)
Error:Overload resolution ambiguity:
public constructor A() defined in ru.netimen.hitch_hikingstats.A
public companion object Factory defined in ru.netimen.hitch_hikingstats.A

fun&lt;K, V&gt; Maps&lt;K, V&gt;.contains(k : K) : Boolean
{
    //simply check for map containing key
}

if(map.contains(key))
{
    map.get(key).callAnyMethod()
    //smartcast get(key) to not null
}

@Entity
@Table(name = "article")
class Article(


        var title: String,
        var headline: String,
        var content: String,
        @ManyToOne var author: User? = null,
        var addedAt: LocalDateTime = LocalDateTime.now(),
        var slug: String = title.toSlug(),
        @Id @GeneratedValue var id: Long? = null)


@Entity
@Table(name = "user")
class User(
        var login: String,
        var firstname: String,
        var lastname: String,
        var description: String? = null,
        @Id @GeneratedValue var id: Long? = null)

interface UserRepository : CrudRepository&lt;User, Long&gt; {
    fun findByLogin(login: String): User?

    fun findByLastname(lastname: String): User?
}

interface ArticleRepository : CrudRepository&lt;Article, Long&gt; {
    fun findBySlug(slug: String): Article?
    fun findAllByOrderByAddedAtDesc(): Iterable&lt;Article&gt;
}

@PostMapping("user/{userId}/newarticle")
    fun createArticle(@RequestBody article: Article, @PathVariable userId: Long) {
        val user = userRepository.findById(userId) 
        article.author = user &lt;-- Type Mismatch
        repository.save(article) 
        var stophere = "what"
    }

init(repeating:count:)
var arrayOfArray = [[String?]](repeating: [], count: 10)

listOf
open class Organism {
    open fun saySomething(){
        print("Nein")
    }
}

class Person : Organism() {
    override fun saySomething() {
        println("Saying hello")
    }
}

 val x = Person()
 (x as Organism).saySomething()  // Output: Saying hello

ShapeData
class ShapeData {
    var type: Shape.Type? = null // Circle, Edge, Polygon, Chain

    // PolygonShape / ChainShape
    var vertices: FloatArray? = null
    var offset: Int? = null
    var len: Int? = null

    // setAsBox
    var hx: Float? = null
    var hy: Float? = null
    var center: Vector2? = null
    var angle: Int? = null

    // CircleShape
    var radius: Float? = null
    var position: Vector2? = null

    // EdgeShape
    var v1: Vector2? = null
    var v2: Vector2? = null
}

-1
fun scaledShapeData(data: ShapeData, scalar: Float): ShapeData {
    return ShapeData().apply {
        type = data.type
        vertices = data.vertices?.map { it * scalar }?.toFloatArray()
        offset = data.offset
        len = data.len
        hx = if(data.hx != null) data.hx * scalar else null // This is marked as an error with "None of the following functions can be called with the arguments supplied" message
    }
}

fun main(args: Array&lt;String&gt;) {
    var test1 : Float? = 2f
    val test2 : Float = 2f

    var test3 : Float? = if(test1 != null) test1 * test2 else null

    print(test3)
}

var cl = App.class.getClassLoader();
var euler = (Euler) cl
        .loadClass("com.gorauskas.euler.solutions.Euler" + Util.problem)
        .getDeclaredConstructor()
        .newInstance();

Euler
com.gorauskas.euler.solutions
Util.problem
val cl = this.javaClass.classLoader
val e = cl.loadClass("com.gorauskas.euler.solutions.Euler" + problem)
    .getDeclaredConstructor()
    .newInstance()

e.problem
Unresolved reference
as
val e: EulerInterface = cl.loadClass(EULER_PACKAGE + EULER_CLASS + problem)
    .getDeclaredConstructor()
    .newInstance() as EulerInterface 

fun gen():List&lt;Int&gt;{
    val numbers=List(10){Random.nextInt(1,100)}
    return numbers.filter{it&gt;0}
}
fun res(){...}

fun getFileDirectoryFiles() {
    File("$fileDirectory").walk().forEach {
        println(it)
    }
}

Product
flatMap
val allOrderedProducts = customers.flatMap {it.orders.flatMap {it.products}}.toSet()

allOrderedProducts.fold(products) { theList, theProduct -&gt; { ... } }

theProduct
() -&gt; Product
Product
// Return the set of products that were ordered by every customer
fun Shop.getSetOfProductsOrderedByEveryCustomer(): Set&lt;Product&gt; {
    val products: Set&lt;Product&gt; = setOf()
    val allOrderedProducts = customers.flatMap {it.orders.flatMap {it.products}}.toSet()
    allOrderedProducts.fold(products) { theList, theProduct -&gt; 
        customers.all { customer -&gt;
            val orderedProducts = customer.orders.flatMap { it.products }           
            orderedProducts.contains { theProduct }  // type mismatch inferred type is () -&gt; Product but Product was expected 
        }
        val ret: Set&lt;Product&gt; = setOf()
        ret
    }
    val retValue: Set&lt;Product&gt; = setOf()
    return retValue
}

Toast.makeText()
Toast.makeText()
&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;uses-permission android:name="android.permission.SEND_SMS" /&gt;
&lt;uses-permission android:name="android.permission.RECEIVE_SMS" /&gt;
&lt;uses-permission android:name="android.permission.READ_SMS" /&gt;

&lt;application
    android:allowBackup="true"
    android:icon="@mipmap/ic_launcher"
    android:label="@string/app_name"
    android:roundIcon="@mipmap/ic_launcher_round"
    android:supportsRtl="true"
    android:theme="@style/AppTheme"&gt;
    &lt;receiver
        android:name=".SmsReceiver"
        android:enabled="true"
        android:exported="true"
        android:permission="android.permission.BROADCAST_SMS"&gt;
        &lt;intent-filter &gt;
            &lt;action android:name="android.provider.Telephony.SMS_RECEIVED"/&gt;
            &lt;category android:name="android.intent.category.DEFAULT"/&gt;
        &lt;/intent-filter&gt;
    &lt;/receiver&gt;

    &lt;activity android:name=".MainActivity"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.MAIN" /&gt;

            &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;
&lt;/application&gt;

package com.example.sendmessege

import android.annotation.TargetApi
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.os.Build
import android.telephony.SmsMessage
import android.util.Log
import android.widget.Toast


class SmsReceiver : BroadcastReceiver() {

private val TAG: String = SmsReceiver::class.java.getSimpleName()
val pdu_type = "pdus"


@TargetApi(Build.VERSION_CODES.M)
override fun onReceive(
    context: Context?,
    intent: Intent
) { // Get the SMS message.
    val bundle = intent.extras
    val msgs: Array&lt;SmsMessage?&gt;
    var strMessage = ""
    val format = bundle!!.getString("format")
    // Retrieve the SMS message received.
    val pdus = bundle[pdu_type] as Array&lt;Any&gt;?
    if (pdus != null) { // Check the Android version.
        val isVersionM = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M
        // Fill the msgs array.
        msgs = arrayOfNulls(pdus.size)
        for (i in msgs.indices) { // Check Android version and use appropriate createFromPdu.
            if (isVersionM) { // If Android version M or newer:
                msgs[i] = SmsMessage.createFromPdu(
                    pdus[i] as ByteArray,
                    format
                )
            } else { // If Android version L or older:
                msgs[i] =
                    SmsMessage.createFromPdu(pdus[i] as ByteArray)
            }
            // Build the message to show.
            strMessage += "SMS from " + msgs[i]?.originatingAddress
            strMessage += " :" + (msgs[i]?.messageBody) + "\n"
            // Log and display the SMS message.
            Log.d(TAG, "onReceive: $strMessage")
            Toast.makeText(context, strMessage, Toast.LENGTH_LONG).show()
        }
    }
 }


}

onReceive()
Toat.makeText()
val arr1 = arrayOf(1,2,3,"Apple")
val arr2: Array&lt;Int&gt; = Array(6,{i -&gt; i * 2})
val arr3: Array&lt;Int&gt; = Array&lt;Int&gt;(6,{i -&gt; i+1})
val arr4 = arrayOf&lt;Int&gt;(1,2,3)
for (i in 1..4){
    val arrResult = java.util.Arrays.deepToString("arr${i}")
    println(arrResult)
}

data class Chef(val name: String, val level: Int)

val listOfChefsOne = listOf(
    Chef("Remy", 9), 
    Chef("Linguini", 7))

val listOfChefsTwo = listOf(
    Chef("Mark", 6), 
    Chef("Maria", 8))

println(pairChefs(listOfChefsOne, listOfChefsTwo))

######################################

[(Chef(name=Remy, level=9), Chef(name=Mark, level=6)), 
(Chef(name=Linguini, level=7), Chef(name=Maria, level=8))]

override var unmapped: MutableMap&lt;String, String&gt; = TreeMap()

@JsonAnySetter fun setAny(key: String, value: String): Unit {
    unmapped.put(key,value)
}

ObjectMapper
om.registerModule(new KotlinModule());

readValue()
Caused by: com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field [...]

package test

interface Thing {
    val x: Int
}

class RealThing(override var x: Int) : Thing {
}

open class FakeThing(var thingy: Thing) : Thing by thingy {
}

class ShiftyThing(val t: Thing) : FakeThing(t) {
    fun shift(otherValue: Thing) {
        println("changing value ${thingy.x} to ${otherValue.x}")
        thingy = otherValue;
        println("changed value to ${thingy.x}")
    }
}

fun main(args : Array&lt;String&gt;) {
    val one = RealThing(1)
    val two = RealThing(2)
    val s1 = ShiftyThing(one)
    s1.shift(two)
    println("Expected: 2, got: " + s1.x)
}

changing value 1 to 2
changed value to 2
Expected: 2, got: 1

1
fun getEncodedData(data: String): String? {

        val MD5 = "MD5"

        // Create MD5 Hash
        val digest = java.security.MessageDigest
            .getInstance(MD5)

        digest.update(data.toByte())
        val messageDigest = digest.digest()

        // Create Hex String
        val hexString = StringBuilder()
        for (aMessageDigest in messageDigest) {
            var h = Integer.toHexString(0xFF and aMessageDigest.toInt())
            while (h.length &lt; 2)
                h = "0$h"
            hexString.append(h)
        }
        return hexString.toString()
    }

digest.update(data.toByte())
data
oEXm43
11
data
integer
string
number
characters
test:100
test1:200
test2:300
test3:400

object App {

@JvmStatic
fun main(args: Array&lt;String&gt;) {

    // file containing lines of text
    val lines = Files.readAllLines(Paths.get("./hashes.txt"))

    // not empty
    println(lines.size)

    // write back a modified version
    PrintWriter(FileWriter(File("./lines2.txt"))).use { out -&gt; {

            // this doesn't get called
            println(lines.size)
            lines.forEach {
                out.println(it.split(":")[0])
            }

        }
    }

}

}

static {
    boolean assertsEnabled = false;
    assert assertsEnabled = true;
    if (!assertsEnabled)
        throw new AssertionError("Please enable assertions!");
}

assertsEnabled = true
assert
